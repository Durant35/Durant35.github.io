<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tarantula-7&#39;s Blog</title>
  <subtitle>　　你永远流淌在我的记忆里？River flows in you</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://durant35.github.io/"/>
  <updated>2017-06-24T07:57:34.582Z</updated>
  <id>http://durant35.github.io/</id>
  
  <author>
    <name>Gary</name>
    <email>chenshj35@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法设计与分析[0018] 图的点连通度和边连通度</title>
    <link href="http://durant35.github.io/2017/06/24/Algorithms_Vertex&amp;Edge%20connectivity%20degree/"/>
    <id>http://durant35.github.io/2017/06/24/Algorithms_Vertex&amp;Edge connectivity degree/</id>
    <published>2017-06-24T06:00:22.000Z</published>
    <updated>2017-06-24T07:57:34.582Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念？"><a href="#基本概念？" class="headerlink" title="基本概念？"></a>基本概念？</h4><ul>
<li>点连通度（图的连通度）：对应一个图 $G$，对于所有点集 $U \subset V_G$，也就是 $V_G$ 的子集中，使得 $G-U$（在图 $G$ 中删去 $U$ 和与 $U$ 关联的边）要么是一个非连通图，要么就是一个平凡图，其中最小的集合 $U$ 的大小 $|U|$ 就是图 $G$ 的<strong>点连通度</strong>（有时候也直接称为<strong>图的连通度</strong>）。<a id="more"></a><blockquote>
<p>连通图&amp;非连通图（无向图）</p>
<ul>
<li>如果无向图 $G$ 中任意一对顶点都是连通的，此图是<code>连通图</code>；</li>
<li>相反，如果一个无向图不是连通图，则称为<code>非连通图</code>。</li>
</ul>
<p>强连通&amp;单连通&amp;弱连通（有向图）</p>
<ul>
<li>如果对有向图 $G$ 中任意两个顶点 $u$ 和 $v$，既存在从 $u$ 到 $v$ 的路径，也存在从 $v$ 到 $u$ 的路径，则称该有向图 $G$ 为<code>强连通有向图</code>；</li>
<li>如果仅存在从 $u$ 到 $v$ 的路径，或从 $v$ 到 $u$ 的路径，则称该有向图 $G$ 为<code>单连通有向图</code>；</li>
<li>如果忽略有向图 $G$ 中每条有向边的方向，得到的无向图（即该有向图的基图）是连通图，则称该有向图 $G$ 为<code>弱连通有向图</code>。</li>
</ul>
<p>平凡图&amp;非平凡图</p>
<ul>
<li>只有一个节点，没有边的图为<code>平凡图</code>；</li>
<li>有至少两个节点，一条边的图，为<code>非平凡图</code>。</li>
</ul>
</blockquote>
</li>
</ul>
<p>　　只许删点，求至少要删掉几个点，即一个图 $G$ 最少要去掉多少个点会变成非连通图或者平凡图：对于一个完全图 $K_n$ 来说，它的（点）连通度为 $n-1$。</p>
<blockquote>
<p><code>完全图</code>：若一个图的每一对不同顶点恰有一条边相连。</p>
</blockquote>
<ul>
<li>边连通度：同理，<strong>边连通度</strong>就是对于一个非平凡图 $G$，至少去掉多少条边才能使得该图变成非连通图。<br>　　只许删边，求至少要删掉几条边。</li>
</ul>
<h4 id="如何求解？"><a href="#如何求解？" class="headerlink" title="如何求解？"></a>如何求解？</h4><p>　　对于任意一个图，如何求该<strong>图的（点）连通度</strong>和<strong>边连通度</strong>呢？</p>
<ul>
<li><code>有向图的边连通度</code>其实就是一个<a href="https://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/">最小割问题</a>。<ul>
<li>求解思路<ul>
<li>将原图 $G$ 中每条边$\lt u, v \gt$设置为容量为1的边，其它都不需要修改，即可得到对应的流网络图</li>
<li>任意选取一个节点 $u$ 作为源点，枚举其他所有与节点 $u$ 不相邻的节点作为汇点，求所有汇点情况下的各个最大流</li>
<li>其中最小的那个最大流即为原图的边连通度</li>
</ul>
</li>
<li>最小的最大流中，所有流量为1的边组成的边集即为最小的边割集（割边集/割集）<blockquote>
<p>设 $E’$ 是连通图 $G$ 的边集的子集，在 $G$ 中删去 $E’$ 后图不连通，则称 $E’$ 是 $G$ 的<code>割边集</code></p>
<ul>
<li>如果割边集 $E’$ 的任何真子集都不是割边集，则称 $E’$ 为<code>极小割边集</code></li>
<li>边的数目（图 $G$ 的边连通度）最小的极小割边集称为 <code>最小割边集</code></li>
</ul>
<p>如果割边集中只有一条边，则该边可以称为<code>割边</code>（或<code>桥</code>）</p>
</blockquote>
</li>
</ul>
</li>
<li><code>有向图的点连通度</code><ul>
<li>求解思路<ul>
<li>点连通度的流网络构造方法其实是将点连通度的求解转化为了边连通度的求解；<ul>
<li>对于有向图 $G$，将每个节点 $u$ 拆分成 $u1$ 和 $u2$ 两个节点，并添加一条 $u1$ 到 $u2$ 容量为1的边$\lt u, v \gt$；</li>
<li>对于原图 $G$ 中的边$\lt u, v \gt$，对应在新网络中有边$\lt u2, v1 \gt$，容量为正无穷，即可得到对应的流网络图。<blockquote>
<p><font color="red">实际上：</font><br>　原图 $G$ 上节点 $u$，$v$ 和从 $u$ 到 $v$ 的边<code>&lt;u,v&gt;</code>在对应的流网络中为节点 $u1$，$u2$，$v1$ 和 $v2$ 以及边<code>&lt;u1,u2&gt;</code>（容量为1）；<code>&lt;u2,v1&gt;</code>（容量为正无穷）；<code>&lt;v1,v2&gt;</code>（容量为1），也是一条路径。</p>
</blockquote>
</li>
</ul>
</li>
<li>也是在上述对应的流网络上任意选取一个节点 $u$ 作为源点，枚举所有其他不相邻的节点求最大流，其中最小的那个最大流即为原图 $G$ 的点连通度。</li>
</ul>
</li>
<li>最小的最大流中，所有流量为1的边\lt u1, u2 \gt$对应的原图中的同一节点 $u$ 组成的点集即为最小的点割集（割顶集/割点集）<blockquote>
<p>设 $V’$ 是连通图 $G$ 的一个顶点子集，在 $G$ 中删去 $V’$ 和与 $V’$ 关联的边后图不连通，则称 $V’$ 是 $G$ 的<code>割顶集</code></p>
<ul>
<li>如果割边顶集 $V’$ 的任何真子集都不是割顶集，则称 $V’$ 为<code>极小割顶集</code></li>
<li>顶点个数（图 $G$ 的（点）连通度）最小的极小割顶集称为 <code>最小割顶集</code></li>
</ul>
<p>如果割顶集中只有一个顶点，则该顶点可以称为<code>割点</code>（或<code>关节点</code>）</p>
</blockquote>
</li>
</ul>
</li>
<li><code>关于无向图</code>：将图中的每条边 $(u, v)$ 拆成 $\lt u, v \gt$ 和 $\lt v, u \gt$ 两条边，即转成有向图处理。</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9467709">图的匹配问题与最大流问题（四）——计算图的边连通度和点连通度</a> </li>
<li><a href="http://www.cppblog.com/matono1/archive/2011/04/05/143449.html">图的连通度问题的求法</a></li>
<li><a href="https://www.zybuluo.com/DATASOURCE/note/168108">图的连通性问题</a></li>
<li><a href="https://github.com/zhaochenyou/Way-to-Algorithm/blob/master/5_GraphTheory/5_FlowNetwork/11_connectivity.cpp">Github: zhaochenyou/Way-to-Algorithm 连通度基础概念</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念？&quot;&gt;&lt;a href=&quot;#基本概念？&quot; class=&quot;headerlink&quot; title=&quot;基本概念？&quot;&gt;&lt;/a&gt;基本概念？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;点连通度（图的连通度）：对应一个图 $G$，对于所有点集 $U \subset V_G$，也就是 $V_G$ 的子集中，使得 $G-U$（在图 $G$ 中删去 $U$ 和与 $U$ 关联的边）要么是一个非连通图，要么就是一个平凡图，其中最小的集合 $U$ 的大小 $|U|$ 就是图 $G$ 的&lt;strong&gt;点连通度&lt;/strong&gt;（有时候也直接称为&lt;strong&gt;图的连通度&lt;/strong&gt;）。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0017] NP-完全问题：概述（两道证明习题）</title>
    <link href="http://durant35.github.io/2017/06/08/Algorithms_NP-Complete(I)/"/>
    <id>http://durant35.github.io/2017/06/08/Algorithms_NP-Complete(I)/</id>
    <published>2017-06-08T06:00:22.000Z</published>
    <updated>2017-06-10T07:38:17.327Z</updated>
    
    <content type="html"><![CDATA[<p>　　在计算机算法求解问题当中，经常用<code>时间复杂度</code>和<code>空间复杂度</code>来表示一个算法的运行效率。空间复杂度表示一个算法在计算过程当中要占用的内存空间大小；时间复杂度则表示这个算法运行得到想要的解所需的计算工作量，并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快，即探讨的是当输入值接近无穷时，算法所需工作量的变化快慢程度。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。<a id="more"></a><br>　　不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有$O(1)$的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是$O(N)$，比如找$N$个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于$O(N^2)$的复杂度；还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是$O(a^N)$的指数级复杂度，甚至$O(N!)$的阶乘级复杂度。时间复杂度排序：$O(1) \lt O(N) \lt O(logN) \lt O(N^2) \lt O(N^a) \lt O(b^N) \lt O(N!)$（$a \gt 2, b \gt 1$，$N$表示输入的数据个数）。<br>　　容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是$O(1), O(logN), O(N^a)$等，我们把它叫做多项式级（$ax^n - bx^{n-1} + … + c$）的时间复杂度，因为它的规模$N$出现在底数的位置；另一种是$O(a^N)$和$O(N!)$型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的时间复杂度，非多项式级的时间复杂度需要的时间太多，往往会超时，除非是数据规模非常小。<br>　　自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为<strong>“不可解问题”(Undecidable Decision Problem)</strong>。下面引入 <code>P问题</code>、<code>NP问题</code> 等概念对一个问题求解的复杂度进行不同等级的评估。</p>
<h4 id="P-问题"><a href="#P-问题" class="headerlink" title="P 问题"></a>P 问题</h4><p>　如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于<code>P问题</code>，P(olynominal) 问题。</p>
<h4 id="NP-问题"><a href="#NP-问题" class="headerlink" title="NP 问题"></a>NP 问题</h4><p>　能在多项式时间内验证给出的一个解的问题属于<code>NP问题</code>，Nondeterministic Polynominal，非确定性多项式问题。</p>
<ul>
<li>NP 问题不是非 P 类问题，NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。之所以要定义NP问题，是因为通常只有 NP 问题才可能找到多项式时间复杂度的算法，因为我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。</li>
<li>NP 问题，实际上是在探讨 NP 问题与 P 问题的关系。<ul>
<li>很显然，<strong>所有的 P 问题都是 NP 问题</strong>，也就是说，能多项式地解决一个问题，必然能多项式时间内验证一个问题的解（既然正解都出来了，验证任意给定的解也只需要比较一下就可以了）。</li>
<li><strong>是否所有的 NP 问题都是 P 问题</strong>？我们可以用集合的观点来说明：如果把所有 P 类问题归为一个集合 P 中，把所有 NP 问题划进另一个集合 NP 中，那么，显然有P 属于 NP。现在，所有对 NP 问题的研究都集中在一个问题上，即究竟是否有 <code>P=NP</code>？在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 <code>NP-完全问题</code>，也即所谓的 NPC 问题。正是 NPC 问题的存在，使人们相信 <code>P≠NP</code>。</li>
</ul>
</li>
</ul>
<h4 id="NPC-NP-Complete-问题"><a href="#NPC-NP-Complete-问题" class="headerlink" title="NPC(NP-Complete) 问题"></a>NPC(NP-Complete) 问题</h4><p>　<code>NPC问题</code>的定义非常简单，同时满足下面两个条件的问题就是 NPC 问题：① 首先，它得是一个 NP 问题；②然后，所有的 NP 问题都可以在多项式时间内归约到它。即如果所有 NP 问题都能在多项式时间内归约到一个 NP 问题，则称该 NP 问题为 <code>NPC问题</code>，NP Complete，NP 完全问题。</p>
<ul>
<li>什么是 <strong>归约</strong>？<ul>
<li>归约(Reducibility，有的资料上叫“约化”)。一个问题A可以归约到问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。<ul>
<li>举个例子，一元一次方程的求解，跟二元一次方程的求解</li>
<li>我们知道，只要能求解二元一次方程，那就可以用二元一次方程的解法来求解一元一次方程，只需要将一元一次方程加上y，并附加一个方程y=0就可以将一元一次方程变形为一个二元一次方程，然后用二元一次方程的解法来求解这个方程。</li>
<li>注意，这里二元一次方程的解法会比一元一次的复杂。所以我们说，只需要找到解二元一次方程的规则性解法，那就能用这个规则性解法来求解一元一次方程。</li>
</ul>
</li>
<li>“问题A可归约到问题B” 有一个重要的直观意义：B的时间复杂度≥A的时间复杂度，也就是说，问题A不比问题B难。<ul>
<li>这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。</li>
<li>正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</li>
</ul>
</li>
<li>很显然，归约具有一项重要的性质：归约具有传递性。如果问题A可归约到问题B，问题B可归约到问题C，则问题A一定归约到问题C。<ul>
<li>不断归约下去，我们会发现一个很惊人的特性：就是一定会存在一个最大的问题，我们只需要解决了这个问题，那其下的所有问题也就解决啦！这个问题就是上面所说的 NPC 问题！！！</li>
</ul>
</li>
<li>对于同一类的所有的 NP 问题，若他们都可以在多项式时间内归约到 NPC 问题（更复杂的时间复杂度），当我们针对这个时间复杂度最高的超级 NP 问题要是能找到他的多项式时间算法的话，那就等于变向地证明了其下的所有属于同一类的 NP 问题都是存在多项式算法的，即 <code>NP=P</code>！！！！</li>
</ul>
</li>
<li>NPC 问题是 NP 问题的子集。</li>
<li>证明一个问题是 NPC 问题也很简单：先证明它至少是一个 NP 问题，再证明一个已知的 NPC 问题能在多项式时间内归约到它（由归约的传递性，则 NPC 问题定义的第二条条件也得以满足；至于第一个 NPC 问题是怎么来的？），这样就可以说它是 NPC 问题了。</li>
<li>既然所有的 NP 问题都能归约成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式时间复杂度的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了。因此，给 NPC 找一个多项式时间复杂度算法太不可思议了。因此，上文才说，“正是 NPC 问题的存在，使人们相信 P≠NP”。</li>
<li>我们可以直观地理解：NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度进行搜索求解。</li>
</ul>
<h4 id="两道习题：如何证明一个问题是-NPC-NP-Complete-问题"><a href="#两道习题：如何证明一个问题是-NPC-NP-Complete-问题" class="headerlink" title="两道习题：如何证明一个问题是 NPC(NP-Complete) 问题"></a>两道习题：如何证明一个问题是 NPC(NP-Complete) 问题</h4><ul>
<li>证明一个问题是 NPC 问题<ul>
<li>先证明它至少是一个 NP 问题；</li>
<li>再证明一个已知的 NPC 问题能在多项式时间内归约到它。</li>
</ul>
</li>
</ul>
<h5 id="两道习题"><a href="#两道习题" class="headerlink" title="两道习题"></a>两道习题</h5><blockquote>
<ul>
<li>[8.3] <strong>STINGY SAT</strong> is the following problem: given a set of clauses (each a disjunction of literals) and an integer k, find a satisfying assignment in which at most k variables are true, if such an assignment exists. Prove that <strong>STINGY SAT</strong> is NP-complete.</li>
</ul>
</blockquote>
<ul>
<li><strong>STINGY SAT</strong> 是这样的：给定一组子句（每个子句都是其中变量的析取）和整数$k$，求一个最多有$k$个变量为 true 的满足赋值——如果该赋值存在。证明 <strong>STINGY SAT</strong> 是一个 NP-完全问题。<ul>
<li>首先，易知 <strong>STINGY SAT</strong> 的解是可在多项式时间内验证的，因此 <strong>STINGY SAT</strong> 是一个 NP 问题。</li>
<li>另外，很容易可以将 <strong>SAT</strong> 归约到 <strong>STINGY SAT</strong>：将 k 设为 <strong>SAT</strong> 问题中所有变量的总个数即可，于是证明：<strong>STINGY SAT</strong> 是一个 NP 完全问题。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>[8.8] In the <strong>EXACT 4SAT</strong> problem, the input is a set of clauses, each of which is a disjunction of exactly four literals, and such that each variable occurs at most once in each clause. The goal is to find a satisfying assignment, if one exists. Prove that <strong>EXACT 4SAT</strong> is NP-complete.</li>
</ul>
</blockquote>
<ul>
<li>在 <strong>EXACT 4SAT</strong> 问题中，输入为一组子句，每个字句都是恰好 4 个变量的析取，且每个变量最多在每个子句中出现一次；目标是求它的满足——如果该赋值存在。证明 <strong>EXACT 4SAT</strong> 是一个 NP-完全问题。<ul>
<li>首先很显然，<strong>EXACT 4SAT</strong> 是一个 NP 问题。</li>
<li>现在通过将 <strong>3SAT</strong> 归约到 <strong>EXACT 4SAT</strong> 来证明后者的 NP 完全性。<ul>
<li>对于任意一个 <strong>3SAT</strong> 实例（一组子句），如果其中某个子句中包含了同一个变量多次，那么可以缩减为一次；如果同时包含了某个变量本身及其取反，那么可以将这个变量去掉。</li>
<li>然后，再在每个子句中添加一些哑变量（即没用的辅助变量，赋值为 true），这样就可以将每个子句所包含的变量数目扩充到 4 个。至此，即已将该 <strong>3SAT</strong> 实例转化成了一个 <strong>EXACT 4SAT</strong> 实例，于是证明：<strong>EXACT 4SAT</strong> 是一个 NP-完全问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="NPH-NP-Hard-问题"><a href="#NPH-NP-Hard-问题" class="headerlink" title="NPH(NP-Hard) 问题"></a>NPH(NP-Hard) 问题</h4><p>　假如一个问题，不是一个 NP 问题，但所有的 NPC 问题都可以在多项式时间内归约到它的话，我们就叫它 <code>NPH问题</code>，NP Hard，NP 难问题。</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a></li>
<li><a href="http://blog.csdn.net/databatman/article/details/49304295">[总结]算法中的P问题、NP问题、NP完全问题和NP难问题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在计算机算法求解问题当中，经常用&lt;code&gt;时间复杂度&lt;/code&gt;和&lt;code&gt;空间复杂度&lt;/code&gt;来表示一个算法的运行效率。空间复杂度表示一个算法在计算过程当中要占用的内存空间大小；时间复杂度则表示这个算法运行得到想要的解所需的计算工作量，并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快，即探讨的是当输入值接近无穷时，算法所需工作量的变化快慢程度。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DARPA[Boss]: Motion Planning in Urban Environments</title>
    <link href="http://durant35.github.io/2017/06/02/DARPA_Boss_MotionPlanninginUrbanEnvironments/"/>
    <id>http://durant35.github.io/2017/06/02/DARPA_Boss_MotionPlanninginUrbanEnvironments/</id>
    <published>2017-06-02T05:00:22.000Z</published>
    <updated>2017-06-03T14:37:33.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>model-predictIve trajectory generation algorithm（模型预测轨迹生成算法）</li>
<li>long range plans<ul>
<li>on-road planning</li>
<li>unstructured planning: parking lots/anomalous on-road scenarios（异常路况）<a id="more"></a>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;model-predictIve trajectory generation algorithm（模型预测轨迹生成算法）&lt;/li&gt;
&lt;li&gt;long range plans&lt;ul&gt;
&lt;li&gt;on-road planning&lt;/li&gt;
&lt;li&gt;unstructured planning: parking lots/anomalous on-road scenarios（异常路况）
    
    </summary>
    
      <category term="自动驾驶" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
      <category term="DARPA" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/DARPA/"/>
    
    
      <category term="DARPA" scheme="http://durant35.github.io/tags/DARPA/"/>
    
  </entry>
  
  <entry>
    <title>DARPA[Boss]: Boss and the Urban Challenge</title>
    <link href="http://durant35.github.io/2017/06/02/DARPA_Boss_BossandtheUrbanChallenge/"/>
    <id>http://durant35.github.io/2017/06/02/DARPA_Boss_BossandtheUrbanChallenge/</id>
    <published>2017-06-02T05:00:22.000Z</published>
    <updated>2017-06-04T02:37:58.380Z</updated>
    
    <content type="html"><![CDATA[<p>　Boss 自动驾驶软硬件概述。</p>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul>
<li>软件概述<ul>
<li>Motion planning sub-system<br>==&gt; 2 planners: avoiding static and dynamic obstacles while achieving a desired goal（最终都是产生一条 trajectory）<ul>
<li>structured driving: road following</li>
<li>unstructured driving: maneuvering in parking lots（停车场等的机动控制）</li>
</ul>
</li>
<li>Perception sub-system<a id="more"></a>
<ul>
<li>static obstacle map</li>
<li>moving obstacles</li>
<li>location relative to the road</li>
</ul>
</li>
<li>Mission planner<ul>
<li>optimal path given knowledge of the road network</li>
</ul>
</li>
<li>Behavioral sub-system<ul>
<li>Lane Driving</li>
<li>Intersection Handling</li>
<li>Goal Selection：分配 execution tasks</li>
</ul>
</li>
<li>Software infrastructure（软件基础框架） and tools<br>==&gt; online data logging, offline data log playback and visualization.</li>
</ul>
</li>
<li>硬件概述<ul>
<li>With electric motors to<ul>
<li>转向</li>
<li>踩刹车</li>
<li>shift the transmission 换挡、变速器</li>
</ul>
</li>
<li>保留 normal human driving controls：steering wheel、brake、gas pedal</li>
<li>Two independent power busses<ul>
<li>remaining 12VDC battery and harnesses（电池和线束）</li>
<li>an upgraded high-output alternator：24VDC</li>
</ul>
</li>
<li>Sensors 感知传感器<center><img src="/img/DARPA/Boss_sensorsOverview.png" width="540px"/></center>

</li>
</ul>
</li>
</ul>
<h4 id="Motion-Planning"><a href="#Motion-Planning" class="headerlink" title="Motion Planning"></a>Motion Planning</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　Boss 自动驾驶软硬件概述。&lt;/p&gt;
&lt;h4 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;软件概述&lt;ul&gt;
&lt;li&gt;Motion planning sub-system&lt;br&gt;==&amp;gt; 2 planners: avoiding static and dynamic obstacles while achieving a desired goal（最终都是产生一条 trajectory）&lt;ul&gt;
&lt;li&gt;structured driving: road following&lt;/li&gt;
&lt;li&gt;unstructured driving: maneuvering in parking lots（停车场等的机动控制）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Perception sub-system
    
    </summary>
    
      <category term="自动驾驶" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
      <category term="DARPA" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/DARPA/"/>
    
    
      <category term="DARPA" scheme="http://durant35.github.io/tags/DARPA/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0016] 二分图匹配问题</title>
    <link href="http://durant35.github.io/2017/06/01/Algorithms_BiGraphMatching/"/>
    <id>http://durant35.github.io/2017/06/01/Algorithms_BiGraphMatching/</id>
    <published>2017-06-01T13:00:22.000Z</published>
    <updated>2017-06-07T14:52:12.712Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二分图匹配问题"><a href="#二分图匹配问题" class="headerlink" title="二分图匹配问题"></a>二分图匹配问题</h4><ul>
<li>二分图<br><center><img src="/img/Algorithms/0016_bipartiteGraph.png" width="340px" alt=""/></center><ul>
<li>顶点被分成两个不相交的集合（$U$ 和 $V$）并且同属一个集合内的点两两不相连（$E_{in U} = E_{in V} = \emptyset$），即要么没有圈，要么圈所包含的边数必定是偶数。</li>
<li><strong>二分图</strong> 的一个等价定义是：不含有 <strong>含奇数条边的环</strong> 的图。<a id="more"></a></li>
</ul>
</li>
<li><strong>匹配</strong> 是边的集合 $M$（$M \subseteq E$），其中任意的两条边不共点：$e_1, e_2 \in M, e_1 \cap e_2 = \varnothing $<ul>
<li>集合 $M$ 中的元素（边），称为 <strong>匹配边</strong></li>
<li>匹配边所连接的点被称为 <strong>匹配点</strong></li>
<li>同理可以定义 <strong>非匹配边</strong> 和 <strong>非匹配点</strong> 的概念</li>
</ul>
</li>
<li>最大匹配<ul>
<li>对于一个二分图可能有多种匹配，如果二分图里的某一个匹配包含的边的数量，在该二分图的所有匹配中最大，那么这个匹配称为 <strong>最大匹配</strong></li>
<li>如果一个图的某个匹配中，<font color="blue">所有的顶点都是匹配点</font>（可能会残留一些边不是匹配边），那么它就是一个 <strong>完美匹配</strong>。</li>
<li>显然，<strong>完美匹配</strong> 一定是 <strong>最大匹配</strong>（<strong>完美匹配</strong> 的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）；但并非每个图都存在 <strong>完美匹配</strong>，即  <strong>最大匹配</strong> 不一定是 <strong>完美匹配</strong>。</li>
</ul>
</li>
<li>增广路径（增广轨）<ul>
<li>在二分图的匹配中，如果一条路径的首尾是 <strong>非匹配点</strong>，路径中除此之外的（如果有）其他点均是 <strong>匹配点</strong>，那么这条路径就是一条 <strong>增广路径（agumenting path）/增广轨</strong>（顾名思义是指一条可以使匹配数变多的路径）。<ul>
<li>$A：$首尾是非匹配点，因此，增广路径的第一条和最后一条边，必然是 <strong>非匹配边</strong>。</li>
<li>$B：$增广路径的第二条（如果有）和倒数第二条（如果有），必然是 <strong>匹配边</strong> $\Longleftarrow N$ 个点（$0～N-1$），$v_1, v_2, …, v_{N-3}, v_{N-2}$ 均为匹配点，且 ($v_0 → v_1$) 和 ($v_{N-2} → v_{N-1}$) 为 <strong>非匹配边</strong>。</li>
<li>$C：$第三条（如果有）和倒数第三条（如果有）一定是 <strong>非匹配边</strong> $\Longleftarrow $($v_1 → v_2$)$\in M$，($v_1 → v_2$)$\cap$($v_2 → v_3$)$= v_2$，故 ($v_2 → v_3$) 只能是 <strong>非匹配边</strong></li>
</ul>
</li>
<li>$A, B, C \Longrightarrow$ 增广路径从非匹配边开始，匹配边和非匹配边依次交替，最后由非匹配边结束 $\Longrightarrow$ 增广路径中，非匹配边的数目会比匹配边大 1。</li>
<li>在二分图的匹配中，从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫 <strong>交替路径/交替轨</strong>。<ul>
<li><strong>增广路径/增广轨</strong> 也被称为 <strong>交替路径/交替轨</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><ul>
<li>增广路径的性质<ul>
<li>有奇数条边</li>
<li>起点在二分图的左半边$U$，终点在右半边$V$</li>
<li>路径上的点一定是一个在左半边，一个在右半边，交替出现。（其实二分图的性质就决定了这一点，因为二分图同一边的点之间没有边相连）</li>
<li>整条路径上没有重复的点</li>
<li>起点和终点都是目前还没有配对的点，而其它所有点都是已经配好对的</li>
<li>路径上的所有第奇数条边都不在原匹配中，所有第偶数条边都出现在原匹配中</li>
<li>最后，也是最重要的一条，把增广路径上的所有第奇数条边加入到原匹配中去，并把增广路径中的所有第偶数条边从原匹配中删除（这个操作称为增广路径的 <strong>取反</strong> ），则新的匹配数就比原匹配数增加了1个</li>
</ul>
</li>
<li>算法思想<ul>
<li>初始时最大匹配为空。</li>
<li>从二分图中找出一条路径来，让路径的起点和终点都是还没有匹配过的点，并且路径经过的连线是一条没被匹配、一条已经匹配过、再下一条又没被匹配过这样交替的出现。</li>
<li>找到这样的路径后，显然路径里没被匹配过的连线比已经匹配了的连线多一条，于是修改匹配图，把路径里所有匹配过的连线去掉匹配关系，把没有匹配的连线变成匹配的，这样匹配数就比原来多1。</li>
<li>不断执行上述操作，直到找不到这样的路径为止。<ul>
<li>从反证法考虑，即假设存在这样的情况：当前匹配不是二分图的最大匹配，但已找不到一条新的增广路径。因为当前匹配不是二分图的最大匹配，那么在两个集合中，分别至少存在一个非匹配点。那么情况分为两种：<ul>
<li>这两个点之间存在一条边——那么我们找到了一条新的增广路径，产生矛盾；</li>
<li>这两个点之间不存在直接的边，即这两个点分别都只与匹配点相连——那么：（1）如果这两个点可以用已有的匹配点相连，那么我们找到了一条新的增广路径，产生矛盾；（2）如果这两个点无法用已有的匹配点相连，那么这两个点也就无法增加匹配中边的数量，也就是我们已经找到了二分图的最大匹配，产生矛盾。</li>
</ul>
</li>
<li>在所有可能的情况，上述假设都会产生矛盾。因此假设不成立，亦即贪心算法：不断地搜寻出增广路径，直到最终我们找不到新的增广路径为止，必然能求得最大匹配的解。</li>
</ul>
</li>
<li>如果二分图的左半边 $U$ 一共有 $|V_U|$ 个点，最多找 $|V_U|$ 条增广路径，如果图中有 $|E|$ 条边，每一条增广路径把所有边遍历一遍，所以时间复杂度为 $O(|V_U|·|E|)$。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>BigraphMatching.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>		<span class="comment">/* queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNMATCHING 	-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTPOINT	-1</span></div><div class="line">  </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  <span class="comment">// 0: in U/ 1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  <span class="comment">// 0: in U/1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data &gt;&gt; UorV; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].UorV = UorV;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">    <span class="comment">// Bigraph is a undirected graph</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeStart;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeEnd].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeEnd].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for Bigraph&lt;U, V&gt; is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].UorV == <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"U"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"V"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span> prevs[], <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != STARTPOINT) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx].data;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatching</span><span class="params">(Graph&amp; g, <span class="keyword">const</span> <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(matchings[i]!=<span class="number">-1</span> &amp;&amp; !visited[i]) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--&gt;"</span> &lt;&lt; g.VertexNodes[matchings[i]].data</div><div class="line">         &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">     	visited[i] = <span class="literal">true</span>;</div><div class="line">     	visited[matchings[i]] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> U[g.vertexNum], V[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> uSize = <span class="number">0</span>, vSize = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertex=<span class="number">0</span>; vertex&lt;g.vertexNum; vertex++) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[vertex].UorV == <span class="number">0</span>) &#123;</div><div class="line">      U[uSize++] = g.VertexNodes[vertex].vertexIdx;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      V[vSize++] = g.VertexNodes[vertex].vertexIdx;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> matchingSize = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="comment">// -1 means no matching</span></div><div class="line">    matchings[i] = UNMATCHING;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// cout &lt;&lt; "U: #" &lt;&lt; uSize &lt;&lt; " V: #" &lt;&lt; vSize &lt;&lt; endl;</span></div><div class="line"> </div><div class="line">  <span class="keyword">int</span> prevs[g.vertexNum];</div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; bfsVertexQueue;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Hungarian Algorithm's Process: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexInU=<span class="number">0</span>; vertexInU&lt;uSize; vertexInU++) &#123;</div><div class="line">    <span class="keyword">int</span> vertexIdx = U[vertexInU];</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="comment">// find an agumenting path, starting with an unmatching vertex</span></div><div class="line">    <span class="keyword">if</span>(matchings[vertexIdx] == UNMATCHING) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"unmatched vertex"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">      <span class="keyword">while</span>(!bfsVertexQueue.empty()) &#123;</div><div class="line">        bfsVertexQueue.pop();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">bool</span> visited[g.vertexNum] = &#123;<span class="literal">false</span>&#125;;</div><div class="line"> </div><div class="line">      bfsVertexQueue.push(vertexIdx);</div><div class="line">      visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line">      <span class="comment">// prevs for augumenting path's backtracking, -1 means starting point</span></div><div class="line">      prevs[vertexIdx] = STARTPOINT;</div><div class="line"> </div><div class="line">      <span class="keyword">bool</span> pathFound = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">while</span>(!bfsVertexQueue.empty() &amp;&amp; !pathFound) &#123;</div><div class="line">        <span class="keyword">int</span> u = bfsVertexQueue.front();</div><div class="line">        <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; g.VertexNodes[u].data &lt;&lt; endl;</span></div><div class="line">        bfsVertexQueue.pop();</div><div class="line"> </div><div class="line">        adjVertexNode* head = g.VertexNodes[u].<span class="built_in">list</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; !pathFound) &#123;</div><div class="line">          <span class="keyword">int</span> v = head-&gt;adjVertexIdx;</div><div class="line">          <span class="comment">// visited: avoid loop</span></div><div class="line">          <span class="keyword">if</span>(!visited[v]) &#123;</div><div class="line">            <span class="comment">// v is a matching vertex</span></div><div class="line">            <span class="keyword">if</span>(matchings[v] != UNMATCHING) &#123;</div><div class="line">              bfsVertexQueue.push(matchings[v]);</div><div class="line">              visited[v] = <span class="literal">true</span>;</div><div class="line">              visited[matchings[v]] = <span class="literal">true</span>;</div><div class="line">              prevs[v] = u;</div><div class="line">              prevs[matchings[v]] = v;</div><div class="line">              <span class="comment">// cout &lt;&lt; "push: " &lt;&lt; g.VertexNodes[matchings[v]].data &lt;&lt; endl;</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// v is the other unmatching vertex, augumenting path found</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">// record previous vertex for backtracking</span></div><div class="line">              prevs[v] = u;</div><div class="line"> </div><div class="line">              pathFound = <span class="literal">true</span>;</div><div class="line">              <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\tAugumenting path: "</span>;</div><div class="line">              PrintPath(g, prevs, v);</div><div class="line">              <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">              <span class="comment">// reverse the augumenting path, for one more matching</span></div><div class="line">              <span class="keyword">int</span> curIdx = v, prevIdx = u;</div><div class="line">              <span class="keyword">bool</span> isMatchedEdge = <span class="literal">false</span>;</div><div class="line">              <span class="keyword">while</span>(prevIdx != STARTPOINT) &#123;</div><div class="line">                <span class="keyword">if</span>(!isMatchedEdge) &#123;</div><div class="line">                  matchings[curIdx] = prevIdx;</div><div class="line">                  matchings[prevIdx] = curIdx;</div><div class="line">                &#125;</div><div class="line">                isMatchedEdge = !isMatchedEdge;</div><div class="line">                curIdx = prevIdx;</div><div class="line">                prevIdx = prevs[prevIdx];</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          head = head-&gt;next;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// expand one more matching</span></div><div class="line">      <span class="keyword">if</span>(matchings[vertexIdx] != UNMATCHING) &#123;</div><div class="line">        matchingSize++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"matched vertex"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> matchingSize;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_GRAPH1</span></div><div class="line">    freopen(<span class="string">"Bigraph1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"Bigraph2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> matchings[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> matchingSize = Hungarian(g, matchings);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maximum Matching: #"</span> &lt;&lt; matchingSize &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMatching(g, matchings);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节如下<ul>
<li><code>int Hungarian(Graph&amp; g, int matchings[])</code> 函数根据传入的二分图 <code>g</code>，运行<strong>匈牙利算法</strong>确定该二分图的最大匹配数并返回，对应的匹配信息通过 <code>matchings</code> 数组返回。</li>
<li>从左边 $U$ 顶点集第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路径。<ul>
<li>上述实现中采用<strong>BFS</strong>进行搜索，也可以采用<strong>DFS</strong>进行搜索。<ul>
<li>如果经过一个未匹配点，说明搜索成功：根据增广路径更新匹配信息，最大匹配数 +1，停止搜索。</li>
<li>如果经过一个匹配点，</li>
</ul>
</li>
<li>如果未能找到增广路径，则跳过这个点进行下一次搜索：事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li>
</ul>
</li>
<li>由于找到增广路径之后需要沿着路径更新匹配信息（取反操作），所以我们需要一个结构来记录路径上的点。DFS 通过函数递归调用隐式地使用一个栈，而 我们的 BFS 实现中使用 <code>prevs</code> 数组来记录增广路径上途径的点信息。<ul>
<li>沿着增广路径更新匹配信息（取反操作）是根据增广路径上的匹配边、非匹配边交替出现的性质。<center><img src="/img/Algorithms/0016_ExampleBigraphHungarian.png" width="420px" alt=""/></center></li>
</ul>
</li>
</ul>
</li>
<li><code>Graph[1]</code> 输入文件如下：</li>
<li>  <figure class="highlight cpp"><figcaption><span>Bigraph1.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">8</span> <span class="number">7</span></div><div class="line"><span class="number">1</span> <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">0</span></div><div class="line"><span class="number">3</span> <span class="number">0</span></div><div class="line"><span class="number">4</span> <span class="number">0</span></div><div class="line"><span class="number">5</span> <span class="number">1</span></div><div class="line"><span class="number">6</span> <span class="number">1</span></div><div class="line"><span class="number">7</span> <span class="number">1</span></div><div class="line"><span class="number">8</span> <span class="number">1</span></div><div class="line"><span class="number">0</span> <span class="number">4</span></div><div class="line"><span class="number">0</span> <span class="number">6</span></div><div class="line"><span class="number">1</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">5</span></div><div class="line"><span class="number">3</span> <span class="number">6</span></div><div class="line"><span class="number">3</span> <span class="number">7</span></div></pre></td></tr></table></figure>
<ul>
<li>构建运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_GRAPH1 BigraphMatching.cpp -o BigraphMatching</div><div class="line">$ ./BigraphMatching </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;7 5 </div><div class="line"> 2(U)-&gt;5 </div><div class="line"> 3(U)-&gt;6 5 </div><div class="line"> 4(U)-&gt;8 7 </div><div class="line"> 5(V)-&gt;3 2 1 </div><div class="line"> 6(V)-&gt;3 </div><div class="line"> 7(V)-&gt;4 1 </div><div class="line"> 8(V)-&gt;4 </div><div class="line"> </div><div class="line">Hungarian Algorithm&apos;s Process: </div><div class="line">  1: unmatched vertex</div><div class="line">    Augumenting path: 1-&gt;7</div><div class="line">  2: unmatched vertex</div><div class="line">    Augumenting path: 2-&gt;5</div><div class="line">  3: unmatched vertex</div><div class="line">    Augumenting path: 3-&gt;6</div><div class="line">  4: unmatched vertex</div><div class="line">    Augumenting path: 4-&gt;8</div><div class="line"> </div><div class="line">Maximum Matching: #4</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;5</div><div class="line">  + 3&lt;--&gt;6</div><div class="line">  + 4&lt;--&gt;8</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>Graph[2]</code> 输入文件如下：</li>
<li>  <figure class="highlight cpp"><figcaption><span>Bigraph2.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="number">12</span> <span class="number">16</span></div><div class="line"><span class="number">1</span> <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">0</span></div><div class="line"><span class="number">3</span> <span class="number">0</span></div><div class="line"><span class="number">4</span> <span class="number">0</span></div><div class="line"><span class="number">5</span> <span class="number">0</span></div><div class="line"><span class="number">6</span> <span class="number">0</span></div><div class="line"><span class="number">7</span> <span class="number">1</span></div><div class="line"><span class="number">8</span> <span class="number">1</span></div><div class="line"><span class="number">9</span> <span class="number">1</span></div><div class="line">a <span class="number">1</span></div><div class="line">b <span class="number">1</span></div><div class="line">c <span class="number">1</span></div><div class="line"><span class="number">0</span> <span class="number">6</span></div><div class="line"><span class="number">0</span> <span class="number">7</span></div><div class="line"><span class="number">0</span> <span class="number">9</span></div><div class="line"><span class="number">1</span> <span class="number">7</span></div><div class="line"><span class="number">1</span> <span class="number">11</span></div><div class="line"><span class="number">2</span> <span class="number">7</span></div><div class="line"><span class="number">2</span> <span class="number">8</span></div><div class="line"><span class="number">3</span> <span class="number">8</span></div><div class="line"><span class="number">3</span> <span class="number">10</span></div><div class="line"><span class="number">3</span> <span class="number">11</span></div><div class="line"><span class="number">4</span> <span class="number">8</span></div><div class="line"><span class="number">4</span> <span class="number">9</span></div><div class="line"><span class="number">4</span> <span class="number">10</span></div><div class="line"><span class="number">4</span> <span class="number">11</span></div><div class="line"><span class="number">5</span> <span class="number">7</span></div><div class="line"><span class="number">5</span> <span class="number">10</span></div></pre></td></tr></table></figure>
<ul>
<li>构建运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">$ g++ BigraphMatching.cpp -o BigraphMatching</div><div class="line">$ ./BigraphMatching </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;a 8 7 </div><div class="line"> 2(U)-&gt;c 8 </div><div class="line"> 3(U)-&gt;9 8 </div><div class="line"> 4(U)-&gt;c b 9 </div><div class="line"> 5(U)-&gt;c b a 9 </div><div class="line"> 6(U)-&gt;b 8 </div><div class="line"> 7(V)-&gt;1 </div><div class="line"> 8(V)-&gt;6 3 2 1 </div><div class="line"> 9(V)-&gt;5 4 3 </div><div class="line"> a(V)-&gt;5 1 </div><div class="line"> b(V)-&gt;6 5 4 </div><div class="line"> c(V)-&gt;5 4 2 </div><div class="line"> </div><div class="line">Hungarian Algorithm&apos;s Process: </div><div class="line">  1: unmatched vertex</div><div class="line">    Augumenting path: 1-&gt;a</div><div class="line">  2: unmatched vertex</div><div class="line">    Augumenting path: 2-&gt;c</div><div class="line">  3: unmatched vertex</div><div class="line">    Augumenting path: 3-&gt;9</div><div class="line">  4: unmatched vertex</div><div class="line">    Augumenting path: 4-&gt;b</div><div class="line">  5: unmatched vertex</div><div class="line">    Augumenting path: 5-&gt;c-&gt;2-&gt;8</div><div class="line">  6: unmatched vertex</div><div class="line">    Augumenting path: 6-&gt;b-&gt;4-&gt;c-&gt;5-&gt;a-&gt;1-&gt;7</div><div class="line"> </div><div class="line">Maximum Matching: #6</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;8</div><div class="line">  + 3&lt;--&gt;9</div><div class="line">  + 4&lt;--&gt;c</div><div class="line">  + 5&lt;--&gt;a</div><div class="line">  + 6&lt;--&gt;b</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>补充概念：匈牙利树<br><center><img src="/img/Algorithms/0016_HungarianTree.png" width="540px" alt=""/></center><ul>
<li>上文提到的 <strong>匈牙利树</strong> 一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。</li>
<li>上图（1），可以得到如图（2）的一棵 BFS 树：这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。相比之下，由图（3）得到的如图（4）的一棵 BFS 树，就是一棵匈牙利树。</li>
</ul>
</li>
</ul>
<h4 id="最大流方法计算最大匹配"><a href="#最大流方法计算最大匹配" class="headerlink" title="最大流方法计算最大匹配"></a>最大流方法计算最大匹配</h4><p>　如下图所示，对于一个二分图$G$，令已有的边的容量（Capacity）为无穷大，增加一个源点$S$和一个汇点$T$，令$S$和$T$分别连接二分图中的左半边$U$和右半边$V$，并设置其容量为1。这时得到流网络$G’$，计算得到的$G’$最大流就等于$G$的最大匹配。</p>
<center><img src="/img/Algorithms/0016_Bigraph2NetworkGraph.png" width="440px" alt=""/></center>

<ul>
<li>算法正确性简单证明<ul>
<li>首先假设，当前流网络有一个最大流，但它对应的不是最大匹配。那么，我们至少还可以向最大匹配中加入一条边$(u→v)$，显然我们还可以增加一条增广路径：<code>s-&gt;u-&gt;v-&gt;t</code>，那么就得到一个更大的流，和假设矛盾，所以假设不成立。</li>
<li>同理，假设当前有一个最大匹配，其对应的不是最大流，那么至少还存在一条增广路径<code>s-&gt;u-&gt;v-&gt;t</code>以确保更大的流，这时就可以增加边$(u→v)$到最大匹配中，同样和假设矛盾。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>BigraphMatchingbyMaxFlow.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>			<span class="comment">/* setw */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>			<span class="comment">/* queue */</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">  </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNMATCHING 	-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTPOINT	-1</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  <span class="comment">// 0: in U/ 1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  <span class="comment">// 0: in U/1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data &gt;&gt; UorV; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].UorV = UorV;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line">    </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">    <span class="comment">// Bigraph is a undirected graph</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeStart;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeEnd].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeEnd].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for Bigraph&lt;U, V&gt; is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].UorV == <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"U"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"V"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span> prevs[], <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != STARTPOINT) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(toIdx == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(toIdx == g.vertexNum+<span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx<span class="number">-1</span>].data;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatching</span><span class="params">(Graph&amp; g, <span class="keyword">const</span> <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(matchings[i]!=<span class="number">-1</span> &amp;&amp; !visited[i]) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--&gt;"</span> &lt;&lt; g.VertexNodes[matchings[i]].data</div><div class="line">         &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">     	visited[i] = <span class="literal">true</span>;</div><div class="line">     	visited[matchings[i]] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>** graph, <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx, <span class="keyword">int</span>* prevs)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;vertexNum; vertexIdx++) &#123;</div><div class="line">    visited[vertexIdx] = <span class="literal">false</span>;</div><div class="line">    prevs[vertexIdx] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertexIdxQueue;</div><div class="line">  vertexIdxQueue.push(fromIdx);</div><div class="line">  visited[fromIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span> (!vertexIdxQueue.empty()) &#123;</div><div class="line">    <span class="keyword">int</span> u = vertexIdxQueue.front();</div><div class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " ";</span></div><div class="line">    <span class="keyword">if</span>(u == toIdx) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    vertexIdxQueue.pop();</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[v] &amp;&amp; graph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        vertexIdxQueue.push(v);</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">        prevs[v] = u;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> visited[toIdx];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxMatchingbyMaxFlow</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    matchings[i] = UNMATCHING;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// Add source[0] and sink[g.vertexNum+1]</span></div><div class="line">  <span class="keyword">int</span> N = g.vertexNum+<span class="number">2</span>;</div><div class="line">  <span class="keyword">int</span> sourceIdx = <span class="number">0</span>, sinkIdx = g.vertexNum+<span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> maxFlow = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> flowGraph[N][N];</div><div class="line">  <span class="comment">// initialize the residual graph</span></div><div class="line">  <span class="keyword">int</span>** residualGraph = <span class="keyword">new</span> <span class="keyword">int</span>*[N];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;N; u++) &#123;</div><div class="line">    residualGraph[u] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;N; v++) &#123;</div><div class="line">      residualGraph[u][v] = <span class="number">0</span>;</div><div class="line">      flowGraph[u][v] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;g.vertexNum; vertexIdx++) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[vertexIdx].UorV == <span class="number">0</span>) &#123;</div><div class="line">      residualGraph[sourceIdx][vertexIdx+<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"> </div><div class="line">      adjVertexNode* head = g.VertexNodes[vertexIdx].<span class="built_in">list</span>;</div><div class="line">      <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">        residualGraph[vertexIdx+<span class="number">1</span>][head-&gt;adjVertexIdx+<span class="number">1</span>] = INT_MAX;</div><div class="line">        head = head-&gt;next;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      residualGraph[vertexIdx+<span class="number">1</span>][sinkIdx] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// prevs array for storing the augmenting path</span></div><div class="line">  <span class="keyword">int</span> prevs[N];</div><div class="line">  <span class="keyword">int</span> iter = <span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Algorithm Process:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// Augment the flow while there is a path from source to sink</span></div><div class="line">  <span class="keyword">while</span>(BFS(residualGraph, N, sourceIdx, sinkIdx, prevs)) &#123;</div><div class="line">    <span class="comment">// find the maximum flow(minimum residual capacity) through the path found</span></div><div class="line">    <span class="keyword">int</span> pathFlow = INT_MAX;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sinkIdx; v!=sourceIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      <span class="keyword">if</span>(residualGraph[u][v] &lt; pathFlow) &#123;</div><div class="line">        pathFlow = residualGraph[u][v];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update residual capacities of the edges &amp; reverse edges along the augmenting path</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sinkIdx; v!=sourceIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      residualGraph[u][v] -= pathFlow;</div><div class="line">      residualGraph[v][u] += pathFlow;</div><div class="line">      <span class="comment">// record flows</span></div><div class="line">      flowGraph[u][v] += pathFlow;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update matching from augumenting path</span></div><div class="line">    <span class="keyword">int</span> curIdx = prevs[sinkIdx], prevIdx = prevs[curIdx];</div><div class="line">    <span class="keyword">while</span>(prevIdx != STARTPOINT) &#123;</div><div class="line">      <span class="comment">// -1 with source and sink</span></div><div class="line">      matchings[curIdx<span class="number">-1</span>] = prevIdx<span class="number">-1</span>;</div><div class="line">      matchings[prevIdx<span class="number">-1</span>] = curIdx<span class="number">-1</span>;</div><div class="line"></div><div class="line">      curIdx = prevs[prevIdx];</div><div class="line">      prevIdx = prevs[curIdx];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    maxFlow += pathFlow;</div><div class="line">    <span class="comment">// print current iteration's info</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t#"</span> &lt;&lt; iter++ &lt;&lt; <span class="string">" flow: "</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; pathFlow &lt;&lt; <span class="string">" Augmenting-path: "</span>;</div><div class="line">    PrintPath(g, prevs, sinkIdx);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// memory release</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">    <span class="keyword">delete</span>[] residualGraph[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>[] residualGraph;</div><div class="line"> </div><div class="line">  <span class="comment">// show the flows</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">bool</span> noflow;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    noflow = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> &lt;&lt; g.VertexNodes[u].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(flowGraph[u+<span class="number">1</span>][v+<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; g.VertexNodes[v].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; flowGraph[u+<span class="number">1</span>][v+<span class="number">1</span>] &lt;&lt; <span class="string">")\t"</span>;</div><div class="line">        noflow = <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(noflow) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> maxFlow;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_GRAPH1</span></div><div class="line">    freopen(<span class="string">"Bigraph1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"Bigraph2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> matchings[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> matchingSize = MaxMatchingbyMaxFlow(g, matchings);</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maximum Matching: #"</span> &lt;&lt; matchingSize &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMatching(g, matchings);</div><div class="line">  </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节如下：<ul>
<li><code>int MaxMatchingbyMaxFlow(Graph&amp; g, int matchings[])</code> 实现了和匈牙利算法中一样的函数接口，思路很简单，<code>residualGraph</code> 初始化为构造的流网络$G’$，然后调用最大流算法，得到的<strong>最大流</strong>即为返回的<strong>最大匹配数</strong>；此外，利用最大流算法每次迭代搜索到的增广路径更新匹配信息<code>matchings</code>。</li>
<li>因为二分图上任何匹配数目至多为$|V’| = min(|V_{\in U}|, |V_{\in V}|)$，所以流网络$G’$中最大流的值为$O(|V’|)$，因此，可以在$O(|V’|·|E’|) = O(|V|·|E|)$的时间内找出二分图的最大匹配。</li>
</ul>
</li>
<li>利用上述最大流方法得到的匹配信息和匈牙利算法有些许区别，但可以看出，都能正确得到最大匹配，同时也是完美匹配。<center><img src="/img/Algorithms/0016_ExampleBigraphMaxflow.png" width="420px" alt=""/></center>

</li>
</ul>
<figure class="highlight plain"><figcaption><span>Graph[1]</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_GRAPH1 BigraphMatchingbyMaxFlow.cpp -o BigraphMatchingbyMaxFlow</div><div class="line">$ ./BigraphMatchingbyMaxFlow </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;7 5 </div><div class="line"> 2(U)-&gt;5 </div><div class="line"> 3(U)-&gt;6 5 </div><div class="line"> 4(U)-&gt;8 7 </div><div class="line"> 5(V)-&gt;3 2 1 </div><div class="line"> 6(V)-&gt;3 </div><div class="line"> 7(V)-&gt;4 1 </div><div class="line"> 8(V)-&gt;4 </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   1 Augmenting-path: S-&gt;1-&gt;5-&gt;T</div><div class="line">  #2 flow:   1 Augmenting-path: S-&gt;3-&gt;6-&gt;T</div><div class="line">  #3 flow:   1 Augmenting-path: S-&gt;4-&gt;7-&gt;T</div><div class="line">  #4 flow:   1 Augmenting-path: S-&gt;2-&gt;5-&gt;1-&gt;7-&gt;4-&gt;8-&gt;T</div><div class="line"> Maximum Flow Graph:</div><div class="line">   1: -&gt;5(1)	-&gt;7(1)	</div><div class="line">   2: -&gt;5(1)	</div><div class="line">   3: -&gt;6(1)	</div><div class="line">   4: -&gt;7(1)	-&gt;8(1)	</div><div class="line">   5: -&gt;1(1)	</div><div class="line">   6: NULL</div><div class="line">   7: -&gt;4(1)	</div><div class="line">   8: NULL</div><div class="line"> </div><div class="line">Maximum Matching: #4</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;5</div><div class="line">  + 3&lt;--&gt;6</div><div class="line">  + 4&lt;--&gt;8</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>Graph[2]</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">$ g++ BigraphMatchingbyMaxFlow.cpp -o BigraphMatchingbyMaxFlow</div><div class="line">$ ./BigraphMatchingbyMaxFlow </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;a 8 7 </div><div class="line"> 2(U)-&gt;c 8 </div><div class="line"> 3(U)-&gt;9 8 </div><div class="line"> 4(U)-&gt;c b 9 </div><div class="line"> 5(U)-&gt;c b a 9 </div><div class="line"> 6(U)-&gt;b 8 </div><div class="line"> 7(V)-&gt;1 </div><div class="line"> 8(V)-&gt;6 3 2 1 </div><div class="line"> 9(V)-&gt;5 4 3 </div><div class="line"> a(V)-&gt;5 1 </div><div class="line"> b(V)-&gt;6 5 4 </div><div class="line"> c(V)-&gt;5 4 2 </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   1 Augmenting-path: S-&gt;1-&gt;7-&gt;T</div><div class="line">  #2 flow:   1 Augmenting-path: S-&gt;2-&gt;8-&gt;T</div><div class="line">  #3 flow:   1 Augmenting-path: S-&gt;3-&gt;9-&gt;T</div><div class="line">  #4 flow:   1 Augmenting-path: S-&gt;4-&gt;b-&gt;T</div><div class="line">  #5 flow:   1 Augmenting-path: S-&gt;5-&gt;a-&gt;T</div><div class="line">  #6 flow:   1 Augmenting-path: S-&gt;6-&gt;8-&gt;2-&gt;c-&gt;T</div><div class="line"> Maximum Flow Graph:</div><div class="line">   1: -&gt;7(1)	</div><div class="line">   2: -&gt;8(1)	-&gt;c(1)	</div><div class="line">   3: -&gt;9(1)	</div><div class="line">   4: -&gt;b(1)	</div><div class="line">   5: -&gt;a(1)	</div><div class="line">   6: -&gt;8(1)	</div><div class="line">   7: NULL</div><div class="line">   8: -&gt;2(1)	</div><div class="line">   9: NULL</div><div class="line">   a: NULL</div><div class="line">   b: NULL</div><div class="line">   c: NULL</div><div class="line">  </div><div class="line">Maximum Matching: #6</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;c</div><div class="line">  + 3&lt;--&gt;9</div><div class="line">  + 4&lt;--&gt;b</div><div class="line">  + 5&lt;--&gt;a</div><div class="line">  + 6&lt;--&gt;8</div></pre></td></tr></table></figure>
<h4 id="最大匹配与最大边独立集"><a href="#最大匹配与最大边独立集" class="headerlink" title="最大匹配与最大边独立集"></a>最大匹配与最大边独立集</h4><ul>
<li>边独立集即一个边集，满足边集中的任意两边不邻接。</li>
<li>极大边独立集(maximal edge independent set)：本身为边独立集，再加入任何边都不是。</li>
<li>最大边独立集(maximum edge independent set)：边最多的边独立集。</li>
<li>边独立数(edge independent number)：最大边独立集的边数。</li>
<li>边独立集又称匹配(matching)，相应的有极大匹配(maximal matching)，最大匹配(maximum matching)，匹配数(matching number)。</li>
</ul>
<h4 id="最大匹配与最小路径覆盖"><a href="#最大匹配与最小路径覆盖" class="headerlink" title="最大匹配与最小路径覆盖"></a>最大匹配与最小路径覆盖</h4><ul>
<li>给定有向图$G=(V, E)$，设$P$是$G$的一个简单路（顶点不相交）的集合。如果$V$中每个顶点恰好在$P$的一条路上，则称$P$是$G$的一个<strong>路径覆盖</strong>。$P$中路径可以从$V$的任何一个顶点开始，长度也是任意的，特别地，可以为0（单个点）。$G$的<strong>最小路径覆盖</strong>是$G$的所含路径条数$|P|$最少的路径覆盖。</li>
<li><strong>最小路径覆盖数＝$G$的点数$|V|$ - 最小路径覆盖$P$中的边的数目</strong>（$P$由边和点组成，且不出现重复点）$\Longrightarrow$ 最小路径覆盖$P$中的边数尽量多，但是又不能让两条边在同一个顶点相交。<ul>
<li>拆点：将每一个顶点$i$拆成两个顶点$U_i$和$V_i$。</li>
<li>根据原图中边的信息，从左半边$U$往右半边$V$引边，所有边的方向都是由$U$到$V$，即如果有边$(u→v)$，则在二分图$G’$中引入边$(U_u→V_v)$。</li>
<li>因此，所转化出的二分图$G’$的最大匹配数则是原图$G$中最小路径覆盖上的边数。因此<strong>最小路径覆盖数＝原图$G$的顶点数 - 二分图$G’$的最大匹配数</strong>便可以得解。</li>
</ul>
</li>
<li>简单证明：<strong>最小路径覆盖数＝$G$的点数$|V|$-$G’$的最大匹配数</strong><ul>
<li>首先，若最大匹配数为0，则二分图$G’$中无边，也就是说图$G$中不存在边，那么显然：最小路径覆盖数=$|V|$ - 最大匹配数=$|V|$ - 0=$|V|$。</li>
<li>若此时增加一条匹配边$(U_u→V_v)$，则在图$G$中，u、v在同一条路径上，最小路径覆盖数减少一个。继续增加匹配边，每增加一条，最小路径覆盖数减少一个，则公式：最小路径覆盖数=|V|-$G’$最大匹配数得证。</li>
</ul>
</li>
<li>提取最小路径覆盖？<ul>
<li>二分图$G’$的最大匹配中的匹配边对应的原图$G$中的边，加上未在边中的顶点，即为最小路径覆盖。 </li>
</ul>
</li>
</ul>
<h4 id="最大匹配与最小点覆盖"><a href="#最大匹配与最小点覆盖" class="headerlink" title="最大匹配与最小点覆盖"></a>最大匹配与最小点覆盖</h4><ul>
<li>顶点覆盖问题：输入一个图$G$和预算$b$，求$b$个能够覆盖到每条边的顶点。</li>
<li>最小覆盖要求用最少的点（假如是二分图，$U$集合或$V$集合的都行），让每条边都至少和其中一个点关联，即假如选了一个点就相当于覆盖了以它为端点的所有边，如何需要选择最少的点来覆盖途图中的所有的边？</li>
<li><strong>König定理</strong>：一个二分图中的最大匹配数等于这个图中的最小点覆盖数。<br><center><img src="/img/Algorithms/0016_Bigraph3.png" width="480px" alt=""/></center><ul>
<li>如上图，我们已经通过上述的匈牙利算法求出了最大匹配数：$M=3$，最大匹配：$(A→G)、(B→H)、(D→I)$。</li>
<li>匈牙利算法需要我们从左半边$U$的某个没有匹配的点，走出一条使得“一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现”的路（交错轨，增广轨）。但是，现在我们已经找到了最大匹配，已经不存在这样的路了。换句话说，我们能寻找到很多可能的增广路，但最后都以找不到“终点是还没有匹配过的点”而失败（如上图$[E→B→H→D→I]$和$[F→B→H→D→I]$）。我们给所有这样的点打上记号（用<font color="red">“√”</font>表示）：从右半边$V$（从左半边$U$出发的增广路径已经在匈牙利算法中搜索过，重复显然没有意义）的所有没有匹配过的点出发，按照增广轨“交替出现”的要求可以走到的所有点（最后走出的路径是很多条不完整的增广路），我们将这些点一一打上标记。</li>
<li>那么这些点（红色矩形圈出来的点）组成了最小点覆盖点集：<strong>右边所有没有打上记号的点，加上左边已经有记号的点</strong>。</li>
</ul>
</li>
<li><strong>König定理</strong>简单证明<ul>
<li>首先，为什么这样得到的点集，点的个数恰好有$M$个呢？<ul>
<li>答案很简单，因为这样得到的点集中的每个点都是某条匹配边的其中一个端点。<ul>
<li><strong>右边所有没有打上<font color="red">“√”</font>的点和左边已经有<font color="red">“√”</font>的点</strong>一定都是匹配边的端点。<ul>
<li>如果右半边的哪个点是没有匹配过的，那么它早就当成起点被标记了。</li>
<li>如果左半边的哪个点是没有匹配过的，那就走不到它那里去，否则就找到了一条完整的增广路径，与已经求出最大匹配矛盾。</li>
</ul>
</li>
<li>一条匹配边不可能左端点是标记了的，同时右端点是没标记的，不然的话右边的点就可以经过这条匹配边到达了（右半边到左半边通过非匹配边/左半边到右半边通过匹配边）。</li>
</ul>
</li>
<li>因此，最后我们圈起来的点数与匹配边数。</li>
</ul>
</li>
<li>其次，为什么这样得到的点集可以覆盖所有的边呢？<ul>
<li>答案同样简单。不可能存在某一条边，它的左端点是没有标记的，而右端点是有标记的。<ul>
<li>如果这条边不属于匹配边，那么左端点就可以通过这条边到达（右半边到左半边通过非匹配边/左半边到右半边通过匹配边），从而得到标记。</li>
<li>如果这条边属于我们的匹配边，那么右端点不可能是一条路径的起点，于是它的标记只能是从这条边的左端点过来的（匹配边的右端点不可能作为起点被标记），左端点就应该有标记。</li>
</ul>
</li>
</ul>
</li>
<li>最后，为什么这样得到的点集是最小的点覆盖集呢？<ul>
<li>这当然是最小的，不可能有比$M$还小的点覆盖集了，因为要覆盖这$M$条匹配边至少就需要$M$个点（匹配边互不相交）。</li>
</ul>
</li>
</ul>
</li>
<li>提取最小点覆盖？<ul>
<li>通过上述的方法对二分图$G$中的顶点进行标记，<strong>$V$中所有没有被打上记号的点，加上$U$中已经有记号的点</strong>，即为最小点覆盖。</li>
</ul>
</li>
</ul>
<h4 id="最大匹配与最大独立数"><a href="#最大匹配与最大独立数" class="headerlink" title="最大匹配与最大独立数"></a>最大匹配与最大独立数</h4><ul>
<li>独立集问题：给定一个图和整数$g$，目标是求图中的$g$个相互独立的顶点，即在任意两个这样的顶点间都不存在相连的边（或者说导出的子图是零图（没有边）的点集）。</li>
<li>简单证明：<strong>二分图最大独立集=顶点数-二分图最大匹配</strong><br><center><img src="/img/Algorithms/0016_Bigraph3MaxIndependentSet.png" width="480px" alt=""/></center><ul>
<li>上图，我们用红圈圈住的三个点（$B$、$D$、$G$）覆盖了所有边，这是我们证明的前提条件：已经达到最小覆盖，即条件①已经覆盖所有边；条件②所用的点数最小。</li>
<li>首先我们来证明其余点（$A$、$C$、$E$、$F$、$H$、$I$）组成的是一个独立集。<ul>
<li>如果有两个蓝圈点间有边相连，那么这条边则没有被覆盖，则与条件①矛盾，因此是独立集。</li>
</ul>
</li>
<li>再来证明这个独立集是最大的。<ul>
<li>如果我们要再增加这个独立集中的点，则需要把某个红圈点变成蓝圈点。而由<strong>最小覆盖数=最大匹配数</strong>的证明我们知道，每一个红圈点是最大匹配中的一个匹配点，也就是说每个红圈点至少连接了一条边。因此当我们将某个红圈点变成蓝圈点时，我们需要牺牲的蓝圈点的个数是≥1的。也就是说，我们最多只能找到顶点数量相等的其他独立集，而无法找到数量更大的。因此蓝圈点集必定为最大独立集。</li>
<li>蓝圈点数 = 总点数 - 红圈点数，即最大独立集=顶点数 - 最小覆盖集。</li>
</ul>
</li>
<li>上面已经证明的<strong>König定理：最小点覆盖数=最大匹配数</strong>，故有<strong>二分图最大独立数=顶点数-二分图最大匹配数</strong>。</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://liam0205.me/2016/04/03/Hungarian-algorithm-in-the-maximum-matching-problem-of-bigraph/">二分图最大匹配问题与匈牙利算法的核心思想</a></li>
<li><a href="http://blog.csdn.net/hackbuteer1/article/details/7398008">二分图的最大匹配</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9672181">图的匹配问题与最大流问题(五)——计算二分图的最大匹配</a></li>
<li><a href="https://www.renfei.org/blog/bipartite-matching.html">二分图的最大匹配、完美匹配和匈牙利算法</a></li>
<li><a href="http://www.cnblogs.com/pony1993/archive/2012/07/25/2607738.html">二分图的最大匹配—匈牙利算法</a></li>
<li><a href="http://www.matrix67.com/blog/archives/116">二分图最大匹配的König定理及其证明</a></li>
<li><a href="http://dsqiu.iteye.com/blog/1689505">二分图大讲堂——彻底搞定最大匹配数（最小覆盖数）、最大独立数、最小路径覆盖、带权最优匹配</a></li>
<li><a href="http://m.blog.csdn.net/article/details?id=50011363">最大独立集=总数-最小覆盖集证明</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二分图匹配问题&quot;&gt;&lt;a href=&quot;#二分图匹配问题&quot; class=&quot;headerlink&quot; title=&quot;二分图匹配问题&quot;&gt;&lt;/a&gt;二分图匹配问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;二分图&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0016_bipartiteGraph.png&quot; width=&quot;340px&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;&lt;ul&gt;
&lt;li&gt;顶点被分成两个不相交的集合（$U$ 和 $V$）并且同属一个集合内的点两两不相连（$E_{in U} = E_{in V} = \emptyset$），即要么没有圈，要么圈所包含的边数必定是偶数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二分图&lt;/strong&gt; 的一个等价定义是：不含有 &lt;strong&gt;含奇数条边的环&lt;/strong&gt; 的图。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0015] Union Find Set（并查集）</title>
    <link href="http://durant35.github.io/2017/06/01/Algorithms_UnionFindSet/"/>
    <id>http://durant35.github.io/2017/06/01/Algorithms_UnionFindSet/</id>
    <published>2017-06-01T06:00:22.000Z</published>
    <updated>2017-06-03T05:53:41.360Z</updated>
    
    <content type="html"><![CDATA[<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><ul>
<li>并查集：并查集处理的是集合之间的关系，即 union，find。在这种数据类型中，N个不同元素被分成若干个组，每组是一个集合，这种集合叫做分离集合。并查集支持查找一个元素所属的集合和两个元素分别所属的集合的合并。注意：并查集只能进行合并操作，不能进行分割操作。</li>
<li>并查集支持以下操作：<ul>
<li><code>makeset(x)</code>：创建一个仅包含 x 的独立集合（分离集）；最初每个节点单独构成了一个分离集 ==&gt; 一组分离集</li>
<li><code>find(x)</code>：不断重复地检验节点对，判断其是否属于同一个集合？</li>
<li><code>union(x, y)</code>：每当增加了一条边，将与之相关的两个集合合并。<a id="more"></a></li>
</ul>
</li>
<li>并查集的实现原理<ul>
<li>并查集是使用树结构实现的<ul>
<li>初始化：准备 N 个节点来表示 N 个元素，最开始没有边。</li>
<li>为避免树的退化，对于每棵树，记录其高度 rank。</li>
<li>查询：查询两个节点是否在同一个集合，只需要查询他们是否具有相同的根。<center><img src="/img/Algorithms/0007_UnionFind_find.png" width="340px"/></center></li>
<li>合并：从一个分离集的根向另一个分离集的根连边，这样两棵树就变为了一棵树，也就把两个集合合并为一个了；除非将要合并的树等高，否则将不会出现合并后总高度增加的情形；如果合并时两棵树高度不同，那么从 rank 小的向 rank 大的连边。<center><img src="/img/Algorithms/0007_UnionFind_union.png" width="580px"/></center></li>
<li>路径压缩：每次 find 操作中，当循着一系列的父指针最终找到树的根后，改变所有这些父指针的目标，使其直接指向树根。<br><center><img src="/img/Algorithms/0007_UnionFind_find2.png" width="420px"/></center><ul>
<li>通过路径压缩，所有节点的等级都不会发生改变；节点的 rank 不再能解释为其下方子树的高度</li>
<li>union 操作只关注树的顶层，路径压缩不会对 union 操作产生影响，它将保持树的顶层不变</li>
<li>find 操作（不论是否采用路径压缩）仅仅触及树的内部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>并查集实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><ul>
<li>Kruskal 最小生成树算法<br><center><img src="/img/Algorithms/0007_KruskalPseudo.png" width="720px"/></center><ul>
<li>起始于一个空的图。</li>
<li>通过逐条增加边来构造最小生成树：假如在构建最小生成树的过程中，我们已经选择了某些边并在向着正确的方向前进，下一步选择那条边呢？<ul>
<li>不断重复地选择未被选中的边中权重最轻的且不会形成环的一条。<ul>
<li>为保证连接等价类边的权值最短，算法首先对图中所有边按照权值进行排序。按权值由小到大依次选择边</li>
<li>不会形成环：每次选择一条边加入到现有的部分解中 ===&gt; 需要检验每一条侯选边(u-&gt;v) 的端点是否属于不同的连通分量，一旦选定了某条边，则将这条边添加到 MST 并将两个相关的连通分量将被合并。</li>
</ul>
</li>
</ul>
</li>
<li>Kruskal 最小生成树算法关键数据结构：并查集/分离集 (union-find/disjoint sets)<ul>
<li>Kruskal 算法开始有 n 个分别包含一个节点的集合（即 n 个分离集）；随着算法的进展，分离集的个数逐渐减少，直到算法的最后一步，分离集的个数变为 1，此时产生最小生成树。</li>
</ul>
</li>
</ul>
</li>
<li>基于并查集的 Kruskal 算法实现：</li>
</ul>
<figure class="highlight cpp"><figcaption><span>Kruskal 最小生成树</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>			<span class="comment">/* priority_queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">  </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">   </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">  <span class="keyword">int</span> fromIdx, toIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> weight &gt; right.weight;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">   </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="function">UnionFindSets <span class="title">sets</span><span class="params">(g.vertexNum)</span></span>;</div><div class="line">  <span class="comment">// use priority_queue for sorting the edges E by weight</span></div><div class="line">  priority_queue&lt;Edge&gt; EdgeQueue;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    sets.makeset(g.VertexNodes[i].vertexIdx);</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      Edge e;</div><div class="line">      e.fromIdx = g.VertexNodes[i].vertexIdx;</div><div class="line">      e.toIdx = head-&gt;adjVertexIdx;</div><div class="line">      e.weight = head-&gt;weight;</div><div class="line">      EdgeQueue.push(e);</div><div class="line"></div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMST constructing: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">while</span>(!EdgeQueue.empty()) &#123;</div><div class="line">    Edge e = EdgeQueue.top();</div><div class="line">    EdgeQueue.pop();</div><div class="line">    <span class="comment">// cout &lt;&lt; "\npop: " &lt;&lt; e.fromIdx &lt;&lt; "-&gt;" &lt;&lt; e.toIdx &lt;&lt; "(" &lt;&lt; e.weight &lt;&lt; ")" &lt;&lt; endl;</span></div><div class="line">    <span class="keyword">if</span>(sets.find(e.fromIdx) != sets.find(e.toIdx)) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * 2 edges with same vertex in an undirect graph</div><div class="line">       *	but every VertexNode can only have on prev.</div><div class="line">       */</span></div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[e.toIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      g.VertexNodes[e.toIdx].prev = &amp;g.VertexNodes[e.fromIdx];</div><div class="line">      g.VertexNodes[e.toIdx].cost = e.weight;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[e.fromIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[e.toIdx].data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; e.weight &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">      sets.unite(e.fromIdx, e.toIdx);</div><div class="line">      <span class="comment">// sets.printset();</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line">  </div><div class="line">  Kruskal(g);</div><div class="line">   </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Kruskal.cpp -o Kruskal</div><div class="line">$ ./Kruskal </div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing: </div><div class="line">  + 6--&gt;7(1)</div><div class="line">  + 5--&gt;6(2)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 2--&gt;5(4)</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 2--&gt;3(7)</div><div class="line">  + 2--&gt;1(8)</div><div class="line">  + 3--&gt;4(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 7&lt;--6(1)</div><div class="line">  + 6&lt;--5(2)</div><div class="line">  + 5&lt;--2(4)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--8(2)</div><div class="line">  + 1&lt;--2(8)</div><div class="line">  + 0&lt;--1(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTKruskal.png" width="640px"/></center>

</li>
</ul>
<h4 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/#/description">Number of Islands</a></h4><p>　下面使用并查集解决 <strong>岛屿数量</strong> 问题，该问题描述如下：</p>
<blockquote>
<p>　Given a 2d grid map of <strong>‘1’</strong>s (land) and <strong>‘0’</strong>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. <strong>You may assume all four edges of the grid are all surrounded by water</strong>.</p>
<ul>
<li><code>Example 1</code>:<br>　11110<br>　11010<br>　11000<br>　00000<br>Answer: 1</li>
<li><code>Example 2</code>:<br>　11000<br>　11000<br>　00100<br>　00011<br>Answer: 3</li>
</ul>
</blockquote>
<ul>
<li>问题分析<ul>
<li>问题实际就是寻找 0-1 2d 网格中由 1 表示的 land 的连通区域块的数目，所以首先是如何确定一个连通区域块，确定之后即可统计整个网格中的块数目即可。</li>
<li>可以通过 DFS 确定寻找连通区域块：由上至下/从左及右从一块 land 开始，向右/向下进行 DFS 遍历，当遍历结束时，即到达本岛屿的每一块 land，可以寻找下一块岛屿；为了避免重复遍历，需要将每一块 land 打上标签，标注已属于某个岛屿。</li>
<li>一个岛屿即为一个集合，通过遍历每块 land，通过集合的并操作将 land 依次并入各岛屿集合，最终统计岛屿集合的数目即可。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>Number of Islands</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PI;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">        PI.resize(size);</div><div class="line">        rank.resize(size);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            PI[i] = <span class="number">-1</span>;</div><div class="line">            rank[i] = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        PI[x] = x;</div><div class="line">        rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(PI[x] &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">            PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="keyword">if</span>(rx==<span class="number">-1</span> || ry==<span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">            PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">                rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(grid.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rowSize = grid.size();</div><div class="line">        <span class="keyword">int</span> colSize = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="function">UnionFindSets <span class="title">sets</span><span class="params">(rowSize*colSize)</span></span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;colSize; col++) &#123;</div><div class="line">                <span class="keyword">int</span> gridSetIdx = row*colSize + col;</div><div class="line">                <span class="comment">// water grid not need to make set, still -1</span></div><div class="line">                <span class="keyword">if</span>(grid[row][col] == <span class="string">'0'</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    sets.makeset(gridSetIdx);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// upper grid is land, need to unite for enlarging land</span></div><div class="line">                <span class="keyword">if</span>(row&gt;<span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col]==<span class="string">'1'</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> upperSetIdx = (row<span class="number">-1</span>)*colSize + col;</div><div class="line">                    sets.unite(gridSetIdx, upperSetIdx);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// left grid is land, need to unite for enlarging land</span></div><div class="line">                <span class="keyword">if</span>(col&gt;<span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>]==<span class="string">'1'</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> leftSetIdx = row*colSize + (col<span class="number">-1</span>);</div><div class="line">                    sets.unite(gridSetIdx, leftSetIdx);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// count the number of united sets</span></div><div class="line">        <span class="keyword">int</span> unitedSetNum = <span class="number">0</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; counted;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> setIdx=<span class="number">0</span>; setIdx&lt;rowSize*colSize; setIdx++) &#123;</div><div class="line">            <span class="keyword">int</span> unitedSetIdx = sets.find(setIdx);</div><div class="line">            <span class="keyword">if</span>(unitedSetIdx == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!counted[unitedSetIdx]) &#123;</div><div class="line">                unitedSetNum++;</div><div class="line">                counted[unitedSetIdx] = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> unitedSetNum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节<ul>
<li><strong>“0”</strong> 网格（water）不作为并查集合元素，每一个 <strong>“1”</strong> 网格（land）一开始为一个集合。</li>
<li>如果一个网格为 <strong>“1”</strong> ，那这个网格和它左方/上方为 <strong>“1”</strong> 的网格属于一个连通块，并到一个集合。</li>
<li>最后，遍历并查集合中的每个元素（忽略了 water 未初始化集合），对其中存在的集合进行计数。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;并查集：并查集处理的是集合之间的关系，即 union，find。在这种数据类型中，N个不同元素被分成若干个组，每组是一个集合，这种集合叫做分离集合。并查集支持查找一个元素所属的集合和两个元素分别所属的集合的合并。注意：并查集只能进行合并操作，不能进行分割操作。&lt;/li&gt;
&lt;li&gt;并查集支持以下操作：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;makeset(x)&lt;/code&gt;：创建一个仅包含 x 的独立集合（分离集）；最初每个节点单独构成了一个分离集 ==&amp;gt; 一组分离集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find(x)&lt;/code&gt;：不断重复地检验节点对，判断其是否属于同一个集合？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union(x, y)&lt;/code&gt;：每当增加了一条边，将与之相关的两个集合合并。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0014] Dynamic Programming(V) 一道习题</title>
    <link href="http://durant35.github.io/2017/05/26/Algorithms_Dynamic%20Programming(V)/"/>
    <id>http://durant35.github.io/2017/05/26/Algorithms_Dynamic Programming(V)/</id>
    <published>2017-05-26T06:00:22.000Z</published>
    <updated>2017-05-29T05:46:08.630Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>Consider the following game. A “dealer” produces a sequence $s_1, …, s_n$ of “cards”, face up, where each card $s_i$ has a value $v_i$. Then two players take turns picking a card from the sequence, but can only pick the first or the last card of the (remaining) sequence. The goal is to collect cards of largest total value. (For example, you can think of the cards as bills of different denominations.) Assume n is even.</li>
</ul>
<a id="more"></a>
<p>　(a) Show a sequence of cards such that it is not optimal for the first player to start by picking up the available card of larger value. That is, the natural greedy strategy is suboptimal.<br>　(b) Give an $O(n^2)$ algorithm to compute an optimal strategy for the first player. Given the initial sequence, your algorithm should precompute in $O(n^2)$ time some information, and then the first player should be able to make each move optimally in $O(1)$ time by looking up the precomputed information.</p>
</blockquote>
<ul>
<li>考虑如下博弈：发牌手准备了一摞扑克牌 $s_1, …, s_n$。从牌面上看，牌 $s_i$ 的价值为 $v_i$。现在两个玩家轮流拿牌，每人每次只能拿最前或最后的一张。玩家的目标是使所拿到的牌总价值最高（不妨想象这些牌都是有面值的筹码）。假设 $n$ 为偶数。<ul>
<li>请给出一个序列，使得先开始的玩家如果采取贪心策略（即每次取走能拿的牌中面值较大的一张），最终的牌总价值并不比另一个玩家大。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Solution：&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">3</span>&#125;</div><div class="line">先手：<span class="number">3</span></div><div class="line">后手：<span class="number">10</span>（先手由于贪心损失最大牌值的一张牌）</div><div class="line">先手：<span class="number">2</span></div><div class="line">后手：<span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li>给出一个 $O(n^2)$ 的算法，用于计算先开始玩家的最优策略。给定初始序列，该算法首先利用 $O(n^2)$ 的时间进行预先计算，然后在每次选择时，玩家只需通过查找预先计算的结果即可在 $O(1)$ 内做出最有选择。<br><font color="red">Solution：</font><br>　　$r(i, j)$ 表示在子串 $s[i, j]$ 中进行游戏时所获得的最大分数值（假设对手也总是采取最优的策略），设 $r_i$ 是在子串 $s[i, j]$ 中进行游戏时，先手第一步选择最前一张牌所能得到的分数； $r_j$ 是先手第一步选择最后一张牌所能得到的分数，则有：<br>　　$\begin{cases}<br>r_i = v_i + min(r(i+2, j), r(i+1, j-1))\cr<br>r_j = v_j + min(r(i+1, j-1), r(i, j-2))<br>\end{cases}$，当先手第一步选择最前一张牌后，在第二步的选择中，$r(i+2, j)$ 对应后手第一步选择剩下的最前一张牌，$r(i+1, j-1)$则是后手第一步选择剩下的牌中的最后一张；类似地，当先手第一步选择最后一张牌后，在第二步的选择中，$r(i+1, j-1)$ 对应后手第一步选择剩下的最前一张牌，$r(i, j-2)$则是后手第一步选择了最后一张牌。<br>　　子串的长度 <code>len</code> 从2, 4, …, 初始序列长度 <code>LEN</code>，然后遍历（$i =  0,1,…,LEN-len-1: s[i, i+len]$）所有可能的子串进行如上的预处理。<br>　　为了在 $O(1)$ 内做出最有选择，还需要记录对于每个子串，先手玩家第一步的选择 $c(i, j)：$<br>　　$\begin{cases}<br>if(r_i \gt r_j): c(i, j)=pickfront \cr<br>else: \qquad c(i, j)=pickback<br>\end{cases}$</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Consider the following game. A “dealer” produces a sequence $s_1, …, s_n$ of “cards”, face up, where each card $s_i$ has a value $v_i$. Then two players take turns picking a card from the sequence, but can only pick the first or the last card of the (remaining) sequence. The goal is to collect cards of largest total value. (For example, you can think of the cards as bills of different denominations.) Assume n is even.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0013] 网络流：最大流（Max Flow）问题</title>
    <link href="http://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/"/>
    <id>http://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/</id>
    <published>2017-05-19T02:54:22.000Z</published>
    <updated>2017-05-24T06:44:48.026Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络流：最大流问题"><a href="#网络流：最大流问题" class="headerlink" title="网络流：最大流问题"></a>网络流：最大流问题</h4><ul>
<li>所谓网络：<ul>
<li>一个有向图 $G=(V, E)$</li>
<li>G中有两个特殊节点 $s, t \in V$，分别称为 G 中的源点(source) 和汇点(sink)。</li>
<li>G中每条边都有容量 $c_e \lt 0$。</li>
</ul>
</li>
<li>所谓流是指一种特定的输送方式，其中对每条边赋予一个变量 $f_e$，使其满足如下三个基本性质：<a id="more"></a>
<ul>
<li>容量限制(Capacity Constraints)：不超过边的容量，即对所有 $e \in E, 0 \leq f_e \leq c_e$</li>
<li>流量守恒(Flow Conservation)：对于 s 和 t  之外的任意节点 u，输入 u 的流量等于输出 u 的流量（流量是守恒的）：$\sum_{(w, u) \in E} f_{wu} = \sum_{(u, z) \in E} f_{uz} $</li>
<li>斜对称性(Skew Symmetry)：$ f_{uv} = -f_{vu}$</li>
</ul>
</li>
<li>网络流问题（NetWork Flow Problem）<ul>
<li>给定指定的一个有向图，其中有两个特殊的点：源 S 和汇 T，每条边有指定的容量(Capacity)，求满足条件的从 S 到 T 的最大流(MaxFlow)。</li>
</ul>
</li>
<li>最大流<ul>
<li>流的规模为由 s 流向 t 的总流量，由上面的流量的守恒律，其等于离开 s 的流量。</li>
<li>目标函数（最大化）：$ 规模(f) =  \sum_{(s, u) \in E} f_{su} = \sum_{(z, t) \in E} f_{zt} $</li>
</ul>
</li>
<li>其他相关定义<ul>
<li>容量网络(capacity network)&amp;流量网络(flow network)&amp;残留网络(residual network)<ul>
<li>网络就是有源、汇的有向图，关于什么的网络就是指边权的含义是什么。<center><img src="/img/Algorithms/0013_networkGraphSketch.png" width="540px"/></center></li>
<li>容量网络就是关于容量的网络。在求解问题的过程中，容量网络基本是不改变的。</li>
<li>流量网络就是关于流量的网络。在求解问题的过程中，流量网络通常在不断改变，但是总是满足上述三个性质；调整到最后就是最大流网络，同时也可以得到最大流值。</li>
<li>残量网络往往概括了容量网络和流量网络，是最为常用的，残量网络=容量网络-流量网络。</li>
</ul>
</li>
<li>增广路径(Augmenting path)：增广路径顾名思义就是能够增加流量的路径。增广路径 p 是残量网络中一条从源点 s 到汇点 t 的简单路径，在一条增广路径 p 上能够为每条边增加的流量的最大值为路径 p 的 <strong>残存容量(remaining capacity)</strong>：$c_f(p) = min \verb|{| c_f(u,v):(u,v) \in p \verb|}|$</li>
<li>割&amp;割集<ul>
<li>一个无向连通网络，去掉一个边集可以使其变成两个连通分量，则这个边集就是割集<ul>
<li>无向图的割集(Cut Set)：$C[A,B]$ 是将图 G 分为 A 和 B 两个点集（连通分量）的连接 A 和 B 之间的边的全集。</li>
</ul>
</li>
<li>带权图的割(Cut) 就是割集中边或者有向边的权和。<ul>
<li>最小割集当然就是权和最小的割集。</li>
</ul>
</li>
<li>在有向图网络 $G(V, E)$ 中, 割(S, T) 将 V 划分为 S 和 T=V-S，使得 s 属于 S 集合，t 属于 T 集合，割(S, T) 的容量是指从集合 S 到集合 T 所有边的容量之和。<center><img src="/img/Algorithms/0013_cutSketch.png" width="540px"/></center>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="最大流问题与线性规划"><a href="#最大流问题与线性规划" class="headerlink" title="最大流问题与线性规划"></a>最大流问题与线性规划</h4><p>　最大流问题可以转换为线性规划问题，而线性规划问题最著名的解法自然就是 <strong>单纯形法</strong>。这种算法非常奇特，其复杂度为在最坏情况下是指数级的，但其在实践中绝大多数的情况下表现出的效率非常令人满意。</p>
<ul>
<li>设$c_{uv}$ 代表边 u 到 v 最大允许的流量（capacity），$f_{uv}$ 代表 u 到 v 当前流量。</li>
<li>最大流可以表示为：<br>$$<br>  \Large{max}<br>  \normalsize{ \sum_{u:(s, u) \in E} f_{su} \quad }<br>  \Large{s.t.} \normalsize{<br>   \begin{cases} 0 \leq f_{uv} \leq c_{uv}, \forall (u, v) \in E \cr<br>   \sum_{w:(w, u) \in E} f_{wu} - \sum_{v:(u, v) \in E} f_{uv} = 0, \forall u \in V \backslash \verb|{| s, t \verb|}| \end{cases}<br>  }<br>$$</li>
<li>事实上，使用 <strong>单纯形法</strong> 解决网络最大流问题非常直观：<ol>
<li>从零流量开始</li>
<li>重复下述过程：<ul>
<li>选择一条从源点 s 到汇点 t 的合适路径</li>
<li>将该路径的流量增加到无法增加为止</li>
</ul>
</li>
</ol>
</li>
<li>每次迭代单纯形法寻找到 s→t 的一条路径，路径中的边有两种类型（如下图(b)中右图所示，可以同时存在这两种类型的边）：<br>  　　① 边在最初的网络中，且未达到最大流量，如下图(b)右图中的边 <strong>a→d</strong>；<br>  　　② 边的反向边在最初的网络中，如下图(c)右图中的边 <strong>d→a</strong>。<br><center><img src="/img/Algorithms/0013_residualGraphSketch.png" width="540px"/></center><ul>
<li>如果当前的流为 $f$，则对于第①种情况，边 $(u, v)$ 最多还能接受 $c_{uv} - f_{u, v}$ 的多余流量；而在第②种情况，最多增加的流量为 $f_{vu}$（取消 $(v, u)上的全部或部分流量$ ）。</li>
<li>这类增加流量的机会可以由 <strong>残量网络</strong> $G^f=(V, E^f)$ 来判定，该网络包含了所有的以上两种边，并标出了每条边的剩余流量：<br>$$<br>c^f =<br> \begin{cases} c_{uv} - f_{uv}, \quad 若(u, v) \in E 且 f_{uv} \lt c_{uv} \cr<br>f_{vu}, \qquad \quad 若(v, u) \in E 且 f_{uv} \gt 0 \end{cases}<br>$$</li>
</ul>
</li>
</ul>
<h4 id="最大流基本方法（Ford-Fulkerson）"><a href="#最大流基本方法（Ford-Fulkerson）" class="headerlink" title="最大流基本方法（Ford-Fulkerson）"></a>最大流基本方法（Ford-Fulkerson）</h4><ul>
<li>通过模拟单纯形法，我们得到了一个解决最大流问题的直接算法（Ford-Fulkerson）。该算法采取迭代的方式进行，每次先构造一个 $G^f$，然后在 $G^f$ 中寻找 s 到 t 的一条可行的增广（能够继续提高流量的）路径，找不到任何这样的路径时算法停止。</li>
<li>Ford-Fulkerson 方法<ul>
<li>Ford-Fulkerson 方法，即增广路方法，是一种迭代的方法，之所以称之为方法，而不是算法，因为FF(Ford-Fulkerson) 包含不同运行时间的几种实现。</li>
<li>Ford-Fulkerson 方法伪代码如下，解决了以下三个子问题：①<strong>while</strong>：要增广多少次？②<strong>augmenting path</strong>：如何找到一条增广路径？③<strong>update</strong>：如何增广？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FORD-FULKERSON-METHOD(G, s, t): </div><div class="line">   initialize flow f to <span class="number">0</span></div><div class="line">   <span class="keyword">while</span> there exists an augmenting path p, path-flow as its remaining capacity</div><div class="line">     <span class="keyword">do</span> augment flow path-flow along p to flow f</div><div class="line">     update residual graph</div><div class="line">   <span class="keyword">return</span> flow f</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>最大流算法 Ford-Fulkerson 方法最优性验证<ul>
<li>最大流最小割定理：设 $f$ 为流网络 $G = (V, E)$ 中的一个流，该流网络的源点为 s，汇点为t，则下面的条件是等价的：<ul>
<li>$f$ 是 $G$ 的一个最大流</li>
<li>残量网络 $G^f$ 不包含任何增广路径</li>
<li>$|f| = |C(S, T)|$，即最大流流量等于割 $C$ 的容量，割 $C=(S, T)$ 是流网络 $G$ 的最小割</li>
</ul>
</li>
<li>找到最大流 $f$ $\Longrightarrow$ 残量网络 $G^f$ 中已经无法找到任何由 s 到 t 的路径 $\Longrightarrow$ $(L, R)$ 为图 $G$ 的一个分割 $\begin{cases} L为 G^f 中 s 可达的所有节点集合 \cr R=V-L 为剩余的节点 \end{cases}$</li>
<li>对于任意流 $f$ 和任意 $(s, t)$ 分割 $(L, R)$，$流量(f) \leq 容量(L, R)$，由最大流最小割定理，最大流算法产生最小割，最小割对应于流的上限，这就是所求得流的最优性的保证。</li>
</ul>
</li>
<li>最大流算法的运行效率<ul>
<li>FORD-FULKERSON-METHOD 每个单次循环都是效率很高的，无论通过使用 <a href="http://durant35.github.io/2017/03/15/Algorithms_DFS/">DFS</a> 还是 <a href="http://durant35.github.io/2017/03/22/Algorithms_BFS/">BFS</a>，每次循环都只需要 $O(|E|)$ 的时间，但问题是，我们一共需要循环多少次呢？可以看出，循环次数的上线是所有边流量的最大值 C（每次循环只能增加 1 个流量），算法最坏情况为 $O(C|E|)$，然而 C 可能是一个很大的值！</li>
<li>采用广度优先搜索将使得找到的增广路径包含最少的边，则不管边的容量如何，C 如何，最终的迭代次数将不超过 $O(|V|·|E|)$（所有可能的路径总和）。因此，通过仔细地选择增广路径，可以将循环次数限制在 $O(|V|·|E|)$ 之内，在这种情况下，整个算法的时间复杂度为 $O(|V|·|E|^2)$。在 FORD-FULKERSON-METHOD 中通过 BFS 搜索增广路径，这就是<strong>Edmonds-Karp</strong> 算法（最短路径增广算法），其算法实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MaxFlow.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>			<span class="comment">/* setw */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> capacity;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, capacity;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; capacity;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;capacity = capacity;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data </div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;capacity &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span>* prevs, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="comment">// no previous node ==&gt; reach starting node </span></div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != <span class="number">-1</span>) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx].data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>** graph, <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx, <span class="keyword">int</span>* prevs)</span> </span>&#123;</div><div class="line">  <span class="comment">// cout &lt;&lt; "BFS" &lt;&lt; endl;</span></div><div class="line">  <span class="comment">// for(int u=0; u&lt;vertexNum; u++) &#123;</span></div><div class="line">  <span class="comment">// 	for(int v=0; v&lt;vertexNum; v++) &#123;</span></div><div class="line">  <span class="comment">// 		if(graph[u][v] &gt; 0) &#123;</span></div><div class="line">  <span class="comment">// 			cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; v &lt;&lt; "(" &lt;&lt; graph[u][v] &lt;&lt; ") ";</span></div><div class="line">  <span class="comment">// 		&#125;</span></div><div class="line">  <span class="comment">// 	&#125;</span></div><div class="line">  <span class="comment">// 	cout &lt;&lt; endl;</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="keyword">bool</span> visited[vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;vertexNum; vertexIdx++) &#123;</div><div class="line">    visited[vertexIdx] = <span class="literal">false</span>;</div><div class="line">    prevs[vertexIdx] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertexIdxQueue;</div><div class="line">  vertexIdxQueue.push(fromIdx);</div><div class="line">  visited[fromIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span> (!vertexIdxQueue.empty()) &#123;</div><div class="line">    <span class="keyword">int</span> u = vertexIdxQueue.front();</div><div class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " ";</span></div><div class="line">    <span class="keyword">if</span>(u == toIdx) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    vertexIdxQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[v] &amp;&amp; graph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        vertexIdxQueue.push(v);</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">        prevs[v] = u;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> visited[toIdx];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FordFulkerson</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">const</span> VertexNode&amp; source, <span class="keyword">const</span> VertexNode&amp; sink)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxFlow = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> flowGraph[g.vertexNum][g.vertexNum];</div><div class="line">  <span class="comment">// initialize the residual graph</span></div><div class="line">  <span class="keyword">int</span>** residualGraph = <span class="keyword">new</span> <span class="keyword">int</span>*[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    residualGraph[u] = <span class="keyword">new</span> <span class="keyword">int</span>[g.vertexNum];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      residualGraph[u][v] = <span class="number">0</span>;</div><div class="line">      flowGraph[u][v] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;g.vertexNum; vertexIdx++) &#123;</div><div class="line">    adjVertexNode* head = g.VertexNodes[vertexIdx].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// cout &lt;&lt; vertexIdx &lt;&lt; "--&gt;" &lt;&lt; head-&gt;adjVertexIdx &lt;&lt; endl;</span></div><div class="line">      residualGraph[vertexIdx][head-&gt;adjVertexIdx] = head-&gt;capacity;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// prevs array for storing the augmenting path</span></div><div class="line">  <span class="keyword">int</span> prevs[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> iter = <span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Algorithm Process:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// Augment the flow while there is a path from source to sink</span></div><div class="line">  <span class="keyword">while</span>(BFS(residualGraph, g.vertexNum, source.vertexIdx, sink.vertexIdx, prevs)) &#123;</div><div class="line">    <span class="comment">// find the maximum flow(minimum residual capacity) through the path found</span></div><div class="line">    <span class="keyword">int</span> pathFlow = INT_MAX;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sink.vertexIdx; v!=source.vertexIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      <span class="keyword">if</span>(residualGraph[u][v] &lt; pathFlow) &#123;</div><div class="line">        pathFlow = residualGraph[u][v];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update residual capacities of the edges &amp; reverse edges along the augmenting path</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sink.vertexIdx; v!=source.vertexIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      residualGraph[u][v] -= pathFlow;</div><div class="line">      residualGraph[v][u] += pathFlow;</div><div class="line">      <span class="comment">// record flows</span></div><div class="line">      flowGraph[u][v] += pathFlow;</div><div class="line">    &#125;</div><div class="line">    maxFlow += pathFlow;</div><div class="line">    <span class="comment">// print current iteration's info</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t#"</span> &lt;&lt; iter++ &lt;&lt; <span class="string">" flow: "</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; pathFlow &lt;&lt; <span class="string">" Augmenting-path: "</span>;</div><div class="line">    PrintPath(g, prevs, sink.vertexIdx);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// memory release</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">delete</span>[] residualGraph[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>[] residualGraph;</div><div class="line"> </div><div class="line">  <span class="comment">// show the flows</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">bool</span> noflow;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    noflow = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> &lt;&lt; g.VertexNodes[u].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(flowGraph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; g.VertexNodes[v].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; flowGraph[u][v] &lt;&lt; <span class="string">")\t"</span>;</div><div class="line">        noflow = <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(noflow) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> maxFlow;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_FLOW1</span></div><div class="line">    freopen(<span class="string">"flow1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"flow2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_FLOW1</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow: "</span> &lt;&lt; FordFulkerson(g, g.VertexNodes[<span class="number">0</span>], g.VertexNodes[<span class="number">6</span>]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow: "</span> &lt;&lt; FordFulkerson(g, g.VertexNodes[<span class="number">0</span>], g.VertexNodes[<span class="number">5</span>]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="red">算法实现细节分析如下：</font><ul>
<li><code>bool BFS(int** graph, int vertexNum, int fromIdx, int toIdx, int* prevs)</code> 函数通过广度优先搜索算法寻找边数目最少的增广路径，返回值表示能否寻找到这样的一条路径；假如存在这样的一条增广路径，<code>prevs</code> 数组则记录这样的一条增广路径：<strong>toIdx → prevs[toIdx] → prevs[prevs[toIdx]] → … → fromIdx</strong>。</li>
<li><code>residualGraph[u][v]</code> 通过邻接矩阵的方式维护一个残量网络，<code>flowGraph</code>则维护了流量网络的情况。</li>
<li><code>pathFlow</code> 则用于获取每次迭代寻找到的该增广路径的残存容量，用于更新残量网络和流量网络。<code>maxFlow</code> 则保留了最终的最大流量值。</li>
</ul>
</li>
<li>算法运行实例（一）<br>  <center><img src="/img/Algorithms/0013_demoFlow1.png" width="540px"/></center><ul>
<li>上图网络流对应的输入文件 <strong>flow1.txt</strong> 如下：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span> <span class="number">11</span></div><div class="line">s a b c d e t</div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">4</span></div><div class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">10</span></div><div class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></div><div class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">5</span></div><div class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">2</span></div><div class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<ul>
<li>编译构建，运行结果如下，过程可视化如上图。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_FLOW1 MaxFlow.cpp -o MaxFlow</div><div class="line">$ ./MaxFlow </div><div class="line">The adjacent list for graph is:</div><div class="line"> s-&gt;c(4) b(3) a(3) </div><div class="line"> a-&gt;d(2) </div><div class="line"> b-&gt;d(1) a(10) </div><div class="line"> c-&gt;e(5) </div><div class="line"> d-&gt;t(2) e(1) c(1) </div><div class="line"> e-&gt;t(5) </div><div class="line"> t-&gt;NULL</div><div class="line"> </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   2 Augmenting-path: s-&gt;a-&gt;d-&gt;t</div><div class="line">  #2 flow:   4 Augmenting-path: s-&gt;c-&gt;e-&gt;t</div><div class="line">  #3 flow:   1 Augmenting-path: s-&gt;b-&gt;d-&gt;e-&gt;t</div><div class="line"> Maximum Flow Graph:</div><div class="line">   s: -&gt;a(2)	-&gt;b(1)	-&gt;c(4)	</div><div class="line">   a: -&gt;d(2)	</div><div class="line">   b: -&gt;d(1)	</div><div class="line">   c: -&gt;e(4)	</div><div class="line">   d: -&gt;e(1)	-&gt;t(2)	</div><div class="line">   e: -&gt;t(5)	</div><div class="line">   t: NULL</div><div class="line"> Maximum Flow: 7</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>算法运行实例（二）<br>  <center><img src="/img/Algorithms/0013_demoFlow2.png" width="420px"/></center><ul>
<li>上图网络流对应的输入文件 <strong>flow2.txt</strong> 如下：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span> <span class="number">10</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">16</span></div><div class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">13</span></div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">10</span></div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">12</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">14</span></div><div class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">9</span></div><div class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">20</span></div><div class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">7</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></div></pre></td></tr></table></figure>
<ul>
<li>编译构建，运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ g++ MaxFlow.cpp -o MaxFlow</div><div class="line">$ ./MaxFlow </div><div class="line">The adjacent list for graph is:</div><div class="line"> 0-&gt;2(13) 1(16) </div><div class="line"> 1-&gt;3(12) 2(10) </div><div class="line"> 2-&gt;4(14) 1(4) </div><div class="line"> 3-&gt;5(20) 2(9) </div><div class="line"> 4-&gt;5(4) 3(7) </div><div class="line"> 5-&gt;NULL</div><div class="line"> </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:  12 Augmenting-path: 0-&gt;1-&gt;3-&gt;5</div><div class="line">  #2 flow:   4 Augmenting-path: 0-&gt;2-&gt;4-&gt;5</div><div class="line">  #3 flow:   7 Augmenting-path: 0-&gt;2-&gt;4-&gt;3-&gt;5</div><div class="line"> Maximum Flow Graph:</div><div class="line">   0: -&gt;1(12)	-&gt;2(11)	</div><div class="line">   1: -&gt;3(12)	</div><div class="line">   2: -&gt;4(11)	</div><div class="line">   3: -&gt;5(19)	</div><div class="line">   4: -&gt;3(7)	-&gt;5(4)	</div><div class="line">   5: NULL</div><div class="line"> Maximum Flow: 23</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li>基本概念：<ul>
<li><a href="http://blog.csdn.net/xzz_hust/article/details/22041173">网络流：最大流，最小割 基本概念及算法</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9275177">图的匹配问题与最大流问题(一)</a><ul>
<li>最大流问题跟线性规划又是如何产生联系的呢？</li>
</ul>
</li>
</ul>
</li>
<li>算法涉及概念补充：<a href="http://www.jianshu.com/p/1451e70909c8">最大流, 最小割问题及算法实现</a></li>
<li>算法实现细节：<ul>
<li><a href="http://www.cnblogs.com/gaochundong/p/ford_fulkerson_maximum_flow_algorithm.html">Ford-Fulkerson 最大流算法</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9293805">图的匹配问题与最大流问题（三）——最大流问题Ford-Fulkerson方法Java实现</a></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络流：最大流问题&quot;&gt;&lt;a href=&quot;#网络流：最大流问题&quot; class=&quot;headerlink&quot; title=&quot;网络流：最大流问题&quot;&gt;&lt;/a&gt;网络流：最大流问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;所谓网络：&lt;ul&gt;
&lt;li&gt;一个有向图 $G=(V, E)$&lt;/li&gt;
&lt;li&gt;G中有两个特殊节点 $s, t \in V$，分别称为 G 中的源点(source) 和汇点(sink)。&lt;/li&gt;
&lt;li&gt;G中每条边都有容量 $c_e \lt 0$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所谓流是指一种特定的输送方式，其中对每条边赋予一个变量 $f_e$，使其满足如下三个基本性质：
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CPU 扫盲（核心数/线程数）</title>
    <link href="http://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/"/>
    <id>http://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/</id>
    <published>2017-05-16T07:33:00.000Z</published>
    <updated>2017-05-16T08:02:16.497Z</updated>
    
    <content type="html"><![CDATA[<p>　　处理器（CPU）决定了电脑的性能等级，是一个需要考虑的核心因素。CPU 从早期的单核，发展到现在的双核，多核。除了<strong>核心数</strong>之外，还有<strong>线程数</strong>之说，下面会对这两个概念进行扫盲。
　　</p>
<h4 id="CPU-个数"><a href="#CPU-个数" class="headerlink" title="CPU 个数"></a>CPU 个数</h4><p>　CPU 的个数是指物理上，也就是硬件上存在着几颗物理 CPU，指的是真实存在的处理器的个数，1个代表1颗、2个代表2颗 CPU 处理器。<br><a id="more"></a></p>
<h4 id="CPU-核心数"><a href="#CPU-核心数" class="headerlink" title="CPU 核心数"></a>CPU 核心数</h4><p>　一个核心就是一个物理线程，<strong>单核</strong>、<strong>双核</strong>、<strong>多核</strong>，指的就是物理核心的数目。
　　</p>
<h4 id="CPU-线程数"><a href="#CPU-线程数" class="headerlink" title="CPU 线程数"></a>CPU 线程数</h4><p>　CPU 的线程数概念仅仅只针对 Intel 的 CPU 才有用，因为它是通过 Intel 超线程技术来实现的，最早应用在 Pentium4 上。如果没有超线程技术，一个 CPU 核心对应一个线程（因此对于一个CPU，线程数总是大于或等于核心数的）。所以，对于 AMD 的 CPU 来说，只有核心数的概念，没有线程数的概念。<br>　CPU 之所以要增加线程数，是源于多任务处理的需要：线程数越多，越有利于同时运行多个程序，因为线程数等同于在某个瞬间 CPU 能同时并行处理的任务数。<br>　因此，线程数是一种逻辑的概念，简单地说，就是模拟出的 CPU 核心数。一个核心最少对应一个线程，但英特尔有个超线程技术可以把一个物理线程模拟出两个线程来用，充分发挥 CPU 性能，即一个核心可以有两个到多个线程。</p>
<h4 id="Linux-中获取处理器信息"><a href="#Linux-中获取处理器信息" class="headerlink" title="Linux 中获取处理器信息"></a>Linux 中获取处理器信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看 cpu 型号</span></div><div class="line">sudo dmidecode <span class="_">-s</span> processor-version</div><div class="line"><span class="comment"># 查看 cpu 个数</span></div><div class="line">grep <span class="string">'physical id'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div><div class="line"><span class="comment"># 查看核心数</span></div><div class="line">grep <span class="string">'core id'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div><div class="line"><span class="comment"># 查看线程数</span></div><div class="line">grep <span class="string">'processor'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div></pre></td></tr></table></figure>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　处理器（CPU）决定了电脑的性能等级，是一个需要考虑的核心因素。CPU 从早期的单核，发展到现在的双核，多核。除了&lt;strong&gt;核心数&lt;/strong&gt;之外，还有&lt;strong&gt;线程数&lt;/strong&gt;之说，下面会对这两个概念进行扫盲。
　　&lt;/p&gt;
&lt;h4 id=&quot;CPU-个数&quot;&gt;&lt;a href=&quot;#CPU-个数&quot; class=&quot;headerlink&quot; title=&quot;CPU 个数&quot;&gt;&lt;/a&gt;CPU 个数&lt;/h4&gt;&lt;p&gt;　CPU 的个数是指物理上，也就是硬件上存在着几颗物理 CPU，指的是真实存在的处理器的个数，1个代表1颗、2个代表2颗 CPU 处理器。&lt;br&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="体系结构" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>一张图带你看 Ubuntu(Linux) 系统启动过程</title>
    <link href="http://durant35.github.io/2017/05/13/hsw_UbuntuSystemBootSequence/"/>
    <id>http://durant35.github.io/2017/05/13/hsw_UbuntuSystemBootSequence/</id>
    <published>2017-05-13T14:04:00.000Z</published>
    <updated>2017-05-13T14:21:12.278Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="/img/hsw/BootProcess4Ubuntu.png" width="1600px"/></center><br><a id="more"></a></p>
<h3 id="计算机系统的启动过程"><a href="#计算机系统的启动过程" class="headerlink" title="计算机系统的启动过程"></a>计算机系统的启动过程</h3><blockquote>
<p><a href="https://blog.auroraka.com/2017/02/02/%e5%a4%9a%e7%b3%bb%e7%bb%9f%e6%8a%98%e8%85%be%e8%ae%b0/">Auroraka’s Blog：多系统折腾记——总结</a></p>
</blockquote>
<ol>
<li>计算机通电</li>
<li>CPU读取内置ROM芯片中的数据，BIOS或UEFI进行系统自检，并按照预先设置的优先级依次尝试寻找各储存器，并将控制权交给该储存设备(硬盘)</li>
<li>如果是BIOS启动，系统确定储存器分区表的分区以及操作系统所在的分区，并将控制权转交给操作系统。如果是EFI启动，系统首先确定分区表的分区，接着寻找文件系统格式为FAT32的分区，并按照其中的内容启动EFI系统，接着按照情况启动操作系统的boot loader，将控制权转交给操作系统</li>
<li>操作系统启动</li>
</ol>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/hsw/BootProcess4Ubuntu.png&quot; width=&quot;1600px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="体系结构" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0012] Dynamic Programming(IV)（Longest Palindromic Subsequence）</title>
    <link href="http://durant35.github.io/2017/05/12/Algorithms_LongestPalindromicSubsequence/"/>
    <id>http://durant35.github.io/2017/05/12/Algorithms_LongestPalindromicSubsequence/</id>
    <published>2017-05-12T06:00:22.000Z</published>
    <updated>2017-05-29T14:16:22.537Z</updated>
    
    <content type="html"><![CDATA[<p>　所谓 <strong>回文（palindrome）</strong>，指的是正读和反读都是一样的。而 <strong>字符子串</strong> 和 <strong>字符子序列</strong> 的区别，在前面 <a href="http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/">算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）</a> 中也有提到过，字符字串指的是字符串中连续的n个字符，而字符子序列指的是字符串中不一定连续但先后顺序与原字符串一致的n个字符。<br><a id="more"></a></p>
<h4 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h4><ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/#/description">5. Longest Palindromic Substring</a> 题目描述如下：<blockquote>
<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>> Example:<br>　Input: “babad”<br>　Output: “bab”<br>Note: “aba” is also a valid answer.<br>> Example:<br>　Input: “cbbd”<br>　Output: “bb”</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = s.size();</div><div class="line">        <span class="comment">/*</div><div class="line">         * isPalindrome[i][j]: str[i...j] is a palindrome substring</div><div class="line">         * n ≤ 1000</div><div class="line">         */</span></div><div class="line">        <span class="keyword">bool</span> isPalindrome[n][n] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">        <span class="comment">// &lt;1&gt; palindrome substring with length 2, a single char is a palindrome substring</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> strIdx=<span class="number">0</span>; strIdx&lt;n; strIdx++) &#123;</div><div class="line">            isPalindrome[strIdx][strIdx] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// longest palindrome substring s[longestStartIdx,longestStartIdx+longestLen-1] with length:longestLen</span></div><div class="line">        <span class="keyword">int</span> longestStartIdx=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> longestLen = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// &lt;2&gt; palindrome substring with length 2</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> strIdx=<span class="number">0</span>; strIdx&lt;n<span class="number">-1</span>; strIdx++) &#123;</div><div class="line">            <span class="keyword">if</span>(s[strIdx+<span class="number">1</span>] == s[strIdx]) &#123;</div><div class="line">                isPalindrome[strIdx][strIdx+<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">                longestLen = <span class="number">2</span>;</div><div class="line">                longestStartIdx = strIdx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// &lt;3&gt; palindrome substring with length:len</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>; len&lt;=n; len++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> strIdx=<span class="number">0</span>; strIdx&lt;=n-len; strIdx++) &#123;</div><div class="line">                <span class="keyword">int</span> endIdx = strIdx+len<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span>(s[endIdx] == s[strIdx] &amp;&amp; isPalindrome[strIdx+<span class="number">1</span>][endIdx<span class="number">-1</span>]) &#123;</div><div class="line">                    isPalindrome[strIdx][endIdx] = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">if</span>(len &gt; longestLen) &#123;</div><div class="line">                        longestLen = len;</div><div class="line">                        longestStartIdx = strIdx;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> s.substr(longestStartIdx, longestLen);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节<ul>
<li><code>isPalindrome[i][j]</code>：字符子串 $s[i][j]$ 是否是回文子串？</li>
<li>动态规划过程：依次遍历长度为 $1, 2, …, len, …, n(本题: \leq 1000)$ 的所有子串，判断子串 $s[strIdx, strIdx+len-1], strIdx \in [0, n-len]$ 是否为回文子串<ul>
<li>动态规划初始化①：长度为 1 的子串均为回文子串，即 $\qquad isPalindrome[i][i]=true, i \in [0, n)$</li>
<li>动态规划初始化②：长度为 2 的子串，相邻两个字符相同的子串也为回文子串，即 $\begin{cases} if(s[i] == s[i+1]): \cr \quad isPalindrome[i][i+1]=true \cr else: \cr \quad isPalindrome[i][i+1]=false \end{cases} i \in [0, n-1)$</li>
<li>动态规划填表过程 $isPalindrome[i][j]$：$\begin{cases} for 　 len=3, …, n: \cr \quad for 　 i=0, 1, …, n-len: \cr \qquad j=i+len-1 \cr \qquad if(s[i] == s[j] \&amp;\&amp; isPalindrome[i+1][j-1]): \cr \qquad \quad isPalindrome[i][j]=true \cr \qquad else: \cr \qquad \quad isPalindrome[i][j]=false \end{cases}$</li>
</ul>
</li>
<li>在动态规划过程，通过变量 <code>longestLen</code>记录在动态规划过程中发现的最长回文子串长度及该子串在原始子串中的起始下标 <code>longestStartIdx</code>。</li>
</ul>
</li>
<li><font color="blue">提取最长回文子串</font><ul>
<li>最终得到最长回文子串：$\qquad s[longestStartIdx…longestStartIdx+longestLen-1] $</li>
</ul>
</li>
</ul>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p>　对于任意字符子串，如果头尾字符相同：①由于子字符串必须是连续的，只有在该字符子串除去头尾字符后剩下的部分是回文的，该子字符串才是回文子串；②子序列，因为可以不连续，要求更宽松了，这种情况下，该子字符串存在一个长度至少为2的回文子序列，至于最长子序列，还要加上去掉首尾字符的字符串的最长子序列；<br>　如果首尾字符不同：①该子字符串一定不是回文子串；②对于最长回文子序列，为了尽可能增加长度（也许第二个字符正好与末尾字符相同/也许倒数第二个字符正好与首字符相同），最长回文子序列在去掉头的子字符串的最长回文子序列和去掉尾的子字符串的最长回文子序列中产生，为长度较大者。</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-subsequence/#/description">[516. Longest Palindromic Subsequence]</a> 解题思路<br>　基于上述思路，很容易想到如下的递归实现，不过由于递归中出现的多余计算、频繁的函数调用，在 leetcode 上提交会有：<strong>Time Limit Exceeded</strong> 超时错误。</li>
<li>  <figure class="highlight cpp"><figcaption><span>递归实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lps</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(fromIdx==toIdx) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(str[fromIdx] == str[toIdx]) &#123;</div><div class="line">        <span class="keyword">if</span>(toIdx-fromIdx==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lps(str, fromIdx+<span class="number">1</span>, toIdx<span class="number">-1</span>) + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max(lps(str, fromIdx+<span class="number">1</span>, toIdx), lps(str, fromIdx, toIdx<span class="number">-1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    <span class="keyword">return</span> lps(s, <span class="number">0</span>, n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　基于上述思路的动态规划实现，定义的子问题与最长回文子串有明显出入。<br>　①<strong>子问题</strong>：设字符串为 s，长度为 n，$dp[fromIdx][toIdx]$：子字符串 $s(fromIdx…toIdx)$ 中的最长回文子序列长度。<br>　②与最长回文子串类似，依次遍历长度为 $1, 2, …, len, …, n(本题: \leq 1000)$ 的所有子串，计算 $s(fromIdx…fromIdx+len-1)$ 中的最长回文子序列长度 $dp[fromIdx][fromIdx+len-1]$<br>　　<strong>状态初始条件</strong>（1）：长度为 1 的子串均为回文子序列，即 $\qquad \qquad dp[i][i]=1, i \in [0, n)$<br>　　<strong>状态初始条件</strong>（2）：长度为 2 的子串，相邻两个字符相同的子串也为回文子序列，即 $\begin{cases} if(s[i] == s[i+1]): \cr \quad dp[i][i+1]=2 \cr else: \cr \quad dp[i][i+1]=0 \end{cases} i \in [0, n-1)$<br>　　<font color="red">注：代码实现中将<strong>状态初始条件（2）</strong>这一过程附带在下一步<strong>填表过程</strong>中。</font><br>　　<strong>状态转移方程</strong>（填表过程）：$\qquad \qquad \begin{cases} for 　 len=3, …, n: \cr \quad for 　 i=0, 1, …, n-len: \cr \qquad j=i+len-1 \cr \qquad if(s[i] == s[j]): \cr \qquad \quad dp[i][j]=dp[i+1][j-1]+2 \cr \qquad else: \cr \qquad \quad dp[i][j]=max(dp[i+1][j], dp[i][j-1]) \end{cases}$</p>
<ul>
<li>  <figure class="highlight cpp"><figcaption><span>动态规划实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    <span class="comment">// dp[fromIdx][toIdx]: s(fromIdx,toIdx) is palindrome of length dp[fromIdx][toIdx]</span></div><div class="line">    <span class="keyword">int</span> dp[n][n];</div><div class="line">    </div><div class="line">    <span class="comment">// strings of length 1 are palindrome of length 1</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;n; idx++) &#123;</div><div class="line">        dp[idx][idx] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;=n-len; fromIdx++) &#123;</div><div class="line">            <span class="keyword">int</span> toIdx = fromIdx + len - <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(s[fromIdx] == s[toIdx]) &#123;</div><div class="line">                <span class="keyword">if</span>(len==<span class="number">2</span>) &#123;</div><div class="line">                    dp[fromIdx][toIdx] = <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// s(fromIdx+1,toIdx-1) have smaller length:len-2</span></div><div class="line">                    dp[fromIdx][toIdx]= dp[fromIdx+<span class="number">1</span>][toIdx<span class="number">-1</span>] + <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// s(fromIdx+1,toIdx) &amp; s(fromIdx,toIdx-1) have smaller length:len-1 </span></div><div class="line">                dp[fromIdx][toIdx] = max(dp[fromIdx+<span class="number">1</span>][toIdx], dp[fromIdx][toIdx<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><font color="blue">提取最长回文子序列</font><ul>
<li>利用动态规划过程的中间结果 <code>dp[i][j]</code>，使用与 <strong>提取最长公共子序列</strong> 一样的方法，能够提取出最长回文子序列。</li>
<li>在序列 s 中分别从头下标 <code>fromIdx: 0</code> 和尾下标 <code>toIdx: n-1</code> 向中间挪动，找出  <code>dp[i][j]</code> 个字符，即为提取的最长回文子序列。</li>
<li>如何在序列中向中间挪动呢？<ul>
<li><code>s[fromIdx]==s[toIdx]</code>，当前字符在最长回文子序列中，头尾下标同时向中间挪：<code>fromIdx++</code> &amp; <code>toIdx--</code>。</li>
<li><code>s[fromIdx]!=s[toIdx]</code>，当前字符不相同<ul>
<li><code>dp[fromIdx][toIdx-1]</code> 大，说明 <code>s[fromIdx]</code> 可能是最长回文子序列的下一个字符，需要挪动尾下标：<code>toIdx--</code>；</li>
<li>反之<code>dp[fromIdx+1][toIdx]</code> 大，则需要挪动头下标：<code>fromIdx++</code>。</li>
</ul>
</li>
</ul>
</li>
<li>挪动的边界条件：<code>while(fromIdx≤toIdx)</code><ul>
<li>出现 <code>fromIdx==toIdx</code> 后退出循环：最长回文子序列长度为奇数（如：”bab”），选择夹在原序列中最后一个相同字符间的任一字符作为唯一一个不成对字符。</li>
<li>直接因为 <code>fromIdx&lt;toIdx)</code> 退出循环：最长回文子序列长度为偶数（如：”bb”），原序列中最后一个相同字符间不存在其它字符。</li>
</ul>
</li>
<li>具体的代码实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> LPS;</div><div class="line">fromIdx = <span class="number">0</span>;</div><div class="line">toIdx = n<span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span>(fromIdx&lt;=toIdx) &#123;</div><div class="line">    <span class="keyword">if</span>(s[fromIdx] == s[toIdx]) &#123;</div><div class="line">        LPS += s[fromIdx];</div><div class="line">        fromIdx++;</div><div class="line">        toIdx--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(dp[fromIdx][toIdx<span class="number">-1</span>] &lt; dp[fromIdx+<span class="number">1</span>][toIdx]) &#123;</div><div class="line">            fromIdx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            toIdx--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　所谓 &lt;strong&gt;回文（palindrome）&lt;/strong&gt;，指的是正读和反读都是一样的。而 &lt;strong&gt;字符子串&lt;/strong&gt; 和 &lt;strong&gt;字符子序列&lt;/strong&gt; 的区别，在前面 &lt;a href=&quot;http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/&quot;&gt;算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）&lt;/a&gt; 中也有提到过，字符字串指的是字符串中连续的n个字符，而字符子序列指的是字符串中不一定连续但先后顺序与原字符串一致的n个字符。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）</title>
    <link href="http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/"/>
    <id>http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/</id>
    <published>2017-05-03T06:00:22.000Z</published>
    <updated>2017-05-15T13:06:15.880Z</updated>
    
    <content type="html"><![CDATA[<p>　　子序列和子字符串的不同之处在于，子序列不需要是原序列上连续的字符。对于 <a href="http://www.lintcode.com/en/problem/longest-common-substring/">Longest Common Substring</a> 以及 <a href="http://www.lintcode.com/en/problem/longest-common-subsequence/"> Longest Common Subsequence</a> 这类题目，大多数需要用到 DP 的思想，其中，状态转移是关键。<br><a id="more"></a></p>
<h4 id="最长公共子字符串"><a href="#最长公共子字符串" class="headerlink" title="最长公共子字符串"></a>最长公共子字符串</h4><blockquote>
<p>Given two strings, find the longest common substring.<br>Return the length of it.</p>
<ul>
<li><strong>Example</strong><br>　Given A = “ABCD”, B = “CBCE”, return 2.</li>
</ul>
</blockquote>
<ul>
<li>$L(idxA, idxB)$：以 $A[idxA]$ 和 $B[idxB]$ 结尾的相同子字符串的最长长度。最长公共子字符串必然存在所有情况中以 A 序列中某个字符结尾，以 B 序列中某个字符结尾的一种情况，所以<strong>取所有可能情况中的最大值</strong>即为 Longest Common Substring 的长度。<ul>
<li>因为要求子串连续，所以对于 $A_{idxA}$ 与 $B_{idxB}$ 来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串。<br>$$ L(idxA, idxB) =  \begin{cases}<br>  if（idxA==0||idxB==0）: \begin{cases} 1, A[idxA]==B[idxB] \cr 0, others \end{cases} \cr<br>  else-if（A[idxA]==B[idxB]）: L(idxA-1, idxB-1) + 1 \cr<br>  else: 0<br>  \end{cases}<br>$$</li>
<li>上述过程的示例图如下，可以看出只有对角线方向上的长度延伸，长度不能保留。<br><center><img src="/img/Algorithms/0011_LCStringProcessDemo.jpg" width="480px"/></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>: </div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two string.</div><div class="line">     * @return: the length of the longest common substring.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the largest length of LCS ending with A[idxA] and B[idxB] </span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                L[idxA][idxB] = A[idxA]==B[idxB]? L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>]+<span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxLenIdx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                    maxLenIdx = idxA;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="blue">提取最长公共子串</font><ul>
<li>使用变量 <code>maxLenIdx</code> 记录最长公共子串（长度 <code>maxLen</code> ）对应的结尾字符下标（序列 A/B 都可以），回退获取 <code>maxLen</code> 个字符即可。</li>
</ul>
</li>
</ul>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><blockquote>
<p>Given two strings, find the longest common subsequence (<em>LCS</em>).<br>Your code should return the length of <em>LCS</em>.</p>
<ul>
<li><strong>Example</strong><br>　For “ABCD” and “EDCA”, the LCS is “A” (or “D”, “C”), return 1.<br>　For “ABCD” and “EACB”, the LCS is “AC”, return 2.</li>
</ul>
</blockquote>
<ul>
<li>$L(idxA, idxB)$：以 $A_{idxA}$ 结尾的子串（$A[0, 1, …, idxA], 0 \leq idxA \lt len_A$） 和 $B_{idxB}$ 结尾的子串（$B[0, 1, …, idxB], 0 \leq idxB \lt len_B$）最长公共子序列的长度。自然地，$L(len_A-1, len_B-1)$ 即为所求的最长公共子序列长度。</li>
<li>与子串不同，子序列可以是不连续的。<ul>
<li>$L(idxA, idxB)$ 与 $L(idxA-1, idxB-1)$ 两者其实只差 $A_{idxA}$ 和 $B_{idxB}$ 这一对字符。</li>
<li>如果 $A_{idxA}$ 和 $B_{idxB}$ 相同，那么就只要在以 $A_{idxA}$ 和以 $B_{idxB}$ 结尾的两个子串的最长公共子序列之后添上这个相同字符即可，这样就可以让长度增加一位。</li>
<li>如果 $A_{idxA}$ 和 $B_{idxB}$ 不同，两个子串在末尾添加一个字符后最长公共子序列并不能得到延伸。考虑到 $A_{idxA}$ 可能与 $B_{idxB-1}$ 相同或者 $B_{idxB}$ 会与 $A_{idxA-1}$ 相同，没能延伸的最长公共子序列只能在 $L(idxA, idxB-1)$ 和 $L(idxA-1, idxB)$ 存在，取更长的那个。</li>
<li>结合边界限制，最终得到的状态转移方程如下：<br>$$ L(idxA, idxB) =  \begin{cases}<br>  if（idxA==0）: \begin{cases} 1, B[idxB]==A[0] \cr L(0, idxB-1), others \end{cases} \cr<br>  else·if（idxB==0）: \begin{cases} 1, A[idxA]==B[0] \cr L(idxA-1, 0), others \end{cases} \cr<br>  else·if（A[idxA]==B[idxB]）: L(idxA-1, idxB-1) + 1 \cr<br>  else: max(L(idxA, idxB-1), L(idxA-1, idxB))<br>  \end{cases}<br>$$</li>
<li>上述过程的示例图如下，可以看出同样只有对角线方向上的长度延伸，不过长度可以在 <strong>上→下</strong> 和 <strong>左→右</strong> 方向上得到保留。<br><center><img src="/img/Algorithms/0011_LCSequenceProcessDemo.png" width="450px"/></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two strings.</div><div class="line">     * @return: The length of longest common subsequence of A and B.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the length of the LCS ending with A[idxA] and B[idxB]</span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="comment">// for recording LCS's tail element index</span></div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, maxLenIdxA = <span class="number">0</span>, maxLenIdxB = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        L[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : L[<span class="number">0</span>][idxB<span class="number">-1</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// for recording LCS's tail element index</span></div><div class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>][idxB] &gt; maxLen) &#123;</div><div class="line">                maxLen = L[<span class="number">0</span>][idxB];</div><div class="line">                maxLenIdxB = idxB;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : L[idxA<span class="number">-1</span>][<span class="number">0</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// for recording LCS's tail element index</span></div><div class="line">            <span class="keyword">if</span>(L[idxA][<span class="number">0</span>] &gt; maxLen) &#123;</div><div class="line">                maxLen = L[idxA][<span class="number">0</span>];</div><div class="line">                maxLenIdxA = idxA;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">                <span class="keyword">if</span>(A[idxA] == B[idxB]) &#123;</div><div class="line">                    L[idxA][idxB] = L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    L[idxA][idxB] = max(L[idxA][idxB<span class="number">-1</span>], L[idxA<span class="number">-1</span>][idxB]);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// for recording LCS's tail element index</span></div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                    maxLenIdxA = idxA;</div><div class="line">                    maxLenIdxB = idxB;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> L[lenA<span class="number">-1</span>][lenB<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="blue">提取最长公共子序列</font><ul>
<li>使用变量 <code>maxLen</code> 记录最长公共子序列的长度，并通过变量 <code>maxLenIdxA</code> 和 <code>maxLenIdxB</code> 记录该最长长度序列末尾字符对应的序列 A 和序列 B 中的字符下标。</li>
<li>在序列 A 和 B 中分别从下标 <code>maxLenIdxA</code> 和 <code>maxLenIdxB</code> 向左挪动，找出  <code>maxLen</code> 个相同字符，即为提取的最长公共子序列。</li>
<li>如何在序列 A 和 B 中向左挪动呢？<ul>
<li><code>A[maxLenIdxA]==B[maxLenIdxB]</code>，当前字符相同，同时左挪（因为公共子序列的特点，此时二者肯定均为到达边界）：<code>maxLenIdxA--</code> &amp; <code>maxLenIdxB--</code>。</li>
<li><code>A[maxLenIdxA]!=B[maxLenIdxB]</code>，当前字符不相同<ul>
<li>有挪动到边界（0）的，只能挪动另一个还没到边界的；假如同时挪动到边界，由于  <code>maxLen</code> 的准确性，说明已经提取出最长公共子序列。</li>
<li><code>L[idxA][idxB-1]</code> 大，说明 <code>A[maxLenIdxA]</code> 可能与序列 B 中下一个字符相同，需要挪动序列 B：<code>maxLenIdxB--</code>；反之，则需要挪动序列 A：<code>maxLenIdxA--</code>。</li>
</ul>
</li>
</ul>
</li>
<li>具体的代码实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> LCS;</div><div class="line"><span class="keyword">while</span>(maxLenIdxA&gt;=<span class="number">0</span> &amp;&amp; maxLenIdxB&gt;=<span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(A[maxLenIdxA] == B[maxLenIdxB]) &#123;</div><div class="line">        LCS += A[maxLenIdxA];</div><div class="line">        maxLenIdxA--;</div><div class="line">        maxLenIdxB--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(maxLenIdxA == <span class="number">0</span>) &#123;</div><div class="line">            maxLenIdxB--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(maxLenIdxB == <span class="number">0</span>) &#123;</div><div class="line">            maxLenIdxA--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(L[maxLenIdxA][maxLenIdxB<span class="number">-1</span>] &lt; L[maxLenIdxA<span class="number">-1</span>][maxLenIdxB]) &#123;</div><div class="line">                maxLenIdxB--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxLenIdxA--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　子序列和子字符串的不同之处在于，子序列不需要是原序列上连续的字符。对于 &lt;a href=&quot;http://www.lintcode.com/en/problem/longest-common-substring/&quot;&gt;Longest Common Substring&lt;/a&gt; 以及 &lt;a href=&quot;http://www.lintcode.com/en/problem/longest-common-subsequence/&quot;&gt; Longest Common Subsequence&lt;/a&gt; 这类题目，大多数需要用到 DP 的思想，其中，状态转移是关键。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0010] Longest Increasing Subsequence（最长递增子序列）</title>
    <link href="http://durant35.github.io/2017/04/28/Algorithms_LongestIncreasingSubsequence/"/>
    <id>http://durant35.github.io/2017/04/28/Algorithms_LongestIncreasingSubsequence/</id>
    <published>2017-04-28T06:00:22.000Z</published>
    <updated>2017-05-15T06:31:11.744Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/#/description">300. Longest Increasing Subsequence</a></h4><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.<br>For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. </p>
</blockquote>
<ul>
<li>给出一个序列 $a_1, a_2, …, a_n$，求它的一个子序列（设为 $s_1, s_2, …, s_n$ ），使得这个子序列满足这样的性质：$ s_1 &lt; s_2 &lt; s_3 &lt;…&lt; s_n $ 并且这个子序列的长度最长，输出这个最长的长度。实际上，诸如最长下降子序列，最长不上升子序列等问题都可以看成同一个问题，仔细思考就会发现，这其实只是 $&lt;$ 符号定义上的问题，并不影响问题的实质。<a id="more"></a>
<h4 id="转化为图的最长路径问题（-O-N-2-）"><a href="#转化为图的最长路径问题（-O-N-2-）" class="headerlink" title="转化为图的最长路径问题（$O(N^2)$）"></a>转化为图的最长路径问题（$O(N^2)$）</h4></li>
<li>解决最长递增子序列的一种方法是将其转换为图的最长路径问题（可以说是一种归约思想）<ul>
<li>为序列中的每个元素 $a_i$ 建立一个对应的节点 i。</li>
<li>对于任意两个可能在某递增序列中存在递进关系的元素 $a_i$ 和 $a_j$（即，同时满足 $ i &lt; j $，且 $ a_i &lt; a_j $），增加一条连接二者对应节点的有向边 $i-&gt;j$。</li>
<li>基于简单的动态规划，寻找转化后的图中的最长路径。如下图：<center><img src="/img/Algorithms/0010_LISGraph.png" width="640px"/></center></li>
</ul>
</li>
<li>基于上述思路的代码实现如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> graph[<span class="number">10000</span>][<span class="number">10000</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="comment">//sanity check</span></div><div class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;numsSize; fromIdx++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> toIdx=fromIdx+<span class="number">1</span>; toIdx&lt;numsSize; toIdx++) &#123;</div><div class="line">            graph[fromIdx][toIdx] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// convert the sequence into a directed graph</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;numsSize; fromIdx++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> toIdx=fromIdx+<span class="number">1</span>; toIdx&lt;numsSize; toIdx++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[toIdx] &gt; nums[fromIdx]) &#123;</div><div class="line">                graph[fromIdx][toIdx] = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// find the longest path &lt;--&gt; LIS</span></div><div class="line">    <span class="keyword">int</span> L[numsSize];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">int</span> localMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;=idx; fromIdx++) &#123;</div><div class="line">            <span class="keyword">if</span>(graph[fromIdx][idx] == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(L[fromIdx] &gt; localMax) &#123;</div><div class="line">                    localMax = L[fromIdx];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        L[idx] = localMax + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> globalMax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">if</span>(L[idx] &gt; globalMax) &#123;</div><div class="line">            globalMax = L[idx];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> globalMax;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">需要特别留意的是：</font>存储转换后的图的邻接矩阵 graph，实际上应该是一个动态大小的二维数组，然而，由于 <strong>堆栈内存限制</strong>，只能将其预设为足够大小的二维数组，作为 <strong>全局</strong> 或者 <strong>static</strong> 变量在堆中开辟内存，避免 <strong>Runtime Error</strong>（堆栈溢出）的错误。</li>
<li>在求解转换后的图中的最长路径时，采用了动态规划的方法<ul>
<li>$L[idx]$ ：第 idx 个元素对应的节点的最长路径（从根（序列的第一个元素）出发）；</li>
<li>$L[idx+1]$ 显然为带有最大最长路径的前驱节点的最长路径+1。</li>
</ul>
</li>
<li>算法是可行准确的，但是运行效率就不敢恭维了。<br><img src="/img/Algorithms/0010_LISGraph_result.png" width="720px"/></li>
</ul>
<h4 id="动态规划（-O-N-2-）"><a href="#动态规划（-O-N-2-）" class="headerlink" title="动态规划（$O(N^2)$）"></a>动态规划（$O(N^2)$）</h4><ul>
<li>既然是动态规划法，那么最重要的自然就是寻找子问题，对于这个问题，我们找到他的子问题<ul>
<li>用$dp[idx]$ 来存放以 $a_{idx}$ 结尾的最大递增子序列长度。</li>
</ul>
</li>
<li>找到子问题之后，接下来就是关于子问题如何求解的问题（状态转移方程）<ul>
<li>想求以 $a_{idx}$ 结尾的最大递增子序列的长度，我们就需要遍历 $idx$ 之前的所有位置 $ i, i \in [1, idx-1]$，在这些 $ i $ 中，找出 $ a[i] &lt; a[idx]$，计算能产生最大 $dp[i]$ 的 $i$，之后就可以求出 $dp[idx]$： $dp[idx] = max(dp[i]) + 1, i \in [1, idx-1]  \&amp;\&amp;  a_i &lt; a_{idx}$。</li>
</ul>
</li>
<li>对序列中的每一个元素都计算以他们各自结尾的最大递增子序列的长度，这些长度的最大值，就是我们要求的问题 —— 序列的最大递增子序列。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="comment">// sanity check</span></div><div class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// dp[idx]: the length of the LIS ending with the idx-th element</span></div><div class="line">    <span class="keyword">int</span> dp[numsSize];</div><div class="line">    <span class="comment">// prev[idx]:record the previous index of the LIS ending with the idx-th element</span></div><div class="line">    <span class="keyword">int</span> prev[numsSize];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="comment">// the maximum length of previous index LIS ending with an element not greater than current element </span></div><div class="line">        <span class="keyword">int</span> localIdxMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;idx; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[idx] &amp;&amp; dp[i] &gt; localIdxMax) &#123;</div><div class="line">                localIdxMax = dp[i];</div><div class="line">                prev[idx] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[idx] = localIdxMax + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// the longest increasing subsequence should ending with one index-th element</span></div><div class="line">    <span class="keyword">int</span> totalMax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">if</span>(dp[idx] &gt; totalMax) &#123;</div><div class="line">            totalMax = dp[idx];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> totalMax;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>因为避免了将问题转化为图这一繁琐的步骤，所以虽然同为 $O(N^2)$ 的复杂度，这种方法效率明显提升了。<br><img src="/img/Algorithms/0010_dp_result.png" width="720px"/></li>
</ul>
<h4 id="耐心排序法（-O-N-logN-）"><a href="#耐心排序法（-O-N-logN-）" class="headerlink" title="耐心排序法（$O(N logN)$）"></a>耐心排序法（$O(N logN)$）</h4><ul>
<li>上面的解法时间复杂度仍然为 $O(N^2)$，仔细分析一下原因，之所以慢，是因为<font color="blue">对于每一个新的位置 $idx$ 都需要遍历 $idx$ 之前的所有位置 $ i, i \in [1, idx-1]$</font>，找出之前位置的最长递增子序列长度。我们是不是可以有一种方法能不用遍历之前所有的位置，而可以更快的确定 $i$ 的位置呢？<ul>
<li>举个例子，比如序列 $1, 3, 5, 2, 8, 4, 6$ 这个例子中，当到 6 时，我们一共可以有四种(1)不同长度；(2)保证该升序序列在同长度升序序列中末尾最小的升序序列<ul>
<li>1</li>
<li>1,2</li>
<li>1,2,4</li>
<li>1,2,4,6</li>
</ul>
</li>
<li>以上这些序列都是未来有可能成为最长序列的候选序列。这样，每来一个新的数，我们便按照以下规则更新这些序列：<ul>
<li>如果 $idx$ 元素比所有序列的末尾都大，说明有一个更长的递增序列产生，我们把最长的序列复制一遍，并加上这个元素。</li>
<li>如果 $idx$ 元素比所有序列的末尾都小，说明长度为1的序列可以更新了，更新为这个更小的末尾。</li>
<li>如果刚好在中间，则更新那个末尾数字刚刚大于等于自己的那个序列，说明那个长度的序列可以更新了。</li>
</ul>
</li>
</ul>
</li>
<li>基于上面的例子，我们可以推导出这样的一种思路<ul>
<li>$A[i]$ 数组用来记录长度为 $i$ 的递增子序列的末尾元素的最小值<ul>
<li>其中$ i \leq numsSize$</li>
<li>数组 $A[i]$ 的 size 为 $numsSize+1$</li>
<li>我们很容易能够得到关于数组 $A[i]$ 的一个性质：$i &lt; j$ 时，$A[i] &lt; A[j]$</li>
</ul>
</li>
<li>maxLen 变量记录当前的最长递增子序列的长度。</li>
<li>上述的更新规则就转变成对 $A[1, 2, i, maxLen]$ 数组进行更新。<ul>
<li>$A[1, 2, i, maxLen]$ 是有序的</li>
<li>更新操作只需要进行替换而不需要挪动——也就是说，我们可以使用二分查找，将<font color="blue">每个 $idx$ 元素对 $A[1, 2, i, maxLen]$ 数组的更新时间优化到 $O(logN)$（不需要 $O(N)$ 了）</font>，算法的时间复杂度就降低到了$O(N logN)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</div><div class="line"> * finds a minimum value greater than findingNum in findingArray[1, 2, ..., findingArraySize] and returns its position</div><div class="line"> *  findingArray should be in order</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* findingArray, <span class="keyword">int</span> findingArraySize, <span class="keyword">int</span> findingNum)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> begin = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = findingArraySize;</div><div class="line">    <span class="keyword">while</span>(begin &lt;= end) &#123;</div><div class="line">        <span class="keyword">int</span> mid = begin + (end - begin)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(findingArray[mid] &gt; findingNum) &#123;</div><div class="line">            end = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(findingArray[mid] &lt; findingNum) &#123;</div><div class="line">            begin = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// return the same value position for covering</span></div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return postion to insert after</span></div><div class="line">    <span class="keyword">return</span> begin;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="comment">// sanity check</span></div><div class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// A[i=1, 2, ..., maxLen]: the minimum value of the end element of the i-length increasing sequence</span></div><div class="line">    <span class="keyword">int</span> A[numsSize+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> maxLen;</div><div class="line">    </div><div class="line">    maxLen = <span class="number">1</span>;</div><div class="line">    A[<span class="number">1</span>] = nums[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">1</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">if</span>(nums[idx] &gt; A[maxLen]) &#123;</div><div class="line">            maxLen += <span class="number">1</span>;</div><div class="line">            A[maxLen] = nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> pos = binarySearch(A, maxLen, nums[idx]);</div><div class="line">            A[pos] = nums[idx];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxLen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>复杂度从 $O(N^2)$ 缩小到 $O(N logN)$，运行效率得到较大的提升。<br><img src="/img/Algorithms/0010_nlogn_result.png" width="720px"/></li>
</ul>
<h4 id="提取最长递增子序列"><a href="#提取最长递增子序列" class="headerlink" title="提取最长递增子序列"></a>提取最长递增子序列</h4><ul>
<li>规约为图的最长路径问题<ul>
<li>利用 $prev[numsSize]$ 数组记录每个最长路径 $L[idx]$ 的前驱节点元素下标 $prev[idx]$，通过 $prev[idx]$ 迭代还原出最长路径。</li>
<li>具体实现与下面的动态规划类似。</li>
</ul>
</li>
<li>动态规划  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// int totalMaxIdx = &lt;idx for toalMax element index&gt;;</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; nums[totalMaxIdx];</div><div class="line"><span class="keyword">int</span> prevIdx = prev[totalMaxIdx];</div><div class="line"><span class="keyword">while</span>(prevIdx != <span class="number">-1</span>) &#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; nums[prevIdx];</div><div class="line">  prevIdx = prev[prevIdx];</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>耐心排序法<ul>
<li>$A[i=1, 2, …, maxLen]$ 就是满足要求的最长递增子序列。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;300-Longest-Increasing-Subsequence&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence&quot; class=&quot;headerlink&quot; title=&quot;300. Longest Increasing Subsequence&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-subsequence/#/description&quot;&gt;300. Longest Increasing Subsequence&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;br&gt;For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;给出一个序列 $a_1, a_2, …, a_n$，求它的一个子序列（设为 $s_1, s_2, …, s_n$ ），使得这个子序列满足这样的性质：$ s_1 &amp;lt; s_2 &amp;lt; s_3 &amp;lt;…&amp;lt; s_n $ 并且这个子序列的长度最长，输出这个最长的长度。实际上，诸如最长下降子序列，最长不上升子序列等问题都可以看成同一个问题，仔细思考就会发现，这其实只是 $&amp;lt;$ 符号定义上的问题，并不影响问题的实质。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0009] Dynamic Programming(II)（Maximum Sum/Product Subarray）</title>
    <link href="http://durant35.github.io/2017/04/23/Algorithms_Dynamic%20Programming(II)/"/>
    <id>http://durant35.github.io/2017/04/23/Algorithms_Dynamic Programming(II)/</id>
    <published>2017-04-23T06:00:22.000Z</published>
    <updated>2017-05-15T07:05:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong><a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> &amp; <a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a></strong> 分析根据动态规划思路进行问题求解中的一个关键环节：子问题的拆分和求解。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><ul>
<li>两道题解决的问题相似，都是求解给定序列中满足某种数学特征（和最大/乘积最大）的子序列，虽然不需要将该子序列输出。</li>
</ul>
<blockquote>
<p>Find the contiguous subarray within an array(containing at least one number) which has the largest sum/product.</p>
<ul>
<li>For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. </li>
<li>For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. </li>
</ul>
</blockquote>
<ul>
<li>留意的关键字眼是：<code>containing at least one number</code>，所以给定序列至少有一个元素，这也启发我们可以将其作为特殊处理。</li>
</ul>
<h4 id="53-Maximum-Subarray-解题思路"><a href="#53-Maximum-Subarray-解题思路" class="headerlink" title="53. Maximum Subarray 解题思路"></a><a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> 解题思路</h4><ul>
<li>思路一：$sums[j]$ 为序列前 j 个元素的最大子段和作为求解的子问题，则 $sum[n]$ 则为问题的答案。然而，如何利用 $sums[1, 2, …, j-1]$ 对 $sums[j]$ 进行求解呢？显然需要知道前 j 个元素的最大字段和的子段起始和终止位置，求解这个子问题的状态迁移显然比较复杂。</li>
<li>换一种思路。思路二：$sums[j]$ 为以第 j 个元素为结尾的子段的最大子段和作为求解的子问题，$max_{1 \leq j \leq n}(sums[j])$ 即为整个序列的最大子段和。而通过 $sums[j-1]$ 和当前元素 $nums[j]$ 即可计算以第 j 个元素为结尾的最大子段和 $sums[j]$，<code>状态转移方程</code> 如下：<br>$$ sums[j+1] = \begin{cases}  nums[j+1]　　　　　　sums[j] \lt 0 \cr sums[j] + nums[j+1]　others \end{cases}$$</li>
<li>根据思路二，<a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> 解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sums[SizeofNums];</div><div class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="comment">// sums[i]: The largest sum of subarray ending with the i-th element</span></div><div class="line">            sums[i] = sums[i<span class="number">-1</span>]&lt;<span class="number">0</span> ? nums[i] : sums[i<span class="number">-1</span>]+nums[i]; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// The largest sum of the whole array</span></div><div class="line">        <span class="keyword">int</span> largestSum = sums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(largestSum &lt; sums[i]) &#123;</div><div class="line">                largestSum = sums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>为了得到 <code>largestSum</code> 对应的子序列，我们可以通过变量 <code>startIdx</code> 记录以第 j 个元素结尾（<code>endIdx</code>）的最大子段和对应子序列的起始位置，$nums[startIdx, …, endIdx]$ 即为对应的子序列；另外，考虑到<strong>当前状态只与前一个状态有关</strong>，所以可以使用变量代替数组，节省内存，同时，避免获取<code>The largest sum of the whole array</code> 时的重复循环。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// largest sum for the subarray ending with current element </span></div><div class="line">        <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// largest sum of subarray for the whole array</span></div><div class="line">        <span class="keyword">int</span> largestSum = curSum;</div><div class="line">        <span class="comment">// subarray[startIdx, endIdx] with largest sum for the whole array</span></div><div class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>, endIdx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</div><div class="line">                curSum = nums[i];</div><div class="line">                startIdx = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                curSum = curSum + nums[i];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curSum &gt; largestSum) &#123;</div><div class="line">                largestSum = curSum;</div><div class="line">                endIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="152-Maximum-Product-Subarray-解题思路"><a href="#152-Maximum-Product-Subarray-解题思路" class="headerlink" title="152. Maximum Product Subarray 解题思路"></a><a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a> 解题思路</h4><ul>
<li>这一题的解题流程与上一题基本类似，但是要解决的关键问题是：状态转移，即如何根据上一个子问题（以第 j 个元素为结尾的子段的max product）的答案推算出当前子问题的结果。</li>
<li>从上一题的分析可以看出，当前子问题（以第 j 个元素为结尾的子段的max sum）的计算只需考虑上一个子问题的结果 $sum[j-1]$，$sum[j-1] &lt; 0$，因为是加法，显然可以将子问题结果忽略；$sum[j-1] &gt; 0$，$sum[j-1]$ 加上当前元素就是当前子问题的结果。</li>
<li>类似的问题，只不过换成乘积，子问题的求解就变得复杂了，需要考虑以下几种情况：<ul>
<li>当前元素是正数，max product可能是正正得正的情况，因为都是整数，乘积＞1，上一子问题的结果乘上当前元素即为当前子问题的答案</li>
<li>当前元素是负数，max product可能是负负得正的情况，因此需要维护以第 j 个元素为结尾的子段的min product（很大可能是负数）</li>
<li>另外，需要考虑上一个子问题的结果为0的情况</li>
<li>总之，乘积的最大值为上述三种情况之一<br>状态转移方程如下：<br>$$ maxProducts[j+1] = max(maxProducts[j-1]*nums[j], minProducts[j-1]*nums[j], nums[j])$$</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a> 解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The largest/least product of subarray ending with the i-th element</span></div><div class="line">        <span class="keyword">int</span> maxProducts[SizeofNums];</div><div class="line">        <span class="keyword">int</span> minProducts[SizeofNums];</div><div class="line">        maxProducts[<span class="number">0</span>] = minProducts[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="comment">// positive with positive, negative with negative, ignore previous zero</span></div><div class="line">            maxProducts[i] = max( max(maxProducts[i<span class="number">-1</span>]*nums[i], minProducts[i<span class="number">-1</span>]*nums[i]), nums[i]);</div><div class="line">            <span class="comment">// positive with negative, negative with positive, ignore previous zero</span></div><div class="line">            minProducts[i] = min( min(maxProducts[i<span class="number">-1</span>]*nums[i], minProducts[i<span class="number">-1</span>]*nums[i]), nums[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// getting the largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> largestProduct = maxProducts[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(maxProducts[i] &gt; largestProduct) &#123;</div><div class="line">                largestProduct = maxProducts[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestProduct;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>与上一题类似，添加额外变量，也能实现节省内存，记录子段最大乘积对应子段（$nums[startIdx, endIdx]$）的起始和终止位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The largest/least product of subarray ending with the i-th element</span></div><div class="line">        <span class="keyword">int</span> largestProduct = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> leastProduct = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// The largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> maxProduct = largestProduct;</div><div class="line">        <span class="comment">// subarray[startIdx, endIdx] with largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>, endIdx = <span class="number">0</span>;</div><div class="line">        <span class="comment">// start index for largestProduct/leastProduct</span></div><div class="line">        <span class="keyword">int</span> startIdx_pos = startIdx, startIdx_neg = startIdx;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">int</span> largestProduct_pre = largestProduct;</div><div class="line">            <span class="keyword">int</span> leastProduct_pre = leastProduct;</div><div class="line">            </div><div class="line">            <span class="comment">// positive with positive, negative with negative, ignore previous zero</span></div><div class="line">            largestProduct = max( max(largestProduct_pre*nums[i], leastProduct_pre*nums[i]), nums[i]);</div><div class="line">            <span class="keyword">if</span>((largestProduct_pre != nums[i]) &amp;&amp; (largestProduct == nums[i])) &#123;</div><div class="line">                startIdx_pos = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// positive with negative, negative with positive, ignore previous zero</span></div><div class="line">            leastProduct = min( min(largestProduct_pre*nums[i], leastProduct_pre*nums[i]), nums[i]);</div><div class="line">            <span class="keyword">if</span>((leastProduct_pre != nums[i]) &amp;&amp; (leastProduct == nums[i])) &#123;</div><div class="line">                startIdx_neg = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(largestProduct &gt; maxProduct) &#123;</div><div class="line">                maxProduct = largestProduct;</div><div class="line">                <span class="keyword">if</span>(largestProduct_pre*nums[i] &gt; leastProduct_pre*nums[i]) &#123;</div><div class="line">                    startIdx = startIdx_pos;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    startIdx = startIdx_neg;</div><div class="line">                &#125;</div><div class="line">                endIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> maxProduct;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/#/description&quot;&gt;53. Maximum Subarray&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode.com/problems/maximum-product-subarray/#/description&quot;&gt;152. Maximum Product Subarray&lt;/a&gt;&lt;/strong&gt; 分析根据动态规划思路进行问题求解中的一个关键环节：子问题的拆分和求解。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0008] Dynamic Programming(I)（Unique Paths）</title>
    <link href="http://durant35.github.io/2017/04/13/Algorithms_Dynamic%20Programming(I)/"/>
    <id>http://durant35.github.io/2017/04/13/Algorithms_Dynamic Programming(I)/</id>
    <published>2017-04-13T06:00:22.000Z</published>
    <updated>2017-05-15T07:04:09.443Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong>Unique Paths <a href="https://leetcode.com/problems/unique-paths/#/description">[I]</a> &amp; <a href="https://leetcode.com/problems/unique-paths-ii/#/description">[II]</a></strong> 两道题从普通的递归思路到动态规划两种方式的求解尝试，希望能够初步分析如何根据动态规划的思路，进行问题求解。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><p><center><img src="/img/Algorithms/0008_robot_maze.png" width="380px"/></center></p>
<ul>
<li>两道题解决的问题相似，都是求解从格网图左上角（Start）→ 右下角（Finish）可行的路径总数，而且行走方向只有向下或者向右移动两种方式，只是在以下两个地方存在一些区别：<ul>
<li><a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a> 行走的格网图不设立障碍，而 <a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 中行走的格网图存在障碍，在可行路径选取上需要考虑避开障碍物的问题。</li>
<li>由于上面的区别，导致在输入上两道题有所不同：前者只需要输入格网图的大小（#row*#column）；后者则需要提供格网图的0-1矩阵（1表示网格存在障碍物）</li>
</ul>
</li>
</ul>
<h4 id="递归思想解答"><a href="#递归思想解答" class="headerlink" title="递归思想解答"></a>递归思想解答</h4><ul>
<li>由于每一步的行走策略只有两种，不是向下走就是向右走，因此，假设当前这一步完成后到达右下角（#row，#column），那么只有（#row-1，#column）向下走和（#row，#column-1）向右走这两种方式，所以可行的路径总数显然就是从起点（1，1）到这两个中间点的可行路径总数之和。</li>
<li>按照上述的思路，很容易通过递归的方式最终会退到起点（递归基），并通过递归函数返回得到总的可行路径数目。</li>
<li>需要注意的一点是，由于每一步只有向右或者向下两种策略，所以，并不需要递归回起点（1，1），当回退到（1，？）或（？，1）时，从起点到当前中间点，有且只有一条路径（一直向右走或者一直想下走）。</li>
<li><a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a>  按照递归思路的解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// when m==1 or n==1, only directly down or directly right</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// left to right + up to down</span></div><div class="line">        <span class="keyword">return</span> uniquePaths(m, n<span class="number">-1</span>) + uniquePaths(m<span class="number">-1</span>, n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 则需要进一步考虑当前步是否可行的问题，倘若存在障碍物，显然此路不通，不应计入可行路径的统计，<code>return 0</code>。</li>
<li>另外，与 <a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a> 不同，只有回退到起点，才能判断通过递归历经的网格所构成的路径是可行的。因为，只是回退到（1，？）或（？，1），一旦起点到该中间点的<code>向右直走路径</code>或<code>向下直走路径</code>中间出现任何一个障碍物，该路径都是不可行的。</li>
<li>以下是递归解答，留意与前一道题目在输入上的区别。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// obstacleGrid[0][0] == 0</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// left to right</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m, n<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// up to down</span></div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m<span class="number">-1</span>, n);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// up to down + left to right</span></div><div class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m<span class="number">-1</span>, n) + uniquePathsWithObstacles(obstacleGrid, m, n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rowSize = obstacleGrid.size();</div><div class="line">        <span class="keyword">int</span> colSize = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        </div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>((colSize &lt; <span class="number">1</span>) || (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) || (obstacleGrid[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>] == <span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, rowSize, colSize);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">递归思路解答对上述问题并不可行</font><ul>
<li>我们都知道，直接的递归实现，可读性强，但频繁的函数调用会造成一定的时间损耗，因此上述两题都存在 <code>Time Limit Exceeded</code> 的错误。</li>
<li>另一个更为关键的问题是，上述简单的递归实现，每次递归的时候都对从起点到达当前中间网格的可行路径数进行了重复计算，这种重复计算的代价是巨大的，往往需要好几层回退；假如能够避免这种冗余，肯定会带来巨大的提升。</li>
</ul>
</li>
</ul>
<h4 id="动态规划思路解答"><a href="#动态规划思路解答" class="headerlink" title="动态规划思路解答"></a>动态规划思路解答</h4><ul>
<li>动态规划思路就能很好解决上述的问题：回退的方式不好避免重复计算的问题（可能需要维护从起点到达每个网格可行路径总数的表，另外通过是否为<code>Inf</code>避免重复计算，为了让每次递归均能访问操作该表，需要将其置为全局变量），我们干脆换个方向，从起点出发，直到到达右下角；动态规划的过程就像是在填上述这样一个表。</li>
<li>通过递归回退+维护从起点到达每个网格可行路径总数的表避免冗余计算的方式（记忆化搜索），因为只有在右下角到起点的可行路径上的网格才会被计算，能够避开其他不必要的网格；但是，函数的调用显然有一定损耗。</li>
<li>动态规划这种填表的思路，会将所有网格对应的表项填满，但这种顺序进行的操作实现简易（通过一个数组，两三层循环即可实现），耗时也较少，因此在大多数问题（动态规划多余的计算数目并不算多）下较记忆化搜索有一定优势。</li>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 的动态规划解答关键已经在递归思路中体现，即：从起点到当前网格的可行路径总数为到左方网格（向右移动到达当前网格）及上方网格（向下移动达到当前网格）可行路径总数之和。<ul>
<li>需要注意的是，从起点到（1，？）或（？，1）的可行路径显然都只有一条（一直向右移动/一直向下移动）。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> paths[m][n];</div><div class="line">        <span class="comment">// paths(1, 1...n), left to right</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;n; col++) &#123;</div><div class="line">            paths[<span class="number">0</span>][col] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// paths(1...n, 1), up to down</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;m; row++) &#123;</div><div class="line">            paths[row][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;m; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;n; col++) &#123;</div><div class="line">                <span class="comment">// left to right + up to down</span></div><div class="line">                paths[row][col] = paths[row][col<span class="number">-1</span>] + paths[row<span class="number">-1</span>][col];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> paths[m<span class="number">-1</span>][n<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 思路基本一致，只是当当前网格存在障碍物，其到起点的可行路径显然不存在。<ul>
<li>另外，对于从起点到（1，？）或（？，1）可行路径的分析与递归思路解答时一致。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rowSize = obstacleGrid.size();</div><div class="line">        <span class="keyword">int</span> colSize = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>((rowSize &lt; <span class="number">1</span>) || (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) || (obstacleGrid[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>] == <span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> paths[rowSize][colSize];</div><div class="line">        <span class="comment">// obstacleGrid[0][0] == 0 from above</span></div><div class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// paths(1, 1...n)</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;colSize; col++) &#123;</div><div class="line">            paths[<span class="number">0</span>][col] = obstacleGrid[<span class="number">0</span>][col]==<span class="number">0</span> ? paths[<span class="number">0</span>][col<span class="number">-1</span>] : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// paths(1...n, 1)</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            paths[row][<span class="number">0</span>] = obstacleGrid[row][<span class="number">0</span>]==<span class="number">0</span> ? paths[row<span class="number">-1</span>][<span class="number">0</span>] : <span class="number">0</span>;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;colSize; col++) &#123;</div><div class="line">                <span class="comment">// left to right + up to down</span></div><div class="line">                paths[row][col] = obstacleGrid[row][col]==<span class="number">0</span> ? (paths[row][col<span class="number">-1</span>] + paths[row<span class="number">-1</span>][col]) : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> paths[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;Unique Paths &lt;a href=&quot;https://leetcode.com/problems/unique-paths/#/description&quot;&gt;[I]&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode.com/problems/unique-paths-ii/#/description&quot;&gt;[II]&lt;/a&gt;&lt;/strong&gt; 两道题从普通的递归思路到动态规划两种方式的求解尝试，希望能够初步分析如何根据动态规划的思路，进行问题求解。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0007] Minimum Spanning Tree（最小生成树）</title>
    <link href="http://durant35.github.io/2017/04/06/Algorithms_Minimum%20Spanning%20Tree/"/>
    <id>http://durant35.github.io/2017/04/06/Algorithms_Minimum Spanning Tree/</id>
    <published>2017-04-06T06:00:22.000Z</published>
    <updated>2017-06-02T13:22:06.491Z</updated>
    
    <content type="html"><![CDATA[<p>　本文将介绍带权图的最小生成树（Minimum Spanning Tree）算法：给定一个无向图 G，并且它的每条边均有权值，则 MST 是一个包括 G 的所有顶点及边的子集的图，这个子集保证图是连通的，并且子集中所有边的权值之和为所有子集中最小的。<br>　本文中介绍两种求解图的最小生成树的算法：Prim 算法和 Kruskal 算法，这两种算法都是贪心算法。一般而言，贪心策略不一定能保证找到全局最优解，但是对最小生成树问题来说，贪心策略能获得具有最小权值的生成树。<br><a id="more"></a></p>
<h4 id="Minimum-spanning-trees"><a href="#Minimum-spanning-trees" class="headerlink" title="Minimum spanning trees"></a>Minimum spanning trees</h4><ul>
<li>让所有节点都被连接的最佳边集合：不可能包含环。<ul>
<li>移除环中的任何一条边都会降低代价而不破坏<strong>连通性</strong>（所有节点都被连接）。</li>
</ul>
</li>
<li><strong>树</strong>是一种连通且无环的无向图。<ul>
<li>性质①：移除环中的任意一条边不会破坏图的连通性。</li>
<li>性质②：具有 n 个节点的树的边数为 n-1。<ul>
<li>n 个节点，n 个独立的连接部件。</li>
<li>边 ${u, v}$ 的两个顶点分别处于两个独立的连接部件，否则，必然已存在连接两者的一条路径， ${u, v}$ 将导致环的出现。</li>
<li>每添加一条边，总的连接部件数减少了 1，从 n 一步步减少到 1，需要添加 n-1 条边。</li>
</ul>
</li>
<li>性质③：任何一个连通无向图 $G = (V, E)$，若满足 $|E| = |V| - 1$，则其为树。<ul>
<li>如果 G 中包含一个环，则移除该环上任意一边，直到得到一个无环图。</li>
<li>G’ 是连通的（<code>性质①</code>），且无环，故为树，故 $|E’| = |V| - 1$（<code>性质②</code>），实际上并没有移除过任意一条边，其本身就是树，即 $G’ = G$。</li>
</ul>
</li>
<li>性质④：一个无向图是树，当且仅当在其任意两个节点间仅存在唯一路径。<ul>
<li>任意两个节点间都存在一条路径 ===&gt; 连通性</li>
<li>路径唯一 ===&gt; 无环，环必然使得任意两个节点间存在两条路径</li>
</ul>
</li>
</ul>
</li>
<li><strong>最小生成树</strong>：具有最小代价（总权重）的树<ul>
<li>图的生成树是它的一棵含有其所有顶点的无环连通子图，一幅加权图的最小生成树（MST）是它的一棵权值（树中的所有边的权值之和）最小的生成树。</li>
<li>树$T = (V, E’)$，其中 $E \subseteq E’$，使得权重 $weight(T) = \sum_{e \in E’} w_e$ 最小。</li>
</ul>
</li>
</ul>
<h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591446.html">6.3.2 最小支撑树树–Prim算法，基于优先队列的Prim算法，Kruskal算法，Boruvka算法，“等价类”UnionFind</a></li>
</ul>
</blockquote>
<ul>
<li>Prim 算法可以说是所有 MST 算法中最简单的，比较适用于稠密图。以图中任意一个顶点 s 开始，MST 初始化为 ：{ V(s), E(none) }（顶点，边），称之为“当前 MST”，选择与当前 MST 中所有顶点相关连的边中权值最小的边，并添加到当前 MST 中。这一过程一直迭代到图中所有顶点都添加到 MST 中为止。<ul>
<li>在迭代时，假设当前 MST 中顶点形成集合 $V(v_0, v_1, …)$，则对 $V(v_0, v_1, …)$ 中的每一个 $v_i$，遍历与其相邻的所有边，并找到权值最小的边。<center><img src="/img/Algorithms/0007_PrimPseudo.png" width="720px"/></center></li>
</ul>
</li>
<li>Prim 最小生成树算法与 <a href="http://durant35.github.io/2017/03/29/Algorithms_Some%20Shortest-path%20Algorithms/#Dijkstra-算法">Dijkstra 最短路径算法</a> 十分相似，只不过 Prim 算法里节点的值是该节点到当前最小生成树中所有节点的边中的最短长度，而 Dijkstra 算法中节点的值是该节点到源节点的当前最短路径长度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> start=<span class="number">0</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].cost = INT_MAX;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"MST constructing:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  g.VertexNodes[start].cost = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNuminMST = <span class="number">0</span>; vertexNuminMST &lt; g.vertexNum; vertexNuminMST++) &#123;</div><div class="line">    <span class="comment">// Pick the node not in current MST with smallest cost</span></div><div class="line">    <span class="keyword">int</span> minCost = INT_MAX;</div><div class="line">    <span class="keyword">int</span> pickIdx = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[i] &amp;&amp; g.VertexNodes[i].cost&lt;minCost) &#123;</div><div class="line">        minCost = g.VertexNodes[i].cost;</div><div class="line">        pickIdx = i;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// other nodes are unreachable</span></div><div class="line">    <span class="keyword">if</span>(pickIdx == <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    visited[pickIdx] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// select an edge</span></div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[pickIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[pickIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[pickIdx].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[pickIdx].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    VertexNode* v = &amp;g.VertexNodes[pickIdx];</div><div class="line"> </div><div class="line">    <span class="comment">// update the cost(cost to current MST) for the successor vertex of current adding node</span></div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// visited to avoid repeatedly update</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx]</div><div class="line">        &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].cost &gt; head-&gt;weight) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].cost = head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].prev = v;</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  Prim(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Prim.cpp -o Prim</div><div class="line">$ ./Prim</div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing:</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 2--&gt;1(8)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 5--&gt;2(4)</div><div class="line">  + 6--&gt;5(2)</div><div class="line">  + 7--&gt;6(1)</div><div class="line">  + 3--&gt;2(7)</div><div class="line">  + 4--&gt;3(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 8&lt;--2(2)</div><div class="line">  + 7&lt;--6(1)</div><div class="line">  + 6&lt;--5(2)</div><div class="line">  + 5&lt;--2(4)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--1(8)</div><div class="line">  + 1&lt;--0(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTPrim.png" width="640px"/></center></li>
<li>上述无向图对应的输入文件 <code>Prim.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">9 26</div><div class="line">0 1 2 3 4 5 6 7 8</div><div class="line">0 1 4</div><div class="line">0 7 8</div><div class="line">1 0 4</div><div class="line">1 2 8</div><div class="line">2 1 8</div><div class="line">2 3 7</div><div class="line">2 5 4</div><div class="line">2 8 2</div><div class="line">3 2 7</div><div class="line">3 4 9</div><div class="line">3 5 14</div><div class="line">4 3 9</div><div class="line">4 5 10</div><div class="line">5 2 4</div><div class="line">5 3 14</div><div class="line">5 4 10</div><div class="line">5 6 2</div><div class="line">6 5 2</div><div class="line">6 7 1</div><div class="line">6 8 6</div><div class="line">7 0 8</div><div class="line">7 6 1</div><div class="line">7 8 7</div><div class="line">8 2 2</div><div class="line">8 6 6</div><div class="line">8 7 7</div></pre></td></tr></table></figure>
<ul>
<li>从上述的实现过程可以发现，在遍历与顶点相邻的所有边寻找与当前 MST 最近的顶点时，需要进行循环判断，选择距离最近的边之后其余边的信息将被舍弃；在下次循环判断时这些舍弃的边又被再次参与“竞选”最近的边，这无疑带来了重复判断。可以引入一个 <strong>最小堆</strong>，堆中存放遍历过的边。在遍历与顶点相邻的所有边时，首先将连边添加到堆中，然后直接将堆顶的边取出并添加到 MST 中。这样就可以避免重复判断。<ul>
<li>基于 <code>std::priority_queue</code> 优先级队列的实现</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>		<span class="comment">/* priority_queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">  <span class="comment">/* reload compare operator for priority queue</div><div class="line">   * In order to achieve the minimum heap(in ascending order)</div><div class="line">   *   reload operator&lt;, redefine the priority to smaller one</div><div class="line">   */</span></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> VertexNode&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> cost &gt; right.cost;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> start=<span class="number">0</span>)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode&gt; vertexQueue;</div><div class="line"> </div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].cost = INT_MAX;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">    visited[g.VertexNodes[i].vertexIdx] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  g.VertexNodes[start].cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// make priority queue, using cost-values as keys</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    vertexQueue.push(g.VertexNodes[i]);</div><div class="line">  &#125;</div><div class="line"> 	</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMST constructing:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    <span class="comment">// print current priority queue</span></div><div class="line">    <span class="comment">// #define PRINT</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    priority_queue&lt;VertexNode&gt; printQueue = vertexQueue;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">while</span>(!printQueue.empty()) &#123;</div><div class="line">      VertexNode tmp = printQueue.top();</div><div class="line">      printQueue.pop();</div><div class="line">      <span class="keyword">if</span>(tmp.cost != INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; tmp.data</div><div class="line">         	 &lt;&lt; <span class="string">"("</span></div><div class="line">           &lt;&lt; tmp.cost</div><div class="line">         	 &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">    VertexNode v = vertexQueue.top();</div><div class="line"> </div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\tpop: "</span> &lt;&lt; v.data &lt;&lt; <span class="string">"("</span>;</div><div class="line">    <span class="keyword">if</span>(v.cost != INT_MAX) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; v.cost;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">    vertexQueue.pop();</div><div class="line">  </div><div class="line">    <span class="keyword">int</span> vertexIdx = v.vertexIdx;</div><div class="line">    <span class="comment">// cout &lt;&lt; "[" &lt;&lt; vertexIdx &lt;&lt; "]";</span></div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// an edge is selecting </span></div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[vertexIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[vertexIdx].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[vertexIdx].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push: "</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">    adjVertexNode* head = v.<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx]</div><div class="line">        &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].cost &gt; head-&gt;weight) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].cost = head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].prev = &amp;g.VertexNodes[v.vertexIdx];</div><div class="line">        vertexQueue.push(g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].cost &lt;&lt; <span class="string">")"</span></div><div class="line">           &lt;&lt; <span class="string">" "</span>;</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  Prim(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Prim_queue.cpp -o Prim_queue</div><div class="line">$ ./Prim_queue </div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing:</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 7--&gt;0(8)</div><div class="line">  + 6--&gt;7(1)</div><div class="line">  + 5--&gt;6(2)</div><div class="line">  + 2--&gt;5(4)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 3--&gt;2(7)</div><div class="line">  + 4--&gt;3(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 8&lt;--2(2)</div><div class="line">  + 7&lt;--0(8)</div><div class="line">  + 6&lt;--7(1)</div><div class="line">  + 5&lt;--6(2)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--5(4)</div><div class="line">  + 1&lt;--0(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTPrimqueue.png" width="640px"/></center>

</li>
</ul>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/cielosun/p/5654539.html">并查集(union-find set)与Kruskal算法</a></li>
</ul>
</blockquote>
<ul>
<li>Prim 算法的思路是通过一次找出一条边添加到 MST 中，其中每一步都是要找到一条新的边并且关联到不断增长的当前 MST。Kruskal 算法也是一次找到一条边来不断构建 MST，但是与 Prim 算法不同的是，它要找到连接两棵树的一条边，这两棵树处于一个 MST 子树的分离的森林中，其中 MST 子树将不断增长。<ul>
<li>算法由一个包括 N 棵（单个顶点组成的）树的森林开始。然后持续完成合并两棵树的操作（使用最短的边连接它们），直至只剩下一棵树，这棵树就是最终的MST树。</li>
<li>Kruskal 算法的正确性源自所谓的分割性质<ul>
<li><strong>分割性质</strong>：设边集 X 是 $G = (V, E)$ 的某个生成树的一部分，选定任一节点集合 $S \subset V$，使得 X 中没有跨越 S 和 $V - S$ 的边。若 e 是跨越 S 和 $V - S$ 的权重最轻的边，则 $X \cup {e}$ 也是某个 MST 的一部分。<ul>
<li>有：对任意的分割，在 X 不含跨越分割的边（该边的一个端点属于 S，另一个端点属于 $V - S$ ）这一前提下，增加跨越该分割的权重最轻的边 e 总是安全的。</li>
<li>假设 X 是某个 MST T 的一部分，① e 恰好也在 T 中，无需证明；② e 不属于 T，通过改变 T 中的一条边可以构造一个与之不同的 MST T’，使得 T’ 包含  $X \cup {e}$；由于 T 是连通的，在 T 中必然存在一条路径连接 e 的两个端点，故增加 e 将形成一个环，这个环包含另外某条跨越分割 ${S, V - S}$ 的边 e’，将其移除，得到 $T’ = T \cup {e} - {e’}$；③  <code>性质①</code> 可证 T’ 是连通的；另，T’ 和 T 的边数相同，<code>性质②</code> 和 <code>性质③</code> 可知，T’ 也是树。</li>
<li>树T’ 代价：$ weight(T’) = weight(T) + w(e) - w(e’)$，<strong>e 是跨越 S 和 $V - S$ 的权重最轻的边</strong>，有 $w(e) \leq w(e’)$，从而  $weight(T) \leq weight(T’)$，由 T 是 MST，可知 $weight(T) = weight(T’)$，T’ 也是 MST。<center><img src="/img/Algorithms/0007_KruskalPseudo.png" width="720px"/></center></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Kruskal 最小生成树算法实现细节<ul>
<li>起始于一个空的图。</li>
<li>通过逐条增加边来构造最小生成树：假如在构建最小生成树的过程中，我们已经选择了某些边并在向着正确的方向前进，下一步选择那条边呢？<ul>
<li>不断重复地选择未被选中的边中权重最轻的且不会形成环的一条。<ul>
<li>为保证连接等价类边的权值最短，算法首先对图中所有边按照权值进行排序。按权值由小到大依次选择边</li>
<li>不会形成环：每次选择一条边加入到现有的部分解中 ===&gt; 需要检验每一条侯选边(u-&gt;v) 的端点是否属于不同的连通分量，一旦选定了某条边，则将这条边添加到 MST 并将两个相关的连通分量将被合并。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Kruskal 最小生成树算法关键数据结构：并查集/分离集 (union-find/disjoint sets)<ul>
<li>Kruskal 算法开始有 n 个分别包含一个节点的集合（即 n 个分离集）；随着算法的进展，分离集的个数逐渐减少，直到算法的最后一步，分离集的个数变为 1，此时产生最小生成树。</li>
<li>并查集：并查集处理的是集合之间的关系，即 union，find。在这种数据类型中，N个不同元素被分成若干个组，每组是一个集合，这种集合叫做分离集合。并查集支持查找一个元素所属的集合和两个元素分别所属的集合的合并。注意：并查集只能进行合并操作，不能进行分割操作。</li>
<li>并查集支持以下操作：<ul>
<li><code>makeset(x)</code>：创建一个仅包含 x 的独立集合（分离集）；最初每个节点单独构成了一个分离集 ==&gt; 一组分离集</li>
<li><code>find(x)</code>：不断重复地检验节点对，判断其是否属于同一个集合？</li>
<li><code>union(x, y)</code>：每当增加了一条边，将与之相关的两个集合合并。</li>
</ul>
</li>
<li>并查集的实现原理<ul>
<li>并查集是使用树结构实现的<ul>
<li>初始化：准备 N 个节点来表示 N 个元素，最开始没有边。</li>
<li>为避免树的退化，对于每棵树，记录其高度 rank。</li>
<li>查询：查询两个节点是否在同一个集合，只需要查询他们是否具有相同的根。<center><img src="/img/Algorithms/0007_UnionFind_find.png" width="340px"/></center></li>
<li>合并：从一个分离集的根向另一个分离集的根连边，这样两棵树就变为了一棵树，也就把两个集合合并为一个了；除非将要合并的树等高，否则将不会出现合并后总高度增加的情形；如果合并时两棵树高度不同，那么从 rank 小的向 rank 大的连边。<center><img src="/img/Algorithms/0007_UnionFind_union.png" width="580px"/></center></li>
<li>路径压缩：每次 find 操作中，当循着一系列的父指针最终找到树的根后，改变所有这些父指针的目标，使其直接指向树根。<br><center><img src="/img/Algorithms/0007_UnionFind_find2.png" width="420px"/></center><ul>
<li>通过路径压缩，所有节点的等级都不会发生改变；节点的 rank 不再能解释为其下方子树的高度</li>
<li>union 操作只关注树的顶层，路径压缩不会对 union 操作产生影响，它将保持树的顶层不变</li>
<li>find 操作（不论是否采用路径压缩）仅仅触及树的内部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>基于并查集的 Kruskal 算法实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>			<span class="comment">/* priority_queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">  <span class="keyword">int</span> fromIdx, toIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> weight &gt; right.weight;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="function">UnionFindSets <span class="title">sets</span><span class="params">(g.vertexNum)</span></span>;</div><div class="line">  <span class="comment">// use priority_queue for sorting the edges E by weight</span></div><div class="line">  priority_queue&lt;Edge&gt; EdgeQueue;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    sets.makeset(g.VertexNodes[i].vertexIdx);</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      Edge e;</div><div class="line">      e.fromIdx = g.VertexNodes[i].vertexIdx;</div><div class="line">      e.toIdx = head-&gt;adjVertexIdx;</div><div class="line">      e.weight = head-&gt;weight;</div><div class="line">      EdgeQueue.push(e);</div><div class="line"></div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMST constructing: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">while</span>(!EdgeQueue.empty()) &#123;</div><div class="line">    Edge e = EdgeQueue.top();</div><div class="line">    EdgeQueue.pop();</div><div class="line">    <span class="comment">// cout &lt;&lt; "\npop: " &lt;&lt; e.fromIdx &lt;&lt; "-&gt;" &lt;&lt; e.toIdx &lt;&lt; "(" &lt;&lt; e.weight &lt;&lt; ")" &lt;&lt; endl;</span></div><div class="line">    <span class="keyword">if</span>(sets.find(e.fromIdx) != sets.find(e.toIdx)) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * 2 edges with same vertex in an undirect graph</div><div class="line">       *	but every VertexNode can only have on prev.</div><div class="line">       */</span></div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[e.toIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      g.VertexNodes[e.toIdx].prev = &amp;g.VertexNodes[e.fromIdx];</div><div class="line">      g.VertexNodes[e.toIdx].cost = e.weight;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[e.fromIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[e.toIdx].data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; e.weight &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">      sets.unite(e.fromIdx, e.toIdx);</div><div class="line">      <span class="comment">// sets.printset();</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  Kruskal(g);</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Kruskal.cpp -o Kruskal</div><div class="line">$ ./Kruskal </div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing: </div><div class="line">  + 6--&gt;7(1)</div><div class="line">  + 5--&gt;6(2)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 2--&gt;5(4)</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 2--&gt;3(7)</div><div class="line">  + 2--&gt;1(8)</div><div class="line">  + 3--&gt;4(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 7&lt;--6(1)</div><div class="line">  + 6&lt;--5(2)</div><div class="line">  + 5&lt;--2(4)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--8(2)</div><div class="line">  + 1&lt;--2(8)</div><div class="line">  + 0&lt;--1(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTKruskal.png" width="640px"/></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文将介绍带权图的最小生成树（Minimum Spanning Tree）算法：给定一个无向图 G，并且它的每条边均有权值，则 MST 是一个包括 G 的所有顶点及边的子集的图，这个子集保证图是连通的，并且子集中所有边的权值之和为所有子集中最小的。&lt;br&gt;　本文中介绍两种求解图的最小生成树的算法：Prim 算法和 Kruskal 算法，这两种算法都是贪心算法。一般而言，贪心策略不一定能保证找到全局最优解，但是对最小生成树问题来说，贪心策略能获得具有最小权值的生成树。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0006] Some Shortest-path Algorithms（最短路径算法）</title>
    <link href="http://durant35.github.io/2017/03/29/Algorithms_Some%20Shortest-path%20Algorithms/"/>
    <id>http://durant35.github.io/2017/03/29/Algorithms_Some Shortest-path Algorithms/</id>
    <published>2017-03-29T06:00:22.000Z</published>
    <updated>2017-05-06T00:55:06.507Z</updated>
    
    <content type="html"><![CDATA[<p>　本文介绍几种常见的最短路径算法：</p>
<ul>
<li>Breadth-first Search 无权最短路径算法；</li>
<li>Dijkstra 带权（非负权）图的单源最短路算法；</li>
<li>Bellman-Ford 带权（可负权）图的单源最短路算法；</li>
<li>Floyd-Warshall 带权（可负权）图的全源最短路算法，<br>　包括它们各自的<strong>使用条件&amp;范围</strong>，<strong>算法原理介绍</strong>以及<strong>代码实现</strong>。<a id="more"></a>
</li>
</ul>
<h4 id="Breadth-first-Search-无权最短路径算法"><a href="#Breadth-first-Search-无权最短路径算法" class="headerlink" title="Breadth-first Search 无权最短路径算法"></a>Breadth-first Search 无权最短路径算法</h4><ul>
<li><strong>BFS</strong> 适合边的权值均是 1（无权图）的最短路径问题，因为，假设 S 为起始点，<strong>BFS</strong> 每次都会先发现距离 S 为 k 的所有顶点，然后才会发现距离 S 为 k+1 的所有顶点。<br><center><img src="/img/Algorithms/0006_BFSPseudo.png" width="640px"/></center><br>① 对于外面的<code>while</code>循环，会执行|V|次，因为每个顶点入队出队一次。<br>② <code>dist(v)==∞</code> 说明节点 v 还没被访问，将其放入队列并更新<code>dist</code>值。<br>③ 里面的<code>for</code>循环一共会执行|E|次，即变长，所以该算法时间复杂度为O(|V|+|E|)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="built_in">queue</span>&lt;VertexNode*&gt; vertexQueue;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  vertexQueue.push(&amp;Source);</div><div class="line">  <span class="keyword">while</span> (!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode* v = vertexQueue.front();</div><div class="line">    vertexQueue.pop();</div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (g.VertexNodes[head-&gt;adjVertexIdx].dist == INT_MAX) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + <span class="number">1</span>;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">        vertexQueue.push(&amp;g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"BFS.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(VertexNode) &lt;&lt; <span class="keyword">sizeof</span>(adjVertexNode*) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    BFS(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<center><img src="/img/Algorithms/0006_BFSGraph.png" width="640px"/></center>

<ul>
<li>忽略边的权值，该图对应的输入文件 <code>BFS.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">6 18</div><div class="line">S A B C D T</div><div class="line">0 1</div><div class="line">0 3</div><div class="line">0 4</div><div class="line">1 0</div><div class="line">1 2 </div><div class="line">1 4</div><div class="line">2 1</div><div class="line">2 4</div><div class="line">2 5</div><div class="line">3 0</div><div class="line">3 4</div><div class="line">4 0</div><div class="line">4 1</div><div class="line">4 2</div><div class="line">4 3</div><div class="line">4 5</div><div class="line">5 2</div><div class="line">5 4</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>g++</code>进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// -m32 option <span class="keyword">for</span> 32-bit execution</div><div class="line">g++ [-m32] BFS.cpp -o BFS</div></pre></td></tr></table></figure>
<p><a href="http://durant35.github.io/2017/03/22/Algorithms_BFS/#more">更多关于BFS算法的实现，可以点击阅读</a> </p>
<h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/skywang12345/p/3711512.html">Dijkstra算法(一)之 C语言详解</a></li>
<li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html">最短路径—Dijkstra算法和Floyd算法</a></li>
</ul>
</blockquote>
<center><img src="/img/Algorithms/0006_DijkstraDerivation.png" width="480px"/></center>

<ul>
<li>Dijkstra <strong>算法推导</strong><ul>
<li>已知区域<code>S</code> 是包含 s 的某个顶点子集。</li>
<li>关于当前最短路径有很多单边扩展路径，其中 <code>u→v</code> 是最短的一条。</li>
<li>上图中，s 到 v 的最短路径即为这样一条路径：基于一条已知的最短路径中的某条边（如上图<code>s→u</code>）的扩展路径。<ul>
<li>推导条件：假设无负权，u 一定比 v 距离 s 更近，这意味着 u 在已知区域 S 中，否则将与 <strong>v 是 S 之外且与 s 距离最近的顶点</strong> 这一假设相矛盾。</li>
</ul>
</li>
<li>检查当前已知最短路径集合 S 的所有单边扩展路径，找到这些扩展路径中的最短路径，该路径的另一个端点即为加入 S 的下一个顶点。</li>
<li>提高算法的执行效率：基于这样一个事实，在算法的任意迭代步骤中，仅有的新扩展路径是那些连接最近加入到 S 中的顶点的路径，其它所有路径的长度之前已经计算过，无需重新计算。</li>
</ul>
</li>
</ul>
<center><img src="/img/Algorithms/0006_DijkstraPseudo.png" width="880px"/></center>

<ul>
<li>Dijkstra <strong>算法思想</strong> ：<ul>
<li>左图：① <code>dist(v)</code>：指向 v 的当前最短单边扩展路径的长度（对于与 S 不相邻的顶点，取值为 ∞）；② 每次 while 循环迭代的末尾，（1）存在一个值 d，使得从 s 到 S 中所有顶点的距离 ≤d。同时 s 到 S 外的所有顶点的距离≥d；（2）对于每个顶点 v，dist(v) 表示一条从 s 到 v 的最短路径的长度，该路径经过的顶点均在 S 中（如果不存在这样的路径，dist 为 ∞）。</li>
<li>右图：设 <code>G=(V，E)</code> 是一个带权有向图（无向可以转化为双向有向），把图中顶点集合<code>V</code>分成两组，第一组为已求出最短路径的顶点集合（用<code>S</code>表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将其加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用<code>U</code>表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离， S 中的顶点的距离就是从 v 到此顶点的最短路径长度， U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。</li>
</ul>
</li>
<li>Dijkstra <strong>算法具体步骤</strong><br>  （1）初始时，S只包含源点，即S＝{v}，v的距离dist[v]为0。U包含除v外的其他顶点，U中顶点u距离dis[u]为边上的权值（若v与u有边）或 ∞（若u不是v的出边邻接点即没有边 <code>&lt;v→u&gt;</code>）。<br>  （2）从U中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离（dist[k]）就是 v 到 k 的最短路径长度）。<br>  （3）以 k 为新考虑的中间点，修改 <code>U</code> 中各顶点的距离（松弛操作）：若从源点v到顶点u（u∈ U）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值等于顶点k的距离加上边上的权（即如果 <code>dist[k]+w[k,u]&lt;dist[u]</code>，那么把dist[u]更新成更短的距离 <code>dist[k]+w[k,u]</code>）。<br>  （4）重复步骤（2）和（3）直到所有顶点都包含在 <code>S</code> 中(要循环n-1次)。</li>
<li>基于数组实现的 Dijkstra 算法（<strong>void Dijkstra(Graph&amp; g, VertexNode&amp; Source)</strong> 函数）<ul>
<li>总共需要循环 |V| 次（步骤（4）），实现将所有节点添加进已知区域 S。</li>
<li>每次循环，需要选取一个距离最小的顶点（步骤（2）），需要对所有节点进行遍历（$O(|V|)$）。</li>
<li>在循环执行的过程中，该循环为了更新距离（步骤（3）），需要访问每条边一次（有向图的情况）或两次（无向图的情况），从而花费了 $O(|E|)$ 的时间。</li>
<li>该算法的整体运行时间为：$O(|V|^2)$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNuminS = <span class="number">0</span>; vertexNuminS &lt; g.vertexNum; vertexNuminS++) &#123;</div><div class="line">    <span class="comment">// Pick the node not in S with smallest dist</span></div><div class="line">    <span class="keyword">int</span> minDist = INT_MAX;</div><div class="line">    <span class="keyword">int</span> pickIdx = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[i] &amp;&amp; g.VertexNodes[i].dist&lt;minDist) &#123;</div><div class="line">        minDist = g.VertexNodes[i].dist;</div><div class="line">        pickIdx = i;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// other nodes are unreachable</span></div><div class="line">    <span class="keyword">if</span>(pickIdx == <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    visited[pickIdx] = <span class="literal">true</span>;</div><div class="line">    VertexNode* v = &amp;g.VertexNodes[pickIdx];</div><div class="line"></div><div class="line">    <span class="comment">// update the current new extended path and the predecessor vertex</span></div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// visited to avoid repeatedly enqueue</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v-&gt;dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Dijkstra.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>基于 <a href="http://www.cplusplus.com/reference/queue/priority_queue/">std::priority_queue</a> 实现的 Dijkstra 算法（<strong>void Dijkstra(Graph&amp; g, VertexNode&amp; Source)</strong> 函数）<ul>
<li>由于使用了指针类型（<code>VertexNode*</code>）的优先级队列，需要声明额外的比较方法 <code>struct cmp</code>，重载其 <code>operator()</code>，并按以下方式声明：<code>priority_queue&lt;VertexNode*, vector&lt;VertexNode*&gt;, cmp&gt; vertexQueue;</code>，而不能通过直接重载优先级队列元素类型的比较函数 <code>operator&lt;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line"></div><div class="line">  <span class="comment">/*</div><div class="line">  bool operator&lt; (VertexNode* a, VertexNode* b) &#123;</div><div class="line">    return a-&gt;dist &gt; b-&gt;dist;</div><div class="line">  &#125;;*/</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/* compare struct for priority queue</div><div class="line"> * In order to achieve the minimum heap(in ascending order)</div><div class="line"> *   reload operator&lt;, redefine the priority to smaller one</div><div class="line"> */</span></div><div class="line"><span class="keyword">struct</span> cmp &#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(VertexNode* a, VertexNode* b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a-&gt;dist &gt; b-&gt;dist;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode*, <span class="built_in">vector</span>&lt;VertexNode*&gt;, cmp&gt; vertexQueue;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  vertexQueue.push(&amp;Source);</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode* v = vertexQueue.top();</div><div class="line">    <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; v-&gt;data &lt;&lt; " ";</span></div><div class="line">    vertexQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> vertexIdx = v - g.VertexNodes;</div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="comment">// cout &lt;&lt; "push: ";</span></div><div class="line">    <span class="comment">// relax operation: update the estimated distance for all adjacent vertex </span></div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span> </div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v-&gt;dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">        vertexQueue.push(&amp;g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">        <span class="comment">// cout &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; " ";</span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Dijkstra.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="comment">//freopen("BellmanFord.txt", "r", stdin);</span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">注意：</font><ul>
<li>基于优先级队列实现的 Dijkstra 算法，为了保证每次迭代均能够获取未知区域中距离源点最近的顶点，存在将一个节点重复入队的情况。当该节点被加入到已知区域时，这种重复入队保证其距离为最短距离；此后，队列中存在该节点的残留节点（距离不是最短距离）的可能，需要滤除这些残留节点。</li>
<li><strong>Dijkstra 算法</strong> 中，已知区域内的顶点距离确定是最短距离，因此不应由于新节点的加入而发生更新。对于正权图，不会对已知区域内的节点进行松弛操作；对于负权图，则可能发生，因此需要对松弛操作节点范围进行限制。<center><img src="/img/Algorithms/0006_DijkstraGraph.png" width="800px"/></center></li>
</ul>
</li>
<li>上图对应的输入文件 <code>Dijkstra.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">6 18</div><div class="line">S A B C D T</div><div class="line">0 1 1</div><div class="line">0 3 2</div><div class="line">0 4 5</div><div class="line">1 0 1</div><div class="line">1 2 2</div><div class="line">1 4 5</div><div class="line">2 1 2</div><div class="line">2 4 1</div><div class="line">2 5 4</div><div class="line">3 0 2</div><div class="line">3 4 3</div><div class="line">4 0 5</div><div class="line">4 1 5</div><div class="line">4 2 1</div><div class="line">4 3 3</div><div class="line">4 5 1</div><div class="line">5 2 4</div><div class="line">5 4 1</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>g++</code>进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ Dijkstra.cpp -o Dijkstra</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">更新：</font>基于优先级队列实现的 Dijkstra 算法存在问题，<code>priority_queue&lt;vertexnode*, vector&lt;vertexnode*=&quot;&quot;&gt;, cmp&gt; vertexQueue;</code> 优先级队列保存的是节点的指针，为了保证从队头都能取得距离源点距离最近的节点，同一个节点（不同的距离值）会被重复入队；然而由于存入的是指针，对即将入队的节点的松弛操作同样会影响到先前入队的同一个节点（不同的距离值），破坏了原先的优先队列顺序（可能是基于 heap 实现），造成优先级队列操作异常，故修正为如下代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">  <span class="comment">/* reload compare operator for priority queue</div><div class="line">   * In order to achieve the minimum heap(in ascending order)</div><div class="line">   *   reload operator&lt;, redefine the priority to smaller one</div><div class="line">   */</span></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> VertexNode&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> dist &gt; right.dist;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode&gt; vertexQueue;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="comment">// void push( const value_type&amp; value );</span></div><div class="line">  vertexQueue.push(Source);</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode v = vertexQueue.top();</div><div class="line">    <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; v.data &lt;&lt; " ";</span></div><div class="line">    vertexQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> vertexIdx = v.vertexIdx;</div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    adjVertexNode* head = v.<span class="built_in">list</span>;</div><div class="line">    <span class="comment">// cout &lt;&lt; "push: ";</span></div><div class="line">    <span class="comment">// relax operation: update the estimated distance for all adjacent vertex </span></div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span> </div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v.dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v.dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = &amp;g.VertexNodes[v.vertexIdx];</div><div class="line">        vertexQueue.push(g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">        <span class="comment">// cout &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; " ";</span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="https://www.renfei.org/blog/weighted-shortest-path.html">带权最短路 Dijkstra, SPFA, Bellman-Ford, ASP, Floyd-Warshall 算法分析</a></li>
</ul>
</blockquote>
<ul>
<li>查看从 <strong>s</strong> 到 <strong>t</strong> 的最短路径<br><center><img src="/img/Algorithms/0006_BellmanFordSketch.png" width="480px"/></center><ul>
<li>该路径最多含有 $|V|-1$ 条边。<ul>
<li>因为最短路径肯定是个简单路径，不可能包含回路的：如果包含回路，且回路的权值和为正的，那么去掉这个回路，可以得到更短的路径；如果回路的权值是负的，那么肯定没有解了</li>
<li>图有 $|V|$ 个点，又不能有回路，所以最短路径最多 $|V|-1$ 边</li>
</ul>
</li>
<li>如果执行的更新操作按照以下顺序 $(s, u_1), (u_, u_2), …, (u_k, t)$（更新序列） 进行（只要保证上述更新操作全部按顺序执行即可，并不要求上述更新操作是连续进行的），最终 t 的最短路径一定是正确的。<ul>
<li>最短路的局部最优性：中间即便穿插其它 update 操作，也不会影响最短路径。</li>
<li>其它 update 操作是否在这些边上进行无关紧要，同样，图上其它部分进行的 update 操作也不对上述最短路产生影响。</li>
<li>即，update 操作是安全的。</li>
</ul>
</li>
<li>Dijkstra 算法所运行的更新序列是经过选择的。<ul>
<li>选择基于这一假设：从起始点 <strong>s</strong> 到任意顶点 <strong>v</strong> 的最短路径一定会经过比 <strong>v</strong> 距离  <strong>s</strong> 更近的顶点。</li>
<li>当边的长度可以为负值时，这一假设将不再成立，如下图：从 S 到 A 的最短路径经过 B，而 B 却比 A 距离 S 更远！<center><img src="/img/Algorithms/0006_DijkstraNegativeEdge.png" width="200px"/></center></li>
</ul>
</li>
<li>为了求出负权图的最短路径，我们需要保证一个合理的更新序列。但是：我们预先并不知道所求的最短路径（如 <code>s-&gt;t</code>），因此不能确保按照正确的顺序更新了正确的边（$s→u_1, u_1→u_2, …, u_k→t$）<ul>
<li>解决方案：<strong>每次迭代更新所有的边</strong><ul>
<li>由于多余的更新操作总是无害的，因此算法（几乎）可以正确运行。</li>
<li>每条边更新 $|V|-1$ 次（任何含有 $|V|$ 个顶点的图两个点之间的最短路最多含有 $|V|-1$ 条边，每次迭代均能找到从起始点 <strong>s</strong> 出发的最短路上的一条边），时间复杂度为 $O(|V|·|E|)$</li>
<li>如果某次循环没有更新操作发生，后续的迭代也不会有更新操作，可以利用这一性质避免无效的计算。<center><img src="/img/Algorithms/0006_BellmanFordPseudo.png" width="640px"/></center></li>
</ul>
</li>
</ul>
</li>
<li>算法实现中唯一一个需要注意的问题就是负值圈 (negative-cost cycle)。<ul>
<li>负值圈指的是，权值总和为负的圈。如果存在这种圈，我们可以在里面滞留任意长而不断减小最短路径长，因此这种情况下最短路径是不存在的。</li>
<li>对于 Bellman-Ford 算法来说，判断负值圈存在的方法是：在 $|V|-1$ 次循环之后再执行一次循环，如果还有更新操作发生，则说明存在负值圈。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNum=<span class="number">0</span>; vertexNum&lt;=g.vertexNum; vertexNum++) &#123;</div><div class="line">    <span class="keyword">bool</span> updated = <span class="literal">false</span>;</div><div class="line">    <span class="comment">// update all edges</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> VertexIdx=<span class="number">0</span>; VertexIdx&lt;g.vertexNum; VertexIdx++) &#123;</div><div class="line">      adjVertexNode* head = g.VertexNodes[VertexIdx].<span class="built_in">list</span>;</div><div class="line">      <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(g.VertexNodes[VertexIdx].dist != INT_MAX</div><div class="line">          &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist &gt; (g.VertexNodes[VertexIdx].dist + head-&gt;weight)) &#123;</div><div class="line">          g.VertexNodes[head-&gt;adjVertexIdx].dist = g.VertexNodes[VertexIdx].dist + head-&gt;weight;</div><div class="line">          g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = &amp;g.VertexNodes[VertexIdx];</div><div class="line">          updated = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        head = head-&gt;next;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// shortest path got after any round which no update occurred</span></div><div class="line">    <span class="keyword">if</span>(!updated) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// negative cycles exist</span></div><div class="line">    <span class="keyword">if</span>(vertexNum == g.vertexNum &amp;&amp; updated) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// should never reach here</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    <span class="keyword">if</span>(!BellmanFord(g, g.VertexNodes[from])) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to find shortest path: negative cycles exist..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span> &lt;&lt; g.VertexNodes[to].dist &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于非负权图 Bellman-Ford 算法和 Dijkstra 算法都能得到相同的正确解。<center><img src="/img/Algorithms/0006_DijkstraGraph.png" width="800px"/></center><br><center><img src="/img/Algorithms/0006_BellmanFordGraph.png" width="720px"/></center></li>
<li>Dijkstra 算法难以处理负权图的最短路径问题，主要原因便是上面提到的前提假设不成立，比如，S 到 A 的最短路经过 $(S, G)$，然而 $|(S, A)| &lt; |(S, G)|$。 <center><img src="/img/Algorithms/0006_DijkstravsBellmanFord.png" width="720px"/></center></li>
<li>上图对应的输入文件 <code>BellmanFord.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">8 12</div><div class="line">S A B C D E F G</div><div class="line">0 1 7</div><div class="line">0 7 8</div><div class="line">1 5 2</div><div class="line">2 1 1</div><div class="line">2 3 1</div><div class="line">3 4 3</div><div class="line">4 5 -1</div><div class="line">5 2 -2</div><div class="line">6 1 -4</div><div class="line">6 5 -1</div><div class="line">7 6 1</div></pre></td></tr></table></figure>
<h4 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/gaochundong/p/floyd_warshall_algorithm.html">Floyd-Warshall 全源最短路径算法</a></li>
<li><a href="http://www.wutianqi.com/?p=1903">最短路径算法—Floyd(弗洛伊德)算法分析与实现(C/C++)</a></li>
<li><a href="https://www.renfei.org/blog/weighted-shortest-path.html">带权最短路 Dijkstra, SPFA, Bellman-Ford, ASP, Floyd-Warshall 算法分析</a></li>
</ul>
</blockquote>
<ul>
<li>解决单源最短路径问题的方案有 Dijkstra 算法和 Bellman-Ford 算法，对于全源最短路径问题（All-Pairs Shortest Paths Problem）可以认为是单源最短路径问题（Single Source Shortest Paths Problem）的推广，即分别以每个顶点作为源顶点并求其至其它顶点的最短距离（如运行<strong>Bellman-Ford 最短路径算法</strong>（由于可能存在负边），这样下来总的运行时间将是$O(|V|^2 E)$，事实上有一种稍好的选择，其运行时间为$O(|V|^3)$，正是本节介绍的基于动态规划的 <strong>Floyd-Warshall 算法</strong>）。</li>
<li>Floyd-Warshall 算法采用动态规划方案来解决在一个有向图（无向图可以转化为双向有向） G = (V, E) 上每对顶点间的最短路径问题，即全源最短路径问题，其中图 G 允许存在权值为负的边，但不存在权值为负的回路。</li>
<li>Floyd-Warshall <strong>算法思想</strong><ul>
<li>最短路径算法中的最优子结构：两顶点之间的最短路径包含路径上其它顶点的最短路径。<ul>
<li>具体描述为：对于给定的带权图 $G = (V, E)$，设 $p = \lt v_1, v_2, …,v_n \gt$ 是从 $v_1$ 到 $v_n$ 的最短路径，那么对于任意 i 和 j，$1≤i≤j≤n, p_{ij} (shortestPath(i, j, k)) = \lt v_i, v_{i+1}, …, v_j \gt$ 为 p 中从顶点 $v_i$ 到 $v_j$ 的一条子路径，那么 $p_{ij}$ 是顶点 $v_i$ 到 $v_j$ 的最短路径。</li>
</ul>
</li>
<li>从任意节点 i 到任意节点 j 的最短路径不外乎2种可能：①直接从 i 到 j；②从 i 经过若干个中间节点 k 到 j。<ul>
<li>dist(i, j, k)：从顶点 i 到 j 的仅使用节点 ${1, 2, …, k}$ 作为中间节点的最短路径长度。</li>
<li>$ dist(i, j, 0) = \begin{cases} |E(i, j)| \cr \infty, else \end{cases} $    </li>
<li>当我们在中间节点集中加入一个新的顶点 k 时，需要对所有的节点对 $(i，j)$ 检查是否使用 k 作为中间节点会得到更短的路径。$i → j $ 的使用了 k 和其它编号较小（＜k）的中间节点的最短路径最多经过 k 一次（假设没有负环），通过使用已经计算得到的 i 到 k 和 k 到 j 的使用了较小编号顶点的最短路径长度能够求解 $i → j $ 的最短路径长度。</li>
<li>$ shortestPath(i, j, k) = min(shortestPath(i, j, k-1), shortestPath(i, k, k-1) + shortestPath(k, j, k-1))$<center><img src="/img/Algorithms/0006_FloydSketch.png" width="540px"/></center></li>
</ul>
</li>
<li>Floyd-Warshall 算法的设计基于了如下观察。设带权图 G = (V, E) 中的所有顶点 V = {1, 2, . . . , n}，考虑一个顶点子集 {1, 2, . . . , k}。对于任意对顶点 i, j，考虑从顶点 i 到 j 的所有路径的中间顶点都来自该子集 {1, 2, . . . , k}，设 p 是该子集中的最短路径。Floyd-Warshall 算法描述了 p 与 i, j 间最短路径及中间顶点集合 {1, 2, . . . , k - 1} 的关系，该关系依赖于 k 是否是路径 p 上的一个中间顶点。<br><center><img src="/img/Algorithms/0006_FloydPseudo.png" width="720px"/></center><ul>
<li>①②：不允许路径 $i → j$ 上出现任何的中间节点；不存在直接连接 i 和 j 的边时，$dist(i, j, 0) = \infty$。</li>
<li>③：注意 k，i，j 三重循环的顺序，算法的时间复杂度为 $O(|V|^3)$；另外，$dist(?, ?, k)$ 只与 $dist(?, ?, k-1)$ 有关，使用二维数组即可维护只使用 {1, 2, …, k-1, k} 作为中间节点的最短距离信息，无需开辟三维空间，空间复杂度为 $O(|V|^2)$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 8(16)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FloydWarshall</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> dists[][MAX_VERTEX_NUM], <span class="keyword">int</span> paths[][MAX_VERTEX_NUM])</span> </span>&#123;</div><div class="line">  <span class="comment">// dists[i][j]=INT_MAX; dists[i][i]=0;</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;g.vertexNum; j++) &#123;</div><div class="line">      dists[i][j] = (i==j)? <span class="number">0</span>:INT_MAX;</div><div class="line">      paths[i][j] = j;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// edge&lt;i,j&gt; exists, update dists[i][j]=|edge&lt;i,j&gt;|</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> VertexIdx=<span class="number">0</span>; VertexIdx&lt;g.vertexNum; VertexIdx++) &#123;</div><div class="line">    adjVertexNode* head = g.VertexNodes[VertexIdx].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      dists[VertexIdx][head-&gt;adjVertexIdx] = head-&gt;weight;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;g.vertexNum; k++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;g.vertexNum; j++) &#123;</div><div class="line">        <span class="keyword">if</span>(dists[i][k] != INT_MAX &amp;&amp; dists[k][j] != INT_MAX</div><div class="line">          &amp;&amp; (dists[i][k] + dists[k][j]) &lt; dists[i][j]) &#123;</div><div class="line">          dists[i][j] = dists[i][k] + dists[k][j];</div><div class="line">          paths[i][j] = k;</div><div class="line">          <span class="comment">// negative cycle exists when and only when dists[i][i]&lt;0</span></div><div class="line">          <span class="keyword">if</span>(i == j &amp;&amp; dists[i][j] &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> paths[][MAX_VERTEX_NUM], <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> vertexIdx = fromIdx;</div><div class="line">  <span class="keyword">while</span>(vertexIdx != toIdx) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    vertexIdx = paths[vertexIdx][toIdx];</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[vertexIdx].data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> dists[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> paths[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">if</span>(!FloydWarshall(g, dists, paths)) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to find shortest path: negative cycles exist..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">        <span class="keyword">if</span>(from == to) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">          &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">        <span class="keyword">if</span>(dists[from][to] == INT_MAX) &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; dists[from][to];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">        PrintPath(g, paths, from, to);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>dists[][]</code> 数组初始化为各顶点间的原本距离（不存在直连边时距离为 $\infty$），最后存储各顶点间的最短距离。</li>
<li><code>paths[][]</code> 数组保存最短路径，与当前迭代的次数有关。初始化都为目标顶点下标，表示没有中间顶点。在求 <code>dists[i][j]</code> 过程中，<code>paths[i][j]</code> 存放从顶点$v_i$ 到顶点 $v_j$ 的中间顶点编号不大于 <code>k</code> 的最短路径上前一个结点的编号。在算法结束时，由二维数组 <code>paths</code> 的值回溯，可以得到从顶点 $v_i$ 到顶点 $v_j$ 的最短路径。</li>
<li>通过 <code>g++</code> 进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ FloydWarshall.cpp -o FloydWarshall</div></pre></td></tr></table></figure>
<ul>
<li><strong>Floyd-Warshall 算法</strong> 适用于非负权无向图<center><img src="/img/Algorithms/0006_FloydGraph.png" width="720px"/></center></li>
<li><strong>Floyd-Warshall 算法</strong> 同样适用于负权有向图<center><img src="/img/Algorithms/0006_FloydGraphNegative.png" width="720px"/></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文介绍几种常见的最短路径算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Breadth-first Search 无权最短路径算法；&lt;/li&gt;
&lt;li&gt;Dijkstra 带权（非负权）图的单源最短路算法；&lt;/li&gt;
&lt;li&gt;Bellman-Ford 带权（可负权）图的单源最短路算法；&lt;/li&gt;
&lt;li&gt;Floyd-Warshall 带权（可负权）图的全源最短路算法，&lt;br&gt;　包括它们各自的&lt;strong&gt;使用条件&amp;amp;范围&lt;/strong&gt;，&lt;strong&gt;算法原理介绍&lt;/strong&gt;以及&lt;strong&gt;代码实现&lt;/strong&gt;。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0005] Breadth First Search（广度优先搜索）</title>
    <link href="http://durant35.github.io/2017/03/22/Algorithms_BFS/"/>
    <id>http://durant35.github.io/2017/03/22/Algorithms_BFS/</id>
    <published>2017-03-22T06:00:22.000Z</published>
    <updated>2017-03-27T11:52:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>　本文主要介绍 <strong>BFS</strong> 的 <em>C++</em> 和 <em>C</em> 语言实现，并借助 <a href="https://leetcode.com/">LeetCode</a> 上的一道题，说说基本的 <strong>BFS</strong> 在问题求解中的应用。</p>
<h3 id="What’s-B-readth-F-irst-S-earch"><a href="#What’s-B-readth-F-irst-S-earch" class="headerlink" title="What’s B(readth)F(irst)S(earch)"></a>What’s B(readth)F(irst)S(earch)</h3><p>　广度优先搜索算法（Breadth First Search），又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。<br><a id="more"></a></p>
<p><center><img src="/img/Algorithms/0005_binarytree.png" width="480px"/></center><br>　如上图所示的二叉树，A 节点第一个访问的，然后顺序是 B、C，然后再是 D、E、F、G。</p>
<h3 id="BFS（C-）"><a href="#BFS（C-）" class="headerlink" title="BFS（C++）"></a>BFS（C++）</h3><ul>
<li><em>C++</em> 中借助队列数据结构来保证这个访问的顺序。由于队列是先进先出的顺序，因此可以先将左子树入队，然后再将右子树入队，这样一来，左子树结点就存在队头，可以先被访问到（<strong>void breadthFirstSearch(Tree root)</strong> ）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_NUM 15</span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ELEMENT data;</div><div class="line">    <span class="keyword">struct</span> Node* left;</div><div class="line">    <span class="keyword">struct</span> Node* right;</div><div class="line">&#125;* Tree;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Binary Tree Constructor</div><div class="line"> *  1. construct in preorder</div><div class="line"> *  2. '#' means no left child or right child</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeConstructor</span><span class="params">(Tree &amp;root, ELEMENT data[])</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(index &gt;= NODE_NUM) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ELEMENT ele = data[index++];</div><div class="line">    <span class="keyword">if</span>(ele == <span class="string">'#'</span>) &#123;</div><div class="line">        root = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        root-&gt;data = ele;</div><div class="line">        binaryTreeConstructor(root-&gt;left, data);</div><div class="line">        binaryTreeConstructor(root-&gt;right, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">breadthFirstSearch</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;Node *&gt; treeQueue;			<span class="comment">// using queue in STL</span></div><div class="line">    treeQueue.push(root);</div><div class="line">    Node* curNode;</div><div class="line">    <span class="keyword">while</span>(!treeQueue.empty()) &#123;</div><div class="line">        curNode = treeQueue.front();</div><div class="line">        treeQueue.pop();</div><div class="line">        <span class="built_in">printf</span>(FORMAT, curNode-&gt;data);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">            treeQueue.push(curNode-&gt;left);	<span class="comment">// push left child first</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">            treeQueue.push(curNode-&gt;right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ELEMENT data[NODE_NUM] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'E'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>,<span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'G'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>&#125;;</div><div class="line">    Tree tree;</div><div class="line">    binaryTreeConstructor(tree, data);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Traversal using BFS: "</span>);</div><div class="line">    breadthFirstSearch(tree);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ BFS.cpp -o BFS</div><div class="line">gary@xxx:xxx$ ./BFS </div><div class="line">Traversal using BFS: ABCDEFG</div></pre></td></tr></table></figure></p>
<h3 id="BFS（C）"><a href="#BFS（C）" class="headerlink" title="BFS（C）"></a>BFS（C）</h3><ul>
<li><em>C语言</em> 中采取类似的策略，不过需要手动实现一个队列功能（<strong>void bfs(Node tree[], int vertexIndex, bool visited[])</strong>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODENUM 7            	<span class="comment">// node number</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c "</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</div><div class="line"> </div><div class="line"><span class="comment">// structure for adjacency lists</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AdjList &#123;</div><div class="line">  <span class="keyword">int</span> vertexIndex;</div><div class="line">  <span class="keyword">struct</span> AdjList* next;</div><div class="line">&#125; AdjList;</div><div class="line"> </div><div class="line"><span class="comment">// Graphic node structure</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ELEMENT data;			<span class="comment">// data area</span></div><div class="line">  <span class="keyword">struct</span> AdjList* listAdj; 	<span class="comment">// pointing to neighbouring node</span></div><div class="line">&#125; Node;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="comment">// return the location of current vertex data in array, -1 if not exit. </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">char</span>, Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseBFS</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node[], <span class="keyword">int</span>, <span class="keyword">bool</span>[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  Node tree[NODENUM+<span class="number">1</span>];</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(createTree(tree)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"BFS result as follow:\n"</span>);</div><div class="line">    traverseBFS(tree);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"> </div><div class="line">    treeRelease(tree);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Create graphic fail!\n"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * 1. create a tree by entering all nodes' value and edges of the tree</div><div class="line"> * 2. store the tree in an adjacency list</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,location;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Input all nodes's value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    tree[i].data = getchar();</div><div class="line">    <span class="keyword">if</span>(tree[i].data &lt; <span class="string">'A'</span> || (tree[i].data &gt; <span class="string">'Z'</span> &amp;&amp; tree[i].data &lt; <span class="string">'a'</span>) || tree[i].data &gt; <span class="string">'z'</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Node's value should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// eliminate '\n'</span></div><div class="line">  getchar();</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nInput the directly connected nodes, given a node:\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NODENUM; i++) &#123;</div><div class="line">    <span class="built_in">putchar</span>(tree[i].data);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</div><div class="line">    c = getchar();</div><div class="line">    tree[i].listAdj = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>((location = locate(c, tree)) != <span class="number">-1</span>) &#123;</div><div class="line">      AdjList* newAdjVertex = (AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</div><div class="line">      newAdjVertex-&gt;vertexIndex = location;</div><div class="line">      newAdjVertex-&gt;next = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">      <span class="comment">// insert an adjacent node, as the head need to be dealt with separately </span></div><div class="line">      <span class="keyword">if</span>(tree[i].listAdj == <span class="literal">NULL</span>) &#123;</div><div class="line">        tree[i].listAdj = newAdjVertex;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        AdjList* temp = tree[i].listAdj;</div><div class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">          temp = temp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = newAdjVertex;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      <span class="comment">// '\n' will lead to exit</span></div><div class="line">      c = getchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the index of the given node in the node array, -1 if not exist.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(ELEMENT givenVal, Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> location;</div><div class="line">  <span class="keyword">for</span>(location = NODENUM<span class="number">-1</span>; location&gt;=<span class="number">0</span>; location--) &#123;</div><div class="line">    <span class="keyword">if</span>(tree[location].data == givenVal) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> location;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseBFS</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> visited[NODENUM];</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// need to traverse all nodes, avoid not-connected graph</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</div><div class="line">      bfs(tree, i, visited);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node tree[], <span class="keyword">int</span> vertexIndex, <span class="keyword">bool</span> visited[])</span> </span>&#123;</div><div class="line">  <span class="comment">/*</div><div class="line">   * 采用队列，访问一个节点并让其入队，然后按照同样的方法访问其兄弟节点，访问完毕</div><div class="line">   * 然后再从队列里按顺序再拉出一个节点来，继续访问</div><div class="line">   */</span></div><div class="line">  <span class="keyword">int</span> treeQueue[NODENUM];</div><div class="line">  <span class="keyword">int</span> popIdx=<span class="number">0</span>, pushIdx=<span class="number">0</span>;</div><div class="line">  AdjList *pAdjList;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">  visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line">  treeQueue[<span class="number">0</span>] = vertexIndex;			<span class="comment">// insert the first node</span></div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(popIdx &lt;= pushIdx) &#123;</div><div class="line">    vertexIndex = treeQueue[popIdx++];		<span class="comment">// pop one by one in the queue</span></div><div class="line">    pAdjList = tree[vertexIndex].listAdj;</div><div class="line">    <span class="keyword">while</span>(pAdjList != <span class="literal">NULL</span>) &#123;</div><div class="line">      vertexIndex = pAdjList-&gt;vertexIndex;</div><div class="line">      <span class="keyword">if</span>(!visited[vertexIndex]) &#123;</div><div class="line">        <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">        visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line">        treeQueue[++pushIdx] = vertexIndex;	<span class="comment">// push adjacent nodes into the queue </span></div><div class="line">      &#125;</div><div class="line">      pAdjList = pAdjList-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// reslease the dynamically allocated memory</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  AdjList *p, *temp;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    p = tree[i].listAdj;</div><div class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</div><div class="line">      temp = p;</div><div class="line">      p = p-&gt;next;</div><div class="line">      <span class="built_in">free</span>(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ BFS.c -o BFS</div><div class="line">gary@xxx:xxx$ ./BFS</div><div class="line">Input all nodes<span class="string">'s value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):</div><div class="line">ABCDEFG</div><div class="line"> </div><div class="line">Input the directly connected nodes, given a node:</div><div class="line">A BC</div><div class="line">B ADE</div><div class="line">C AFG</div><div class="line">D B</div><div class="line">E B</div><div class="line">F C</div><div class="line">G C</div><div class="line">BFS result as follow:</div><div class="line">A B C D E F G</span></div></pre></td></tr></table></figure></p>
<h3 id="102-amp-107-Binary-Tree-Level-Order-Traversal-I-amp-II"><a href="#102-amp-107-Binary-Tree-Level-Order-Traversal-I-amp-II" class="headerlink" title="102&amp;107. Binary Tree Level Order Traversal I&amp;II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/#/description">102&amp;107. Binary Tree Level Order Traversal I&amp;II</a></h3><ul>
<li>Description<blockquote>
<p>　Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>　For example:<br>　Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  <span class="number">3</span></div><div class="line"> / \</div><div class="line"><span class="number">9</span>  <span class="number">20</span></div><div class="line">  /  \</div><div class="line"> <span class="number">15</span>   <span class="number">7</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>　return its level order traversal as:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">   [<span class="number">3</span>],</div><div class="line">   [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">   [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>　即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">给定一个二叉树，返回按层级顺序遍历的每个节点的值。</div><div class="line"> </div><div class="line">从左到右，逐层遍历。</div><div class="line"> </div><div class="line">例如：</div><div class="line">给定一个二叉树 &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,#,#,<span class="number">15</span>,<span class="number">7</span>&#125;，</div><div class="line">    <span class="number">3</span></div><div class="line">   / \</div><div class="line">  <span class="number">9</span>  <span class="number">20</span></div><div class="line">    /  \</div><div class="line">   <span class="number">15</span>   <span class="number">7</span></div><div class="line">返回它的层级顺序遍历结果为：</div><div class="line">[</div><div class="line">  [<span class="number">3</span>],</div><div class="line">  [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">  [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div><div class="line"><span class="number">102</span>&amp;<span class="number">107</span> 都是这样的问题，只不过前者返回从上至下每一层的所有节点，后者则按照从下到上的顺序。</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>解题思路<ul>
<li>是一个典型的 <strong>BFS</strong> 遍历的问题，因为 <strong>BFS</strong> 遍历的过程就是一个按层由上至下访问的过程；问题的难点在于，如何区分哪些节点属于哪一层，然后，按照遍历顺序（已经是满足要求的从左到右的顺序），将节点的值插入到每一层对应的向量里面</li>
<li>一开始想到的方式是，<strong>BFS</strong> 遍历通过队列 <strong>queue</strong> 实现，基本的 <strong>BFS</strong> 遍历队列维护的只有节点，想要知道每个节点对应的深度，可以维护一个既包含节点又包含节点深度的队列，可以考虑使用 <strong>map</strong> 字典。</li>
</ul>
</li>
<li>Solution &amp; Analysis<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="comment">// pair's int for recording depth</span></div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; treeQueue;</div><div class="line">        treeQueue.push(make_pair(<span class="number">0</span>, root));</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!treeQueue.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> curDepth = treeQueue.front().first;</div><div class="line">            TreeNode* curNode = treeQueue.front().second;</div><div class="line">            treeQueue.pop();</div><div class="line">            </div><div class="line">            <span class="keyword">while</span>(result.size() &lt; curDepth+<span class="number">1</span>) &#123;</div><div class="line">                result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">            &#125;</div><div class="line">            result[curDepth].push_back(curNode-&gt;val);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">                treeQueue.push(make_pair(curDepth+<span class="number">1</span>, curNode-&gt;left));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">                treeQueue.push(make_pair(curDepth+<span class="number">1</span>, curNode-&gt;right));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　另外需要注意的是  <strong>Line: 27-29</strong>。一开始我们并不知道这个树有多少层，即 <strong>result</strong> 结果集的大小，可以利用 <strong>vector</strong> 自带的动态增长功能灵活检测。<br>　<strong>Accepted</strong>，不过耗时：6ms，感觉挺长的…</p>
<ul>
<li>问题 <strong>107</strong> 只需要将上述得到的结果集反转一下就可以了，可以直接使用 <code>&lt;algorithm&gt;</code> 库中的 <strong>reverse</strong> 函数直接调用（如下），不过耗时较大。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reverse(result.begin(), result.end());</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　使用自己实现的反转函数（如下）效率更高，提交信息号称快了 <strong>3ms</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderReverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> depth;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">        <span class="keyword">for</span>(depth=<span class="number">0</span>; depth&lt;result.size()/<span class="number">2</span>; depth++) &#123;</div><div class="line">            tmp = result[result.size()<span class="number">-1</span> - depth];</div><div class="line">            result[result.size()<span class="number">-1</span> - depth] = result[depth];</div><div class="line">            result[depth] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>其他思路的实现<br>　采用递归实现的 <strong>DFS</strong> 同样能获取树节点的分层信息。 在 <strong>DFS</strong> 的过程中可以直接记录一下当前递归到第几层，就可能找到当前节点对应着哪一行向量；为了满足在同一层中，所有节点按照从左到右的顺序排列，我们需要让遍历节点的顺序也同样满足先到左边子树的节点，再到右边子树的节点，可以通过先递归处理左子树，再处理右子树来实现。<br>　此外，与上面解答类似的，由于我们一开始并不知道整个子树的层数，所以需要根据当前的层数去动态结果集中每层节点对应的向量数量。<br>　代码实现起来比较简单，不过，由于频繁的递归调用，运行时间较长，耗时：<strong>9ms</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// dynamically increase the size of result</span></div><div class="line">        <span class="keyword">if</span> (result.size() &lt;= depth)&#123;</div><div class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// put current node's value into corresponding depth index</span></div><div class="line">        result[depth].push_back(root-&gt;val);</div><div class="line">        </div><div class="line">        <span class="comment">// recursive to child nodes, first left child, then right</span></div><div class="line">        dfs(root-&gt;left, depth+<span class="number">1</span>, result);</div><div class="line">        dfs(root-&gt;right, depth+<span class="number">1</span>, result);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        dfs(root, <span class="number">0</span>, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　下面这一种实现，思路则更加直接：假如每次循环都把上一层的所有节点的左右子树（假如存在）遍历一遍，则会把当前层中的所有节点也遍历一遍；遍历是从根节点出发的，按照这一思路进行迭代，每次循环中将当前循环遍历的当前层所有节点更新成上一层节点；先左子树后右子树以及从0开始遍历上一层的所有节点信息可以保证每一层的节点符合从左往右的顺序。<br>　这种方式，感觉每个节点都需要遍历两次（一次通过上一层节点左右子树的方式；一次为了遍历下一层节点所作的遍历），所以时间也比较长，耗时：<strong>6ms</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// record last-layer nodes</span></div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; lastDepth;</div><div class="line">        lastDepth.push_back(root);</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(lastDepth.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; curDepth;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lastDepth.size(); i++) &#123;</div><div class="line">                TreeNode* curNode = lastDepth[i];</div><div class="line">                tmp.push_back(curNode-&gt;val);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">                    curDepth.push_back(curNode-&gt;left);</div><div class="line">                &#125;</div><div class="line">                 <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">                    curDepth.push_back(curNode-&gt;right);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(tmp.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                result.push_back(tmp);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            lastDepth = curDepth;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　最后一种方法，利用这样一种特点：每一层所有节点的左右子树遍历完，则下一层的所有所有节点也被遍历一遍。使用队列这种数据结构实现 <strong>BFS</strong>，通过向队列中插入额外分割符作为实现层与层之间节点的区分，问题变成何时能够插入这样一个分隔符？这就用到上面的特点，即，当我从队列中取出一个分隔符时，说明上一层的所有节点已经从队列中取出，而且根据上一层所有节点遍历到的所有下一层的节点已经放入队列，因此，此时就需要插入一个分隔符。<br>　这种方法与普通的 <strong>BFS</strong> 遍历过程几乎一样，每个节点也只是遍历一遍（额外的分隔符其实并不多吧…），耗时最少：<strong>3ms</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</div><div class="line">    result.clear();</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; S;</div><div class="line">    S.push(root);</div><div class="line">    S.push(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="keyword">while</span>(!S.empty())&#123;</div><div class="line">      <span class="comment">// travesal current level</span></div><div class="line">      TreeNode* curNode = S.front();</div><div class="line">      S.pop();</div><div class="line">      <span class="keyword">if</span>(curNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        tmp.push_back(curNode-&gt;val);</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">          S.push(curNode-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">          S.push(curNode-&gt;right);</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(!tmp.empty()) &#123;	</div><div class="line">          S.push(<span class="literal">NULL</span>);</div><div class="line">          result.push_back(tmp);</div><div class="line">          tmp.clear();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　
　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文主要介绍 &lt;strong&gt;BFS&lt;/strong&gt; 的 &lt;em&gt;C++&lt;/em&gt; 和 &lt;em&gt;C&lt;/em&gt; 语言实现，并借助 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt; 上的一道题，说说基本的 &lt;strong&gt;BFS&lt;/strong&gt; 在问题求解中的应用。&lt;/p&gt;
&lt;h3 id=&quot;What’s-B-readth-F-irst-S-earch&quot;&gt;&lt;a href=&quot;#What’s-B-readth-F-irst-S-earch&quot; class=&quot;headerlink&quot; title=&quot;What’s B(readth)F(irst)S(earch)&quot;&gt;&lt;/a&gt;What’s B(readth)F(irst)S(earch)&lt;/h3&gt;&lt;p&gt;　广度优先搜索算法（Breadth First Search），又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0004] Depth First Search（深度优先搜索）</title>
    <link href="http://durant35.github.io/2017/03/15/Algorithms_DFS/"/>
    <id>http://durant35.github.io/2017/03/15/Algorithms_DFS/</id>
    <published>2017-03-15T06:00:22.000Z</published>
    <updated>2017-03-27T12:39:55.370Z</updated>
    
    <content type="html"><![CDATA[<p>　本文主要介绍 <strong>DFS</strong> 的 <em>C++</em> 和 <em>C</em> 语言实现，并借助 <a href="https://leetcode.com/">LeetCode</a> 上的一道题，说说基本的 <strong>DFS</strong> 在问题求解中的应用。</p>
<h3 id="What’s-D-epth-F-irst-S-earch"><a href="#What’s-D-epth-F-irst-S-earch" class="headerlink" title="What’s D(epth)F(irst)S(earch)"></a>What’s D(epth)F(irst)S(earch)</h3><p>　深度优先搜索算法（Depth First Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 <strong>N</strong> 的所有边都己被探寻过，搜索将回溯到发现节点 <strong>N</strong> 的那条边的起始节点，这一过程一直进行到已发现从源节点可达的所有节点为止。<br>　如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<br><a id="more"></a></p>
<p><center><img src="/img/Algorithms/0004_binarytree.png" width="480px"/></center><br>　如上图所示的二叉树，A 是第一个访问的，然后顺序是 B、D，然后是 E。接着再是 C、F、G。</p>
<h3 id="DFS（C-）"><a href="#DFS（C-）" class="headerlink" title="DFS（C++）"></a>DFS（C++）</h3><ul>
<li><em>C++</em> 中借助堆栈数据结构来保证这个访问的顺序。由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。这样一来，在遍历了根结点后，就开始遍历左子树，最后才是右子树（v<strong>oid depthFirstSearch(Tree root) </strong>）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DFS.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_NUM 15</span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ELEMENT data;</div><div class="line">    <span class="keyword">struct</span> Node* left;</div><div class="line">    <span class="keyword">struct</span> Node* right;</div><div class="line">&#125;* Tree;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Binary Tree Constructor</div><div class="line"> *  1. construct in preorder</div><div class="line"> *  2. '#' means no left child or right child</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeConstructor</span><span class="params">(Tree &amp;root, ELEMENT data[])</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(index &gt;= NODE_NUM) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ELEMENT ele = data[index++];</div><div class="line">    <span class="keyword">if</span>(ele == <span class="string">'#'</span>) &#123;</div><div class="line">        root = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        root-&gt;data = ele;</div><div class="line">        binaryTreeConstructor(root-&gt;left, data);</div><div class="line">        binaryTreeConstructor(root-&gt;right, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; treeStack;                    <span class="comment">// using stack in STL</span></div><div class="line">    treeStack.push(root);</div><div class="line">    Node* curNode;</div><div class="line">    <span class="keyword">while</span>(!treeStack.empty()) &#123;</div><div class="line">        curNode = treeStack.top();</div><div class="line">        treeStack.pop();</div><div class="line">        <span class="built_in">printf</span>(FORMAT, curNode-&gt;data);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">            treeStack.push(curNode-&gt;right);     <span class="comment">// push right child first</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">            treeStack.push(curNode-&gt;left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ELEMENT data[NODE_NUM] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'E'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>,<span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'G'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>&#125;;</div><div class="line">    Tree tree;</div><div class="line">    binaryTreeConstructor(tree, data);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Traversal using DFS: "</span>);</div><div class="line">    depthFirstSearch(tree);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ DFS.cpp -o DFS</div><div class="line">gary@xxx:xxx$ ./DFS</div><div class="line">Traversal using DFS: ABDECFG</div></pre></td></tr></table></figure></p>
<h3 id="DFS（C）"><a href="#DFS（C）" class="headerlink" title="DFS（C）"></a>DFS（C）</h3><ul>
<li><em>C语言</em> 中采取类似的策略，使用的是递归调用这个“堆栈”（<strong>void dfs(Node tree[], int vertexIndex, bool visited[])</strong>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DFS.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODENUM 7            	<span class="comment">// node number</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c "</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</div><div class="line"></div><div class="line"><span class="comment">// structure for adjacency lists</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AdjList &#123;</div><div class="line">  <span class="keyword">int</span> vertexIndex; </div><div class="line">  <span class="keyword">struct</span> AdjList* next;</div><div class="line">&#125; AdjList;</div><div class="line">  </div><div class="line"><span class="comment">// Graphic node structure</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ELEMENT data;			<span class="comment">// data area</span></div><div class="line">  <span class="keyword">struct</span> AdjList* listAdj; 	<span class="comment">// pointing to neighbouring node</span></div><div class="line">&#125; Node;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="comment">// return the location of current vertex data in array, -1 if not exit. </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">char</span>, Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseDFS</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node[], <span class="keyword">int</span>, <span class="keyword">bool</span>[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  Node tree[NODENUM+<span class="number">1</span>];</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(createTree(tree)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"DFS result as follow:\n"</span>);</div><div class="line">    traverseDFS(tree);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"> </div><div class="line">    treeRelease(tree);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Create graphic fail!\n"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * 1. create a tree by entering all nodes' value and edges of the tree</div><div class="line"> * 2. store the tree in an adjacency list</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,location;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Input all nodes's value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    tree[i].data = getchar();</div><div class="line">    <span class="keyword">if</span>(tree[i].data &lt; <span class="string">'A'</span> || (tree[i].data &gt; <span class="string">'Z'</span> &amp;&amp; tree[i].data &lt; <span class="string">'a'</span>) || tree[i].data &gt; <span class="string">'z'</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Node's value should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// eliminate '\n'</span></div><div class="line">  getchar();</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nInput the directly connected nodes, given a node:\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NODENUM; i++) &#123;</div><div class="line">    <span class="built_in">putchar</span>(tree[i].data);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</div><div class="line">    c = getchar();</div><div class="line">    tree[i].listAdj = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>((location = locate(c, tree)) != <span class="number">-1</span>) &#123;</div><div class="line">      AdjList* newAdjVertex = (AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</div><div class="line">      newAdjVertex-&gt;vertexIndex = location;</div><div class="line">      newAdjVertex-&gt;next = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">      <span class="comment">// insert an adjacent node, as the head need to be dealt with separately </span></div><div class="line">      <span class="keyword">if</span>(tree[i].listAdj == <span class="literal">NULL</span>) &#123;</div><div class="line">        tree[i].listAdj = newAdjVertex;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        AdjList* temp = tree[i].listAdj;</div><div class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">          temp = temp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = newAdjVertex;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      <span class="comment">// '\n' will lead to exit</span></div><div class="line">      c = getchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the index of the given node in the node array, -1 if not exist.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(ELEMENT givenVal, Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> location;</div><div class="line">  <span class="keyword">for</span>(location = NODENUM<span class="number">-1</span>; location&gt;=<span class="number">0</span>; location--) &#123;</div><div class="line">    <span class="keyword">if</span>(tree[location].data == givenVal) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> location;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseDFS</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> visited[NODENUM];</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// need to traverse all nodes, avoid not-connected graph</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</div><div class="line">      dfs(tree, i, visited);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node tree[], <span class="keyword">int</span> vertexIndex, <span class="keyword">bool</span> visited[])</span> </span>&#123;</div><div class="line">  AdjList *pAdjList;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">  visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">  pAdjList = tree[vertexIndex].listAdj;</div><div class="line">  <span class="keyword">while</span>(pAdjList != <span class="literal">NULL</span>) &#123;</div><div class="line">    vertexIndex = pAdjList-&gt;vertexIndex;</div><div class="line">    <span class="keyword">if</span>(!visited[vertexIndex]) &#123;</div><div class="line">      dfs(tree, vertexIndex, visited);</div><div class="line">    &#125;</div><div class="line">    pAdjList = pAdjList-&gt;next;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// reslease the dynamically allocated memory</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  AdjList *p, *temp;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    p = tree[i].listAdj;</div><div class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</div><div class="line">      temp = p;</div><div class="line">      p = p-&gt;next;</div><div class="line">      <span class="built_in">free</span>(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ DFS.c -o DFS</div><div class="line">gary@xxx:xxx$ ./DFS</div><div class="line">Input all nodes<span class="string">'s value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):</div><div class="line">ABCDEFG</div><div class="line"> </div><div class="line">Input the directly connected nodes, given a node:</div><div class="line">A BC</div><div class="line">B ADE</div><div class="line">C AFG</div><div class="line">D B</div><div class="line">E B</div><div class="line">F C</div><div class="line">G C</div><div class="line">DFS result as follow:</div><div class="line">A B D E C F G</span></div></pre></td></tr></table></figure></p>
<h3 id="112-amp-113-Path-Sum-I-amp-II"><a href="#112-amp-113-Path-Sum-I-amp-II" class="headerlink" title="112.&amp;113. Path Sum I&amp;II"></a><a href="https://leetcode.com/problems/path-sum/#/description">112.&amp;113. Path Sum I&amp;II</a></h3><ul>
<li>Description<blockquote>
<p>　Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>　For example:<br>　Given the below binary tree and sum = 22,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      <span class="number">5</span></div><div class="line">     / \</div><div class="line">    <span class="number">4</span>   <span class="number">8</span></div><div class="line">   /   / \</div><div class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line"> /  \      \</div><div class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>return true, as there exist a root-to-leaf path <strong>5-&gt;4-&gt;11-&gt;2</strong> which sum is 22.<br>　即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">给定一个二叉树root和一个和sum，</div><div class="line"> </div><div class="line">决定这个树是否存在一条从根到叶子的路径使得沿路所有节点的和等于给定的sum。</div><div class="line"> </div><div class="line">例如：</div><div class="line">给定如下二叉树和sum=<span class="number">22</span>，</div><div class="line">              <span class="number">5</span></div><div class="line">             / \</div><div class="line">            <span class="number">4</span>   <span class="number">8</span></div><div class="line">           /   / \</div><div class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line">         /  \      \</div><div class="line">        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div><div class="line">返回真，因为这里存在一条根叶路径（<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span>），它的和为<span class="number">22</span>。</div><div class="line"> </div><div class="line"><span class="number">112</span>&amp;<span class="number">113</span> 都是这样的问题，只不过前者只需要判断是否存在，后者则需要遍历所有节点以得到所有满足条件情况：</div><div class="line">　<span class="keyword">return</span></div><div class="line">　[</div><div class="line">   　[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</div><div class="line">   　[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">　]</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>解题思路<ul>
<li>是一个典型的 <strong>DFS</strong> 遍历的问题，因为需要遍历 <strong>root-&gt;leaf</strong> 这样一类路径，通过递归实现。</li>
<li>需要考虑的是在 path 上传递的变量（递归调用过程中传递的参数），<strong>问题 112</strong> 只需要传递 <strong>root-&gt;当前节点</strong> 的求和（这里通过 <strong>Sum</strong> 减去当前节点值的方式），如下：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. An empty tree</span></div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. A leaf, check sum</span></div><div class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> (root-&gt;val == sum);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. Not a leaf, recursive to a child node(|| for "exist")</span></div><div class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-(root-&gt;val)) || hasPathSum(root-&gt;right, sum-(root-&gt;val));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><strong>问题 113</strong> 除了传递 <strong>Sum</strong> 外，还需要传递 <strong>root-&gt;leaf</strong> 路径上的节点值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSet;</div><div class="line">        <span class="comment">// 1. An empty tree, return empty path Set</span></div><div class="line">        <span class="keyword">if</span>(root) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">            dfs(root, sum, path, pathSet);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> pathSet;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curPath, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pathSet)</span> </span>&#123;</div><div class="line">        curPath.push_back(root-&gt;val);</div><div class="line">        sum -= root-&gt;val;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. A leaf reached</span></div><div class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>) &#123;</div><div class="line">                pathSet.push_back(curPath);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. Recursive to a child node</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(root-&gt;left) &#123;</div><div class="line">                dfs(root-&gt;left, sum, curPath, pathSet);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</div><div class="line">                dfs(root-&gt;right, sum, curPath, pathSet);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// backtracking</span></div><div class="line">        curPath.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　此外还需要留意 <strong>backtracking</strong> 部分，因为对于 <strong>Sum</strong>，是一个形式参数，当递归函数返回时，不影响调用函数中的 <strong>Sum</strong>，但对于引用参数 <strong>curPath</strong> 就不一样了，因此，需要在递归函数返回前进行回溯，保证 <strong>curPath</strong> 始终记录 <strong>root-&gt;当前节点</strong> 路径上的节点值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文主要介绍 &lt;strong&gt;DFS&lt;/strong&gt; 的 &lt;em&gt;C++&lt;/em&gt; 和 &lt;em&gt;C&lt;/em&gt; 语言实现，并借助 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt; 上的一道题，说说基本的 &lt;strong&gt;DFS&lt;/strong&gt; 在问题求解中的应用。&lt;/p&gt;
&lt;h3 id=&quot;What’s-D-epth-F-irst-S-earch&quot;&gt;&lt;a href=&quot;#What’s-D-epth-F-irst-S-earch&quot; class=&quot;headerlink&quot; title=&quot;What’s D(epth)F(irst)S(earch)&quot;&gt;&lt;/a&gt;What’s D(epth)F(irst)S(earch)&lt;/h3&gt;&lt;p&gt;　深度优先搜索算法（Depth First Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 &lt;strong&gt;N&lt;/strong&gt; 的所有边都己被探寻过，搜索将回溯到发现节点 &lt;strong&gt;N&lt;/strong&gt; 的那条边的起始节点，这一过程一直进行到已发现从源节点可达的所有节点为止。&lt;br&gt;　如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0003] 一道阿里巴巴面试题（2017） </title>
    <link href="http://durant35.github.io/2017/03/10/Algorithms_An%20Alibaba%20Interview%20Question/"/>
    <id>http://durant35.github.io/2017/03/10/Algorithms_An Alibaba Interview Question/</id>
    <published>2017-03-10T06:00:22.000Z</published>
    <updated>2017-03-12T14:54:00.786Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。</p>
<p><center><img src="/img/Algorithms/0003_alibaba_2017.png" width="1024px"/></center><br><a id="more"></a></p>
<h4 id="转化问题1：求一个字符串中连续出现次数最多的子串"><a href="#转化问题1：求一个字符串中连续出现次数最多的子串" class="headerlink" title="转化问题1：求一个字符串中连续出现次数最多的子串"></a>转化问题1：求一个字符串中连续出现次数最多的子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">char</span> sub_str[<span class="number">2000</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_substr</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str);</div><div class="line">     <span class="keyword">int</span> i, j, k;</div><div class="line">     <span class="keyword">int</span> tmp_cnt = <span class="number">0</span>;</div><div class="line"> </div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i++) &#123;</div><div class="line">         <span class="keyword">for</span> (j = i+<span class="number">2</span>; j &lt; str_len; j++) &#123;</div><div class="line">             <span class="keyword">int</span> n = j-i;                                                     <span class="comment">//sub string length</span></div><div class="line">             tmp_cnt = <span class="number">1</span>;</div><div class="line">             <span class="keyword">if</span> (<span class="built_in">strncmp</span>(&amp;str[i], &amp;str[j], n) == <span class="number">0</span>) &#123;  <span class="comment">//compare n-lengths strings</span></div><div class="line">                 tmp_cnt++;                                             <span class="comment">//they are equal, so add count</span></div><div class="line">                 <span class="keyword">for</span> (k = j+n; k &lt; str_len; k += n) &#123;      <span class="comment">//consecutive checking</span></div><div class="line">                     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(&amp;str[i], &amp;str[k], n) == <span class="number">0</span>) &#123;</div><div class="line">                         tmp_cnt++;</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">else</span> &#123;</div><div class="line">                         <span class="keyword">break</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 <span class="keyword">if</span> (count &lt; tmp_cnt) &#123;</div><div class="line">                     count = tmp_cnt;</div><div class="line">                     <span class="built_in">memcpy</span>(sub_str, &amp;str[i], n);        <span class="comment">//record the sub string</span></div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">char</span> str[<span class="number">2000</span>];</div><div class="line">     <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</div><div class="line">     find_substr(str);</div><div class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, sub_str);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>对于连续出现的子串，我们可以以候选子串长度作为step</li>
<li>通过指定step长度的滑动窗口，统计候选子串出现的次数，并计数</li>
<li>维护出现次数最多的子串<h4 id="转化问题2：求一个字符串中出现次数最多的子串-不一定是连续的"><a href="#转化问题2：求一个字符串中出现次数最多的子串-不一定是连续的" class="headerlink" title="转化问题2：求一个字符串中出现次数最多的子串(不一定是连续的)"></a>转化问题2：求一个字符串中出现次数最多的子串(不一定是连续的)</h4>　假设存在一个长度为 N 的子串 S 出现的次数最多。那么它具有哪些特点呢？</li>
<li>S的任一子串的出现次数不少于 S 的出现次数 </li>
<li>S中不会出现重复的子串字符 </li>
<li>S中不会出现重复的字符 </li>
<li>组成 S 的每一个字符、每一个子串的出现次数都和 S 一样<br>　“S 中不会出现重复的字符”，“组成 S 的每一个字符、每一个子串的出现次数都和 S 一样”！有了这个结论，问题就简单了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mostTimesSubstring.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 1024</span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">deque</span>;</div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; strlist;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> npos = <span class="number">-1</span>;</div><div class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">ignoreChars</span><span class="params">(<span class="string">" /t/n/r"</span>)</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IgnoreChar</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (ignoreChars.find(c) != npos);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the max count</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">TextSummary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">unsigned</span> usecount[], <span class="keyword">int</span> Num4Chars)</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> max_count, i;</div><div class="line"> </div><div class="line">    <span class="built_in">memset</span>(usecount, <span class="number">0</span>, Num4Chars*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; text.length(); usecount[<span class="keyword">unsigned</span>(text[i++])]++);</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(max_count = i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(IgnoreChar(i)) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(usecount[i] &gt; max_count) max_count = usecount[i];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> max_count;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// check whether current substring splicing one more char also reach max count</span></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">StringTryGrowthOneChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> maxcount, <span class="keyword">unsigned</span>* usecount)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="built_in">string</span>::size_type pos;</div><div class="line">    <span class="keyword">char</span> c = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    pos = text.find(str);</div><div class="line">    <span class="keyword">if</span>(pos == npos)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// not the max count char</span></div><div class="line">    c = text[pos + str.length()];</div><div class="line">    <span class="keyword">if</span>(usecount[<span class="keyword">unsigned</span>(c)] &lt; maxcount)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// make sure every char in this growing substring also reach max count</span></div><div class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; pos + str.length() + <span class="number">1</span> &lt; text.length(); pos += str.length())&#123;</div><div class="line">        pos = text.find(str, pos);</div><div class="line">        <span class="keyword">if</span>(pos == npos) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(c != text[pos + str.length()]) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintResult</span><span class="params">(<span class="keyword">const</span> strlist&amp; result)</span></span>&#123;</div><div class="line">    strlist::const_iterator citer;</div><div class="line"> </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"The result substrings :"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(citer = result.begin(); citer != result.end(); citer++)&#123;</div><div class="line">        <span class="comment">// substring should longer than 2 chars</span></div><div class="line">        <span class="keyword">if</span>((*citer).length() &gt; <span class="number">1</span>)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'"'</span> &lt;&lt; *citer &lt;&lt; <span class="string">'"'</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total : "</span> &lt;&lt; result.size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> usecount[<span class="number">256</span>];</div><div class="line">    <span class="keyword">char</span> buffer[BUFFSIZE], c;</div><div class="line">    <span class="keyword">unsigned</span> count, i;</div><div class="line">    <span class="built_in">string</span> text;</div><div class="line">    strlist result;</div><div class="line"> </div><div class="line">    <span class="keyword">while</span>(!feof(<span class="built_in">stdin</span>))&#123;</div><div class="line">        <span class="keyword">if</span>(fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>))</div><div class="line">            text = buffer;</div><div class="line"> </div><div class="line">        <span class="comment">// Count the number of occurrences of characters</span></div><div class="line">        count = TextSummary(text, usecount, <span class="keyword">sizeof</span>(usecount)/<span class="keyword">sizeof</span>(*usecount));</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max count :"</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(<span class="number">1</span> &gt;= count)&#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No longest substring!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// result holds the substring reach max count</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(usecount)/<span class="keyword">sizeof</span>(*usecount); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(usecount[i] == count)</div><div class="line">                result.push_back(<span class="built_in">string</span>(<span class="number">1</span>, <span class="keyword">char</span>(i)));</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// substring growing for more substrings</span></div><div class="line">        <span class="keyword">for</span>(strlist::iterator iter = result.begin(); iter != result.end(); iter++)&#123;</div><div class="line">            c = StringTryGrowthOneChar(text, *iter, count, usecount);</div><div class="line">            <span class="keyword">if</span>(c)</div><div class="line">                result.push_back(*iter + <span class="built_in">string</span>(<span class="number">1</span>, c));</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        PrintResult(result);</div><div class="line">        result.clear();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>编译构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -o mostTimesSubstring mostTimesSubstring.cpp</div></pre></td></tr></table></figure></p>
<p>算法分析：</p>
<ul>
<li>找到文本中的出现次数最高的单个字符组成的子串，放入一个队列中</li>
<li>从队列的头部开始，对每一个子串 S 进行处理，找到文本中该子串出现的任意一个位置 P，判断文本中紧随 S 之后的字符 C 是否的出现次数是最多的<ul>
<li>如果 C 的出现次数不是最多的，结束。</li>
<li>如果 C 的出现次数是最多的，搜索文本中的每一个 S 并判断紧随其后的字符是否是 C <ul>
<li>如果文本中的每一个 S 之后都存在字符 C ，将 S + C 生成的子串放入结果集中</li>
<li>如果文本中出现 S 之后的字符不是 C ，结束。 </li>
</ul>
</li>
<li>如此，直至到达队列尾。</li>
</ul>
</li>
</ul>
<h4 id="回到这道面试题"><a href="#回到这道面试题" class="headerlink" title="回到这道面试题"></a>回到这道面试题</h4><ul>
<li>该题统计的是：子串出现次数与子串长度的乘积，问题是，是否这个乘积的最大值总是：（1）出现次数最多的；（2）长度最长的，显然不是</li>
<li>问题分析1：我们需要穷举所有子串并计数各自出现的次数，最终获取乘积最大的子串</li>
<li>问题分析2：能否不穷举，对上述算法进行变形？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0003_alibaba_2017.png&quot; width=&quot;1024px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
