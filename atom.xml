<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tarantula-7&#39;s Blog</title>
  <subtitle>My Body Knows It&#39;s Time to Say GoodBye... ---- Dear Basketball</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://durant35.github.io/"/>
  <updated>2017-05-02T08:15:24.066Z</updated>
  <id>http://durant35.github.io/</id>
  
  <author>
    <name>Tarantula-7</name>
    <email>1109197209@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法设计与分析[0010] Dynamic Programming(III)（动态规划）</title>
    <link href="http://durant35.github.io/2017/04/28/Algorithms_Dynamic%20Programming(III)/"/>
    <id>http://durant35.github.io/2017/04/28/Algorithms_Dynamic Programming(III)/</id>
    <published>2017-04-28T06:00:22.000Z</published>
    <updated>2017-05-02T08:15:24.066Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong><a href="https://leetcode.com/problems/longest-palindromic-subsequence/#/description"> 516. Longest Palindromic Subsequence </a></strong> 分析。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><ul>
<li>两道题解决的问题相似，都是求解给定序列中满足某种数学特征（和最大/乘积最大）的子序列，虽然不需要将该子序列输出。</li>
</ul>
<blockquote>
<p>Find the contiguous subarray within an array(containing at least one number) which has the largest sum/product.</p>
<ul>
<li>For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. </li>
<li>For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. </li>
</ul>
</blockquote>
<h4 id="516-Longest-Palindromic-Subsequence-解题思路"><a href="#516-Longest-Palindromic-Subsequence-解题思路" class="headerlink" title=" 516. Longest Palindromic Subsequence  解题思路"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/#/description"> 516. Longest Palindromic Subsequence </a> 解题思路</h4><ul>
<li>思路一：</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-subsequence/#/description&quot;&gt; 516. Longest Palindromic Subsequence &lt;/a&gt;&lt;/strong&gt; 分析。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0009] Dynamic Programming(II)（动态规划）</title>
    <link href="http://durant35.github.io/2017/04/23/Algorithms_Dynamic%20Programming(II)/"/>
    <id>http://durant35.github.io/2017/04/23/Algorithms_Dynamic Programming(II)/</id>
    <published>2017-04-23T06:00:22.000Z</published>
    <updated>2017-04-23T13:18:12.921Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong><a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> &amp; <a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a></strong> 分析根据动态规划思路进行问题求解中的一个关键环节：子问题的拆分和求解。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><ul>
<li>两道题解决的问题相似，都是求解给定序列中满足某种数学特征（和最大/乘积最大）的子序列，虽然不需要将该子序列输出。</li>
</ul>
<blockquote>
<p>Find the contiguous subarray within an array(containing at least one number) which has the largest sum/product.</p>
<ul>
<li>For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. </li>
<li>For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. </li>
</ul>
</blockquote>
<ul>
<li>留意的关键字眼是：<code>containing at least one number</code>，所以给定序列至少有一个元素，这也启发我们可以将其作为特殊处理。</li>
</ul>
<h4 id="53-Maximum-Subarray-解题思路"><a href="#53-Maximum-Subarray-解题思路" class="headerlink" title="53. Maximum Subarray 解题思路"></a><a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> 解题思路</h4><ul>
<li>思路一：$sums[j]$ 为序列前 j 个元素的最大子段和作为求解的子问题，则 $sum[n]$ 则为问题的答案。然而，如何利用 $sums[1, 2, …, j-1]$ 对 $sums[j]$ 进行求解呢？显然需要知道前 j 个元素的最大字段和的子段起始和终止位置，求解这个子问题的状态迁移显然比较复杂。</li>
<li>换一种思路。思路二：$sums[j]$ 为以第 j 个元素为结尾的子段的最大子段和作为求解的子问题，$max_{1 \leq j \leq n}(sums[j])$ 即为整个序列的最大子段和。而通过 $sums[j-1]$ 和当前元素 $nums[j]$ 即可计算以第 j 个元素为结尾的最大子段和 $sums[j]$，<code>状态转移方程</code> 如下：<br>$$ sums[j+1] = \begin{cases}  nums[j+1]　　　　　　sums[j] \lt 0 \cr sums[j] + nums[j+1]　others \end{cases}$$</li>
<li>根据思路二，<a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> 解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sums[SizeofNums];</div><div class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="comment">// sums[i]: The largest sum of subarray ending with the i-th element</span></div><div class="line">            sums[i] = sums[i<span class="number">-1</span>]&lt;<span class="number">0</span> ? nums[i] : sums[i<span class="number">-1</span>]+nums[i]; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// The largest sum of the whole array</span></div><div class="line">        <span class="keyword">int</span> largestSum = sums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(largestSum &lt; sums[i]) &#123;</div><div class="line">                largestSum = sums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>为了得到 <code>largestSum</code> 对应的子序列，我们可以通过变量 <code>startIdx</code> 记录以第 j 个元素结尾（<code>endIdx</code>）的最大子段和对应子序列的起始位置，$nums[startIdx, …, endIdx]$ 即为对应的子序列；另外，考虑到<strong>当前状态只与前一个状态有关</strong>，所以可以使用变量代替数组，节省内存，同时，避免获取<code>The largest sum of the whole array</code> 时的重复循环。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// largest sum for the subarray ending with current element </span></div><div class="line">        <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// largest sum of subarray for the whole array</span></div><div class="line">        <span class="keyword">int</span> largestSum = curSum;</div><div class="line">        <span class="comment">// subarray[startIdx, endIdx] with largest sum for the whole array</span></div><div class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>, endIdx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</div><div class="line">                curSum = nums[i];</div><div class="line">                startIdx = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                curSum = curSum + nums[i];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curSum &gt; largestSum) &#123;</div><div class="line">                largestSum = curSum;</div><div class="line">                endIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="152-Maximum-Product-Subarray-解题思路"><a href="#152-Maximum-Product-Subarray-解题思路" class="headerlink" title="152. Maximum Product Subarray 解题思路"></a><a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a> 解题思路</h4><ul>
<li>这一题的解题流程与上一题基本类似，但是要解决的关键问题是：状态转移，即如何根据上一个子问题（以第 j 个元素为结尾的子段的max product）的答案推算出当前子问题的结果。</li>
<li>从上一题的分析可以看出，当前子问题（以第 j 个元素为结尾的子段的max sum）的计算只需考虑上一个子问题的结果 $sum[j-1]$，$sum[j-1] &lt; 0$，因为是加法，显然可以将子问题结果忽略；$sum[j-1] &gt; 0$，$sum[j-1]$ 加上当前元素就是当前子问题的结果。</li>
<li>类似的问题，只不过换成乘积，子问题的求解就变得复杂了，需要考虑以下几种情况：<ul>
<li>当前元素是正数，max product可能是正正得正的情况，因为都是整数，乘积＞1，上一子问题的结果乘上当前元素即为当前子问题的答案</li>
<li>当前元素是负数，max product可能是负负得正的情况，因此需要维护以第 j 个元素为结尾的子段的min product（很大可能是负数）</li>
<li>另外，需要考虑上一个子问题的结果为0的情况</li>
<li>总之，乘积的最大值为上述三种情况之一<br>状态转移方程如下：<br>$$ maxProducts[j+1] = max(maxProducts[j-1]*nums[j], minProducts[j-1]*nums[j], nums[j])$$</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a> 解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The largest/least product of subarray ending with the i-th element</span></div><div class="line">        <span class="keyword">int</span> maxProducts[SizeofNums];</div><div class="line">        <span class="keyword">int</span> minProducts[SizeofNums];</div><div class="line">        maxProducts[<span class="number">0</span>] = minProducts[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="comment">// positive with positive, negative with negative, ignore previous zero</span></div><div class="line">            maxProducts[i] = max( max(maxProducts[i<span class="number">-1</span>]*nums[i], minProducts[i<span class="number">-1</span>]*nums[i]), nums[i]);</div><div class="line">            <span class="comment">// positive with negative, negative with positive, ignore previous zero</span></div><div class="line">            minProducts[i] = min( min(maxProducts[i<span class="number">-1</span>]*nums[i], minProducts[i<span class="number">-1</span>]*nums[i]), nums[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// getting the largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> largestProduct = maxProducts[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(maxProducts[i] &gt; largestProduct) &#123;</div><div class="line">                largestProduct = maxProducts[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestProduct;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>与上一题类似，添加额外变量，也能实现节省内存，记录子段最大乘积对应子段（$nums[startIdx, endIdx]$）的起始和终止位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The largest/least product of subarray ending with the i-th element</span></div><div class="line">        <span class="keyword">int</span> largestProduct = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> leastProduct = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// The largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> maxProduct = largestProduct;</div><div class="line">        <span class="comment">// subarray[startIdx, endIdx] with largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>, endIdx = <span class="number">0</span>;</div><div class="line">        <span class="comment">// start index for largestProduct/leastProduct</span></div><div class="line">        <span class="keyword">int</span> startIdx_pos = startIdx, startIdx_neg = startIdx;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">int</span> largestProduct_pre = largestProduct;</div><div class="line">            <span class="keyword">int</span> leastProduct_pre = leastProduct;</div><div class="line">            </div><div class="line">            <span class="comment">// positive with positive, negative with negative, ignore previous zero</span></div><div class="line">            largestProduct = max( max(largestProduct_pre*nums[i], leastProduct_pre*nums[i]), nums[i]);</div><div class="line">            <span class="keyword">if</span>((largestProduct_pre != nums[i]) &amp;&amp; (largestProduct == nums[i])) &#123;</div><div class="line">                startIdx_pos = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// positive with negative, negative with positive, ignore previous zero</span></div><div class="line">            leastProduct = min( min(largestProduct_pre*nums[i], leastProduct_pre*nums[i]), nums[i]);</div><div class="line">            <span class="keyword">if</span>((leastProduct_pre != nums[i]) &amp;&amp; (leastProduct == nums[i])) &#123;</div><div class="line">                startIdx_neg = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(largestProduct &gt; maxProduct) &#123;</div><div class="line">                maxProduct = largestProduct;</div><div class="line">                <span class="keyword">if</span>(largestProduct_pre*nums[i] &gt; leastProduct_pre*nums[i]) &#123;</div><div class="line">                    startIdx = startIdx_pos;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    startIdx = startIdx_neg;</div><div class="line">                &#125;</div><div class="line">                endIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> maxProduct;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/#/description&quot;&gt;53. Maximum Subarray&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode.com/problems/maximum-product-subarray/#/description&quot;&gt;152. Maximum Product Subarray&lt;/a&gt;&lt;/strong&gt; 分析根据动态规划思路进行问题求解中的一个关键环节：子问题的拆分和求解。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0008] Dynamic Programming(I)（动态规划）</title>
    <link href="http://durant35.github.io/2017/04/13/Algorithms_Dynamic%20Programming(I)/"/>
    <id>http://durant35.github.io/2017/04/13/Algorithms_Dynamic Programming(I)/</id>
    <published>2017-04-13T06:00:22.000Z</published>
    <updated>2017-04-18T08:36:19.306Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong>Unique Paths <a href="https://leetcode.com/problems/unique-paths/#/description">[I]</a> &amp; <a href="https://leetcode.com/problems/unique-paths-ii/#/description">[II]</a></strong> 两道题从普通的递归思路到动态规划两种方式的求解尝试，希望能够初步分析如何根据动态规划的思路，进行问题求解。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><p><center><img src="/img/Algorithms/0008_robot_maze.png" width="380px"/></center></p>
<ul>
<li>两道题解决的问题相似，都是求解从格网图左上角（Start）→ 右下角（Finish）可行的路径总数，而且行走方向只有向下或者向右移动两种方式，只是在以下两个地方存在一些区别：<ul>
<li><a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a> 行走的格网图不设立障碍，而 <a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 中行走的格网图存在障碍，在可行路径选取上需要考虑避开障碍物的问题。</li>
<li>由于上面的区别，导致在输入上两道题有所不同：前者只需要输入格网图的大小（#row*#column）；后者则需要提供格网图的0-1矩阵（1表示网格存在障碍物）</li>
</ul>
</li>
</ul>
<h4 id="递归思想解答"><a href="#递归思想解答" class="headerlink" title="递归思想解答"></a>递归思想解答</h4><ul>
<li>由于每一步的行走策略只有两种，不是向下走就是向右走，因此，假设当前这一步完成后到达右下角（#row，#column），那么只有（#row-1，#column）向下走和（#row，#column-1）向右走这两种方式，所以可行的路径总数显然就是从起点（1，1）到这两个中间点的可行路径总数之和。</li>
<li>按照上述的思路，很容易通过递归的方式最终会退到起点（递归基），并通过递归函数返回得到总的可行路径数目。</li>
<li>需要注意的一点是，由于每一步只有向右或者向下两种策略，所以，并不需要递归回起点（1，1），当回退到（1，？）或（？，1）时，从起点到当前中间点，有且只有一条路径（一直向右走或者一直想下走）。</li>
<li><a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a>  按照递归思路的解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// when m==1 or n==1, only directly down or directly right</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// left to right + up to down</span></div><div class="line">        <span class="keyword">return</span> uniquePaths(m, n<span class="number">-1</span>) + uniquePaths(m<span class="number">-1</span>, n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 则需要进一步考虑当前步是否可行的问题，倘若存在障碍物，显然此路不通，不应计入可行路径的统计，<code>return 0</code>。</li>
<li>另外，与 <a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a> 不同，只有回退到起点，才能判断通过递归历经的网格所构成的路径是可行的。因为，只是回退到（1，？）或（？，1），一旦起点到该中间点的<code>向右直走路径</code>或<code>向下直走路径</code>中间出现任何一个障碍物，该路径都是不可行的。</li>
<li>以下是递归解答，留意与前一道题目在输入上的区别。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// obstacleGrid[0][0] == 0</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// left to right</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m, n<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// up to down</span></div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m<span class="number">-1</span>, n);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// up to down + left to right</span></div><div class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m<span class="number">-1</span>, n) + uniquePathsWithObstacles(obstacleGrid, m, n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rowSize = obstacleGrid.size();</div><div class="line">        <span class="keyword">int</span> colSize = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        </div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>((colSize &lt; <span class="number">1</span>) || (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) || (obstacleGrid[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>] == <span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, rowSize, colSize);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">递归思路解答对上述问题并不可行</font><ul>
<li>我们都知道，直接的递归实现，可读性强，但频繁的函数调用会造成一定的时间损耗，因此上述两题都存在 <code>Time Limit Exceeded</code> 的错误。</li>
<li>另一个更为关键的问题是，上述简单的递归实现，每次递归的时候都对从起点到达当前中间网格的可行路径数进行了重复计算，这种重复计算的代价是巨大的，往往需要好几层回退；假如能够避免这种冗余，肯定会带来巨大的提升。</li>
</ul>
</li>
</ul>
<h4 id="动态规划思路解答"><a href="#动态规划思路解答" class="headerlink" title="动态规划思路解答"></a>动态规划思路解答</h4><ul>
<li>动态规划思路就能很好解决上述的问题：回退的方式不好避免重复计算的问题（可能需要维护从起点到达每个网格可行路径总数的表，另外通过是否为<code>Inf</code>避免重复计算，为了让每次递归均能访问操作该表，需要将其置为全局变量），我们干脆换个方向，从起点出发，直到到达右下角；动态规划的过程就像是在填上述这样一个表。</li>
<li>通过递归回退+维护从起点到达每个网格可行路径总数的表避免冗余计算的方式（记忆化搜索），因为只有在右下角到起点的可行路径上的网格才会被计算，能够避开其他不必要的网格；但是，函数的调用显然有一定损耗。</li>
<li>动态规划这种填表的思路，会将所有网格对应的表项填满，但这种顺序进行的操作实现简易（通过一个数组，两三层循环即可实现），耗时也较少，因此在大多数问题（动态规划多余的计算数目并不算多）下较记忆化搜索有一定优势。</li>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 的动态规划解答关键已经在递归思路中体现，即：从起点到当前网格的可行路径总数为到左方网格（向右移动到达当前网格）及上方网格（向下移动达到当前网格）可行路径总数之和。<ul>
<li>需要注意的是，从起点到（1，？）或（？，1）的可行路径显然都只有一条（一直向右移动/一直向下移动）。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> paths[m][n];</div><div class="line">        <span class="comment">// paths(1, 1...n), left to right</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;n; col++) &#123;</div><div class="line">            paths[<span class="number">0</span>][col] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// paths(1...n, 1), up to down</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;m; row++) &#123;</div><div class="line">            paths[row][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;m; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;n; col++) &#123;</div><div class="line">                <span class="comment">// left to right + up to down</span></div><div class="line">                paths[row][col] = paths[row][col<span class="number">-1</span>] + paths[row<span class="number">-1</span>][col];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> paths[m<span class="number">-1</span>][n<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 思路基本一致，只是当当前网格存在障碍物，其到起点的可行路径显然不存在。<ul>
<li>另外，对于从起点到（1，？）或（？，1）可行路径的分析与递归思路解答时一致。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rowSize = obstacleGrid.size();</div><div class="line">        <span class="keyword">int</span> colSize = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>((rowSize &lt; <span class="number">1</span>) || (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) || (obstacleGrid[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>] == <span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> paths[rowSize][colSize];</div><div class="line">        <span class="comment">// obstacleGrid[0][0] == 0 from above</span></div><div class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// paths(1, 1...n)</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;colSize; col++) &#123;</div><div class="line">            paths[<span class="number">0</span>][col] = obstacleGrid[<span class="number">0</span>][col]==<span class="number">0</span> ? paths[<span class="number">0</span>][col<span class="number">-1</span>] : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// paths(1...n, 1)</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            paths[row][<span class="number">0</span>] = obstacleGrid[row][<span class="number">0</span>]==<span class="number">0</span> ? paths[row<span class="number">-1</span>][<span class="number">0</span>] : <span class="number">0</span>;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;colSize; col++) &#123;</div><div class="line">                <span class="comment">// left to right + up to down</span></div><div class="line">                paths[row][col] = obstacleGrid[row][col]==<span class="number">0</span> ? (paths[row][col<span class="number">-1</span>] + paths[row<span class="number">-1</span>][col]) : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> paths[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;Unique Paths &lt;a href=&quot;https://leetcode.com/problems/unique-paths/#/description&quot;&gt;[I]&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode.com/problems/unique-paths-ii/#/description&quot;&gt;[II]&lt;/a&gt;&lt;/strong&gt; 两道题从普通的递归思路到动态规划两种方式的求解尝试，希望能够初步分析如何根据动态规划的思路，进行问题求解。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0007] Minimum Spanning Tree（最小生成树）</title>
    <link href="http://durant35.github.io/2017/04/06/Algorithms_Minimum%20Spanning%20Tree/"/>
    <id>http://durant35.github.io/2017/04/06/Algorithms_Minimum Spanning Tree/</id>
    <published>2017-04-06T06:00:22.000Z</published>
    <updated>2017-05-04T08:08:18.187Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。</p>
<p><center><img src="/img/Algorithms/0007_ExampleGraph.jpg" width="380px"/></center></p>
<p><center><img src="/img/Algorithms/0007_ExampleGraphMST.jpg" width="380px"/></center><br><a id="more"></a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0007_ExampleGraph.jpg&quot; width=&quot;380px&quot;/&gt;&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0007_ExampleGraphMST.jpg&quot; width=&quot;380px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0006] Some Shortest-path Algorithms（最短路径算法）</title>
    <link href="http://durant35.github.io/2017/03/29/Algorithms_Some%20Shortest-path%20Algorithms/"/>
    <id>http://durant35.github.io/2017/03/29/Algorithms_Some Shortest-path Algorithms/</id>
    <published>2017-03-29T06:00:22.000Z</published>
    <updated>2017-05-06T00:55:06.507Z</updated>
    
    <content type="html"><![CDATA[<p>　本文介绍几种常见的最短路径算法：</p>
<ul>
<li>Breadth-first Search 无权最短路径算法；</li>
<li>Dijkstra 带权（非负权）图的单源最短路算法；</li>
<li>Bellman-Ford 带权（可负权）图的单源最短路算法；</li>
<li>Floyd-Warshall 带权（可负权）图的全源最短路算法，<br>　包括它们各自的<strong>使用条件&amp;范围</strong>，<strong>算法原理介绍</strong>以及<strong>代码实现</strong>。<a id="more"></a>
</li>
</ul>
<h4 id="Breadth-first-Search-无权最短路径算法"><a href="#Breadth-first-Search-无权最短路径算法" class="headerlink" title="Breadth-first Search 无权最短路径算法"></a>Breadth-first Search 无权最短路径算法</h4><ul>
<li><strong>BFS</strong> 适合边的权值均是 1（无权图）的最短路径问题，因为，假设 S 为起始点，<strong>BFS</strong> 每次都会先发现距离 S 为 k 的所有顶点，然后才会发现距离 S 为 k+1 的所有顶点。<br><center><img src="/img/Algorithms/0006_BFSPseudo.png" width="640px"/></center><br>① 对于外面的<code>while</code>循环，会执行|V|次，因为每个顶点入队出队一次。<br>② <code>dist(v)==∞</code> 说明节点 v 还没被访问，将其放入队列并更新<code>dist</code>值。<br>③ 里面的<code>for</code>循环一共会执行|E|次，即变长，所以该算法时间复杂度为O(|V|+|E|)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="built_in">queue</span>&lt;VertexNode*&gt; vertexQueue;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  vertexQueue.push(&amp;Source);</div><div class="line">  <span class="keyword">while</span> (!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode* v = vertexQueue.front();</div><div class="line">    vertexQueue.pop();</div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (g.VertexNodes[head-&gt;adjVertexIdx].dist == INT_MAX) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + <span class="number">1</span>;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">        vertexQueue.push(&amp;g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"BFS.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(VertexNode) &lt;&lt; <span class="keyword">sizeof</span>(adjVertexNode*) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    BFS(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<center><img src="/img/Algorithms/0006_BFSGraph.png" width="640px"/></center>

<ul>
<li>忽略边的权值，该图对应的输入文件 <code>BFS.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">6 18</div><div class="line">S A B C D T</div><div class="line">0 1</div><div class="line">0 3</div><div class="line">0 4</div><div class="line">1 0</div><div class="line">1 2 </div><div class="line">1 4</div><div class="line">2 1</div><div class="line">2 4</div><div class="line">2 5</div><div class="line">3 0</div><div class="line">3 4</div><div class="line">4 0</div><div class="line">4 1</div><div class="line">4 2</div><div class="line">4 3</div><div class="line">4 5</div><div class="line">5 2</div><div class="line">5 4</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>g++</code>进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// -m32 option <span class="keyword">for</span> 32-bit execution</div><div class="line">g++ [-m32] BFS.cpp -o BFS</div></pre></td></tr></table></figure>
<p><a href="http://durant35.github.io/2017/03/22/Algorithms_BFS/#more">更多关于BFS算法的实现，可以点击阅读</a> </p>
<h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/skywang12345/p/3711512.html">Dijkstra算法(一)之 C语言详解</a></li>
<li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html">最短路径—Dijkstra算法和Floyd算法</a></li>
</ul>
</blockquote>
<center><img src="/img/Algorithms/0006_DijkstraDerivation.png" width="480px"/></center>

<ul>
<li>Dijkstra <strong>算法推导</strong><ul>
<li>已知区域<code>S</code> 是包含 s 的某个顶点子集。</li>
<li>关于当前最短路径有很多单边扩展路径，其中 <code>u→v</code> 是最短的一条。</li>
<li>上图中，s 到 v 的最短路径即为这样一条路径：基于一条已知的最短路径中的某条边（如上图<code>s→u</code>）的扩展路径。<ul>
<li>推导条件：假设无负权，u 一定比 v 距离 s 更近，这意味着 u 在已知区域 S 中，否则将与 <strong>v 是 S 之外且与 s 距离最近的顶点</strong> 这一假设相矛盾。</li>
</ul>
</li>
<li>检查当前已知最短路径集合 S 的所有单边扩展路径，找到这些扩展路径中的最短路径，该路径的另一个端点即为加入 S 的下一个顶点。</li>
<li>提高算法的执行效率：基于这样一个事实，在算法的任意迭代步骤中，仅有的新扩展路径是那些连接最近加入到 S 中的顶点的路径，其它所有路径的长度之前已经计算过，无需重新计算。</li>
</ul>
</li>
</ul>
<center><img src="/img/Algorithms/0006_DijkstraPseudo.png" width="880px"/></center>

<ul>
<li>Dijkstra <strong>算法思想</strong> ：<ul>
<li>左图：① <code>dist(v)</code>：指向 v 的当前最短单边扩展路径的长度（对于与 S 不相邻的顶点，取值为 ∞）；② 每次 while 循环迭代的末尾，（1）存在一个值 d，使得从 s 到 S 中所有顶点的距离 ≤d。同时 s 到 S 外的所有顶点的距离≥d；（2）对于每个顶点 v，dist(v) 表示一条从 s 到 v 的最短路径的长度，该路径经过的顶点均在 S 中（如果不存在这样的路径，dist 为 ∞）。</li>
<li>右图：设 <code>G=(V，E)</code> 是一个带权有向图（无向可以转化为双向有向），把图中顶点集合<code>V</code>分成两组，第一组为已求出最短路径的顶点集合（用<code>S</code>表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将其加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用<code>U</code>表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离， S 中的顶点的距离就是从 v 到此顶点的最短路径长度， U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。</li>
</ul>
</li>
<li>Dijkstra <strong>算法具体步骤</strong><br>  （1）初始时，S只包含源点，即S＝{v}，v的距离dist[v]为0。U包含除v外的其他顶点，U中顶点u距离dis[u]为边上的权值（若v与u有边）或 ∞（若u不是v的出边邻接点即没有边 <code>&lt;v→u&gt;</code>）。<br>  （2）从U中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离（dist[k]）就是 v 到 k 的最短路径长度）。<br>  （3）以 k 为新考虑的中间点，修改 <code>U</code> 中各顶点的距离（松弛操作）：若从源点v到顶点u（u∈ U）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值等于顶点k的距离加上边上的权（即如果 <code>dist[k]+w[k,u]&lt;dist[u]</code>，那么把dist[u]更新成更短的距离 <code>dist[k]+w[k,u]</code>）。<br>  （4）重复步骤（2）和（3）直到所有顶点都包含在 <code>S</code> 中(要循环n-1次)。</li>
<li>基于数组实现的 Dijkstra 算法（<strong>void Dijkstra(Graph&amp; g, VertexNode&amp; Source)</strong> 函数）<ul>
<li>总共需要循环 |V| 次（步骤（4）），实现将所有节点添加进已知区域 S。</li>
<li>每次循环，需要选取一个距离最小的顶点（步骤（2）），需要对所有节点进行遍历（$O(|V|)$）。</li>
<li>在循环执行的过程中，该循环为了更新距离（步骤（3）），需要访问每条边一次（有向图的情况）或两次（无向图的情况），从而花费了 $O(|E|)$ 的时间。</li>
<li>该算法的整体运行时间为：$O(|V|^2)$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNuminS = <span class="number">0</span>; vertexNuminS &lt; g.vertexNum; vertexNuminS++) &#123;</div><div class="line">    <span class="comment">// Pick the node not in S with smallest dist</span></div><div class="line">    <span class="keyword">int</span> minDist = INT_MAX;</div><div class="line">    <span class="keyword">int</span> pickIdx = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[i] &amp;&amp; g.VertexNodes[i].dist&lt;minDist) &#123;</div><div class="line">        minDist = g.VertexNodes[i].dist;</div><div class="line">        pickIdx = i;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// other nodes are unreachable</span></div><div class="line">    <span class="keyword">if</span>(pickIdx == <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    visited[pickIdx] = <span class="literal">true</span>;</div><div class="line">    VertexNode* v = &amp;g.VertexNodes[pickIdx];</div><div class="line"></div><div class="line">    <span class="comment">// update the current new extended path and the predecessor vertex</span></div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// visited to avoid repeatedly enqueue</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v-&gt;dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Dijkstra.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>基于 <a href="http://www.cplusplus.com/reference/queue/priority_queue/">std::priority_queue</a> 实现的 Dijkstra 算法（<strong>void Dijkstra(Graph&amp; g, VertexNode&amp; Source)</strong> 函数）<ul>
<li>由于使用了指针类型（<code>VertexNode*</code>）的优先级队列，需要声明额外的比较方法 <code>struct cmp</code>，重载其 <code>operator()</code>，并按以下方式声明：<code>priority_queue&lt;VertexNode*, vector&lt;VertexNode*&gt;, cmp&gt; vertexQueue;</code>，而不能通过直接重载优先级队列元素类型的比较函数 <code>operator&lt;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line"></div><div class="line">  <span class="comment">/*</div><div class="line">  bool operator&lt; (VertexNode* a, VertexNode* b) &#123;</div><div class="line">    return a-&gt;dist &gt; b-&gt;dist;</div><div class="line">  &#125;;*/</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/* compare struct for priority queue</div><div class="line"> * In order to achieve the minimum heap(in ascending order)</div><div class="line"> *   reload operator&lt;, redefine the priority to smaller one</div><div class="line"> */</span></div><div class="line"><span class="keyword">struct</span> cmp &#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(VertexNode* a, VertexNode* b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a-&gt;dist &gt; b-&gt;dist;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode*, <span class="built_in">vector</span>&lt;VertexNode*&gt;, cmp&gt; vertexQueue;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  vertexQueue.push(&amp;Source);</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode* v = vertexQueue.top();</div><div class="line">    <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; v-&gt;data &lt;&lt; " ";</span></div><div class="line">    vertexQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> vertexIdx = v - g.VertexNodes;</div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="comment">// cout &lt;&lt; "push: ";</span></div><div class="line">    <span class="comment">// relax operation: update the estimated distance for all adjacent vertex </span></div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span> </div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v-&gt;dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">        vertexQueue.push(&amp;g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">        <span class="comment">// cout &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; " ";</span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Dijkstra.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="comment">//freopen("BellmanFord.txt", "r", stdin);</span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">注意：</font><ul>
<li>基于优先级队列实现的 Dijkstra 算法，为了保证每次迭代均能够获取未知区域中距离源点最近的顶点，存在将一个节点重复入队的情况。当该节点被加入到已知区域时，这种重复入队保证其距离为最短距离；此后，队列中存在该节点的残留节点（距离不是最短距离）的可能，需要滤除这些残留节点。</li>
<li><strong>Dijkstra 算法</strong> 中，已知区域内的顶点距离确定是最短距离，因此不应由于新节点的加入而发生更新。对于正权图，不会对已知区域内的节点进行松弛操作；对于负权图，则可能发生，因此需要对松弛操作节点范围进行限制。<center><img src="/img/Algorithms/0006_DijkstraGraph.png" width="800px"/></center></li>
</ul>
</li>
<li>上图对应的输入文件 <code>Dijkstra.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">6 18</div><div class="line">S A B C D T</div><div class="line">0 1 1</div><div class="line">0 3 2</div><div class="line">0 4 5</div><div class="line">1 0 1</div><div class="line">1 2 2</div><div class="line">1 4 5</div><div class="line">2 1 2</div><div class="line">2 4 1</div><div class="line">2 5 4</div><div class="line">3 0 2</div><div class="line">3 4 3</div><div class="line">4 0 5</div><div class="line">4 1 5</div><div class="line">4 2 1</div><div class="line">4 3 3</div><div class="line">4 5 1</div><div class="line">5 2 4</div><div class="line">5 4 1</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>g++</code>进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ Dijkstra.cpp -o Dijkstra</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">更新：</font>基于优先级队列实现的 Dijkstra 算法存在问题，<code>priority_queue&lt;vertexnode*, vector&lt;vertexnode*=&quot;&quot;&gt;, cmp&gt; vertexQueue;</code> 优先级队列保存的是节点的指针，为了保证从队头都能取得距离源点距离最近的节点，同一个节点（不同的距离值）会被重复入队；然而由于存入的是指针，对即将入队的节点的松弛操作同样会影响到先前入队的同一个节点（不同的距离值），破坏了原先的优先队列顺序（可能是基于 heap 实现），造成优先级队列操作异常，故修正为如下代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">  <span class="comment">/* reload compare operator for priority queue</div><div class="line">   * In order to achieve the minimum heap(in ascending order)</div><div class="line">   *   reload operator&lt;, redefine the priority to smaller one</div><div class="line">   */</span></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> VertexNode&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> dist &gt; right.dist;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode&gt; vertexQueue;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="comment">// void push( const value_type&amp; value );</span></div><div class="line">  vertexQueue.push(Source);</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode v = vertexQueue.top();</div><div class="line">    <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; v.data &lt;&lt; " ";</span></div><div class="line">    vertexQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> vertexIdx = v.vertexIdx;</div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    adjVertexNode* head = v.<span class="built_in">list</span>;</div><div class="line">    <span class="comment">// cout &lt;&lt; "push: ";</span></div><div class="line">    <span class="comment">// relax operation: update the estimated distance for all adjacent vertex </span></div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span> </div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v.dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v.dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = &amp;g.VertexNodes[v.vertexIdx];</div><div class="line">        vertexQueue.push(g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">        <span class="comment">// cout &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; " ";</span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="https://www.renfei.org/blog/weighted-shortest-path.html">带权最短路 Dijkstra, SPFA, Bellman-Ford, ASP, Floyd-Warshall 算法分析</a></li>
</ul>
</blockquote>
<ul>
<li>查看从 <strong>s</strong> 到 <strong>t</strong> 的最短路径<br><center><img src="/img/Algorithms/0006_BellmanFordSketch.png" width="480px"/></center><ul>
<li>该路径最多含有 $|V|-1$ 条边。<ul>
<li>因为最短路径肯定是个简单路径，不可能包含回路的：如果包含回路，且回路的权值和为正的，那么去掉这个回路，可以得到更短的路径；如果回路的权值是负的，那么肯定没有解了</li>
<li>图有 $|V|$ 个点，又不能有回路，所以最短路径最多 $|V|-1$ 边</li>
</ul>
</li>
<li>如果执行的更新操作按照以下顺序 $(s, u_1), (u_, u_2), …, (u_k, t)$（更新序列） 进行（只要保证上述更新操作全部按顺序执行即可，并不要求上述更新操作是连续进行的），最终 t 的最短路径一定是正确的。<ul>
<li>最短路的局部最优性：中间即便穿插其它 update 操作，也不会影响最短路径。</li>
<li>其它 update 操作是否在这些边上进行无关紧要，同样，图上其它部分进行的 update 操作也不对上述最短路产生影响。</li>
<li>即，update 操作是安全的。</li>
</ul>
</li>
<li>Dijkstra 算法所运行的更新序列是经过选择的。<ul>
<li>选择基于这一假设：从起始点 <strong>s</strong> 到任意顶点 <strong>v</strong> 的最短路径一定会经过比 <strong>v</strong> 距离  <strong>s</strong> 更近的顶点。</li>
<li>当边的长度可以为负值时，这一假设将不再成立，如下图：从 S 到 A 的最短路径经过 B，而 B 却比 A 距离 S 更远！<center><img src="/img/Algorithms/0006_DijkstraNegativeEdge.png" width="200px"/></center></li>
</ul>
</li>
<li>为了求出负权图的最短路径，我们需要保证一个合理的更新序列。但是：我们预先并不知道所求的最短路径（如 <code>s-&gt;t</code>），因此不能确保按照正确的顺序更新了正确的边（$s→u_1, u_1→u_2, …, u_k→t$）<ul>
<li>解决方案：<strong>每次迭代更新所有的边</strong><ul>
<li>由于多余的更新操作总是无害的，因此算法（几乎）可以正确运行。</li>
<li>每条边更新 $|V|-1$ 次（任何含有 $|V|$ 个顶点的图两个点之间的最短路最多含有 $|V|-1$ 条边，每次迭代均能找到从起始点 <strong>s</strong> 出发的最短路上的一条边），时间复杂度为 $O(|V|·|E|)$</li>
<li>如果某次循环没有更新操作发生，后续的迭代也不会有更新操作，可以利用这一性质避免无效的计算。<center><img src="/img/Algorithms/0006_BellmanFordPseudo.png" width="640px"/></center></li>
</ul>
</li>
</ul>
</li>
<li>算法实现中唯一一个需要注意的问题就是负值圈 (negative-cost cycle)。<ul>
<li>负值圈指的是，权值总和为负的圈。如果存在这种圈，我们可以在里面滞留任意长而不断减小最短路径长，因此这种情况下最短路径是不存在的。</li>
<li>对于 Bellman-Ford 算法来说，判断负值圈存在的方法是：在 $|V|-1$ 次循环之后再执行一次循环，如果还有更新操作发生，则说明存在负值圈。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNum=<span class="number">0</span>; vertexNum&lt;=g.vertexNum; vertexNum++) &#123;</div><div class="line">    <span class="keyword">bool</span> updated = <span class="literal">false</span>;</div><div class="line">    <span class="comment">// update all edges</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> VertexIdx=<span class="number">0</span>; VertexIdx&lt;g.vertexNum; VertexIdx++) &#123;</div><div class="line">      adjVertexNode* head = g.VertexNodes[VertexIdx].<span class="built_in">list</span>;</div><div class="line">      <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(g.VertexNodes[VertexIdx].dist != INT_MAX</div><div class="line">          &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist &gt; (g.VertexNodes[VertexIdx].dist + head-&gt;weight)) &#123;</div><div class="line">          g.VertexNodes[head-&gt;adjVertexIdx].dist = g.VertexNodes[VertexIdx].dist + head-&gt;weight;</div><div class="line">          g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = &amp;g.VertexNodes[VertexIdx];</div><div class="line">          updated = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        head = head-&gt;next;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// shortest path got after any round which no update occurred</span></div><div class="line">    <span class="keyword">if</span>(!updated) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// negative cycles exist</span></div><div class="line">    <span class="keyword">if</span>(vertexNum == g.vertexNum &amp;&amp; updated) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// should never reach here</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    <span class="keyword">if</span>(!BellmanFord(g, g.VertexNodes[from])) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to find shortest path: negative cycles exist..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span> &lt;&lt; g.VertexNodes[to].dist &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于非负权图 Bellman-Ford 算法和 Dijkstra 算法都能得到相同的正确解。<center><img src="/img/Algorithms/0006_DijkstraGraph.png" width="800px"/></center><br><center><img src="/img/Algorithms/0006_BellmanFordGraph.png" width="720px"/></center></li>
<li>Dijkstra 算法难以处理负权图的最短路径问题，主要原因便是上面提到的前提假设不成立，比如，S 到 A 的最短路经过 $(S, G)$，然而 $|(S, A)| &lt; |(S, G)|$。 <center><img src="/img/Algorithms/0006_DijkstravsBellmanFord.png" width="720px"/></center></li>
<li>上图对应的输入文件 <code>BellmanFord.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">8 12</div><div class="line">S A B C D E F G</div><div class="line">0 1 7</div><div class="line">0 7 8</div><div class="line">1 5 2</div><div class="line">2 1 1</div><div class="line">2 3 1</div><div class="line">3 4 3</div><div class="line">4 5 -1</div><div class="line">5 2 -2</div><div class="line">6 1 -4</div><div class="line">6 5 -1</div><div class="line">7 6 1</div></pre></td></tr></table></figure>
<h4 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/gaochundong/p/floyd_warshall_algorithm.html">Floyd-Warshall 全源最短路径算法</a></li>
<li><a href="http://www.wutianqi.com/?p=1903">最短路径算法—Floyd(弗洛伊德)算法分析与实现(C/C++)</a></li>
<li><a href="https://www.renfei.org/blog/weighted-shortest-path.html">带权最短路 Dijkstra, SPFA, Bellman-Ford, ASP, Floyd-Warshall 算法分析</a></li>
</ul>
</blockquote>
<ul>
<li>解决单源最短路径问题的方案有 Dijkstra 算法和 Bellman-Ford 算法，对于全源最短路径问题（All-Pairs Shortest Paths Problem）可以认为是单源最短路径问题（Single Source Shortest Paths Problem）的推广，即分别以每个顶点作为源顶点并求其至其它顶点的最短距离（如运行<strong>Bellman-Ford 最短路径算法</strong>（由于可能存在负边），这样下来总的运行时间将是$O(|V|^2 E)$，事实上有一种稍好的选择，其运行时间为$O(|V|^3)$，正是本节介绍的基于动态规划的 <strong>Floyd-Warshall 算法</strong>）。</li>
<li>Floyd-Warshall 算法采用动态规划方案来解决在一个有向图（无向图可以转化为双向有向） G = (V, E) 上每对顶点间的最短路径问题，即全源最短路径问题，其中图 G 允许存在权值为负的边，但不存在权值为负的回路。</li>
<li>Floyd-Warshall <strong>算法思想</strong><ul>
<li>最短路径算法中的最优子结构：两顶点之间的最短路径包含路径上其它顶点的最短路径。<ul>
<li>具体描述为：对于给定的带权图 $G = (V, E)$，设 $p = \lt v_1, v_2, …,v_n \gt$ 是从 $v_1$ 到 $v_n$ 的最短路径，那么对于任意 i 和 j，$1≤i≤j≤n, p_{ij} (shortestPath(i, j, k)) = \lt v_i, v_{i+1}, …, v_j \gt$ 为 p 中从顶点 $v_i$ 到 $v_j$ 的一条子路径，那么 $p_{ij}$ 是顶点 $v_i$ 到 $v_j$ 的最短路径。</li>
</ul>
</li>
<li>从任意节点 i 到任意节点 j 的最短路径不外乎2种可能：①直接从 i 到 j；②从 i 经过若干个中间节点 k 到 j。<ul>
<li>dist(i, j, k)：从顶点 i 到 j 的仅使用节点 ${1, 2, …, k}$ 作为中间节点的最短路径长度。</li>
<li>$ dist(i, j, 0) = \begin{cases} |E(i, j)| \cr \infty, else \end{cases} $    </li>
<li>当我们在中间节点集中加入一个新的顶点 k 时，需要对所有的节点对 $(i，j)$ 检查是否使用 k 作为中间节点会得到更短的路径。$i → j $ 的使用了 k 和其它编号较小（＜k）的中间节点的最短路径最多经过 k 一次（假设没有负环），通过使用已经计算得到的 i 到 k 和 k 到 j 的使用了较小编号顶点的最短路径长度能够求解 $i → j $ 的最短路径长度。</li>
<li>$ shortestPath(i, j, k) = min(shortestPath(i, j, k-1), shortestPath(i, k, k-1) + shortestPath(k, j, k-1))$<center><img src="/img/Algorithms/0006_FloydSketch.png" width="540px"/></center></li>
</ul>
</li>
<li>Floyd-Warshall 算法的设计基于了如下观察。设带权图 G = (V, E) 中的所有顶点 V = {1, 2, . . . , n}，考虑一个顶点子集 {1, 2, . . . , k}。对于任意对顶点 i, j，考虑从顶点 i 到 j 的所有路径的中间顶点都来自该子集 {1, 2, . . . , k}，设 p 是该子集中的最短路径。Floyd-Warshall 算法描述了 p 与 i, j 间最短路径及中间顶点集合 {1, 2, . . . , k - 1} 的关系，该关系依赖于 k 是否是路径 p 上的一个中间顶点。<br><center><img src="/img/Algorithms/0006_FloydPseudo.png" width="720px"/></center><ul>
<li>①②：不允许路径 $i → j$ 上出现任何的中间节点；不存在直接连接 i 和 j 的边时，$dist(i, j, 0) = \infty$。</li>
<li>③：注意 k，i，j 三重循环的顺序，算法的时间复杂度为 $O(|V|^3)$；另外，$dist(?, ?, k)$ 只与 $dist(?, ?, k-1)$ 有关，使用二维数组即可维护只使用 {1, 2, …, k-1, k} 作为中间节点的最短距离信息，无需开辟三维空间，空间复杂度为 $O(|V|^2)$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 8(16)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FloydWarshall</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> dists[][MAX_VERTEX_NUM], <span class="keyword">int</span> paths[][MAX_VERTEX_NUM])</span> </span>&#123;</div><div class="line">  <span class="comment">// dists[i][j]=INT_MAX; dists[i][i]=0;</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;g.vertexNum; j++) &#123;</div><div class="line">      dists[i][j] = (i==j)? <span class="number">0</span>:INT_MAX;</div><div class="line">      paths[i][j] = j;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// edge&lt;i,j&gt; exists, update dists[i][j]=|edge&lt;i,j&gt;|</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> VertexIdx=<span class="number">0</span>; VertexIdx&lt;g.vertexNum; VertexIdx++) &#123;</div><div class="line">    adjVertexNode* head = g.VertexNodes[VertexIdx].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      dists[VertexIdx][head-&gt;adjVertexIdx] = head-&gt;weight;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;g.vertexNum; k++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;g.vertexNum; j++) &#123;</div><div class="line">        <span class="keyword">if</span>(dists[i][k] != INT_MAX &amp;&amp; dists[k][j] != INT_MAX</div><div class="line">          &amp;&amp; (dists[i][k] + dists[k][j]) &lt; dists[i][j]) &#123;</div><div class="line">          dists[i][j] = dists[i][k] + dists[k][j];</div><div class="line">          paths[i][j] = k;</div><div class="line">          <span class="comment">// negative cycle exists when and only when dists[i][i]&lt;0</span></div><div class="line">          <span class="keyword">if</span>(i == j &amp;&amp; dists[i][j] &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> paths[][MAX_VERTEX_NUM], <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> vertexIdx = fromIdx;</div><div class="line">  <span class="keyword">while</span>(vertexIdx != toIdx) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    vertexIdx = paths[vertexIdx][toIdx];</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[vertexIdx].data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> dists[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> paths[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">if</span>(!FloydWarshall(g, dists, paths)) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to find shortest path: negative cycles exist..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">        <span class="keyword">if</span>(from == to) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">          &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">        <span class="keyword">if</span>(dists[from][to] == INT_MAX) &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; dists[from][to];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">        PrintPath(g, paths, from, to);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>dists[][]</code> 数组初始化为各顶点间的原本距离（不存在直连边时距离为 $\infty$），最后存储各顶点间的最短距离。</li>
<li><code>paths[][]</code> 数组保存最短路径，与当前迭代的次数有关。初始化都为目标顶点下标，表示没有中间顶点。在求 <code>dists[i][j]</code> 过程中，<code>paths[i][j]</code> 存放从顶点$v_i$ 到顶点 $v_j$ 的中间顶点编号不大于 <code>k</code> 的最短路径上前一个结点的编号。在算法结束时，由二维数组 <code>paths</code> 的值回溯，可以得到从顶点 $v_i$ 到顶点 $v_j$ 的最短路径。</li>
<li>通过 <code>g++</code> 进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ FloydWarshall.cpp -o FloydWarshall</div></pre></td></tr></table></figure>
<ul>
<li><strong>Floyd-Warshall 算法</strong> 适用于非负权无向图<center><img src="/img/Algorithms/0006_FloydGraph.png" width="720px"/></center></li>
<li><strong>Floyd-Warshall 算法</strong> 同样适用于负权有向图<center><img src="/img/Algorithms/0006_FloydGraphNegative.png" width="720px"/></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文介绍几种常见的最短路径算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Breadth-first Search 无权最短路径算法；&lt;/li&gt;
&lt;li&gt;Dijkstra 带权（非负权）图的单源最短路算法；&lt;/li&gt;
&lt;li&gt;Bellman-Ford 带权（可负权）图的单源最短路算法；&lt;/li&gt;
&lt;li&gt;Floyd-Warshall 带权（可负权）图的全源最短路算法，&lt;br&gt;　包括它们各自的&lt;strong&gt;使用条件&amp;amp;范围&lt;/strong&gt;，&lt;strong&gt;算法原理介绍&lt;/strong&gt;以及&lt;strong&gt;代码实现&lt;/strong&gt;。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0005] Breadth First Search（广度优先搜索）</title>
    <link href="http://durant35.github.io/2017/03/22/Algorithms_BFS/"/>
    <id>http://durant35.github.io/2017/03/22/Algorithms_BFS/</id>
    <published>2017-03-22T06:00:22.000Z</published>
    <updated>2017-03-27T11:52:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>　本文主要介绍 <strong>BFS</strong> 的 <em>C++</em> 和 <em>C</em> 语言实现，并借助 <a href="https://leetcode.com/">LeetCode</a> 上的一道题，说说基本的 <strong>BFS</strong> 在问题求解中的应用。</p>
<h3 id="What’s-B-readth-F-irst-S-earch"><a href="#What’s-B-readth-F-irst-S-earch" class="headerlink" title="What’s B(readth)F(irst)S(earch)"></a>What’s B(readth)F(irst)S(earch)</h3><p>　广度优先搜索算法（Breadth First Search），又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。<br><a id="more"></a></p>
<p><center><img src="/img/Algorithms/0005_binarytree.png" width="480px"/></center><br>　如上图所示的二叉树，A 节点第一个访问的，然后顺序是 B、C，然后再是 D、E、F、G。</p>
<h3 id="BFS（C-）"><a href="#BFS（C-）" class="headerlink" title="BFS（C++）"></a>BFS（C++）</h3><ul>
<li><em>C++</em> 中借助队列数据结构来保证这个访问的顺序。由于队列是先进先出的顺序，因此可以先将左子树入队，然后再将右子树入队，这样一来，左子树结点就存在队头，可以先被访问到（<strong>void breadthFirstSearch(Tree root)</strong> ）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_NUM 15</span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ELEMENT data;</div><div class="line">    <span class="keyword">struct</span> Node* left;</div><div class="line">    <span class="keyword">struct</span> Node* right;</div><div class="line">&#125;* Tree;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Binary Tree Constructor</div><div class="line"> *  1. construct in preorder</div><div class="line"> *  2. '#' means no left child or right child</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeConstructor</span><span class="params">(Tree &amp;root, ELEMENT data[])</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(index &gt;= NODE_NUM) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ELEMENT ele = data[index++];</div><div class="line">    <span class="keyword">if</span>(ele == <span class="string">'#'</span>) &#123;</div><div class="line">        root = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        root-&gt;data = ele;</div><div class="line">        binaryTreeConstructor(root-&gt;left, data);</div><div class="line">        binaryTreeConstructor(root-&gt;right, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">breadthFirstSearch</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;Node *&gt; treeQueue;			<span class="comment">// using queue in STL</span></div><div class="line">    treeQueue.push(root);</div><div class="line">    Node* curNode;</div><div class="line">    <span class="keyword">while</span>(!treeQueue.empty()) &#123;</div><div class="line">        curNode = treeQueue.front();</div><div class="line">        treeQueue.pop();</div><div class="line">        <span class="built_in">printf</span>(FORMAT, curNode-&gt;data);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">            treeQueue.push(curNode-&gt;left);	<span class="comment">// push left child first</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">            treeQueue.push(curNode-&gt;right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ELEMENT data[NODE_NUM] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'E'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>,<span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'G'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>&#125;;</div><div class="line">    Tree tree;</div><div class="line">    binaryTreeConstructor(tree, data);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Traversal using BFS: "</span>);</div><div class="line">    breadthFirstSearch(tree);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ BFS.cpp -o BFS</div><div class="line">gary@xxx:xxx$ ./BFS </div><div class="line">Traversal using BFS: ABCDEFG</div></pre></td></tr></table></figure></p>
<h3 id="BFS（C）"><a href="#BFS（C）" class="headerlink" title="BFS（C）"></a>BFS（C）</h3><ul>
<li><em>C语言</em> 中采取类似的策略，不过需要手动实现一个队列功能（<strong>void bfs(Node tree[], int vertexIndex, bool visited[])</strong>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODENUM 7            	<span class="comment">// node number</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c "</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</div><div class="line"> </div><div class="line"><span class="comment">// structure for adjacency lists</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AdjList &#123;</div><div class="line">  <span class="keyword">int</span> vertexIndex;</div><div class="line">  <span class="keyword">struct</span> AdjList* next;</div><div class="line">&#125; AdjList;</div><div class="line"> </div><div class="line"><span class="comment">// Graphic node structure</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ELEMENT data;			<span class="comment">// data area</span></div><div class="line">  <span class="keyword">struct</span> AdjList* listAdj; 	<span class="comment">// pointing to neighbouring node</span></div><div class="line">&#125; Node;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="comment">// return the location of current vertex data in array, -1 if not exit. </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">char</span>, Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseBFS</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node[], <span class="keyword">int</span>, <span class="keyword">bool</span>[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  Node tree[NODENUM+<span class="number">1</span>];</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(createTree(tree)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"BFS result as follow:\n"</span>);</div><div class="line">    traverseBFS(tree);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"> </div><div class="line">    treeRelease(tree);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Create graphic fail!\n"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * 1. create a tree by entering all nodes' value and edges of the tree</div><div class="line"> * 2. store the tree in an adjacency list</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,location;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Input all nodes's value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    tree[i].data = getchar();</div><div class="line">    <span class="keyword">if</span>(tree[i].data &lt; <span class="string">'A'</span> || (tree[i].data &gt; <span class="string">'Z'</span> &amp;&amp; tree[i].data &lt; <span class="string">'a'</span>) || tree[i].data &gt; <span class="string">'z'</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Node's value should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// eliminate '\n'</span></div><div class="line">  getchar();</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nInput the directly connected nodes, given a node:\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NODENUM; i++) &#123;</div><div class="line">    <span class="built_in">putchar</span>(tree[i].data);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</div><div class="line">    c = getchar();</div><div class="line">    tree[i].listAdj = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>((location = locate(c, tree)) != <span class="number">-1</span>) &#123;</div><div class="line">      AdjList* newAdjVertex = (AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</div><div class="line">      newAdjVertex-&gt;vertexIndex = location;</div><div class="line">      newAdjVertex-&gt;next = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">      <span class="comment">// insert an adjacent node, as the head need to be dealt with separately </span></div><div class="line">      <span class="keyword">if</span>(tree[i].listAdj == <span class="literal">NULL</span>) &#123;</div><div class="line">        tree[i].listAdj = newAdjVertex;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        AdjList* temp = tree[i].listAdj;</div><div class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">          temp = temp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = newAdjVertex;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      <span class="comment">// '\n' will lead to exit</span></div><div class="line">      c = getchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the index of the given node in the node array, -1 if not exist.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(ELEMENT givenVal, Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> location;</div><div class="line">  <span class="keyword">for</span>(location = NODENUM<span class="number">-1</span>; location&gt;=<span class="number">0</span>; location--) &#123;</div><div class="line">    <span class="keyword">if</span>(tree[location].data == givenVal) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> location;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseBFS</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> visited[NODENUM];</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// need to traverse all nodes, avoid not-connected graph</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</div><div class="line">      bfs(tree, i, visited);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node tree[], <span class="keyword">int</span> vertexIndex, <span class="keyword">bool</span> visited[])</span> </span>&#123;</div><div class="line">  <span class="comment">/*</div><div class="line">   * 采用队列，访问一个节点并让其入队，然后按照同样的方法访问其兄弟节点，访问完毕</div><div class="line">   * 然后再从队列里按顺序再拉出一个节点来，继续访问</div><div class="line">   */</span></div><div class="line">  <span class="keyword">int</span> treeQueue[NODENUM];</div><div class="line">  <span class="keyword">int</span> popIdx=<span class="number">0</span>, pushIdx=<span class="number">0</span>;</div><div class="line">  AdjList *pAdjList;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">  visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line">  treeQueue[<span class="number">0</span>] = vertexIndex;			<span class="comment">// insert the first node</span></div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(popIdx &lt;= pushIdx) &#123;</div><div class="line">    vertexIndex = treeQueue[popIdx++];		<span class="comment">// pop one by one in the queue</span></div><div class="line">    pAdjList = tree[vertexIndex].listAdj;</div><div class="line">    <span class="keyword">while</span>(pAdjList != <span class="literal">NULL</span>) &#123;</div><div class="line">      vertexIndex = pAdjList-&gt;vertexIndex;</div><div class="line">      <span class="keyword">if</span>(!visited[vertexIndex]) &#123;</div><div class="line">        <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">        visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line">        treeQueue[++pushIdx] = vertexIndex;	<span class="comment">// push adjacent nodes into the queue </span></div><div class="line">      &#125;</div><div class="line">      pAdjList = pAdjList-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// reslease the dynamically allocated memory</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  AdjList *p, *temp;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    p = tree[i].listAdj;</div><div class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</div><div class="line">      temp = p;</div><div class="line">      p = p-&gt;next;</div><div class="line">      <span class="built_in">free</span>(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ BFS.c -o BFS</div><div class="line">gary@xxx:xxx$ ./BFS</div><div class="line">Input all nodes<span class="string">'s value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):</div><div class="line">ABCDEFG</div><div class="line"> </div><div class="line">Input the directly connected nodes, given a node:</div><div class="line">A BC</div><div class="line">B ADE</div><div class="line">C AFG</div><div class="line">D B</div><div class="line">E B</div><div class="line">F C</div><div class="line">G C</div><div class="line">BFS result as follow:</div><div class="line">A B C D E F G</span></div></pre></td></tr></table></figure></p>
<h3 id="102-amp-107-Binary-Tree-Level-Order-Traversal-I-amp-II"><a href="#102-amp-107-Binary-Tree-Level-Order-Traversal-I-amp-II" class="headerlink" title="102&amp;107. Binary Tree Level Order Traversal I&amp;II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/#/description">102&amp;107. Binary Tree Level Order Traversal I&amp;II</a></h3><ul>
<li>Description<blockquote>
<p>　Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>　For example:<br>　Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  <span class="number">3</span></div><div class="line"> / \</div><div class="line"><span class="number">9</span>  <span class="number">20</span></div><div class="line">  /  \</div><div class="line"> <span class="number">15</span>   <span class="number">7</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>　return its level order traversal as:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">   [<span class="number">3</span>],</div><div class="line">   [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">   [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>　即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">给定一个二叉树，返回按层级顺序遍历的每个节点的值。</div><div class="line"> </div><div class="line">从左到右，逐层遍历。</div><div class="line"> </div><div class="line">例如：</div><div class="line">给定一个二叉树 &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,#,#,<span class="number">15</span>,<span class="number">7</span>&#125;，</div><div class="line">    <span class="number">3</span></div><div class="line">   / \</div><div class="line">  <span class="number">9</span>  <span class="number">20</span></div><div class="line">    /  \</div><div class="line">   <span class="number">15</span>   <span class="number">7</span></div><div class="line">返回它的层级顺序遍历结果为：</div><div class="line">[</div><div class="line">  [<span class="number">3</span>],</div><div class="line">  [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">  [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div><div class="line"><span class="number">102</span>&amp;<span class="number">107</span> 都是这样的问题，只不过前者返回从上至下每一层的所有节点，后者则按照从下到上的顺序。</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>解题思路<ul>
<li>是一个典型的 <strong>BFS</strong> 遍历的问题，因为 <strong>BFS</strong> 遍历的过程就是一个按层由上至下访问的过程；问题的难点在于，如何区分哪些节点属于哪一层，然后，按照遍历顺序（已经是满足要求的从左到右的顺序），将节点的值插入到每一层对应的向量里面</li>
<li>一开始想到的方式是，<strong>BFS</strong> 遍历通过队列 <strong>queue</strong> 实现，基本的 <strong>BFS</strong> 遍历队列维护的只有节点，想要知道每个节点对应的深度，可以维护一个既包含节点又包含节点深度的队列，可以考虑使用 <strong>map</strong> 字典。</li>
</ul>
</li>
<li>Solution &amp; Analysis<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="comment">// pair's int for recording depth</span></div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; treeQueue;</div><div class="line">        treeQueue.push(make_pair(<span class="number">0</span>, root));</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!treeQueue.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> curDepth = treeQueue.front().first;</div><div class="line">            TreeNode* curNode = treeQueue.front().second;</div><div class="line">            treeQueue.pop();</div><div class="line">            </div><div class="line">            <span class="keyword">while</span>(result.size() &lt; curDepth+<span class="number">1</span>) &#123;</div><div class="line">                result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">            &#125;</div><div class="line">            result[curDepth].push_back(curNode-&gt;val);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">                treeQueue.push(make_pair(curDepth+<span class="number">1</span>, curNode-&gt;left));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">                treeQueue.push(make_pair(curDepth+<span class="number">1</span>, curNode-&gt;right));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　另外需要注意的是  <strong>Line: 27-29</strong>。一开始我们并不知道这个树有多少层，即 <strong>result</strong> 结果集的大小，可以利用 <strong>vector</strong> 自带的动态增长功能灵活检测。<br>　<strong>Accepted</strong>，不过耗时：6ms，感觉挺长的…</p>
<ul>
<li>问题 <strong>107</strong> 只需要将上述得到的结果集反转一下就可以了，可以直接使用 <code>&lt;algorithm&gt;</code> 库中的 <strong>reverse</strong> 函数直接调用（如下），不过耗时较大。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reverse(result.begin(), result.end());</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　使用自己实现的反转函数（如下）效率更高，提交信息号称快了 <strong>3ms</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderReverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> depth;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">        <span class="keyword">for</span>(depth=<span class="number">0</span>; depth&lt;result.size()/<span class="number">2</span>; depth++) &#123;</div><div class="line">            tmp = result[result.size()<span class="number">-1</span> - depth];</div><div class="line">            result[result.size()<span class="number">-1</span> - depth] = result[depth];</div><div class="line">            result[depth] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>其他思路的实现<br>　采用递归实现的 <strong>DFS</strong> 同样能获取树节点的分层信息。 在 <strong>DFS</strong> 的过程中可以直接记录一下当前递归到第几层，就可能找到当前节点对应着哪一行向量；为了满足在同一层中，所有节点按照从左到右的顺序排列，我们需要让遍历节点的顺序也同样满足先到左边子树的节点，再到右边子树的节点，可以通过先递归处理左子树，再处理右子树来实现。<br>　此外，与上面解答类似的，由于我们一开始并不知道整个子树的层数，所以需要根据当前的层数去动态结果集中每层节点对应的向量数量。<br>　代码实现起来比较简单，不过，由于频繁的递归调用，运行时间较长，耗时：<strong>9ms</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// dynamically increase the size of result</span></div><div class="line">        <span class="keyword">if</span> (result.size() &lt;= depth)&#123;</div><div class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// put current node's value into corresponding depth index</span></div><div class="line">        result[depth].push_back(root-&gt;val);</div><div class="line">        </div><div class="line">        <span class="comment">// recursive to child nodes, first left child, then right</span></div><div class="line">        dfs(root-&gt;left, depth+<span class="number">1</span>, result);</div><div class="line">        dfs(root-&gt;right, depth+<span class="number">1</span>, result);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        dfs(root, <span class="number">0</span>, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　下面这一种实现，思路则更加直接：假如每次循环都把上一层的所有节点的左右子树（假如存在）遍历一遍，则会把当前层中的所有节点也遍历一遍；遍历是从根节点出发的，按照这一思路进行迭代，每次循环中将当前循环遍历的当前层所有节点更新成上一层节点；先左子树后右子树以及从0开始遍历上一层的所有节点信息可以保证每一层的节点符合从左往右的顺序。<br>　这种方式，感觉每个节点都需要遍历两次（一次通过上一层节点左右子树的方式；一次为了遍历下一层节点所作的遍历），所以时间也比较长，耗时：<strong>6ms</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// record last-layer nodes</span></div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; lastDepth;</div><div class="line">        lastDepth.push_back(root);</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(lastDepth.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; curDepth;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lastDepth.size(); i++) &#123;</div><div class="line">                TreeNode* curNode = lastDepth[i];</div><div class="line">                tmp.push_back(curNode-&gt;val);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">                    curDepth.push_back(curNode-&gt;left);</div><div class="line">                &#125;</div><div class="line">                 <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">                    curDepth.push_back(curNode-&gt;right);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(tmp.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                result.push_back(tmp);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            lastDepth = curDepth;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　最后一种方法，利用这样一种特点：每一层所有节点的左右子树遍历完，则下一层的所有所有节点也被遍历一遍。使用队列这种数据结构实现 <strong>BFS</strong>，通过向队列中插入额外分割符作为实现层与层之间节点的区分，问题变成何时能够插入这样一个分隔符？这就用到上面的特点，即，当我从队列中取出一个分隔符时，说明上一层的所有节点已经从队列中取出，而且根据上一层所有节点遍历到的所有下一层的节点已经放入队列，因此，此时就需要插入一个分隔符。<br>　这种方法与普通的 <strong>BFS</strong> 遍历过程几乎一样，每个节点也只是遍历一遍（额外的分隔符其实并不多吧…），耗时最少：<strong>3ms</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</div><div class="line">    result.clear();</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; S;</div><div class="line">    S.push(root);</div><div class="line">    S.push(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="keyword">while</span>(!S.empty())&#123;</div><div class="line">      <span class="comment">// travesal current level</span></div><div class="line">      TreeNode* curNode = S.front();</div><div class="line">      S.pop();</div><div class="line">      <span class="keyword">if</span>(curNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        tmp.push_back(curNode-&gt;val);</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">          S.push(curNode-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">          S.push(curNode-&gt;right);</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(!tmp.empty()) &#123;	</div><div class="line">          S.push(<span class="literal">NULL</span>);</div><div class="line">          result.push_back(tmp);</div><div class="line">          tmp.clear();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　
　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文主要介绍 &lt;strong&gt;BFS&lt;/strong&gt; 的 &lt;em&gt;C++&lt;/em&gt; 和 &lt;em&gt;C&lt;/em&gt; 语言实现，并借助 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt; 上的一道题，说说基本的 &lt;strong&gt;BFS&lt;/strong&gt; 在问题求解中的应用。&lt;/p&gt;
&lt;h3 id=&quot;What’s-B-readth-F-irst-S-earch&quot;&gt;&lt;a href=&quot;#What’s-B-readth-F-irst-S-earch&quot; class=&quot;headerlink&quot; title=&quot;What’s B(readth)F(irst)S(earch)&quot;&gt;&lt;/a&gt;What’s B(readth)F(irst)S(earch)&lt;/h3&gt;&lt;p&gt;　广度优先搜索算法（Breadth First Search），又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0004] Depth First Search（深度优先搜索）</title>
    <link href="http://durant35.github.io/2017/03/15/Algorithms_DFS/"/>
    <id>http://durant35.github.io/2017/03/15/Algorithms_DFS/</id>
    <published>2017-03-15T06:00:22.000Z</published>
    <updated>2017-03-27T12:39:55.370Z</updated>
    
    <content type="html"><![CDATA[<p>　本文主要介绍 <strong>DFS</strong> 的 <em>C++</em> 和 <em>C</em> 语言实现，并借助 <a href="https://leetcode.com/">LeetCode</a> 上的一道题，说说基本的 <strong>DFS</strong> 在问题求解中的应用。</p>
<h3 id="What’s-D-epth-F-irst-S-earch"><a href="#What’s-D-epth-F-irst-S-earch" class="headerlink" title="What’s D(epth)F(irst)S(earch)"></a>What’s D(epth)F(irst)S(earch)</h3><p>　深度优先搜索算法（Depth First Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 <strong>N</strong> 的所有边都己被探寻过，搜索将回溯到发现节点 <strong>N</strong> 的那条边的起始节点，这一过程一直进行到已发现从源节点可达的所有节点为止。<br>　如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<br><a id="more"></a></p>
<p><center><img src="/img/Algorithms/0004_binarytree.png" width="480px"/></center><br>　如上图所示的二叉树，A 是第一个访问的，然后顺序是 B、D，然后是 E。接着再是 C、F、G。</p>
<h3 id="DFS（C-）"><a href="#DFS（C-）" class="headerlink" title="DFS（C++）"></a>DFS（C++）</h3><ul>
<li><em>C++</em> 中借助堆栈数据结构来保证这个访问的顺序。由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。这样一来，在遍历了根结点后，就开始遍历左子树，最后才是右子树（v<strong>oid depthFirstSearch(Tree root) </strong>）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DFS.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_NUM 15</span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ELEMENT data;</div><div class="line">    <span class="keyword">struct</span> Node* left;</div><div class="line">    <span class="keyword">struct</span> Node* right;</div><div class="line">&#125;* Tree;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Binary Tree Constructor</div><div class="line"> *  1. construct in preorder</div><div class="line"> *  2. '#' means no left child or right child</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeConstructor</span><span class="params">(Tree &amp;root, ELEMENT data[])</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(index &gt;= NODE_NUM) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ELEMENT ele = data[index++];</div><div class="line">    <span class="keyword">if</span>(ele == <span class="string">'#'</span>) &#123;</div><div class="line">        root = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        root-&gt;data = ele;</div><div class="line">        binaryTreeConstructor(root-&gt;left, data);</div><div class="line">        binaryTreeConstructor(root-&gt;right, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; treeStack;                    <span class="comment">// using stack in STL</span></div><div class="line">    treeStack.push(root);</div><div class="line">    Node* curNode;</div><div class="line">    <span class="keyword">while</span>(!treeStack.empty()) &#123;</div><div class="line">        curNode = treeStack.top();</div><div class="line">        treeStack.pop();</div><div class="line">        <span class="built_in">printf</span>(FORMAT, curNode-&gt;data);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">            treeStack.push(curNode-&gt;right);     <span class="comment">// push right child first</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">            treeStack.push(curNode-&gt;left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ELEMENT data[NODE_NUM] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'E'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>,<span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'G'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>&#125;;</div><div class="line">    Tree tree;</div><div class="line">    binaryTreeConstructor(tree, data);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Traversal using DFS: "</span>);</div><div class="line">    depthFirstSearch(tree);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ DFS.cpp -o DFS</div><div class="line">gary@xxx:xxx$ ./DFS</div><div class="line">Traversal using DFS: ABDECFG</div></pre></td></tr></table></figure></p>
<h3 id="DFS（C）"><a href="#DFS（C）" class="headerlink" title="DFS（C）"></a>DFS（C）</h3><ul>
<li><em>C语言</em> 中采取类似的策略，使用的是递归调用这个“堆栈”（<strong>void dfs(Node tree[], int vertexIndex, bool visited[])</strong>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DFS.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODENUM 7            	<span class="comment">// node number</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c "</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</div><div class="line"></div><div class="line"><span class="comment">// structure for adjacency lists</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AdjList &#123;</div><div class="line">  <span class="keyword">int</span> vertexIndex; </div><div class="line">  <span class="keyword">struct</span> AdjList* next;</div><div class="line">&#125; AdjList;</div><div class="line">  </div><div class="line"><span class="comment">// Graphic node structure</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ELEMENT data;			<span class="comment">// data area</span></div><div class="line">  <span class="keyword">struct</span> AdjList* listAdj; 	<span class="comment">// pointing to neighbouring node</span></div><div class="line">&#125; Node;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="comment">// return the location of current vertex data in array, -1 if not exit. </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">char</span>, Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseDFS</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node[], <span class="keyword">int</span>, <span class="keyword">bool</span>[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  Node tree[NODENUM+<span class="number">1</span>];</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(createTree(tree)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"DFS result as follow:\n"</span>);</div><div class="line">    traverseDFS(tree);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"> </div><div class="line">    treeRelease(tree);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Create graphic fail!\n"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * 1. create a tree by entering all nodes' value and edges of the tree</div><div class="line"> * 2. store the tree in an adjacency list</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,location;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Input all nodes's value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    tree[i].data = getchar();</div><div class="line">    <span class="keyword">if</span>(tree[i].data &lt; <span class="string">'A'</span> || (tree[i].data &gt; <span class="string">'Z'</span> &amp;&amp; tree[i].data &lt; <span class="string">'a'</span>) || tree[i].data &gt; <span class="string">'z'</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Node's value should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// eliminate '\n'</span></div><div class="line">  getchar();</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nInput the directly connected nodes, given a node:\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NODENUM; i++) &#123;</div><div class="line">    <span class="built_in">putchar</span>(tree[i].data);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</div><div class="line">    c = getchar();</div><div class="line">    tree[i].listAdj = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>((location = locate(c, tree)) != <span class="number">-1</span>) &#123;</div><div class="line">      AdjList* newAdjVertex = (AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</div><div class="line">      newAdjVertex-&gt;vertexIndex = location;</div><div class="line">      newAdjVertex-&gt;next = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">      <span class="comment">// insert an adjacent node, as the head need to be dealt with separately </span></div><div class="line">      <span class="keyword">if</span>(tree[i].listAdj == <span class="literal">NULL</span>) &#123;</div><div class="line">        tree[i].listAdj = newAdjVertex;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        AdjList* temp = tree[i].listAdj;</div><div class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">          temp = temp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = newAdjVertex;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      <span class="comment">// '\n' will lead to exit</span></div><div class="line">      c = getchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the index of the given node in the node array, -1 if not exist.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(ELEMENT givenVal, Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> location;</div><div class="line">  <span class="keyword">for</span>(location = NODENUM<span class="number">-1</span>; location&gt;=<span class="number">0</span>; location--) &#123;</div><div class="line">    <span class="keyword">if</span>(tree[location].data == givenVal) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> location;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseDFS</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> visited[NODENUM];</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// need to traverse all nodes, avoid not-connected graph</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</div><div class="line">      dfs(tree, i, visited);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node tree[], <span class="keyword">int</span> vertexIndex, <span class="keyword">bool</span> visited[])</span> </span>&#123;</div><div class="line">  AdjList *pAdjList;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">  visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">  pAdjList = tree[vertexIndex].listAdj;</div><div class="line">  <span class="keyword">while</span>(pAdjList != <span class="literal">NULL</span>) &#123;</div><div class="line">    vertexIndex = pAdjList-&gt;vertexIndex;</div><div class="line">    <span class="keyword">if</span>(!visited[vertexIndex]) &#123;</div><div class="line">      dfs(tree, vertexIndex, visited);</div><div class="line">    &#125;</div><div class="line">    pAdjList = pAdjList-&gt;next;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// reslease the dynamically allocated memory</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  AdjList *p, *temp;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    p = tree[i].listAdj;</div><div class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</div><div class="line">      temp = p;</div><div class="line">      p = p-&gt;next;</div><div class="line">      <span class="built_in">free</span>(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ DFS.c -o DFS</div><div class="line">gary@xxx:xxx$ ./DFS</div><div class="line">Input all nodes<span class="string">'s value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):</div><div class="line">ABCDEFG</div><div class="line"> </div><div class="line">Input the directly connected nodes, given a node:</div><div class="line">A BC</div><div class="line">B ADE</div><div class="line">C AFG</div><div class="line">D B</div><div class="line">E B</div><div class="line">F C</div><div class="line">G C</div><div class="line">DFS result as follow:</div><div class="line">A B D E C F G</span></div></pre></td></tr></table></figure></p>
<h3 id="112-amp-113-Path-Sum-I-amp-II"><a href="#112-amp-113-Path-Sum-I-amp-II" class="headerlink" title="112.&amp;113. Path Sum I&amp;II"></a><a href="https://leetcode.com/problems/path-sum/#/description">112.&amp;113. Path Sum I&amp;II</a></h3><ul>
<li>Description<blockquote>
<p>　Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>　For example:<br>　Given the below binary tree and sum = 22,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      <span class="number">5</span></div><div class="line">     / \</div><div class="line">    <span class="number">4</span>   <span class="number">8</span></div><div class="line">   /   / \</div><div class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line"> /  \      \</div><div class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>return true, as there exist a root-to-leaf path <strong>5-&gt;4-&gt;11-&gt;2</strong> which sum is 22.<br>　即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">给定一个二叉树root和一个和sum，</div><div class="line"> </div><div class="line">决定这个树是否存在一条从根到叶子的路径使得沿路所有节点的和等于给定的sum。</div><div class="line"> </div><div class="line">例如：</div><div class="line">给定如下二叉树和sum=<span class="number">22</span>，</div><div class="line">              <span class="number">5</span></div><div class="line">             / \</div><div class="line">            <span class="number">4</span>   <span class="number">8</span></div><div class="line">           /   / \</div><div class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line">         /  \      \</div><div class="line">        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div><div class="line">返回真，因为这里存在一条根叶路径（<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span>），它的和为<span class="number">22</span>。</div><div class="line"> </div><div class="line"><span class="number">112</span>&amp;<span class="number">113</span> 都是这样的问题，只不过前者只需要判断是否存在，后者则需要遍历所有节点以得到所有满足条件情况：</div><div class="line">　<span class="keyword">return</span></div><div class="line">　[</div><div class="line">   　[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</div><div class="line">   　[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">　]</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>解题思路<ul>
<li>是一个典型的 <strong>DFS</strong> 遍历的问题，因为需要遍历 <strong>root-&gt;leaf</strong> 这样一类路径，通过递归实现。</li>
<li>需要考虑的是在 path 上传递的变量（递归调用过程中传递的参数），<strong>问题 112</strong> 只需要传递 <strong>root-&gt;当前节点</strong> 的求和（这里通过 <strong>Sum</strong> 减去当前节点值的方式），如下：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. An empty tree</span></div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. A leaf, check sum</span></div><div class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> (root-&gt;val == sum);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. Not a leaf, recursive to a child node(|| for "exist")</span></div><div class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-(root-&gt;val)) || hasPathSum(root-&gt;right, sum-(root-&gt;val));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><strong>问题 113</strong> 除了传递 <strong>Sum</strong> 外，还需要传递 <strong>root-&gt;leaf</strong> 路径上的节点值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSet;</div><div class="line">        <span class="comment">// 1. An empty tree, return empty path Set</span></div><div class="line">        <span class="keyword">if</span>(root) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">            dfs(root, sum, path, pathSet);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> pathSet;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curPath, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pathSet)</span> </span>&#123;</div><div class="line">        curPath.push_back(root-&gt;val);</div><div class="line">        sum -= root-&gt;val;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. A leaf reached</span></div><div class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>) &#123;</div><div class="line">                pathSet.push_back(curPath);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. Recursive to a child node</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(root-&gt;left) &#123;</div><div class="line">                dfs(root-&gt;left, sum, curPath, pathSet);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</div><div class="line">                dfs(root-&gt;right, sum, curPath, pathSet);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// backtracking</span></div><div class="line">        curPath.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　此外还需要留意 <strong>backtracking</strong> 部分，因为对于 <strong>Sum</strong>，是一个形式参数，当递归函数返回时，不影响调用函数中的 <strong>Sum</strong>，但对于引用参数 <strong>curPath</strong> 就不一样了，因此，需要在递归函数返回前进行回溯，保证 <strong>curPath</strong> 始终记录 <strong>root-&gt;当前节点</strong> 路径上的节点值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文主要介绍 &lt;strong&gt;DFS&lt;/strong&gt; 的 &lt;em&gt;C++&lt;/em&gt; 和 &lt;em&gt;C&lt;/em&gt; 语言实现，并借助 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt; 上的一道题，说说基本的 &lt;strong&gt;DFS&lt;/strong&gt; 在问题求解中的应用。&lt;/p&gt;
&lt;h3 id=&quot;What’s-D-epth-F-irst-S-earch&quot;&gt;&lt;a href=&quot;#What’s-D-epth-F-irst-S-earch&quot; class=&quot;headerlink&quot; title=&quot;What’s D(epth)F(irst)S(earch)&quot;&gt;&lt;/a&gt;What’s D(epth)F(irst)S(earch)&lt;/h3&gt;&lt;p&gt;　深度优先搜索算法（Depth First Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 &lt;strong&gt;N&lt;/strong&gt; 的所有边都己被探寻过，搜索将回溯到发现节点 &lt;strong&gt;N&lt;/strong&gt; 的那条边的起始节点，这一过程一直进行到已发现从源节点可达的所有节点为止。&lt;br&gt;　如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0003] 一道阿里巴巴面试题（2017） </title>
    <link href="http://durant35.github.io/2017/03/10/Algorithms_An%20Alibaba%20Interview%20Question/"/>
    <id>http://durant35.github.io/2017/03/10/Algorithms_An Alibaba Interview Question/</id>
    <published>2017-03-10T06:00:22.000Z</published>
    <updated>2017-03-12T14:54:00.786Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。</p>
<p><center><img src="/img/Algorithms/0003_alibaba_2017.png" width="1024px"/></center><br><a id="more"></a></p>
<h4 id="转化问题1：求一个字符串中连续出现次数最多的子串"><a href="#转化问题1：求一个字符串中连续出现次数最多的子串" class="headerlink" title="转化问题1：求一个字符串中连续出现次数最多的子串"></a>转化问题1：求一个字符串中连续出现次数最多的子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">char</span> sub_str[<span class="number">2000</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_substr</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str);</div><div class="line">     <span class="keyword">int</span> i, j, k;</div><div class="line">     <span class="keyword">int</span> tmp_cnt = <span class="number">0</span>;</div><div class="line"> </div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i++) &#123;</div><div class="line">         <span class="keyword">for</span> (j = i+<span class="number">2</span>; j &lt; str_len; j++) &#123;</div><div class="line">             <span class="keyword">int</span> n = j-i;                                                     <span class="comment">//sub string length</span></div><div class="line">             tmp_cnt = <span class="number">1</span>;</div><div class="line">             <span class="keyword">if</span> (<span class="built_in">strncmp</span>(&amp;str[i], &amp;str[j], n) == <span class="number">0</span>) &#123;  <span class="comment">//compare n-lengths strings</span></div><div class="line">                 tmp_cnt++;                                             <span class="comment">//they are equal, so add count</span></div><div class="line">                 <span class="keyword">for</span> (k = j+n; k &lt; str_len; k += n) &#123;      <span class="comment">//consecutive checking</span></div><div class="line">                     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(&amp;str[i], &amp;str[k], n) == <span class="number">0</span>) &#123;</div><div class="line">                         tmp_cnt++;</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">else</span> &#123;</div><div class="line">                         <span class="keyword">break</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 <span class="keyword">if</span> (count &lt; tmp_cnt) &#123;</div><div class="line">                     count = tmp_cnt;</div><div class="line">                     <span class="built_in">memcpy</span>(sub_str, &amp;str[i], n);        <span class="comment">//record the sub string</span></div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">char</span> str[<span class="number">2000</span>];</div><div class="line">     <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</div><div class="line">     find_substr(str);</div><div class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, sub_str);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>对于连续出现的子串，我们可以以候选子串长度作为step</li>
<li>通过指定step长度的滑动窗口，统计候选子串出现的次数，并计数</li>
<li>维护出现次数最多的子串<h4 id="转化问题2：求一个字符串中出现次数最多的子串-不一定是连续的"><a href="#转化问题2：求一个字符串中出现次数最多的子串-不一定是连续的" class="headerlink" title="转化问题2：求一个字符串中出现次数最多的子串(不一定是连续的)"></a>转化问题2：求一个字符串中出现次数最多的子串(不一定是连续的)</h4>　假设存在一个长度为 N 的子串 S 出现的次数最多。那么它具有哪些特点呢？</li>
<li>S的任一子串的出现次数不少于 S 的出现次数 </li>
<li>S中不会出现重复的子串字符 </li>
<li>S中不会出现重复的字符 </li>
<li>组成 S 的每一个字符、每一个子串的出现次数都和 S 一样<br>　“S 中不会出现重复的字符”，“组成 S 的每一个字符、每一个子串的出现次数都和 S 一样”！有了这个结论，问题就简单了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mostTimesSubstring.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 1024</span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">deque</span>;</div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; strlist;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> npos = <span class="number">-1</span>;</div><div class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">ignoreChars</span><span class="params">(<span class="string">" /t/n/r"</span>)</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IgnoreChar</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (ignoreChars.find(c) != npos);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the max count</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">TextSummary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">unsigned</span> usecount[], <span class="keyword">int</span> Num4Chars)</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> max_count, i;</div><div class="line"> </div><div class="line">    <span class="built_in">memset</span>(usecount, <span class="number">0</span>, Num4Chars*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; text.length(); usecount[<span class="keyword">unsigned</span>(text[i++])]++);</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(max_count = i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(IgnoreChar(i)) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(usecount[i] &gt; max_count) max_count = usecount[i];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> max_count;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// check whether current substring splicing one more char also reach max count</span></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">StringTryGrowthOneChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> maxcount, <span class="keyword">unsigned</span>* usecount)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="built_in">string</span>::size_type pos;</div><div class="line">    <span class="keyword">char</span> c = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    pos = text.find(str);</div><div class="line">    <span class="keyword">if</span>(pos == npos)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// not the max count char</span></div><div class="line">    c = text[pos + str.length()];</div><div class="line">    <span class="keyword">if</span>(usecount[<span class="keyword">unsigned</span>(c)] &lt; maxcount)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// make sure every char in this growing substring also reach max count</span></div><div class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; pos + str.length() + <span class="number">1</span> &lt; text.length(); pos += str.length())&#123;</div><div class="line">        pos = text.find(str, pos);</div><div class="line">        <span class="keyword">if</span>(pos == npos) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(c != text[pos + str.length()]) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintResult</span><span class="params">(<span class="keyword">const</span> strlist&amp; result)</span></span>&#123;</div><div class="line">    strlist::const_iterator citer;</div><div class="line"> </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"The result substrings :"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(citer = result.begin(); citer != result.end(); citer++)&#123;</div><div class="line">        <span class="comment">// substring should longer than 2 chars</span></div><div class="line">        <span class="keyword">if</span>((*citer).length() &gt; <span class="number">1</span>)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'"'</span> &lt;&lt; *citer &lt;&lt; <span class="string">'"'</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total : "</span> &lt;&lt; result.size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> usecount[<span class="number">256</span>];</div><div class="line">    <span class="keyword">char</span> buffer[BUFFSIZE], c;</div><div class="line">    <span class="keyword">unsigned</span> count, i;</div><div class="line">    <span class="built_in">string</span> text;</div><div class="line">    strlist result;</div><div class="line"> </div><div class="line">    <span class="keyword">while</span>(!feof(<span class="built_in">stdin</span>))&#123;</div><div class="line">        <span class="keyword">if</span>(fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>))</div><div class="line">            text = buffer;</div><div class="line"> </div><div class="line">        <span class="comment">// Count the number of occurrences of characters</span></div><div class="line">        count = TextSummary(text, usecount, <span class="keyword">sizeof</span>(usecount)/<span class="keyword">sizeof</span>(*usecount));</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max count :"</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(<span class="number">1</span> &gt;= count)&#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No longest substring!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// result holds the substring reach max count</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(usecount)/<span class="keyword">sizeof</span>(*usecount); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(usecount[i] == count)</div><div class="line">                result.push_back(<span class="built_in">string</span>(<span class="number">1</span>, <span class="keyword">char</span>(i)));</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// substring growing for more substrings</span></div><div class="line">        <span class="keyword">for</span>(strlist::iterator iter = result.begin(); iter != result.end(); iter++)&#123;</div><div class="line">            c = StringTryGrowthOneChar(text, *iter, count, usecount);</div><div class="line">            <span class="keyword">if</span>(c)</div><div class="line">                result.push_back(*iter + <span class="built_in">string</span>(<span class="number">1</span>, c));</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        PrintResult(result);</div><div class="line">        result.clear();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>编译构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -o mostTimesSubstring mostTimesSubstring.cpp</div></pre></td></tr></table></figure></p>
<p>算法分析：</p>
<ul>
<li>找到文本中的出现次数最高的单个字符组成的子串，放入一个队列中</li>
<li>从队列的头部开始，对每一个子串 S 进行处理，找到文本中该子串出现的任意一个位置 P，判断文本中紧随 S 之后的字符 C 是否的出现次数是最多的<ul>
<li>如果 C 的出现次数不是最多的，结束。</li>
<li>如果 C 的出现次数是最多的，搜索文本中的每一个 S 并判断紧随其后的字符是否是 C <ul>
<li>如果文本中的每一个 S 之后都存在字符 C ，将 S + C 生成的子串放入结果集中</li>
<li>如果文本中出现 S 之后的字符不是 C ，结束。 </li>
</ul>
</li>
<li>如此，直至到达队列尾。</li>
</ul>
</li>
</ul>
<h4 id="回到这道面试题"><a href="#回到这道面试题" class="headerlink" title="回到这道面试题"></a>回到这道面试题</h4><ul>
<li>该题统计的是：子串出现次数与子串长度的乘积，问题是，是否这个乘积的最大值总是：（1）出现次数最多的；（2）长度最长的，显然不是</li>
<li>问题分析1：我们需要穷举所有子串并计数各自出现的次数，最终获取乘积最大的子串</li>
<li>问题分析2：能否不穷举，对上述算法进行变形？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0003_alibaba_2017.png&quot; width=&quot;1024px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0002] Divide and Conquer——FFT（快速傅里叶变换）</title>
    <link href="http://durant35.github.io/2017/03/04/Algorithms_FFT/"/>
    <id>http://durant35.github.io/2017/03/04/Algorithms_FFT/</id>
    <published>2017-03-04T06:00:22.000Z</published>
    <updated>2017-03-12T09:52:51.505Z</updated>
    
    <content type="html"><![CDATA[<p>　本文介绍 <strong>Divide and Conquer（分而治之）</strong> 的一种典型算法，<strong>FFT</strong>（快速傅里叶变换）。</p>
<h3 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h3><p>DFT：$X[k] = \sum_{n=0}^{N-1} x[n] e^{-j \frac{2 \pi k}{N} n}, k = 0, 1, 2, …, N-1$</p>
<ul>
<li>for each k: <strong>N</strong> complex mults, <strong>N-1</strong> complex adds</li>
<li>$e^{-j \frac{2 \pi k}{N} n}$ 预计算并保存在计算机中</li>
<li>$O(N^2)$ computations for direct <strong>DFT</strong> $\Longrightarrow$ $O(N log_2 N)$ for <strong>FFT</strong><a id="more"></a>
<h3 id="FFT-算法原理"><a href="#FFT-算法原理" class="headerlink" title="FFT 算法原理"></a>FFT 算法原理</h3>　做出如下定义：$W_N = e^{-j \frac{2 \pi}{N}}$，则：$W_N^{kn} = e^{-j \frac{2 \pi k}{N} n}$，具有如下性质：</li>
</ul>
<ol>
<li>$W_N^{kN} = e^{-j 2 \pi k } = 1$</li>
<li>复共轭对称：$W_N^{k(N-n)} = W_N^{-kn)} = (W_N^{kn})^{*}$</li>
<li>周期性：$W_N^{kn} = W_N^{k(N+n))} = W_N^{(k+N)n}$</li>
</ol>
<p>　假设 $N = 2^m$，separate $x[n]$ into even and odd-indexed subsequences<br>　$ X[k] = \sum_{n=0}^{N-1} x[n] W_N^{kn} =  \sum_{n \in even} x[n] W_N^{kr} + \sum_{n \in odd} x[n] W_N^{kr} $<br>　$ X[k] = \sum_{r=0}^{\frac{N}{2}-1} x[2r] W_N^{k 2r} +  \sum_{r=0}^{\frac{N}{2}-1} x[2r+1] W_N^{k(2r+1)} $<br>　　　$ = \sum_{r=0}^{\frac{N}{2}-1} x[2r] (W_N^2)^{kr} +  W_N^k \sum_{r=0}^{\frac{N}{2}-1} x[2r+1] (W_N^2)^{kr} $<br>　But：$W_N^2 = e^{-j \frac{2 \pi}{N} 2} = e^{-j \frac{2 \pi}{\frac{N}{2}}} = W_{\frac{N}{2}}$<br>　$ X[k] = \sum_{r=0}^{\frac{N}{2}-1} x[2r] W_{\frac{N}{2}}^{kr} +  W_N^k \sum_{r=0}^{\frac{N}{2}-1} x[2r+1] W_{\frac{N}{2}}^{kr} $<br>　　　$ = X_e[k]  + W_N^k X_o[k]$<br>　其中，$X_e[k]$：N/2 DFT of even samples，$X_o[k]$：N/2 DFT of odd samples，$X[k] \Rightarrow$ sum of 2 N/2 point DFTs<br>　<br>　举$N=8$作为一个例子，根据上述的思路进行一次二分，如下图：</p>
<center><img src="/img/Algorithms/0002_FFT complexity 1.png" width="720px"/></center><br>　左边按照普通的 <strong>DFT</strong> 计算（$O(n^2)$的时间复杂度）得到$x_e[0…3]$和$x_o[0…3]$，需要$(\frac{N}{2})^2·2$ 次乘法；$W_8^{0…7}$ 的预计算需要 $N$ 次乘法；最后的 $X[0…7]$ 的计算每一项都需要一次乘法，总共需要 $N$ 次乘法。故通过一次二分得出的计算复杂度估计为 $\frac{N^2}{2} + N$<br><center><img src="/img/Algorithms/0002_FFT complexity 2.png" width="720px"/></center><br>　按照这种思路，继续二分下去（如下图），得到 <strong>FFT</strong> 算法的最终时间复杂度：$O(N log_2 N)$<br><center><img src="/img/Algorithms/0002_FFT diagram(N=8).png" width="800px"/></center>

<h3 id="FFT算法实现"><a href="#FFT算法实现" class="headerlink" title="FFT算法实现"></a>FFT算法实现</h3><ul>
<li>源代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FFT.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> M_PI  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI 3.14159265358979323846  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024*16</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE_MAX 1000</span></div><div class="line"> </div><div class="line"><span class="comment">// define a complex structure</span></div><div class="line"><span class="keyword">struct</span> Complex_ &#123; </div><div class="line">    <span class="keyword">double</span> real; </div><div class="line">    <span class="keyword">double</span> imagin; </div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Complex_ Complex;</div><div class="line"><span class="comment">// define complex computation: add/subtract/multiply</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex_Add</span><span class="params">(Complex* src1, Complex* src2, Complex* dst)</span></span>&#123; </div><div class="line">    dst-&gt;real = src1-&gt;real + src2-&gt;real; </div><div class="line">    dst-&gt;imagin = src1-&gt;imagin + src2-&gt;imagin; </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex_Sub</span><span class="params">(Complex* src1, Complex* src2, Complex* dst)</span></span>&#123; </div><div class="line">    dst-&gt;real = src1-&gt;real - src2-&gt;real; </div><div class="line">    dst-&gt;imagin = src1-&gt;imagin - src2-&gt;imagin; </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex_Multiply</span><span class="params">(Complex* src1, Complex* src2, Complex* dst)</span></span>&#123;</div><div class="line">    <span class="keyword">double</span> r1 = <span class="number">0.0</span>, r2 = <span class="number">0.0</span>; </div><div class="line">    <span class="keyword">double</span> i1 = <span class="number">0.0</span>, i2 = <span class="number">0.0</span>;</div><div class="line">    r1 = src1-&gt;real; </div><div class="line">    i1 = src1-&gt;imagin; </div><div class="line">    r2 = src2-&gt;real; </div><div class="line">    i2 = src2-&gt;imagin;</div><div class="line">    dst-&gt;real = r1*r2 - i1*i2;</div><div class="line">    dst-&gt;imagin = i1*r2 + r1*i2; </div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// get W_N^k </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getWN</span><span class="params">(<span class="keyword">double</span> k, <span class="keyword">double</span> N, Complex* dst)</span></span>&#123; </div><div class="line">    <span class="keyword">double</span> x = <span class="number">2.0</span>*M_PI*k/N; </div><div class="line">    dst-&gt;real = <span class="built_in">cos</span>(x);</div><div class="line">    dst-&gt;imagin = -<span class="built_in">sin</span>(x); </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// input generator</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_generator</span><span class="params">(<span class="keyword">double</span>* data, <span class="keyword">int</span>  n)</span></span>&#123; </div><div class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>)); </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)&#123; </div><div class="line">        data[i] = rand()%VALUE_MAX;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,data[i]);  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * normal DFT algorithm, with O(n^2) complexity</div><div class="line"> */</span> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">double</span>* src, Complex* dst, <span class="keyword">int</span> size)</span> </span>&#123; </div><div class="line">    <span class="keyword">clock_t</span> start, end; </div><div class="line">    start = clock(); </div><div class="line">    <span class="comment">// 2 cycle, each with step of 1, size n, so O(n*n)</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;size; m++)&#123; </div><div class="line">        <span class="keyword">double</span> real = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">double</span> imagin = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;size; n++)&#123;  </div><div class="line">            <span class="keyword">double</span> x = M_PI*<span class="number">2</span>*m*n;  </div><div class="line">            real += src[n]*<span class="built_in">cos</span>(x/size);  </div><div class="line">            imagin += src[n]*(-<span class="built_in">sin</span>(x/size));  </div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        dst[m].imagin = imagin;  </div><div class="line">        dst[m].real = real;  </div><div class="line">        <span class="keyword">if</span>(imagin &gt;= <span class="number">0.0</span>)</div><div class="line">        	<span class="built_in">printf</span>(<span class="string">"%lf+%lfj\n"</span>, real, imagin); </div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lf%lfj\n"</span>, real, imagin);</div><div class="line">    &#125; </div><div class="line">    end = clock(); </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"DFT use time :%lf for Datasize of:%d\n"</span>,(<span class="keyword">double</span>)(end-start)/CLOCKS_PER_SEC, size); </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(Complex* src, Complex* dst, <span class="keyword">int</span> size)</span> </span>&#123; </div><div class="line">    <span class="keyword">clock_t</span> start, end; </div><div class="line">    start = clock(); </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;size; m++) &#123; </div><div class="line">        <span class="keyword">double</span> real = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">double</span> imagin = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;size; n++) &#123;  </div><div class="line">            <span class="keyword">double</span> x = M_PI*<span class="number">2</span>*m*n/size;  </div><div class="line">            real += src[n].real*<span class="built_in">cos</span>(x)-src[n].imagin*<span class="built_in">sin</span>(x);  </div><div class="line">            imagin += src[n].real*<span class="built_in">sin</span>(x)+src[n].imagin*<span class="built_in">cos</span>(x);  </div><div class="line">                </div><div class="line">        &#125;  </div><div class="line">        real /= SIZE;  </div><div class="line">        imagin /= SIZE;</div><div class="line">  </div><div class="line">        <span class="keyword">if</span>(dst != <span class="literal">NULL</span>)&#123;  </div><div class="line">            dst[m].real = real;  </div><div class="line">            dst[m].imagin = imagin;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(imagin &gt;= <span class="number">0.0</span>)  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lf+%lfj\n"</span>, real, imagin);  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lf%lfj\n"</span>, real, imagin);  </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    end=clock(); </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"IDFT use time :%lfs for Datasize of:%d\n"</span>, (<span class="keyword">double</span>)(end-start)/CLOCKS_PER_SEC,size); </div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// define FFT initialization data, remapping</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FFT_remap</span><span class="params">(<span class="keyword">double</span>* src, <span class="keyword">int</span> N)</span> </span>&#123; </div><div class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">  </div><div class="line">    <span class="keyword">double</span>* temp = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*N); </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) </div><div class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)  </div><div class="line">            temp[i/<span class="number">2</span>] = src[i];  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            temp[(N+i)/<span class="number">2</span>] = src[i];</div><div class="line">  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) </div><div class="line">        src[i] = temp[i];</div><div class="line">  </div><div class="line">    <span class="built_in">free</span>(temp);</div><div class="line">  </div><div class="line">    FFT_remap(src, N/<span class="number">2</span>); </div><div class="line">    FFT_remap(src+N/<span class="number">2</span>, N/<span class="number">2</span>);</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">double</span>* src, Complex* dst, <span class="keyword">int</span> N)</span></span>&#123; </div><div class="line">    FFT_remap(src, N);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) </div><div class="line">    	<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, src[i]);</div><div class="line"> </div><div class="line">    <span class="keyword">clock_t</span> start, end; </div><div class="line">    start = clock(); </div><div class="line">    <span class="keyword">int</span> n = N;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// get number of stage</span></div><div class="line">    <span class="keyword">int</span> stage = <span class="number">0</span>; </div><div class="line">    <span class="keyword">while</span>(n /= <span class="number">2</span>) &#123; </div><div class="line">        stage++;  </div><div class="line">    &#125;</div><div class="line">    n = stage; </div><div class="line">    <span class="keyword">if</span>(N != (<span class="number">1</span>&lt;&lt;n)) </div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"> </div><div class="line">    Complex* src_complex = (Complex*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Complex)*N);</div><div class="line">    <span class="keyword">if</span>(src_complex == <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123; </div><div class="line">        src_complex[i].real = src[i];  </div><div class="line">        src_complex[i].imagin = <span class="number">0</span>;  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123; </div><div class="line">        k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123; </div><div class="line">            <span class="keyword">if</span>((j/(<span class="number">1</span>&lt;&lt;i))%<span class="number">2</span> == <span class="number">1</span>) &#123;  </div><div class="line">                Complex WNk;  </div><div class="line">                getWN(k, N, &amp;WNk);</div><div class="line"> </div><div class="line">                Complex_Multiply(&amp;src_complex[j], &amp;WNk, &amp;src_complex[j]);  </div><div class="line">                k += <span class="number">1</span>&lt;&lt;(k-i<span class="number">-1</span>);</div><div class="line">                Complex temp;  </div><div class="line">                <span class="keyword">int</span> neighbour = j-(<span class="number">1</span>&lt;&lt;(i));  </div><div class="line">                temp.real = src_complex[neighbour].real;  </div><div class="line">                temp.imagin = src_complex[neighbour].imagin;  </div><div class="line">                Complex_Add(&amp;temp, &amp;src_complex[j], &amp;src_complex[neighbour]);  </div><div class="line">                Complex_Sub(&amp;temp, &amp;src_complex[j], &amp;src_complex[j]);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                k = <span class="number">0</span>;  </div><div class="line">        &#125;  </div><div class="line">       </div><div class="line">    &#125; </div><div class="line">     </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">   		<span class="keyword">if</span>(src_complex[i].imagin &gt;= <span class="number">0.0</span>) &#123; </div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%lf+%lfj\n"</span>, src_complex[i].real, src_complex[i].imagin); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> </div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%lf%lfj\n"</span>, src_complex[i].real, src_complex[i].imagin);	</div><div class="line">    &#125; </div><div class="line"> </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</div><div class="line">    dst[i].imagin = src_complex[i].imagin;  </div><div class="line">    dst[i].real = src_complex[i].real;  </div><div class="line">  &#125;</div><div class="line">    end = clock();</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"FFT use time :%lfs for Datasize of:%d\n"</span>,(<span class="keyword">double</span>)(end-start)/CLOCKS_PER_SEC, N); </div><div class="line">       </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123; </div><div class="line">    <span class="keyword">double</span> input[SIZE]; </div><div class="line">    Complex dst[SIZE]; </div><div class="line">    input_generator(input, SIZE); </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</div><div class="line">    DFT(input, dst, SIZE);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>); </div><div class="line">    FFT(input, dst, SIZE);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　</p>
<ul>
<li>编译构建<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -o FFT FFT.cpp -lm</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　</p>
<ul>
<li>测试结果<blockquote>
<p>DFT use time :33.963164 for Datasize of:16384<br>FFT use time :0.090624s for Datasize of:16384</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文介绍 &lt;strong&gt;Divide and Conquer（分而治之）&lt;/strong&gt; 的一种典型算法，&lt;strong&gt;FFT&lt;/strong&gt;（快速傅里叶变换）。&lt;/p&gt;
&lt;h3 id=&quot;DFT&quot;&gt;&lt;a href=&quot;#DFT&quot; class=&quot;headerlink&quot; title=&quot;DFT&quot;&gt;&lt;/a&gt;DFT&lt;/h3&gt;&lt;p&gt;DFT：$X[k] = \sum_{n=0}^{N-1} x[n] e^{-j \frac{2 \pi k}{N} n}, k = 0, 1, 2, …, N-1$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for each k: &lt;strong&gt;N&lt;/strong&gt; complex mults, &lt;strong&gt;N-1&lt;/strong&gt; complex adds&lt;/li&gt;
&lt;li&gt;$e^{-j \frac{2 \pi k}{N} n}$ 预计算并保存在计算机中&lt;/li&gt;
&lt;li&gt;$O(N^2)$ computations for direct &lt;strong&gt;DFT&lt;/strong&gt; $\Longrightarrow$ $O(N log_2 N)$ for &lt;strong&gt;FFT&lt;/strong&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0001] Divide and Conquer </title>
    <link href="http://durant35.github.io/2017/02/26/Algorithms_Divide%20and%20Conquer/"/>
    <id>http://durant35.github.io/2017/02/26/Algorithms_Divide and Conquer/</id>
    <published>2017-02-26T06:00:22.000Z</published>
    <updated>2017-02-26T06:56:45.425Z</updated>
    
    <content type="html"><![CDATA[<p>　本周的 part 是 <strong>Divide and Conquer（分而治之）</strong>。<br><a id="more"></a></p>
<h4 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element "></a><a href="https://leetcode.com/problems/majority-element/?tab=Description">169. Majority Element </a></h4><ul>
<li>Level: Easy</li>
<li>Description<blockquote>
<p>　Given an array of size n, find the <strong>majority element</strong>. The <strong>majority element</strong> is the element that appears more than $⌊ n/2 ⌋$ times.<br>　You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
</li>
<li>解题思路<ul>
<li><strong>Majority Element</strong>: A majority element in an array A[] of size n is an element that appears more than n/2 times（显然，只有唯一一个）</li>
<li>可以通过构造 size 为 n 的向量表计数每个数字出现的次数（$O(n)$ 线性时间复杂度），在计数过程中，一旦发现 $count &gt; n/2$ 即可返回，该数字即为要找的 <strong>Majority Element</strong></li>
<li>细想发现，使用数组构建的向量表，通过下标直接访问的方式，必须满足一个前提条件：n 个元素必须 $\in [0, n)$，所以感觉需要维护两个 size 为 n 的数组，一个保存出现的数字 $elements[0…n)$，另一个是对应的计数 $count[0…n)$，但是这样问题就出现了：在一遍遍历计数每个数字出现的次数过程中，为了找到对应的 $count[0…n)$ 下标，需要对  $elements[0…n)$ 进行查找</li>
<li>考虑了以上的情况，决定使用 C++ 中的 <strong>map</strong> 字典来实现上述的想法，避免手动维护这样一个字典功能带来的低效率和繁琐工作量（毕竟是 Easy）</li>
</ul>
</li>
<li>Solution &amp; Analysis<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="number">1</span> == nums.size()) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; table;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator table_iter = table.end();</div><div class="line"> </div><div class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123;</div><div class="line">            <span class="keyword">if</span>(table.end() == table.find(*iter))&#123;</div><div class="line">                table.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(*iter, <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                table[*iter]++;</div><div class="line">                <span class="keyword">if</span>(table[*iter] &gt; nums.size()/<span class="number">2</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> (*iter);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　<font color="green">Accepted</font>，不过耗时：<strong>38ms</strong>，应该有更高效的方式。</p>
<ul>
<li>补充<ul>
<li>有一种算法：<a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/">A Linear Time Majority Vote Algorithm</a> ，其思路如下<blockquote>
<ol>
<li>Initialize index and count of majority element:  majorityElement = 0, count = 0</li>
<li>Loop for n = 0 to size – 1<br>　(c)If count == 0<br>　　majorityElement = a[n]<br>　　count = 1<br>　(b)If majorityElement == a[n]<br>　　count++<br>　(b)Else<br>　　count–;</li>
<li>Return majorityElement</li>
</ol>
</blockquote>
</li>
<li>代码实现如下，其时间复杂度只有：13 ms，大大降低了<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, n, majorityElement;</div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; numsSize; n++) &#123;</div><div class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</div><div class="line">      majorityElement = nums[n];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (nums[n] == majorityElement) &#123;</div><div class="line">      count++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">      count--;</div><div class="line">  &#125;</div><div class="line">    &#125;</div><div class="line">    count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; numsSize; n++)&#123;</div><div class="line">  <span class="keyword">if</span> (nums[n] == majorityElement) &#123;</div><div class="line">      count++;</div><div class="line">  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (count &gt; numsSize/<span class="number">2</span>)&#123;</div><div class="line">  <span class="keyword">return</span> majorityElement;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>+ </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本周的 part 是 &lt;strong&gt;Divide and Conquer（分而治之）&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Digital Image Process</title>
    <link href="http://durant35.github.io/2017/02/04/cv_Digital-Image-Process(pg_2016)/"/>
    <id>http://durant35.github.io/2017/02/04/cv_Digital-Image-Process(pg_2016)/</id>
    <published>2017-02-04T09:53:31.000Z</published>
    <updated>2017-02-20T06:06:07.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Books：<a href="http://durant35.github.io/pdf/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(%E5%86%88%E8%90%A8%E9%9B%B7%E6%96%AF)%E4%B8%AD%E8%AF%91%E7%AC%AC%E4%B8%89%E7%89%88.pdf" alt="数字图像处理（冈萨雷斯）">数字图像处理（冈萨雷斯）</a><br>Codes：<a href="https://github.com/Durant35/Courses/tree/master/dip">https://github.com/Durant35/Courses/tree/master/dip</a></p>
</blockquote>
<h3 id="第2章-数字图像基础"><a href="#第2章-数字图像基础" class="headerlink" title="第2章 数字图像基础"></a>第2章 数字图像基础</h3><ul>
<li>取样和量化</li>
<li>空间和灰度分辨率<ul>
<li>空间分辨率：空间分辨率是图像在单位面积内像素的个数，表示了图像的空间细节分辨能力</li>
<li>灰度分辨率：灰度分辨率指的是在纯黑和纯白之间灰度级别的多少，指的是图像对灰度变化细节的分辨能力<a id="more"></a></li>
</ul>
</li>
<li>图像内插</li>
<li>像素间的一些基本关系<ul>
<li>$N_4(p)$；$N_8(p) = N_4(p) + N_D(p)$（对角像素） 4领域/8领域</li>
<li>距离度量 $D_e(p, q)$<ul>
<li>城市街区距离：$p(x, y)$；$q(s, t)$；$D_4(p, q) = |x-s| + |y-t|$</li>
<li>棋盘距离：$p(x, y)$；$q(s, t)$；$D_4(p, q) = |x-s| + |y-t|$</li>
<li>邻接性：</li>
<li>4 邻接；8邻接：二义性（像素到另一个像素有多条路径）</li>
<li>m 邻接：p是q的m邻接，首先p，q具有V中的数值；<br>-（i）p在$N_4(q)$中或<br>-（ii）p在$N_D(q)$且$N_4(p)∩N_4(q)$中没有V值（为空或不为空但没有V值）</li>
</ul>
</li>
<li>Path：从一个像素到另一个像素的一个像素序列<ul>
<li>4-path：一个路径上的相邻像素互为4邻接</li>
<li>8-path：一个路径上的相邻像素互为8-neighbors</li>
<li>闭合通路：一个有限区域的边界形成一条闭合通路</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第6章-彩色图像处理"><a href="#第6章-彩色图像处理" class="headerlink" title="第6章 彩色图像处理"></a>第6章 彩色图像处理</h3><ul>
<li>人眼对彩色的敏感程度要远远高于对灰度级别的敏感程度</li>
<li>CMY/CMYK（青色 深红色 黄色 黑色）$\begin{bmatrix} C\\ M \\Y \end{bmatrix} = \begin{bmatrix} 1 \\1 \\1\end{bmatrix} - \begin{bmatrix} R \\G \\B\end{bmatrix}$</li>
<li>HSI（色调 饱和度 强度）<ul>
<li>色调，饱和度和强度<ul>
<li>色调（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受</li>
<li>饱和度（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的</li>
<li>强度（Intensity）：颜色的明亮程度</li>
</ul>
</li>
<li>强度轴：$(0, 0, 0) \rightarrow (1, 1, 1) $</li>
<li>色调平面<ul>
<li>$强度轴 + 彩色点 \Rightarrow 三角面$</li>
<li>$R(0°) \rightarrow G(120°) \rightarrow B(240°)$</li>
</ul>
</li>
<li>饱和度（纯度）<ul>
<li>纯色被白光稀释的程度</li>
<li>以与强度轴的距离为函数</li>
</ul>
</li>
<li>$RGB \rightarrow HSI$　RGB归一化到$[0, 1]$<ul>
<li>$ H[0, 360] = \begin{cases} \theta, &amp;B \leq G \cr 360 - \theta, &amp;B \gt G \end{cases} $，其中$ \theta = arccos\{\frac{\frac{1}{2}[(R-G)+(R-B])}{[(R-G)^2 + (R-B)(G-B)]^\frac{1}{2}} \}$</li>
<li>$ S[0, 1] = 1 - \frac{3}{R+G+B}[min(R, G, B)] $，纯色值为 1</li>
<li>$ I[0, 1] = \frac{1}{3}(R + G + B) $，黑色值为 0/白色值为 1</li>
</ul>
</li>
<li>$HSI \rightarrow RGB$　$H[0, 360]; S[0, 1]; I[0, 1]$<ul>
<li>$ 0° \leq H \le 120°，\begin{cases} B = I(1-S) \cr R = I[1 + \frac{ScosH}{cos(60° - H)}] \cr G = 3I - (R+B) \end{cases} $</li>
<li>$ 120° \leq H \le 240°，H = H - 120°，\begin{cases} R = I(1-S) \cr G = I[1 + \frac{ScosH}{cos(60° - H)}] \cr B = 3I - (R+G) \end{cases} $</li>
<li>$ 240° \leq H \le 360°，H = H - 240°，\begin{cases} G = I(1-S) \cr B = I[1 + \frac{ScosH}{cos(60° - H)}] \cr R = 3I - (G+B) \end{cases} $</li>
</ul>
</li>
<li>HSI 模型更符合人眼对颜色的解释，该模型可以在彩色图像中从携带的彩色信息中将色度信息（色调和饱和度）和强度信息的分量分开</li>
</ul>
</li>
<li>伪彩色：基于一种指定的规则对灰度值赋以颜色的处理<ul>
<li>一幅单色图像<center><img src="/img/CV/dip/PseudoColorProcessing_single.png" width="360px"/></center></li>
<li>多幅单色图像<center><img src="/img/CV/dip/PseudoColorProcessing_multiple.png" width="420px"/></center></li>
</ul>
</li>
<li>全彩色图像：全彩色传感器采集的图像<br>$ \begin{cases} 分别处理每一个向量 \cr 直接处理彩色像素 \end{cases} \Longleftarrow[条件] \begin{cases} ①处理必须对于向量和标量都可用 \cr ②对向量的每一个分量的操作对于其他分量必须是独立的 \end{cases} $</li>
<li>独立于设备的彩色模型：<code>CIEL*a*b*</code>（亮度；红减绿；绿减蓝）<ul>
<li>没有可直接显示的格式（需要变换到另外的彩色空间），但其色域包括整个可见光谱，并可以准确地表示任何显示设备，打印设备或输入设备的颜色</li>
<li>通常的彩色显设备是不能显示自然界所有颜色，仅限于该显示器的三原色所构成的三角形内，不能完全覆盖整个色度图</li>
</ul>
</li>
<li>色调范围（主调类型）：颜色强度的基本分布<ul>
<li>高主调：高（亮）强度处</li>
<li>中主调</li>
<li>低主调：低（暗）亮度处</li>
</ul>
</li>
<li>单独对彩色图像的分量进行直方图均衡通常是不明智的，应当均匀地展开这种彩色灰度，而保持彩色本身（即色调）不变$ \Rightarrow $ 转换到HSI彩色空间进行直方图处理</li>
<li>彩色图像的噪声内容在每个彩色通道中具有相同的特性，但噪声对不同的彩色通道所造成的影响不同</li>
<li>彩色图像平滑<ul>
<li>领域平均平滑可以在每个彩色平面的基础上执行，其结果与使用RGB彩色向量执行平均效果是相同的</li>
</ul>
</li>
<li>彩色图像锐化<ul>
<li>一个向量的拉普拉斯被定义为一个向量，其分量等于输入向量的各个标量分量的拉普拉斯</li>
</ul>
</li>
</ul>
<h3 id="第3章-灰度变换与空间滤波"><a href="#第3章-灰度变换与空间滤波" class="headerlink" title="第3章 灰度变换与空间滤波"></a>第3章 灰度变换与空间滤波</h3><ul>
<li>空间域 vs 变换域<ul>
<li>空间域：直接以图像中的像素操作为基础</li>
<li>空间域处理$ \begin{cases} 灰度变换：在图像的单个像素上操作，主要以对比度/阈值处理为目的（图像增强/图像分割） \cr 空间滤波：图像中每一个像素的领域处理 \end{cases} $</li>
<li>变换域：先把一幅图像变换到变换域，在变换域中进行处理，然后反变换把处理的结果返回到空间域</li>
</ul>
</li>
<li>点处理技术 vs 领域处理技术</li>
<li>图像增强<ul>
<li>对图像进行加工，使其结果对于特定的应用比原始图像更合适的一种处理</li>
<li>“特定”：面向问题，没有通用的“理论”；效果没办法量化</li>
</ul>
</li>
<li>基本的灰度变换函数<ul>
<li>图像反转<ul>
<li>$ S = L - 1 - r，（r \in [0, L-1]）$</li>
<li>增强嵌入在一幅图像的暗区域中的白色或灰色细节，特别是当黑色面积在尺寸上占主导地位时</li>
</ul>
</li>
<li>对数变换<ul>
<li>$ S = clog(1+r)，（c为常数，r \geq 0） $</li>
<li>扩展图像中的暗像素的值，同时压缩更高灰度级的值 $\Longleftrightarrow$ 反对数</li>
<li>压缩像素值变化较大的图像的动态范围，如傅里叶频谱$（0，10^6）\Longrightarrow$ 图像显示系统通常不能如实地再现如此大的范围</li>
</ul>
</li>
<li>幂律（伽马）变换<ul>
<li>$ S = cr^{\gamma}，（c，\gamma为正常数） $</li>
<li>参数性质<ul>
<li>$ \gamma \gt 1 $，（越大越）扩展高灰度级值（亮部的细节）</li>
<li>$ \gamma \lt 1 $，（越小越）扩展低灰度级值（暗部的细节）</li>
</ul>
</li>
<li>有些计算机系统内置部分伽马校正，因为计算机屏幕内部自带伽马校正，改变伽马值不仅会改变亮度，而且会改变彩色图像中的 R，G，B 比率<ul>
<li>整体偏暗的对比度增强</li>
<li>“冲淡”外观的灰度级压缩</li>
</ul>
</li>
</ul>
</li>
<li>分阶级性变换函数<ul>
<li>对比度拉伸：特定灰度级范围斜率变化大（低于 k 的灰度级更暗，高于 k 的灰度级更亮）</li>
<li>灰度级分层：特定灰度级范围的亮度进行不同赋值（例如二值化）</li>
<li>比特平面分层<ul>
<li>$ \begin{cases} 高阶比特：视觉上很重要的大部分数据 \cr 低阶比特：更精细的灰度细节 \end{cases} $ $\Longrightarrow$ 图像压缩：4个高阶比特平面将允许我们从可接受的细节来重建原图像</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>直方图处理<ul>
<li>概述<ul>
<li>灰度级范围为$[0, L-1]$的数字图像的直方图：$h(r_k) = n_k$，$r_k$ 是第 k 级灰度值，$n_k$ 是 $r_k$ 的像素个数</li>
<li>归一化：$p(r_k) = \frac{n_k}{MN}$，灰度级 $r_k$ 在图像中出现的概率</li>
<li>图像的直方图反映了图像的明暗程度以及对比强度，对比度适中的图像通常具有均匀分布的直方图<ul>
<li>低对比度图像具有较窄的直方图，且集中于灰度级的中部；高对比度图像中直方图的分量覆盖了很宽的灰度级范围，而且像素的分布没有太不均匀</li>
<li>若一幅图像的像素倾向于占据整个可能灰度级并且分布均匀，则该图像会有高对比度的外观并展示灰色调的较大变化</li>
</ul>
</li>
</ul>
</li>
<li>直方图均衡化<ul>
<li>直方图均衡化变换（直方图线性变换）<br>　　$ S_k = T(r_k) = (L-1) \sum_{j=0}^k p_r(r_j) = \frac{L-1}{MN}  \sum_{j=0}^k n_j，k=0, 1, 2, 3, …, L-1$</li>
<li>“自动的”：因为图像有相同的内容，直方图均衡导致的对比度增强足以补偿图像在视觉上难以区分灰度级的差别</li>
</ul>
</li>
<li>直方图匹配（直方图规定化）<ul>
<li>Histogram Matching（Specification）：是指对一副图像进行变换，使其直方图与另一幅图像的直方图或特定函数形式的直方图匹配；是用户处理图像后，产生特殊直方图的方法</li>
<li>步骤<ol>
<li>计算直方图 $p_r(r)$，获取直方图均衡变换 $S_k$，把 $S_k$ 四舍五入到 $[0, L-1]$ 范围内的整数</li>
<li>计算变换函数：$G(z_q) = (L-1) \sum_{i=0}^{q} p_z(z_i)$，其中 $q=0, 1, 2, 3, …, L-1$，$p_z(z_i)$ 是规定的直方图</li>
<li>把 G 的值四舍五入到 $[0, L-1]$ 范围整数，存储在查找表中</li>
<li>满足最接近 $S_k$ 的 $G(z_q)$ 的 $z_q$ 值即为直方图规定化后的像素值（当满足给定的 $S_k$ 的 $z_q$ 值多于一个时，选择最小的 $z_q$ 值）</li>
</ol>
</li>
</ul>
</li>
<li>局部直方图均衡化：增强小区域的细节</li>
<li>在图像增强中使用直方图统计<ul>
<li>统计量<ul>
<li>平均灰度：$m = \sum_{i=0}^{L-1} r_i p(r_i)$ 或（取样均值）$m = \frac{1}{MN} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y)$</li>
<li>灰度方差：$\mu_2(r) = \sum_{i=0}^{L-1} (r_i - m)^2 p(r_i)$ 或（取样方差）$\sigma^2 = \frac{1}{MN} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} [f(x, y) - m]^2$</li>
<li>n阶矩：$\mu_{n}(r) = \sum_{i=0}^{L-1} (r_i - m)^n p(r_i)$</li>
</ul>
</li>
<li>根据统计量判断<ul>
<li>判断一个区域在点 $(x, y)$ 是暗还是亮：$m_{S_{xy}} \leq km_G$，其中 $m_{S_{xy}}$ 为局部平均灰度，$m_G$ 为全局均值</li>
<li>判断一个区域的对比度是否可作为低对比度区域：$k_1 \sigma_G \leq \sigma_{S_{xy}} \leq k_2 \sigma_G$（标准差为 0 的区域需排除）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>空间滤波（线性空间滤波器；非线性空间滤波器）<ul>
<li>一个邻域（典型的是一个较小的矩形；奇数尺寸，最小 $3x3$）</li>
<li>对该邻域包围的图像像素执行的预定义操作<ul>
<li>一个 mxn 的滤波器 $\omega(x, y), m=2a+1, n=2b+1$</li>
<li>操作：$g(x, y) = \sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x+s, y+t) $（一般空间滤波器旋转180°后保持不变）</li>
</ul>
</li>
</ul>
</li>
<li>相关 vs 卷积<ul>
<li>1D<ul>
<li>要求：n 必须满足 $g(n)$ 完全滑过 $f(n)$</li>
<li>卷积需要将 $g(n)$ 旋转180°（怎么补零？）$ \Longleftarrow \begin{cases} 卷积：(f \otimes g)[n] = \sum_{m=0}^{N-1} f(m)g(n-m)  \cr 相关：(f \circ g)[n] = \sum_{m=0}^{N-1} f(m)g(n+m) \end{cases} $</li>
</ul>
</li>
<li>2D<ul>
<li>对所有位移变量 x 和 y 求值，以便 $\omega$ 的所有元素访问 $f$ 的每一个像素</li>
<li>$ \Longrightarrow \begin{cases}  卷积：\omega (x, y) \otimes f(x, y) =  \sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x-s, y-t) \cr  相关：\omega (x, y) \circ f(x, y) =  \sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x+s, y+t)  \end{cases} $</li>
</ul>
</li>
</ul>
</li>
<li>平滑空间滤波器：用于模糊处理 $\Rightarrow$ 降低噪声<ul>
<li>平滑线性滤波器（均值滤波器）：响应是包含在滤波器模板邻域内的像素的简单平均值</li>
<li>降低了图像灰度的“尖锐”变化，比如典型的随机噪声就由灰度级急剧变化组成</li>
<li>图像边缘也是由图像灰度尖锐变化带来的特性 $\Rightarrow$ 边缘模糊的负面效应</li>
</ul>
</li>
<li>盒状滤波器 vs 加权平均<ul>
<li>随着距中心点的距离的增加而减小系数值的加权策略 $\Rightarrow$ 降低模糊<br>　　$g(x, y) = \frac{\sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x+s, y+t)}{\sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)}$</li>
<li>空间均值处理：模糊图像，较小物体的灰度与背景混在一起，较大物体变得像“斑点”而易于检测</li>
</ul>
</li>
<li>统计排序（非线性）滤波器<ul>
<li>响应以滤波器包围的区域中所包含像素的排序为基础，使用统计排序结果决定的值代替中心像素的值</li>
<li>中值滤波器 最大值滤波器</li>
</ul>
</li>
<li>锐化空间滤波器：突出灰度的过渡部分<ul>
<li>$ \begin{cases}  图像模糊：通过在空间域用像素邻域平均法实现 \Rightarrow 积分 \cr  锐化可以用空间微分来实现 \Rightarrow 增强边缘和其它突变（如噪声），而削弱灰度变化缓慢的区域 \end{cases} $<center><img src="/img/CV/dip/Grayscale_changes.png" width="540px"/></center></li>
<li>微分<ul>
<li>一阶微分：$\frac{\partial f}{\partial x} = f(x+1) - f(x)$，用到下一个点，“预测未来”</li>
<li>二阶微分：$\frac{\partial^2 f}{\partial^2 x} = f(x+1) + f(x-1) - 2f(x)$</li>
<li>数字图像中的边缘在灰度上常常类似于斜坡过渡，一阶微分会产生较粗的边缘，二阶微分产生由零分开的一个像素宽的双边缘。二阶微分在增强细节方面要比一阶微分好的多，适合锐化图像</li>
</ul>
</li>
<li>拉普拉斯算子：$\nabla^2 f = \frac{\partial^2 f}{\partial^2 x} + \frac{\partial^2 f}{\partial^2 y}$<ul>
<li>是一个各向同性滤波器：响应与作用的图像的突变方向无关；将原图像旋转后进行滤波处理给出的结果与先滤波再旋转的结果相同</li>
<li>$\nabla^2 f(x, y) = f(x+1, y) + f(x-1, y) + f(x, y+1) + f(x, y-1) - 4f(x, y)$</li>
<li>上面公式只是四种算子中的一个<br>　　$\begin{bmatrix} 0 &amp; 1 &amp; 0 \\  1 &amp; -4 &amp; 1 \\  0 &amp; 1 &amp; 0 \end{bmatrix}$ $\begin{bmatrix} 1 &amp; 1 &amp; 1 \\  1 &amp; -8 &amp; 1 \\  1 &amp; 1 &amp; 1 \end{bmatrix}$ $\begin{bmatrix} 0 &amp; -1 &amp; 0 \\  -1 &amp; 4 &amp; -1 \\  0 &amp; -1 &amp; 0 \end{bmatrix}$ $\begin{bmatrix} -1 &amp; -1 &amp; -1 \\  -1 &amp; 8 &amp; -1 \\  -1 &amp; -1 &amp; -1 \end{bmatrix}$</li>
<li>输入图像 $f(x, y)$，锐化后的图像 $g(x, y)$：$g(x, y) = f(x, y) + c[\nabla^2 f(x, y)]$，c 的符号与中心系数 $[f(x, y)]$ 的符号相反<ol>
<li>任意阶微分都是线性操作，$\nabla^2 f(x, y)$ 也是一个线性算子</li>
<li>将原图像和拉普拉斯图像叠加，可以复原背景特性并保持拉普拉斯锐化处理的结果（强调灰度的突变，并不强调灰度缓慢变化的区域）</li>
<li>通过拉普拉斯变换增强了图像中灰度突变处的对比度，使图像中的细节部分得到了增强，并良好地保留了图像的基本色调</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>非锐化掩蔽<ul>
<li>从原图像中减去一幅非锐化（平滑/模糊过的）图像 $\bar{f}(x, y) \leftarrow$ 高斯滤波器模糊</li>
<li>非锐化模板：$g_{mask}(x, y) = f(x, y) - \bar{f}(x, y)$</li>
<li>$g(x, y) =  f(x, y) + k * g_{mask}(x, y)$<ul>
<li>$k = 1$：非锐化掩蔽</li>
<li>$k \gt 1$：高提升滤波</li>
</ul>
</li>
</ul>
</li>
<li>梯度与 Sobel 算子<ul>
<li>梯度<ul>
<li>$\nabla f = grad(f) = \begin{bmatrix} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y} \end{bmatrix}$</li>
<li>$\nabla f $ 为向量，幅度值 $M(x, y) = mag(\nabla f) = \sqrt{g_x^2 + g_y^2}$，不是线性算子，因为做了平方和平方根操作</li>
<li>$\Longrightarrow M(x, y) ≈|g_x| + |g_y|$，仍保留灰度的相对变化，虽然通常丢失了方向性</li>
</ul>
</li>
<li>Sobel 算子<ul>
<li>$M(x, y) ≈|(z_7 + 2z_8 + z_9) - (z_1 + 2z_2 + z_3)| + |(z_3 + 2z_6 + z_9) - (z_1 + 2z_4 + z_7)|$</li>
<li>矩阵形式：$\begin{bmatrix} z_1 &amp; z_2 &amp; z_3 \\  z_4 &amp; z_5 &amp; z_6 \\  z_7 &amp; z_8 &amp; z_9 \end{bmatrix}$ $\begin{bmatrix} -1 &amp; -2 &amp; -1 \\  0 &amp; 0 &amp; 0 \\  1 &amp; 2 &amp; 1 \end{bmatrix}$ $\begin{bmatrix} -1 &amp; 0 &amp; 1 \\  -2 &amp; 0 &amp; 2 \\  -1 &amp; 0 &amp; 1 \end{bmatrix}$</li>
</ul>
</li>
</ul>
</li>
<li>应用多种互补的图像增强技术<ol>
<li><font color="green">拉普拉斯操作</font>作为一种二阶微分算子在图像细节增强方面，它是最好的，但这会导致产生比梯度操作更多的噪声</li>
<li><font color="green">梯度操作（Sobel 算子）</font>对噪声和小细节响应要比拉普拉斯变换操作的响应弱，而且可以通过<font color="green">均值滤波器</font>进行平滑而进一步降低</li>
<li>拉普拉斯图像与平滑处理后的梯度图像相乘，<font color="green">乘积</font>会保留灰度变化强烈区域的细节，同时降低灰度变化相对平坦区域的噪声</li>
<li>具有重要边缘内容的梯度图像，边缘要比拉普拉斯图像突出，乘积的关键目的：强边缘的优势和可见噪声的减少</li>
<li>锐化/平滑过程从感知方法上没有影响图像灰度的动态变化，通过<font color="green">幂律变换</font>可以增大锐化后图像的动态范围</li>
</ol>
</li>
</ul>
<h3 id="第4章-频率域滤波"><a href="#第4章-频率域滤波" class="headerlink" title="第4章 频率域滤波"></a>第4章 频率域滤波</h3><ul>
<li>一维连续<ul>
<li>傅里叶变换对<br>$ F(\mu) = \zeta\{f(t)\} = \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t}\, dt$<br>$ f(t) = \zeta^{-1}\{F(\mu)\} = \int_{-\infty}^{\infty} F(\mu) e^{j2\pi \mu t}\, d\mu$</li>
<li>卷积<br>$ f(t) \bigotimes h(t) = \int_{-\infty}^{\infty} f(\tau) h(t- \tau) \, d\tau = F(\mu)H(\mu) = \sum_{n=-\infty}^{\infty}f(n\Delta T)h(t - n\Delta T)$</li>
</ul>
</li>
<li>一维离散<ul>
<li>$f(t)$ 的 M 个样本组成集合 $\{f_n\} = f(x)$</li>
<li>$M$ 个复数离散值的傅里叶变换样本集合 ${f_m} = F(\mu)$<br>$ F(\mu) = \sum_{x=0}^{M-1} f(x) e^{-j2\pi \frac{\mu x}{M} }，\mu = 0, 1, 2, …, M-1$<br>$ f(x) = \frac{1}{M}\sum_{\mu =0}^{M-1} F(\mu) e^{j2\pi \frac{\mu x}{M} }，x = 0, 1, 2, …, M-1$</li>
</ul>
</li>
<li>二维<ul>
<li>连续<br>$ F(\mu, \nu) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x, y) e^{-j2\pi(\mu t + \nu z)}\, dt\, dz$<br>$ f(t, z) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(\mu, \nu) e^{j2\pi(\mu t + \nu z)}\, d\mu \, d\nu$</li>
<li>离散<br>$ F(\mu, \nu) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) e^{-j2\pi(\frac{\mu x}{M} + \frac{\nu y}{N})}$<br>$ f(x, y) = \frac{1}{MN}\sum_{\mu =0}^{M-1} \sum_{\nu =0}^{N-1} F(\mu, \nu) e^{j2\pi(\frac{\mu x}{M} + \frac{\nu y}{N})}$</li>
</ul>
</li>
<li>使用DFT时，图像和滤波器的大小必须相同<ol>
<li>$MxN$ 的图像 $f$</li>
<li>进行 $PxQ$ 填充成 $f_p$（$P\geq2M-1, Q\geq2N-1$）</li>
<li>$(-1)^{x+y}$ 乘以 $f_p$</li>
<li>$f_p$ 的傅里叶变换（DFT）生成 $F_p$</li>
<li>滤波器扩容成 $PxQ$，关于中心对称化后生成 $H(u, v)$</li>
<li>$H(u, v)F_p \Rightarrow G(u, v)$</li>
<li>计算 $G(u, v)$ 的 IDFT，得到 $\zeta^{-1}[G(u, v)]$</li>
<li>处理后得到图像 $g_p = \{ real[\zeta^{-1}[G(u, v)]] \}(-1)^{x+y}$</li>
<li>裁剪 $g_p$ 的前 M 行和前 N 列得到最终的结果</li>
</ol>
</li>
<li>空间模板 [转换]$\Longrightarrow$ 频率域滤波器 $H(u, v)$<ol>
<li>$h(x, y)$ 扩充成 $h_p(x, y)$</li>
<li>$(-1)^{x+y}$ 乘以 $h_p(x, y)$ 以便频率域滤波器“中心化”</li>
<li>计算上述结果的 DFT</li>
<li>滤波器 $H(u, v)$ 必须是纯虚函数，将得到的 DFT 实部置零</li>
<li>$H(u, v)$ 等于 $(-1)^{x+y}$ 乘以上述结果，隐含着 $h(x, y)$ 被移到 $h_p(x, y)$ 的中心</li>
</ol>
</li>
<li>傅里叶频谱<ul>
<li>傅里叶频谱中心点对应于空间域的平均灰度或背景灰度</li>
<li>从中心点离开，低频信息对应慢变化的分量，如大体轮廓，背景等平滑部分</li>
<li>进一步离开中心点，较高频率对应变化越来越快的灰度级，如边缘，细节，噪声</li>
</ul>
</li>
</ul>
<h3 id="第5章-图像复原与重建"><a href="#第5章-图像复原与重建" class="headerlink" title="第5章 图像复原与重建"></a>第5章 图像复原与重建</h3><ul>
<li>图像退化/复原过程的模型<ul>
<li>$G(u, v) = H(u, v)F(u, v) + N(u, v)$<center><img src="/img/CV/dip/restoration_model.png" width="580px"/></center></li>
</ul>
</li>
<li>图像增强 vs 图像复原<ul>
<li>图像增强主要是一个主观过程，首要目标是处理图像，使其比原始图像更适合于特定应用，如对比度增强</li>
<li>图像复原大部分过程是一个客观过程，利用退化现象的先验知识来重建或复原被退化的原始图像</li>
</ul>
</li>
<li>噪声模型<ul>
<li>高斯噪声<br><center><img src="/img/CV/dip/Noise_Gaussian.png" width="780px"/></center><ul>
<li>去噪：均值，中点</li>
</ul>
</li>
<li>瑞利噪声<br><center><img src="/img/CV/dip/Noise_Rayleigh.png" width="620px"/></center><ul>
<li>近似歪斜，比较胖</li>
<li>去噪：</li>
</ul>
</li>
<li>伽马噪声<br><center><img src="/img/CV/dip/Noise_Gamma.png" width="640px"/></center><ul>
<li>比较尖</li>
<li>去噪：</li>
</ul>
</li>
<li>指数噪声<br><center><img src="/img/CV/dip/Noise_Exp.png" width="580px"/></center><ul>
<li>去噪：</li>
</ul>
</li>
<li>均匀噪声<br><center><img src="/img/CV/dip/Noise_Uniform.png" width="580px"/></center><ul>
<li>去噪：中点</li>
</ul>
</li>
<li>脉冲噪声<br><center><img src="/img/CV/dip/Noise_Impulse.png" width="540px"/></center><ul>
<li>去噪：谐波均值，逆谐波均值，中值，最大值/最小值</li>
</ul>
</li>
<li>周期噪声<ul>
<li>傅里叶共轭点，近似圆</li>
<li>去噪：低通，带通……</li>
</ul>
</li>
<li>如何获取$ N(u, v) $？<ul>
<li>在图像的平坦区域取一小块自图像做直方图，与已有的噪声模型作对比</li>
</ul>
</li>
</ul>
</li>
<li>常见滤波器降噪情况<ul>
<li>高斯或者均匀随机噪声 $ \Longleftarrow  \begin{cases} 均值滤波平滑一幅图像中的局部变化，虽然模糊了结果，但降低了噪声 \cr 几何均值丢失的图像细节更少 \end{cases} $ </li>
<li>谐波均值对盐噪声较好，不适用于椒噪声，善于处理像高斯噪声</li>
<li>逆谐波均值，$ Q \gt 0 $，椒噪声；$ Q \lt 0 $，盐噪声；$ Q = 0 $为算数均值滤波</li>
<li>中值滤波器：比相同尺寸的线性平滑滤波器引起的模糊更小，在存在单极或双极脉冲噪声（椒噪声 and/or 盐噪声）的情况下，尤其有效</li>
<li>最大值降椒噪声，最小值降盐噪声</li>
<li>中点滤波器对于随机分布噪声工作得最好（高斯/均匀）</li>
</ul>
</li>
<li>高斯噪声和椒盐噪声混合的情况<ol>
<li>修正的阿尔法均值滤波器，降噪方面更好</li>
<li>算术均值和几何均值由于脉冲噪声的存在并没有起到良好的作用</li>
<li>使用中值滤波器重复地进行处理$\Longrightarrow$会使得图像变模糊，细节损失<br>$\Longrightarrow$ 自适应中值滤波器：<br><center><img src="/img/CV/dip/AdaptiveMidianFilter.png" width="580px"/></center><ul>
<li>A层确保$Z_{med}（Z_{min} \lt Z_{med} \lt Z_{max}）$ 不是脉冲，B层确保$Z_{xy}（Z_{min} \lt Z_{xy} \lt Z_{max}）$不是脉冲</li>
<li>动态增大窗口</li>
<li>不改变“中心灰度级”，减少图像中的失真</li>
<li>去除椒盐噪声（脉冲噪声），平滑其他非脉冲噪声，并减少诸如物体边界细化或粗化等失真</li>
</ul>
</li>
<li>自适应局部降噪降噪：$\hat{f}(x, y) = g(x, y) \frac{ \sigma^2_{\eta} }{ \sigma^2_L }[g(x, y) - m_L]$<ul>
<li>参数说明<ul>
<li>滤波器作用于局部区域$S_{xy}$</li>
<li>$\sigma^2_{\eta}$ ：污染 $f(x, y)$ 以形成 $g(x, y)$ 的噪声的方差</li>
<li>$m_L$ ：$S_{xy}$中像素的局部均值</li>
<li>$\sigma^2_L$ ：$S_{xy}$中像素的局部方差</li>
</ul>
</li>
<li>计算结果为局部均值或保留原始像素</li>
<li>高局部方差与边缘相关，因此能够保护边缘</li>
</ul>
</li>
</ol>
</li>
<li>逆滤波存在的问题<br>$$ \hat{F}(u, v) = F(u, v) + \frac{N(u, v)}{H(u, v)} $$<ul>
<li>$H(u, v)$ 为零或为非常小的值</li>
<li>解决问题的一种方法是限制滤波的频率，使其接近于频谱原点</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Books：&lt;a href=&quot;http://durant35.github.io/pdf/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(%E5%86%88%E8%90%A8%E9%9B%B7%E6%96%AF)%E4%B8%AD%E8%AF%91%E7%AC%AC%E4%B8%89%E7%89%88.pdf&quot; alt=&quot;数字图像处理（冈萨雷斯）&quot;&gt;数字图像处理（冈萨雷斯）&lt;/a&gt;&lt;br&gt;Codes：&lt;a href=&quot;https://github.com/Durant35/Courses/tree/master/dip&quot;&gt;https://github.com/Durant35/Courses/tree/master/dip&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第2章-数字图像基础&quot;&gt;&lt;a href=&quot;#第2章-数字图像基础&quot; class=&quot;headerlink&quot; title=&quot;第2章 数字图像基础&quot;&gt;&lt;/a&gt;第2章 数字图像基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;取样和量化&lt;/li&gt;
&lt;li&gt;空间和灰度分辨率&lt;ul&gt;
&lt;li&gt;空间分辨率：空间分辨率是图像在单位面积内像素的个数，表示了图像的空间细节分辨能力&lt;/li&gt;
&lt;li&gt;灰度分辨率：灰度分辨率指的是在纯黑和纯白之间灰度级别的多少，指的是图像对灰度变化细节的分辨能力
    
    </summary>
    
      <category term="CV" scheme="http://durant35.github.io/categories/CV/"/>
    
      <category term="dip" scheme="http://durant35.github.io/categories/CV/dip/"/>
    
    
      <category term="CV" scheme="http://durant35.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令小纸条</title>
    <link href="http://durant35.github.io/2017/02/04/linux_Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BA%B8%E6%9D%A1/"/>
    <id>http://durant35.github.io/2017/02/04/linux_Linux命令小纸条/</id>
    <published>2017-02-04T07:20:59.000Z</published>
    <updated>2017-03-20T09:13:00.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压缩-解压"><a href="#压缩-解压" class="headerlink" title="压缩/解压"></a>压缩/解压</h3><ul>
<li><strong>tar</strong> 压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -zcvf dst.tar.gz /src-dir</div></pre></td></tr></table></figure>
<ul>
<li><strong>tar</strong> 解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -xvf src.tar.gz</div></pre></td></tr></table></figure>
<ul>
<li><strong>zip</strong> 压缩<a id="more"></a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ zip -r dst.zip /src-dir</div></pre></td></tr></table></figure>
<ul>
<li><strong>zip</strong> 解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unzip src.zip <span class="_">-d</span> .</div></pre></td></tr></table></figure>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul>
<li><strong>scp</strong> 上传</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp  -P port-number -rp host-path-src user@remote:/path-dst</div></pre></td></tr></table></figure>
<ul>
<li><strong>scp</strong> 下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp -r user@remote:/path-src host-path-dst</div></pre></td></tr></table></figure>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul>
<li>查看进程信息（如：<strong>PID</strong>）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps -aux [| grep key-word]</div></pre></td></tr></table></figure>
<ul>
<li>查看 线程-资源 使用情况</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ top -c <span class="_">-d</span> 1</div></pre></td></tr></table></figure>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul>
<li><strong>端口</strong> 占用情况</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ netstat -anp [| grep target-port]</div></pre></td></tr></table></figure>
<ul>
<li>查看监听端口<center><img src="/img/programPearls/linux/netstat.jpg" alt="netstat" width="720px"/></center>

</li>
</ul>
<h3 id="挂载-解挂"><a href="#挂载-解挂" class="headerlink" title="挂载/解挂"></a>挂载/解挂</h3><ul>
<li>解挂</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo umount <span class="_">-l</span> mount-dir</div></pre></td></tr></table></figure>
<ul>
<li>挂载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看挂载设备 /dev/sd?</span></div><div class="line">$ sudo fdisk <span class="_">-l</span></div><div class="line"><span class="comment"># 需要时创建挂载点</span></div><div class="line">$ mkdir mount-point-dir</div><div class="line"><span class="comment"># 挂载设备</span></div><div class="line">$ sudo mount /dev/sd? mount-point-dir</div></pre></td></tr></table></figure>
<h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><ul>
<li>文件名查找</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find <span class="string">"name-string"</span> find-path</div></pre></td></tr></table></figure>
<ul>
<li>文件内容查找</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grep -r -i <span class="string">"content-string"</span> find-path</div></pre></td></tr></table></figure>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>批量重命名（<strong>*.cpp</strong>全部变成<strong>*.c</strong>）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># "\" 指代相同内容</span></div><div class="line">$ rename -v s/\.cpp/\.c/ *</div></pre></td></tr></table></figure>
<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul>
<li>内核版本信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ uname -r</div></pre></td></tr></table></figure>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul>
<li>查看文件权限信息（注意文件夹和文件的区别）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ls -al</div><div class="line">total 36</div><div class="line">drwxrwxr-x 8 gary gary 4096 3月  17 15:19 .</div><div class="line">drwxrwxr-x 4 gary gary 4096 3月   9 14:13 ..</div><div class="line">drwxrwxr-x 3 gary gary 4096 3月  19 14:38 carControl</div><div class="line">-rw-rw-rw- 1 gary gary 1029 3月   9 14:15 emergencyBrake.ino</div><div class="line">[   权限 ][link][拥有者][群组][文件容量][修改日期][    文件名     ]</div></pre></td></tr></table></figure>
<p><center><img src="/img/programPearls/linux/file_permission.png" alt="file permission" width="540px"/></center></p>
<ul>
<li>修改文件<code>rwx</code>权限，常见的有：777（所有权限）；666（可读写）；用户可执行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo chmod 777 [-R] file-name</div><div class="line">$ sudo chmod u+x file-name</div></pre></td></tr></table></figure>
<ul>
<li>文件拥有者:群组</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo chown owner:group file-name</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;压缩-解压&quot;&gt;&lt;a href=&quot;#压缩-解压&quot; class=&quot;headerlink&quot; title=&quot;压缩/解压&quot;&gt;&lt;/a&gt;压缩/解压&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tar&lt;/strong&gt; 压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ tar -zcvf dst.tar.gz /src-dir&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tar&lt;/strong&gt; 解压&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ tar -xvf src.tar.gz&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;zip&lt;/strong&gt; 压缩
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Linux" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Linux/"/>
    
    
      <category term="CMD" scheme="http://durant35.github.io/tags/CMD/"/>
    
      <category term="Linux" scheme="http://durant35.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vim几步走</title>
    <link href="http://durant35.github.io/2017/02/04/tool_vim%E5%87%A0%E6%AD%A5%E8%B5%B0/"/>
    <id>http://durant35.github.io/2017/02/04/tool_vim几步走/</id>
    <published>2017-02-04T06:07:18.000Z</published>
    <updated>2017-03-31T07:14:06.624Z</updated>
    
    <content type="html"><![CDATA[<p>　通过 <strong>sudo apt-get install vim</strong> 即可安装 <strong>vim</strong>，也能通过 <a href="https://github.com/amix/vimrc">vimrc</a> 之类安装大神们的各种自适配的高级 <strong>vim</strong>。<br>　本文旨在记录开发过程中用过的 <strong>vim</strong> 操作。　　<br><a id="more"></a></p>
<blockquote>
<p>Reference: <a href="http://www.cnblogs.com/wsine/p/5517005.html">Wsnie’s Linux之Vim学习</a></p>
</blockquote>
<h3 id="一般模式下的常见操作"><a href="#一般模式下的常见操作" class="headerlink" title="一般模式下的常见操作"></a>一般模式下的常见操作</h3><ul>
<li>光标移动</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">j或down方向键</td>
<td style="text-align:center">向下移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">k或up方向键</td>
<td style="text-align:center">向上移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">h或left方向键</td>
<td style="text-align:center">向左移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">l或right方向键</td>
<td style="text-align:center">向右移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+f或PageUp键</td>
<td style="text-align:center">屏幕向前移动一页</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b或PageDown键</td>
<td style="text-align:center">屏幕向后移动一页</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">向后移动一个词</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">向前移动一个词</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">向后移动一个词到词尾</td>
</tr>
<tr>
<td style="text-align:center">ge</td>
<td style="text-align:center">向前移动一个词到词头</td>
</tr>
<tr>
<td style="text-align:center">g_</td>
<td style="text-align:center">到本行最后一个不是blank字符的位置</td>
</tr>
<tr>
<td style="text-align:center">0或Shift+6</td>
<td style="text-align:center">移动到行首</td>
</tr>
<tr>
<td style="text-align:center">$或Shift+4</td>
<td style="text-align:center">移动到行尾</td>
</tr>
<tr>
<td style="text-align:center">gg</td>
<td style="text-align:center">移动到首行</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">移动到尾行</td>
</tr>
<tr>
<td style="text-align:center">nG</td>
<td style="text-align:center">移动到第n行</td>
</tr>
</tbody>
</table>
<ul>
<li>增删改查</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">向后删除一个字符</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">向前删除一个字符</td>
</tr>
<tr>
<td style="text-align:center">dd</td>
<td style="text-align:center">删除/剪切当前所在的行</td>
</tr>
<tr>
<td style="text-align:center">ndd</td>
<td style="text-align:center">删除/剪切当前行及其之后的共n行</td>
</tr>
<tr>
<td style="text-align:center">dw</td>
<td style="text-align:center">向后删除一个词</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">在当前字符前插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">在当前字符后插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">在当前行的行首插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">在当前行的行尾插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">在当前行的下一行插入新的一行，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">在当前行的上一行插入新的一行，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">再输入一个字符，向后替换一个字符</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">连续输入字符，向后连续替换字符，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">yy</td>
<td style="text-align:center">复制当前行</td>
</tr>
<tr>
<td style="text-align:center">nyy</td>
<td style="text-align:center">在当前行开始，向下复制n行</td>
</tr>
<tr>
<td style="text-align:center">np</td>
<td style="text-align:center">在当前行开始，向下粘贴已经复制的内容n次</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">在当前行开始，向上粘贴已经复制的内容</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">进入选定模式，移动光标选定字符，可复制剪切删除，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">还原上一步的操作</td>
</tr>
</tbody>
</table>
<h3 id="命令模式下的常见操作"><a href="#命令模式下的常见操作" class="headerlink" title="命令模式下的常见操作"></a>命令模式下的常见操作</h3><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/word</td>
<td style="text-align:center">向后搜索字符串word，按n继续搜索</td>
</tr>
<tr>
<td style="text-align:center">?word</td>
<td style="text-align:center">向前搜索字符串word，按n继续搜索</td>
</tr>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">保存文本</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">退出</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">放弃修改，强制退出</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">保存并退出</td>
</tr>
</tbody>
</table>
<h3 id="我的典型操作"><a href="#我的典型操作" class="headerlink" title="我的典型操作"></a>我的典型操作</h3><table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0y$</td>
<td style="text-align:center">拷贝当前行</td>
</tr>
<tr>
<td style="text-align:center">ye</td>
<td style="text-align:center">从当前位置拷贝到本单词的最后一个字符</td>
</tr>
<tr>
<td style="text-align:center">gU</td>
<td style="text-align:center">变大写</td>
</tr>
<tr>
<td style="text-align:center">gu</td>
<td style="text-align:center">变小写</td>
</tr>
<tr>
<td style="text-align:center">在 Insert 模式下，你可以输入一个词的开头，按如下组合键，ctrl+x ctrl+n 或者 ctrl+x ctrl+p</td>
<td style="text-align:center">自动补齐</td>
</tr>
<tr>
<td style="text-align:center">v<strong>→</strong>d/y<strong>→</strong>p</td>
<td style="text-align:center">剪切/复制粘贴</td>
</tr>
</tbody>
</table>
<h3 id="第三方参考"><a href="#第三方参考" class="headerlink" title="第三方参考"></a>第三方参考</h3><ul>
<li>RiHui-Song’s Blog 的 <a href="https://rh-song.github.io/2016/07/15/vim/#more">本文意在记录vim的使用以及相关的配置</a><ul>
<li>在linux下vim中文出现乱码问题</li>
<li>vim：MarkDown preview</li>
<li>vim添加markdown语法高亮</li>
</ul>
</li>
<li><a href="http://coolshell.cn/articles/5426.html">简明 VIM 练级攻略</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　通过 &lt;strong&gt;sudo apt-get install vim&lt;/strong&gt; 即可安装 &lt;strong&gt;vim&lt;/strong&gt;，也能通过 &lt;a href=&quot;https://github.com/amix/vimrc&quot;&gt;vimrc&lt;/a&gt; 之类安装大神们的各种自适配的高级 &lt;strong&gt;vim&lt;/strong&gt;。&lt;br&gt;　本文旨在记录开发过程中用过的 &lt;strong&gt;vim&lt;/strong&gt; 操作。　　&lt;br&gt;
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="小工具" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vim" scheme="http://durant35.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Summer-trainning in July, 2016</title>
    <link href="http://durant35.github.io/2017/02/04/TACourses_Summer-trainning-in-July,2016/"/>
    <id>http://durant35.github.io/2017/02/04/TACourses_Summer-trainning-in-July,2016/</id>
    <published>2017-02-04T03:21:01.000Z</published>
    <updated>2017-02-04T06:05:48.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>摘自 <a href="https://rh-song.github.io/2016/07/18/Summer-training/#more">RiHui-Song’s Blog：Summer-training</a></p>
</blockquote>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>　本文主要记录SMIE最后一次初级实训学习的主要内容。包括了大概是三个阶段：</p>
<ul>
<li>准备阶段：学习测量仪器，回顾C语言编程；</li>
<li>熟悉阶段：在FPGA上运行HelloWorld，开发小应用，如跑马灯等，最后还了解了uc/os这样一个实时操作系统；</li>
<li>开发阶段：使用PWM波以及H桥控制车轮，使用超声模块控制让小车感知外界状况，从而进行控制，最后可以使用PID控制理论优化小车的控制。<a id="more"></a>
</li>
</ul>
<h3 id="学习仪器"><a href="#学习仪器" class="headerlink" title="学习仪器"></a>学习仪器</h3><ul>
<li>学会使用示波器，可以用来观察从ADC，PWM波等等信号。</li>
<li>学会使用万用表测电压，电阻，电流。<center><img src="/img/TA-Cources/Summer-training2016/Oscilloscope.png" width="420px"/></center>

</li>
</ul>
<h3 id="回顾c语言编程"><a href="#回顾c语言编程" class="headerlink" title="回顾c语言编程"></a>回顾c语言编程</h3><ul>
<li>条件判断</li>
<li>循环：for loop &amp; while loop</li>
<li>数组：<ul>
<li>使用下标访问</li>
<li>使用指针访问</li>
</ul>
</li>
<li>函数使用：<ul>
<li>递归</li>
<li>迭代</li>
</ul>
</li>
<li>链表：<ul>
<li>结构体声明和使用</li>
<li>指针使用</li>
<li>链表结构和基本操作</li>
</ul>
</li>
<li>位操作<ul>
<li>位操作将十进制表示成二进制数</li>
<li>位操作实现某一位的反转，或者某一位不变其它位反转等</li>
</ul>
</li>
</ul>
<h3 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h3><ul>
<li>使用header file，source file以及main file。尝试尽可能的复用。</li>
<li>C语言与安全性<ul>
<li>数组越界</li>
<li>判断逻辑不全</li>
<li>变量没有初始化</li>
<li>内存泄露</li>
<li>没有考虑非法输入</li>
</ul>
</li>
</ul>
<h3 id="FPGA编程"><a href="#FPGA编程" class="headerlink" title="FPGA编程"></a>FPGA编程</h3><ul>
<li>FPGA：DE0-Nano board<center><img src="/img/TA-Cources/Summer-training2016/DE0-Nano.jpg" width="340px"/></center></li>
<li>使用自带软件测试FPGA完好</li>
<li>在FPGA上运行HelloWorld工程</li>
<li>实现LED Sliding Pattern（闪烁模式之类）</li>
<li>使用中断<ul>
<li>中断的原理和运行机制</li>
</ul>
</li>
</ul>
<h3 id="FPGA上编程进阶"><a href="#FPGA上编程进阶" class="headerlink" title="FPGA上编程进阶"></a>FPGA上编程进阶</h3><ul>
<li>在IDE：eclipse上进行Debug</li>
<li>ADC:<ul>
<li>FPDA上有一个ADC的硬件模块</li>
</ul>
</li>
</ul>
<h3 id="PWM-Pulse-Width-Modulation"><a href="#PWM-Pulse-Width-Modulation" class="headerlink" title="PWM(Pulse Width Modulation)"></a>PWM(Pulse Width Modulation)</h3><ul>
<li>Duty cycle 占空比<center><img src="/img/TA-Cources/Summer-training2016/what_is_PWM.png"  width="640px"/></center></li>
<li>Why PWM?<ul>
<li>Digital voltage control: 只能控制1和0</li>
<li>需要最大电压的x%则让占空比为x%</li>
</ul>
</li>
<li>产生PWM的方法：<ul>
<li>软件方法<ul>
<li>使用计数器</li>
<li>使用中断？</li>
</ul>
</li>
<li>硬件方法<ul>
<li>Hardware PWM IP &lt;– NIOS core</li>
<li>moto_setting(),能产生2个PWM波</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="H桥"><a href="#H桥" class="headerlink" title="H桥"></a>H桥</h3><ul>
<li>低电流做控制，产生大电流去驱动电机</li>
<li>PWM波控制H桥驱动电机，使小车前进，后退，转弯等<center><img src="/img/TA-Cources/Summer-training2016/H-Bridge.png"  width="720px"/></center>

</li>
</ul>
<h3 id="超声模块"><a href="#超声模块" class="headerlink" title="超声模块"></a>超声模块</h3><ul>
<li>超声模块是：KS103<br><center><img src="/img/TA-Cources/Summer-training2016/KS103.png"  width="360px"/></center><ul>
<li>VCC: Power Pin</li>
<li>SDA/TX: data pin in I2C bus/TX pin in uart bus</li>
<li>SCL/RX: clock pin in I2C bus/RX pin in uart bus</li>
<li>GND: power ground pin</li>
<li>Mode: Select the communication mode.<ul>
<li>High Level(VCC): I2C</li>
<li>Low Level (GND): Uart</li>
</ul>
</li>
</ul>
</li>
<li>使用流程：<center><img src="/img/TA-Cources/Summer-training2016/how_to_use_KS103.png"  width="480px"/></center></li>
<li>接线：<ul>
<li>使用Uart模式：<ul>
<li>超声TX接入FPGA的RX，超声的RX接入FPGA的TX</li>
</ul>
</li>
<li>使用I2C模式：<ul>
<li>data pin &amp; clock pin</li>
</ul>
</li>
</ul>
</li>
<li>编程时的端口查找：<ul>
<li>结合QSF文件以及FPGA用户手册</li>
</ul>
</li>
</ul>
<h3 id="uc-OS-实时嵌入式操作系统"><a href="#uc-OS-实时嵌入式操作系统" class="headerlink" title="uc/OS 实时嵌入式操作系统"></a>uc/OS 实时嵌入式操作系统</h3><ul>
<li>以上都是bare metal hardware（裸跑）上编程，然后编译我们需要的程序</li>
<li>如果需要完成复杂的多任务，可以考虑跑在一个操作系统上（嵌入式操作系统，如uc/OS）<ul>
<li>多任务（线程）</li>
<li>信号量</li>
<li>临界区访问<center><img src="/img/TA-Cources/Summer-training2016/uc-OS.png"  width="480px"/></center>

</li>
</ul>
</li>
</ul>
<h3 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h3><ul>
<li>p：比例系数，I：积分系数，D：微分系数</li>
<li>使用PI控制，因为高阶噪声，所以不使用D</li>
<li>如下图，其中e(t) = r(t) - y(t)<center><img src="/img/TA-Cources/Summer-training2016/PID.png"  width="480px"/></center>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘自 &lt;a href=&quot;https://rh-song.github.io/2016/07/18/Summer-training/#more&quot;&gt;RiHui-Song’s Blog：Summer-training&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;　本文主要记录SMIE最后一次初级实训学习的主要内容。包括了大概是三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段：学习测量仪器，回顾C语言编程；&lt;/li&gt;
&lt;li&gt;熟悉阶段：在FPGA上运行HelloWorld，开发小应用，如跑马灯等，最后还了解了uc/os这样一个实时操作系统；&lt;/li&gt;
&lt;li&gt;开发阶段：使用PWM波以及H桥控制车轮，使用超声模块控制让小车感知外界状况，从而进行控制，最后可以使用PID控制理论优化小车的控制。
    
    </summary>
    
      <category term="TA Cources" scheme="http://durant35.github.io/categories/TA-Cources/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo，md源文件内容修改预览页面刷新无效</title>
    <link href="http://durant35.github.io/2017/02/02/hexo-md%E6%BA%90%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%BF%AE%E6%94%B9%E9%A2%84%E8%A7%88%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%97%A0%E6%95%88/"/>
    <id>http://durant35.github.io/2017/02/02/hexo-md源文件内容修改预览页面刷新无效/</id>
    <published>2017-02-02T12:42:12.000Z</published>
    <updated>2017-02-02T15:02:38.380Z</updated>
    
    <content type="html"><![CDATA[<p>　　之前在 <strong>Window</strong> 下面通过 <strong>hexo s</strong> 启动本地服务器，通过浏览器预览，对md源文件的当前修改能够通过网页刷新出来。这段时间在 <strong>Linux</strong> 上部署，就一直出现刷新页面无效的情况，必须重新启动服务器才能刷新，有时甚至还需要通过 <strong>hexo g</strong> 重新解析源文件才能成功刷新。之前有段时间也以为是 <strong>Linux</strong> 对带有中文名称的md源文件支持不好的缘故，因为将那些不能成功刷新的源文件的文件名修改下，去掉所有的中文字符后，就可以刷新有效了。</p>
<p>　　不过，今天尝试了这个方法，居然不行了，不知道是不是因为升级了 <strong>Hexo</strong> 的缘故，不过，却发现了更有效的解决方法，可以不用考虑源文件文件名的问题。</p>
<a id="more"></a>
<p>　　解决办法很简单，就是通过使用 <strong>hexo generate</strong> 的 <strong>watch</strong> 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g --watch</div></pre></td></tr></table></figure></p>
<p>　　开启 <strong>hexo generate</strong> 的实时监控，对当前修改的源文件进行实时解析，这样浏览器刷新预览的就是最新的源文件解析的结果了。<br>　　<br>　　注意：<br>　　+ 使用 <strong>Typora</strong>编辑器 <strong>Hexo</strong> 的md源文件进行编写，在上述操作中会有奇怪的现象，详见 <a href="https://github.com/hexojs/hexo/issues/2245">hexo server 运行时自动更新出错把页面文章全部清空</a>。<br>　　+ <strong>hexo s</strong> 命令好像默认是会自动开启 <strong>hexo generate</strong> 的实时监控，上述操作显得画蛇添足；不过，万一像我一样呢？可能你就需要尝试一下上面的命令了。<br>　　+ 笔者最后放弃了 <strong>Typora</strong>编辑器，也没选择安装 <strong>Markdown</strong> 预览插件的 <strong>Sublime Text</strong>，而是选择了<a href="https://remarkableapp.github.io/linux/download.html">Remarkable</a>，下载官网提供的.deb，按照下面命令即可安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo dpkg -i remarkable_*.deb</div><div class="line">$ sudo apt-get install -f</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　之前在 &lt;strong&gt;Window&lt;/strong&gt; 下面通过 &lt;strong&gt;hexo s&lt;/strong&gt; 启动本地服务器，通过浏览器预览，对md源文件的当前修改能够通过网页刷新出来。这段时间在 &lt;strong&gt;Linux&lt;/strong&gt; 上部署，就一直出现刷新页面无效的情况，必须重新启动服务器才能刷新，有时甚至还需要通过 &lt;strong&gt;hexo g&lt;/strong&gt; 重新解析源文件才能成功刷新。之前有段时间也以为是 &lt;strong&gt;Linux&lt;/strong&gt; 对带有中文名称的md源文件支持不好的缘故，因为将那些不能成功刷新的源文件的文件名修改下，去掉所有的中文字符后，就可以刷新有效了。&lt;/p&gt;
&lt;p&gt;　　不过，今天尝试了这个方法，居然不行了，不知道是不是因为升级了 &lt;strong&gt;Hexo&lt;/strong&gt; 的缘故，不过，却发现了更有效的解决方法，可以不用考虑源文件文件名的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="Hexo" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://durant35.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>RaspberryPi, Use an external wireless card(ComFast-WU855P)</title>
    <link href="http://durant35.github.io/2017/01/25/raspberry_using_an_external_wireless_card(CF-WU855P)/"/>
    <id>http://durant35.github.io/2017/01/25/raspberry_using_an_external_wireless_card(CF-WU855P)/</id>
    <published>2017-01-24T16:52:41.000Z</published>
    <updated>2017-02-03T07:00:54.057Z</updated>
    
    <content type="html"><![CDATA[<p>　　树莓派3已经自带无线网卡，这是一种极大的便捷，真正将树莓派变成躲在一个角落里，安静地搞事情的计算机。然而对于树莓派B+或者树莓派2，除了少数免驱的外接无线网卡外（树莓派系统已经自带了驱动），大多数外接无线网卡还是需要经过配置才能使用的，下面就介绍使用过的一款无线网卡（<a href="http://en.comfast.com.cn/product/WirelessAdapter/item-155.html">ComFast-WU855P</a>）的驱动配置过程，该无线网卡采用 <strong>REALTEK8192</strong> 高阶芯片（从<a href="https://detail.tmall.com/item.htm?spm=a230r.1.14.1.JY6QbF&amp;id=37237024789&amp;cm_id=140105335569ed55e27b&amp;abbucket=6&amp;skuId=57539293852">淘宝</a>上了解到的，不知道对不对），这是一款常用的芯片，本文安装的驱动理论上对采用该芯片的无线网卡都是可用的。</p>
<a id="more"></a>
<h4 id="COMFAST-WU855P"><a href="#COMFAST-WU855P" class="headerlink" title="COMFAST-WU855P"></a>COMFAST-WU855P</h4><p>　　本文使用的是与下图这款无线网卡类似的 <strong>COMFAST </strong> 的一款无线网卡产品。</p>
<center><img src="/img/raspberrypi/COMFAST.jpg" width="320px"/></center>

<h4 id="以内核模块的形式编译安装RTL8192驱动"><a href="#以内核模块的形式编译安装RTL8192驱动" class="headerlink" title="以内核模块的形式编译安装RTL8192驱动"></a>以内核模块的形式编译安装RTL8192驱动</h4><blockquote>
<p>Reference：<a href="http://www.geek-workshop.com/thread-16077-1-1.html">树莓派2编译天猫魔盘驱动（8192eu）</a></p>
</blockquote>
<p>　　注意，下面的所有操作都是通过 <strong>ssh</strong> 直接在树莓派上进行构建，所以相对耗时。通过交叉编译环境进行构建则速度明显加快，不过配置交叉编译环境过程也不是那么简单，有兴趣的同学可以尝试一下。<br>　　具体的步骤如下：</p>
<ol>
<li><p>下载内核源代码，为编译 <strong>RTL8192</strong> 驱动模块做准备</p>
<ul>
<li>下载 <strong>rpi-source</strong> 程序</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/Workspace</div><div class="line">$ mkdir wireless &amp;&amp; <span class="built_in">cd</span> wireless</div><div class="line">$ wget https://raw.githubusercontent.com/notro/rpi-source/master/rpi-source</div><div class="line">$ chmod a+x rpi-source</div></pre></td></tr></table></figure>
<ul>
<li>运行 <strong>rpi-source</strong>，这个程序会根据当前内核信息去官方github上下载相应的源码，下载根据网络需要一些时间（我大概等了15分钟）。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./rpi-source</div></pre></td></tr></table></figure>
<ul>
<li>下载程序需要一些依赖，根据提示通过 <strong>apt-get</strong> 安装即可，</li>
</ul>
<blockquote>
<p>ERROR:<br><strong>bc is NOT installed. Needed by ‘make modules_prepare’. On Raspbian, run ‘sudo apt-get install bc’ to install it.</strong><br><strong>*** ncurses-devel is NOT installed. Needed by ‘make menuconfig’. On Raspbian sudo apt-get install libncurses5-dev</strong><br>　　<br>这里我就需要安装下面几个依赖：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get install bc</div><div class="line">$ sudo apt-get install libncurses5-dev</div><div class="line">$ ./rpi-source</div></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>下载程序运行中间的部分打印信息如下：</li>
</ul>
<blockquote>
<p><strong>Saving to: ‘/home/pi/linux-fa00f31867d8f7b7bb2ad2eb6c35f32fa468ca1e.tar.gz’</strong><br><strong>/home/pi/linux-fa     [          &lt;=&gt;   ] 129.96M  1.92MB/s   in 73s</strong><br><strong>2017-02-03 05:46:58 (1.79 MB/s) - ‘/home/pi/linux-fa00f31867d8f7b7bb2ad2eb6c35f32fa468ca1e.tar.gz’ saved [136269962]</strong><br><strong>Unpack kernel source…</strong><br><strong>*** Create symlink: /home/pi/linux</strong><br><strong>*** Create /lib/modules/<ver>/{build,source} symlinks</strong><br><strong>*** Kernel source already installed: /home/pi/linux-fa00f31867d8f7b7bb2ad2eb6c35f32fa468ca1e</strong></p>
</blockquote>
<p>因此会在 <strong>“~ 目录”</strong> 下看到（如下图），此外还创建了一些快捷方式，总之，就是为下一步编译内核模块做好准备。</p>
<center><img src="/img/raspberrypi/rpi-source_result.png" width="420px"/></center></li>
<li><p>获取 <strong>RTL8192</strong> 驱动源代码，构建并安装  <strong>RTL8192</strong> 内核模块</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/wireless</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/Mange/rtl8192eu-linux-driver.git</div><div class="line"><span class="comment"># or</span></div><div class="line"><span class="comment"># git clone https://github.com/pvaret/rtl8192cu-fixes.git</span></div><div class="line">$ <span class="built_in">cd</span> &lt;your-git-clone-driver&gt;</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
<p>注：亲测两个仓库的代码都可以编译构建。</p>
<ul>
<li>可能会出现的问题</li>
</ul>
<blockquote>
<p>Makefile:616: arch/armv6l/Makefile: No such file or directory<br>make[1]: *** No rule to make target ‘arch/armv6l/Makefile’.  Stop.<br>make[1]: Leaving directory ‘/home/pi/linux-fa00f31867d8f7b7bb2ad2eb6c35f32fa468ca1e’<br>Makefile:1335: recipe for target ‘modules’ failed<br>make: *** [modules] Error 2</p>
</blockquote>
<ul>
<li>解决的方法是，根据提示创建通过 <strong>arch/armv6l</strong> 到 <strong>arm</strong> 的软链接，</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># `uname -r`是uname -r命令返回的结果，会自适应到不同的内核版本</span></div><div class="line">$ <span class="built_in">cd</span> /lib/modules/`uname -r`/build</div><div class="line"><span class="comment"># 根据错误提示，参考博文是作 **arch/armv7l** 的软连接，我这里是 **arch/armv6l**</span></div><div class="line">$ ln -sf arm arch/armv6l</div></pre></td></tr></table></figure>
<ul>
<li>顺利进行编译构建（树莓派B+大约需要17分钟），然后安装到系统目录下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> &lt;your-git-clone-driver&gt;</div><div class="line">$ make</div><div class="line">$ sudo make install</div></pre></td></tr></table></figure>
</li>
<li><p>加载  <strong>RTL8192</strong> 内核模块</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo modprobe 8192eu</div></pre></td></tr></table></figure>
<p>然后，插上USB无线网卡，<strong>ifconfig</strong> 或者 <strong>iwconfig</strong> 应该可以看到 <strong>wlan0</strong>，如下图：</p>
<center><img src="/img/raspberrypi/wireless_result.png" width="540px"/></center>

</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　树莓派3已经自带无线网卡，这是一种极大的便捷，真正将树莓派变成躲在一个角落里，安静地搞事情的计算机。然而对于树莓派B+或者树莓派2，除了少数免驱的外接无线网卡外（树莓派系统已经自带了驱动），大多数外接无线网卡还是需要经过配置才能使用的，下面就介绍使用过的一款无线网卡（&lt;a href=&quot;http://en.comfast.com.cn/product/WirelessAdapter/item-155.html&quot;&gt;ComFast-WU855P&lt;/a&gt;）的驱动配置过程，该无线网卡采用 &lt;strong&gt;REALTEK8192&lt;/strong&gt; 高阶芯片（从&lt;a href=&quot;https://detail.tmall.com/item.htm?spm=a230r.1.14.1.JY6QbF&amp;amp;id=37237024789&amp;amp;cm_id=140105335569ed55e27b&amp;amp;abbucket=6&amp;amp;skuId=57539293852&quot;&gt;淘宝&lt;/a&gt;上了解到的，不知道对不对），这是一款常用的芯片，本文安装的驱动理论上对采用该芯片的无线网卡都是可用的。&lt;/p&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="RaspberryPi" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/RaspberryPi/"/>
    
    
  </entry>
  
  <entry>
    <title>RaspberryPi, enable ssh without UI</title>
    <link href="http://durant35.github.io/2017/01/25/raspberry_enable-ssh-without-UI/"/>
    <id>http://durant35.github.io/2017/01/25/raspberry_enable-ssh-without-UI/</id>
    <published>2017-01-24T16:48:58.000Z</published>
    <updated>2017-02-03T06:41:27.905Z</updated>
    
    <content type="html"><![CDATA[<p>　　可能是我写录的树莓派系统image有问题吧，小伙伴都说默认应该是打开22端口，支持ssh的；但是我做的几张SD卡的系统都是不打开的，我很纳闷，怀疑用的是假的镜像吧。前几次都发生在实验室，显示器，HDMI线应有尽有，启动系统，简单地通过界面在系统的 <strong>Preferences</strong> 中开启ssh端口即可。然而这一次，发生在家里（因为之前一直没空写个关于树莓派外置无线网卡驱动安装的教程，想着利用寒假回家弄一弄），家里哪有实验室那么好的环境，所以，甭想通过界面操作开启。</p>
<p>　　那究竟能不能通过直接修改SD卡里面的image文件内容，不用UI的方式，开启ssh端口呢？通过下面的捣鼓发现，这是可行的。</p>
<a id="more"></a> 
<h4 id="SD卡里面就保存着树莓派系统"><a href="#SD卡里面就保存着树莓派系统" class="headerlink" title="SD卡里面就保存着树莓派系统"></a>SD卡里面就保存着树莓派系统</h4><p>　　SD卡里面有两个分区，系统文件保存在非 <strong>boot</strong> 分区中，如下图：</p>
<center><img src="/img/raspberrypi/sd_card.png" width="480px"/></center><br>　　<strong>/usr/bin/raspi-config</strong> 就是树莓派<strong>Preferences</strong>操作对应的配置文件，我们用编辑器（Sublime-Text）打开该文件，<strong>CTRL+F</strong> 找到与 <strong>ssh</strong> 配置相关的部分，即下图显示的 <strong>do_ssh()</strong>。通过<strong>enable</strong>和<strong>start</strong>字段可以推测，该部分的两条命令应该是对应于界面操作里面勾选启用<strong>ssh</strong>对应的操作，通过这两条命令，应该可以开启系统的<strong>ssh</strong>端口！<br><br><center><img src="/img/raspberrypi/raspi-config.jpg" width="360px"/></center>

<h4 id="将开启端口命令自启动"><a href="#将开启端口命令自启动" class="headerlink" title="将开启端口命令自启动"></a>将开启端口命令自启动</h4><p>　　我的想法是，要不让这两条命令开机启动吧，看看上一步的猜测是不是真的有效。<strong>/etc/rc.local</strong> 是配置系统自启动的文件，我们将与开启<strong>ssh</strong>端口相关的两条命令添加到 <strong>exit 0</strong> 之前，如下图所示。</p>
<center><img src="/img/raspberrypi/rc.local.jpg" width="360px"/></center>

<h4 id="nmap来检测"><a href="#nmap来检测" class="headerlink" title="nmap来检测"></a>nmap来检测</h4><p>　　上面的操作真的能得偿所愿吗？我们需要验证一下，看能否<strong>ssh</strong>进去已经启动的树莓派系统。然而问题又来了，树莓派的<strong>ip</strong>是哪一个呀？很不幸，我的树莓派是插在小米3路由器，笔记本连着小米3路由器的无线网络，不过，小米3路由器是通过无线桥接到一个信号还不错，通过<strong>WiFi万能钥匙</strong> 破解出密码的不知道是邻居哪家里面的网。无线桥接，<strong>DHCP</strong>全都由桥接的路由器管理，小弟不才，撞不出人家的管理密码。咋办呢？这里介绍一个强大的工具，<strong><a href="http://blog.csdn.net/keepsmi1e/article/details/9370049">nmap</a></strong>。</p>
<p>　　通过下面的命令可以扫描出局域网内所有的ip地址（进行ping扫描，打印出对扫描做出响应的主机，这里通过笔记本的ip可以知道整个局域网是192.168.1.0网段）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ nmap -sP 192.168.1.0/24</div></pre></td></tr></table></figure>
<p>　　然后，把树莓派一拔一插，对比前后两次打印的ip地址列表的情况，就能找出树莓派的ip地址了。</p>
<p>　　也可以通过 <strong>nmap</strong> 命令查看一台主机开放了哪些端口，如下图。    </p>
<center><img src="/img/raspberrypi/nmap4ssh.jpg" width="360px"/></center>

<p>　　树莓派确实把<strong>ssh</strong>端口开放了，直接<strong>ssh</strong>也能够顺利进入树莓派系统，问题解决了。</p>
<h4 id="还原自启动，即可大功告成"><a href="#还原自启动，即可大功告成" class="headerlink" title="还原自启动，即可大功告成"></a>还原自启动，即可大功告成</h4><p>　　有必要每次系统启动都去开放 <strong>ssh</strong> 端口吗？可能没这个必要，因为经过两条命令的操作后，应该会修改系统的一些变量或者状态位，这些操作应该不是掉电还原的，否则，在第一节中，关闭ssh端口就不需要额外的两条命令了吧。我们不妨再试试。</p>
<p>　　既可以直接在起来的系统中将自启动文件 <strong>/etc/rc.local</strong> 还原，当然也可以像第一节中那样，还是对SD卡的内容进行修改。</p>
<p>　　还原<strong>rc.local</strong>，再把SD卡插回去或者<strong>reboot</strong>系统，还是能够顺利通过<strong>ssh</strong>进入树莓派系统的，大功告成。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　可能是我写录的树莓派系统image有问题吧，小伙伴都说默认应该是打开22端口，支持ssh的；但是我做的几张SD卡的系统都是不打开的，我很纳闷，怀疑用的是假的镜像吧。前几次都发生在实验室，显示器，HDMI线应有尽有，启动系统，简单地通过界面在系统的 &lt;strong&gt;Preferences&lt;/strong&gt; 中开启ssh端口即可。然而这一次，发生在家里（因为之前一直没空写个关于树莓派外置无线网卡驱动安装的教程，想着利用寒假回家弄一弄），家里哪有实验室那么好的环境，所以，甭想通过界面操作开启。&lt;/p&gt;
&lt;p&gt;　　那究竟能不能通过直接修改SD卡里面的image文件内容，不用UI的方式，开启ssh端口呢？通过下面的捣鼓发现，这是可行的。&lt;/p&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="RaspberryPi" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/RaspberryPi/"/>
    
    
  </entry>
  
  <entry>
    <title>8 sort functions using python</title>
    <link href="http://durant35.github.io/2017/01/24/python_sort-Functions/"/>
    <id>http://durant35.github.io/2017/01/24/python_sort-Functions/</id>
    <published>2017-01-24T08:18:38.000Z</published>
    <updated>2017-02-02T07:15:24.072Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>libpcap, 32-bit&amp;64-bit</title>
    <link href="http://durant35.github.io/2016/10/10/linux_libpcap%2032-bit&amp;64-bit/"/>
    <id>http://durant35.github.io/2016/10/10/linux_libpcap 32-bit&amp;64-bit/</id>
    <published>2016-10-10T02:42:37.000Z</published>
    <updated>2016-10-10T07:30:43.225Z</updated>
    
    <content type="html"><![CDATA[<p>　情况是这样的，在之前讲过的回播 <strong>.pcap</strong> 数据的 <strong>Velodyne_player</strong> 程序中，需要调用 <strong>Winpcap</strong> (其实就是 <strong>libpcap</strong> 的 Win挫版) 的 API 解析 <strong>.pcap</strong> 数据，再通过 UDP 发送出去。我们的 <strong>Velodyne_player</strong> 是一个 <strong>Win32</strong> 的程序，显然调用的就是32位的 <strong>Winpcap</strong> 库的 API； 后来我们也移植了一个 <strong>.pcap</strong> 采集程序的 Linux 版本，结果，用该 Linux 版本采集程序采集到的 <strong>.pcap</strong> 数据却没办法用我们 Win 下的 <strong>Velodyne_player</strong> 回播。后来发现，我们的 Linux 版本的采集程序用的是64位的 <strong>libpcap</strong> 库(因为系统是64位的 Ubuntu16.04，默认安装的就是64位的 <strong>libpcap</strong> 库)，64位和32位的 <strong>libpcap</strong>，在时间戳上有很关键的区别，下面是开源的 <strong>pcap.h</strong> 中的声明:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</div><div class="line"> * Generic per-packet information, as supplied by libpcap.</div><div class="line"> *</div><div class="line"> * The time stamp can and should be a "struct timeval", regardless of</div><div class="line"> * whether your system supports 32-bit tv_sec in "struct timeval",</div><div class="line"> * 64-bit tv_sec in "struct timeval", or both if it supports both 32-bit</div><div class="line"> * and 64-bit applications.  The on-disk format of savefiles uses 32-bit</div><div class="line"> * tv_sec (and tv_usec); this structure is irrelevant to that.  32-bit</div><div class="line"> * and 64-bit versions of libpcap, even if they're on the same platform,</div><div class="line"> * should supply the appropriate version of "struct timeval", even if</div><div class="line"> * that's not what the underlying packet capture mechanism supplies.</div><div class="line"> */</span></div><div class="line"><span class="keyword">struct</span> pcap_pkthdr &#123;</div><div class="line">  <span class="keyword">struct</span> timeval ts;	<span class="comment">/* time stamp */</span></div><div class="line">  bpf_u_int32 caplen;	<span class="comment">/* length of portion present */</span></div><div class="line">  bpf_u_int32 len;	<span class="comment">/* length this packet (off wire) */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>　对于上面遇到的问题，我们想到的解决办法是，移植的 Linux 版本采集程序生成32位的，而不是目前的64位。因为现在装的是64位的 <strong>libpcap</strong>(64位系统使然)，那接下来的问题便是，如何在64位的 <strong>Ubuntu16.04</strong> 上面安装32位的 <strong>libpcap</strong> 库，然后生成我们需要的32位数据采集程序(-m32 or -m64)。</p>
<h3 id="Generate-32-bit-exes-depending-on-libpcap"><a href="#Generate-32-bit-exes-depending-on-libpcap" class="headerlink" title="Generate 32-bit exes depending on libpcap"></a>Generate 32-bit exes depending on libpcap</h3><ol>
<li><p>64位系统默认安装的包都是64位的，所以，64位的 <strong>Ubuntu16.04</strong> 安装64位的 <strong>libpcap</strong> 库比较简单。</p>
<blockquote>
<p>Reference: <a href="http://askubuntu.com/questions/347788/how-can-i-install-libpcap-header-files-on-ubuntu-12-04">How can I install libpcap header files on Ubuntu 12.04?</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xxx@...$ sudo apt-get install libpcap0.8 libpcap0.8-dev libpcap-dev</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>64位的 <strong>Ubuntu16.04</strong> 安装32位的 <strong>libpcap</strong> 库则比较麻烦一点。</p>
<blockquote>
<p>Reference: <a href="http://askubuntu.com/questions/654079/libpcap-32-bit-on-64-bit-ubuntu">libpcap 32 bit on 64 bit Ubuntu</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># enable multiarch support for i386 architecture</span></div><div class="line">xxx@...$ sudo dpkg --add-architecture i386</div><div class="line"><span class="comment"># update the source </span></div><div class="line">xxx@...$ sudo apt-get update</div><div class="line"><span class="comment"># now, you can install the pcap library</span></div><div class="line">xxx@...$ sudo apt-get install libpcap0.8:i386 libpcap0.8-dev:i386 libpcap-dev:i386</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>装了32位的 <strong>libpcap</strong> 库，并不意味着你就能编译32位的，<strong>libpcap</strong> 应用程序，因为，64位系统默认并没有32位应用程序需要的基本库(诸如<strong>C/C++标准库</strong>)，所以需要安装好基本库环境。</p>
<blockquote>
<p>Reference: <a href="http://askubuntu.com/questions/709893/14-04-01-32-bit-missing-g-64-bit-include-files-when-cross-compiling">14.04.01 32-bit: Missing g++ 64-bit include files when cross-compiling</a></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xxx@...$ sudo apt-get install g++-multilib</div></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>安装好32位的基本库，还有 <strong>libpcap</strong> 后，我们就能生成需要的32位程序了。步骤很简单，源代码不需要修改，在 <strong>CodeBlocks</strong> 中只需要在项目对应的 <strong>Build Option</strong> 中将 <strong>-m64</strong> 调整为 <strong>-m32</strong>；对于其他构建方式(如 <strong>cmake</strong>)，方法应该类似，核心都是 <strong>-m32</strong> 还是 <strong>-m64</strong> 作为构建参数。</p>
</li>
</ol>
<h3 id="Linux-下如何查看程序-库信息"><a href="#Linux-下如何查看程序-库信息" class="headerlink" title="Linux 下如何查看程序/库信息"></a>Linux 下如何查看程序/库信息</h3><p>1.查看导出信息<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">xxx@...$ nm -D xxx.so/xxx.out</div><div class="line">xxx@...$ nm -g xxx.a</div><div class="line"><span class="comment"># or using objdump</span></div><div class="line">xxx@...$ objdump -tT xxx.so</div></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>nm [option]:</strong><br>-A 在每个符号信息的前面打印所在对象文件名称；<br>-C 输出demangle过了的符号名称；<br>-D 打印动态符号；<br>-l 使用对象文件中的调试信息打印出所在源文件及行号；<br>-n 按照地址/符号值来排序；<br>-u 打印出那些未定义的符号</p>
</blockquote>
<p>2.查看依赖库信息<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看动态依赖库信息</span></div><div class="line">xxx@...$ ldd xxx.so/xxx.out</div></pre></td></tr></table></figure></p>
<p>3.查看程序/库位数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xxx@...$ objdump <span class="_">-a</span> xxx.a/xxx.so/xxx.out</div></pre></td></tr></table></figure></p>
<blockquote>
<p>输出结果: elf32-i386或elf64-x86-64</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　情况是这样的，在之前讲过的回播 &lt;strong&gt;.pcap&lt;/strong&gt; 数据的 &lt;strong&gt;Velodyne_player&lt;/strong&gt; 程序中，需要调用 &lt;strong&gt;Winpcap&lt;/strong&gt; (其实就是 &lt;strong&gt;libpcap&lt;/strong&gt; 的 Win挫版) 的 API 解析 &lt;strong&gt;.pcap&lt;/strong&gt; 数据，再通过 UDP 发送出去。我们的 &lt;strong&gt;Velodyne_player&lt;/strong&gt; 是一个 &lt;strong&gt;Win32&lt;/strong&gt; 的程序，显然调用的就是32位的 &lt;strong&gt;Winpcap&lt;/strong&gt; 库的 API； 后来我们也移植了一个 &lt;strong&gt;.pcap&lt;/strong&gt; 采集程序的 Linux 版本，结果，用该 Linux 版本采集程序采集到的 &lt;strong&gt;.pcap&lt;/strong&gt; 数据却没办法用我们 Win 下的 &lt;strong&gt;Velodyne_player&lt;/strong&gt; 回播。后来发现，我们的 Linux 版本的采集程序用的是64位的 &lt;strong&gt;libpcap&lt;/strong&gt; 库(因为系统是64位的 Ubuntu16.04，默认安装的就是64位的 &lt;strong&gt;libpcap&lt;/strong&gt; 库)，64位和32位的 &lt;strong&gt;libpcap&lt;/strong&gt;，在时间戳上有很关键的区别，下面是开源的 &lt;strong&gt;pcap.h&lt;/strong&gt; 中的声明:&lt;br&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * Generic per-packet information, as supplied by libpcap.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; *&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * The time stamp can and should be a &quot;struct timeval&quot;, regardless of&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * whether your system supports 32-bit tv_sec in &quot;struct timeval&quot;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * 64-bit tv_sec in &quot;struct timeval&quot;, or both if it supports both 32-bit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * and 64-bit applications.  The on-disk format of savefiles uses 32-bit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * tv_sec (and tv_usec); this structure is irrelevant to that.  32-bit&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * and 64-bit versions of libpcap, even if they&#39;re on the same platform,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * should supply the appropriate version of &quot;struct timeval&quot;, even if&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; * that&#39;s not what the underlying packet capture mechanism supplies.&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; pcap_pkthdr &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; timeval ts;	&lt;span class=&quot;comment&quot;&gt;/* time stamp */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  bpf_u_int32 caplen;	&lt;span class=&quot;comment&quot;&gt;/* length of portion present */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  bpf_u_int32 len;	&lt;span class=&quot;comment&quot;&gt;/* length this packet (off wire) */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Linux" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Linux/"/>
    
    
      <category term="Linux" scheme="http://durant35.github.io/tags/Linux/"/>
    
      <category term="pcap" scheme="http://durant35.github.io/tags/pcap/"/>
    
  </entry>
  
  <entry>
    <title>Key Word Engineering</title>
    <link href="http://durant35.github.io/2016/10/09/OverlappingSounds_Key%20Word%20Engineering/"/>
    <id>http://durant35.github.io/2016/10/09/OverlappingSounds_Key Word Engineering/</id>
    <published>2016-10-09T00:14:45.000Z</published>
    <updated>2017-02-03T08:06:26.508Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote>
<p><strong>AI</strong>（Artificial Intelligence），人工智能<br><strong>ATM</strong>（asynchronous transfer mode），异步传输模式<br><strong>ARPA</strong>（Advanced Research Projects Agency），（美国国防部）高级研究计划署<br><strong>AR</strong>（augmented reality），增强实现<br><strong>ADSL</strong>（Asymmetrical Dingital Subscriber Loop），非对称数字用户环线<a id="more"></a><br>acoustic coupler，声音耦合器<br>Active Directory，活动目录<br>affinity，绑定<br>affinity group，地缘组<br>agent，代理<br>agent-based interface，代理人界面<br>agility，敏捷性<br>air waves，无线电波<br>algorithm，算法<br>analog，模拟的<br>animation，动画<br>annotation，注解，注释<br>answering machine，电话应答机<br>antenna，天线<br>application pool，应用程序池<br>architecture decay，架构腐坏<br>ARPAnet，ARPA网<br>aspect ratio，屏幕高宽比<br>atomic opreation，原子操作<br>atomic transaction，原子事务<br>atomicity，原子性<br>authentication，身份验证<br>authorization，授权<br>automation，自动化<br>autonomous，独立性<br>availability，可用性<br>availability set，可用性集</p>
</blockquote>
<h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote>
<p><strong>bps</strong>（bits per second），比特/秒<br><strong>BS</strong>（browser-server），浏览器-服务器<br>backpane，底板<br>backward compatibility，向后兼容性<br>bandwidth，带宽<br>bar code，条形码<br>baseline，准线<br>baud，波特<br>bit，比特<br>bitnik，比特族<br>bottleneck，瓶颈<br>broadcast，（无线电或电视）广播<br>bug，缺陷<br>built-in，内置的，内建的；嵌入的；内置<br>business layer，业务层<br>business intelligence，商业智能<br>byte，字节</p>
</blockquote>
<h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><blockquote>
<p><strong>CC</strong>（carbon copy），复写本，副本；抄送<br><strong>CPU</strong>（Central Processing Unit），中央处理器<br><strong>CA</strong>（Certificate Authority），证书认证机构<br><strong>CS</strong>（client-server），客户端-服务器<br><strong>CRT</strong>（cathode ray tube），阴极射线管<br>Cache/Caching，缓存<br>call stack，调用堆栈<br>carriage return，回车<br>cell，单元<br>certificate，（数字）证书<br>channel，信道，频道<br>character，字符<br>check in，签入<br>check out，签出<br>chip，芯片<br>cipher，密码<br>claim，声明<br>clone，克隆，复制<br>cloud computing，云计算<br>cloud service，云服务<br>cluster，集群<br>clustered index，聚集索引<br>coaxial cable，同轴电缆<br>command，命令<br>command prompt，命令行提示<br>commingled bits，混合的比特<br>communication，通信<br>community，社区<br>committed，已提交（的）<br>compatibility，兼容性<br>comcurrency，并发<br>concurrency mode，并发模式<br>conditional compilation，条件编译<br>conditional compilation statement，条件编译语句<br>configuration，配置，设置<br>connection string，连接字符串<br>consistenct，一致性<br>constructor，构造函数<br>container，容器<br>context，上下文<br>continuous integration，持续集成<br>contribute，贡献<br>Contributor License Agreement，贡献者许可协议<br>convert，转换<br>cookie，Cookie<br>corruption，损毁<br>crash，（程序）崩溃<br>crash dump，故障转储<br>crytography，密码术<br>cursor，光标<br>cybraian，电脑族<br>cyberspace，电脑空间</p>
</blockquote>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><blockquote>
<p><strong>DL</strong>（Deep Learning），深度学习<br><strong>DM</strong>（data mining），数据挖掘<br><strong>DI</strong>（dependenct injection），依赖注入<br>dashboard，仪表盘<br>data layer，数据层<br>data integrity，数据完整性<br>deployment，部署<br>derives from 继承<br>diagnostics，诊断<br>directive，指令<br>discussion forum，论坛<br>distributed system，分布式系统<br>dummy function，虚构函数<br>durability，持久性</p>
</blockquote>
<h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><blockquote>
<p><strong>EAP</strong>（Early Assessment Program），早期评估版本<br>Egress，流出<br>elasticity，弹性<br>entity，实体<br>erosion，侵蚀<br>exception handling，异常处理<br>explanatory figures，图示</p>
</blockquote>
<h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><blockquote>
<p><strong>FDD</strong>（Floopy Disk Drive），软盘<br>failover，容错转移<br>failure domain，故障域<br>fat client，胖客户端<br>follow up，跟进<br>foreign key，外键<br>forward，转发<br>full-duplex，全双工<br><strong>FPP</strong>（Full Packaged Product），零售版</p>
</blockquote>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a>G</h3><blockquote>
<p>Geo-Replication，地域复制<br>Geo Redundant，地域冗余</p>
</blockquote>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a>H</h3><blockquote>
<p><strong>HDD</strong>（Hard Disk Drive），硬盘<br>handle，句柄<br>High Avaliability，高可用性<br>Homogeneous，同质化<br>Horizontal Scale，水平缩放<br>Hosting，宿主<br>Hybrid Cloud，混合云</p>
</blockquote>
<h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><blockquote>
<p><strong>Iaas</strong>（Infrastructure as a Service），设施即服务<br>Idempotent Operation，幂等操作<br>Identity Provider，身份提供方<br>image，镜像<br>ingesting，摄取<br>ingress，流入<br>input endpoint，输入端点<br>Instance InputEndpoint，实例输入端点<br>Intercept，截取<br>Internal Endpoint，内部端点<br>Isolation，隔离性</p>
</blockquote>
<h3 id="J"><a href="#J" class="headerlink" title="J"></a>J</h3><blockquote>
</blockquote>
<h3 id="K"><a href="#K" class="headerlink" title="K"></a>K</h3><blockquote>
</blockquote>
<h3 id="L"><a href="#L" class="headerlink" title="L"></a>L</h3><blockquote>
<p>Legacy system，遗留系统<br>license，许可证<br>lifetime，生命周期<br>linked resource，链接的资源<br>load-balancing，负载平衡<br>load balancer，负载平衡器<br>log，日志<br>loose coupling，松耦合</p>
</blockquote>
<h3 id="M"><a href="#M" class="headerlink" title="M"></a>M</h3><blockquote>
<p>Mainframe，主机<br>Maintainability，可维护性<br>Management Key，管理密钥<br>Media Service，媒体服务<br>Merge，合并<br>Metadata，元数据<br>Middleware，中间件<br>Mobile Service，移动服务<br>Mock Object，模拟对象<br>Multitenancy，多租户<br>Multitier Architecture，多层体系结构<br>Multi-factor Authentication，多重验证</p>
</blockquote>
<h3 id="N"><a href="#N" class="headerlink" title="N"></a>N</h3><blockquote>
<p>Namespace，命名空间，名称空间<br>Non-clustered Index，非聚集索引<br>node，节点<br>normalize，规格化，归一化<br>notification hub，通知中心<br>N-Tier，N 层（结构）</p>
</blockquote>
<h3 id="O"><a href="#O" class="headerlink" title="O"></a>O</h3><blockquote>
<p>On-demand (media)，点播（媒体）<br>Optimistic Concurrency，乐观并发控制<br>Overview，概览<br>over-post，过度提交</p>
</blockquote>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><blockquote>
<p><strong>Paas</strong>（Platform as a Service），平台即服务<br>partition，分区<br>Pay as You Go，即用即付<br>peek，查看<br>performance counter，性能计数器<br>Pessimistic Concurrency，悲观并发控制<br>Point-to-Site，点到站点<br>polling，轮询<br>presentation layer，表现层<br>private cloud，私有云<br>priority queue，优先级队列<br>probe，探测器<br>process，进程<br>production，生产（环境）<br>protocol，协议<br>proxy，代理<br>public cloud，公有云<br>push，推送</p>
</blockquote>
<h3 id="Q"><a href="#Q" class="headerlink" title="Q"></a>Q</h3><blockquote>
<p>Quota，配额</p>
</blockquote>
<h3 id="R"><a href="#R" class="headerlink" title="R"></a>R</h3><blockquote>
<p>Rack，机架<br>real-time，即时、实时<br>Redundancy，冗余<br>Redundant，冗余（的）<br>Refactor，重构<br>relay，中继<br>Relevancy，适切性<br>Reliability，可靠性<br>Relying Party，依赖方<br>Repository，存储库；仓储；仓库<br>request pipeline，请求管道<br>reserved，专属<br>reverse proxy module，反向代理模块<br>retail，零售版<br>Rich Client，丰富客户端<br>Ripple Effect，涟漪效应<br>Rolling Upgrade，滚动升级<br>round-robin，轮流（分配）；轮叫<br>round-tripping，还原；回传；往返，往返切换<br>router，路由器</p>
</blockquote>
<h3 id="S"><a href="#S" class="headerlink" title="S"></a>S</h3><blockquote>
<p><strong>Saas</strong>（Software as a Service），软件即服务<br><strong>SSL</strong>（Security Socket Layer），安全套接层<br><strong>SLA</strong>（Service Level Agreement），服务水平协议<br>Scalability，缩放性<br>Scale，缩放<br>Scale Out，向外缩放<br>Scale Up，向上缩放<br>Schema (database)，架构（数据）<br>Schema (xml)，架构（xml）<br>Security Token，安全令牌<br>Self-signed Certificate，自签名证书<br>Serializable，可序列化<br>Server Affinity，服务器绑定<br>Service Bus，服务总线<br>Service Contract，服务合同<br>Service Provider，服务提供方<br>Shopping cart，购物车<br>Signature，签名<br>snapshot，快照<br>Staging，过渡（环境）<br>Sticky Session，黏性会话<br>Stickyness，黏性；黏度<br>Sign in，登录<br>Sign out，注销<br>Site-to-Site，站点到站点<br>Storage Account，存储账户<br>Subnet，子网<br>Sub-region，子地域<br>Subscription，订阅</p>
</blockquote>
<h3 id="T"><a href="#T" class="headerlink" title="T"></a>T</h3><blockquote>
<p>Tenant，租户<br>Terminus，端点<br>Thin Client，瘦客户端<br>Thread Pool，线程池<br>Thread Starvation，线程饥荒<br>Throttle，节流；限速<br>Timestamp，时间戳<br>Throughput，吞吐量<br>Topology，拓扑结构<br>Token，令牌<br>(Code) Tracing，（代码）追踪<br>Transaction，事务<br>Transient Error，瞬时错误</p>
</blockquote>
<h3 id="U"><a href="#U" class="headerlink" title="U"></a>U</h3><blockquote>
<p>Ubiquitous Computing，普存计算<br>under-post，提交不足<br>Unit test，单元测试<br>Uncommitted，未提交（的）<br>Update Domain，更新域</p>
</blockquote>
<h3 id="V"><a href="#V" class="headerlink" title="V"></a>V</h3><blockquote>
<p><strong>VOL</strong> 或 <strong>VLO</strong>（Volume Licensing for Organizations），团体批量许可证；大量采购授权合约<br>Vertical Scale，垂直缩放<br>VIP，虚拟 IP（或不译）<br>VIP Swap，VIP 交换<br>Virtual Network，虚拟网络<br>Virtual Machine，虚拟机</p>
</blockquote>
<h3 id="W"><a href="#W" class="headerlink" title="W"></a>W</h3><blockquote>
<p><strong>WMI</strong>（Windows Management Instrumentation），Windows 管理规范<br><strong>WINS</strong>（Windows Internet Name Service），Windows Internet 命名服务<br>Wearable Device，可穿戴设备<br>Web Role，网站角色<br>Web Service，网络服务<br>Web Sites，网站<br>wireless communication，无线通讯<br>Worker Role，辅助角色<br>Workflow，工作流<br>workgroup，工作组</p>
</blockquote>
<h3 id="X"><a href="#X" class="headerlink" title="X"></a>X</h3><blockquote>
<p><strong>XOR</strong>（Exclusive OR），异或<br>X.509v3 certificate，X.509 证书</p>
</blockquote>
<h3 id="Y"><a href="#Y" class="headerlink" title="Y"></a>Y</h3><blockquote>
</blockquote>
<h3 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h3><blockquote>
<p>Zero-downtime Upgrade，零停机升级<br>zip disk，压缩磁盘<br>zone，区域<br>zone list，区域列表<br>zone transfer，区域传送</p>
</blockquote>
<p>　　</p>
<blockquote>
<p><strong>References:</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/linJie1930906722/p/5768669.html">计算机专业术语对照</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;A&quot;&gt;&lt;a href=&quot;#A&quot; class=&quot;headerlink&quot; title=&quot;A&quot;&gt;&lt;/a&gt;A&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;AI&lt;/strong&gt;（Artificial Intelligence），人工智能&lt;br&gt;&lt;strong&gt;ATM&lt;/strong&gt;（asynchronous transfer mode），异步传输模式&lt;br&gt;&lt;strong&gt;ARPA&lt;/strong&gt;（Advanced Research Projects Agency），（美国国防部）高级研究计划署&lt;br&gt;&lt;strong&gt;AR&lt;/strong&gt;（augmented reality），增强实现&lt;br&gt;&lt;strong&gt;ADSL&lt;/strong&gt;（Asymmetrical Dingital Subscriber Loop），非对称数字用户环线
    
    </summary>
    
    
      <category term="Key-words" scheme="http://durant35.github.io/tags/Key-words/"/>
    
  </entry>
  
</feed>
