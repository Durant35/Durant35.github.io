<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tarantula-7&#39;s Blog</title>
  <subtitle>My Body Knows It&#39;s Time to Say GoodBye... ---- Dear Basketball</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://durant35.github.io/"/>
  <updated>2017-05-24T06:44:48.026Z</updated>
  <id>http://durant35.github.io/</id>
  
  <author>
    <name>Tarantula-7</name>
    <email>1109197209@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法设计与分析[0013] 网络流：最大流（Max Flow）问题</title>
    <link href="http://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/"/>
    <id>http://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/</id>
    <published>2017-05-19T02:54:22.000Z</published>
    <updated>2017-05-24T06:44:48.026Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络流：最大流问题"><a href="#网络流：最大流问题" class="headerlink" title="网络流：最大流问题"></a>网络流：最大流问题</h4><ul>
<li>所谓网络：<ul>
<li>一个有向图 $G=(V, E)$</li>
<li>G中有两个特殊节点 $s, t \in V$，分别称为 G 中的源点(source) 和汇点(sink)。</li>
<li>G中每条边都有容量 $c_e \lt 0$。</li>
</ul>
</li>
<li>所谓流是指一种特定的输送方式，其中对每条边赋予一个变量 $f_e$，使其满足如下三个基本性质：<a id="more"></a>
<ul>
<li>容量限制(Capacity Constraints)：不超过边的容量，即对所有 $e \in E, 0 \leq f_e \leq c_e$</li>
<li>流量守恒(Flow Conservation)：对于 s 和 t  之外的任意节点 u，输入 u 的流量等于输出 u 的流量（流量是守恒的）：$\sum_{(w, u) \in E} f_{wu} = \sum_{(u, z) \in E} f_{uz} $</li>
<li>斜对称性(Skew Symmetry)：$ f_{uv} = -f_{vu}$</li>
</ul>
</li>
<li>网络流问题（NetWork Flow Problem）<ul>
<li>给定指定的一个有向图，其中有两个特殊的点：源 S 和汇 T，每条边有指定的容量(Capacity)，求满足条件的从 S 到 T 的最大流(MaxFlow)。</li>
</ul>
</li>
<li>最大流<ul>
<li>流的规模为由 s 流向 t 的总流量，由上面的流量的守恒律，其等于离开 s 的流量。</li>
<li>目标函数（最大化）：$ 规模(f) =  \sum_{(s, u) \in E} f_{su} = \sum_{(z, t) \in E} f_{zt} $</li>
</ul>
</li>
<li>其他相关定义<ul>
<li>容量网络(capacity network)&amp;流量网络(flow network)&amp;残留网络(residual network)<ul>
<li>网络就是有源、汇的有向图，关于什么的网络就是指边权的含义是什么。<center><img src="/img/Algorithms/0013_networkGraphSketch.png" width="540px"/></center></li>
<li>容量网络就是关于容量的网络。在求解问题的过程中，容量网络基本是不改变的。</li>
<li>流量网络就是关于流量的网络。在求解问题的过程中，流量网络通常在不断改变，但是总是满足上述三个性质；调整到最后就是最大流网络，同时也可以得到最大流值。</li>
<li>残量网络往往概括了容量网络和流量网络，是最为常用的，残量网络=容量网络-流量网络。</li>
</ul>
</li>
<li>增广路径(Augmenting path)：增广路径顾名思义就是能够增加流量的路径。增广路径 p 是残量网络中一条从源点 s 到汇点 t 的简单路径，在一条增广路径 p 上能够为每条边增加的流量的最大值为路径 p 的 <strong>残存容量(remaining capacity)</strong>：$c_f(p) = min \verb|{| c_f(u,v):(u,v) \in p \verb|}|$</li>
<li>割&amp;割集<ul>
<li>一个无向连通网络，去掉一个边集可以使其变成两个连通分量，则这个边集就是割集<ul>
<li>无向图的割集(Cut Set)：$C[A,B]$ 是将图 G 分为 A 和 B 两个点集（连通分量）的连接 A 和 B 之间的边的全集。</li>
</ul>
</li>
<li>带权图的割(Cut) 就是割集中边或者有向边的权和。<ul>
<li>最小割集当然就是权和最小的割集。</li>
</ul>
</li>
<li>在有向图网络 $G(V, E)$ 中, 割(S, T) 将 V 划分为 S 和 T=V-S，使得 s 属于 S 集合，t 属于 T 集合，割(S, T) 的容量是指从集合 S 到集合 T 所有边的容量之和。<center><img src="/img/Algorithms/0013_cutSketch.png" width="540px"/></center>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="最大流问题与线性规划"><a href="#最大流问题与线性规划" class="headerlink" title="最大流问题与线性规划"></a>最大流问题与线性规划</h4><p>　最大流问题可以转换为线性规划问题，而线性规划问题最著名的解法自然就是 <strong>单纯形法</strong>。这种算法非常奇特，其复杂度为在最坏情况下是指数级的，但其在实践中绝大多数的情况下表现出的效率非常令人满意。</p>
<ul>
<li>设$c_{uv}$ 代表边 u 到 v 最大允许的流量（capacity），$f_{uv}$ 代表 u 到 v 当前流量。</li>
<li>最大流可以表示为：<br>$$<br>  \Large{max}<br>  \normalsize{ \sum_{u:(s, u) \in E} f_{su} \quad }<br>  \Large{s.t.} \normalsize{<br>   \begin{cases} 0 \leq f_{uv} \leq c_{uv}, \forall (u, v) \in E \cr<br>   \sum_{w:(w, u) \in E} f_{wu} - \sum_{v:(u, v) \in E} f_{uv} = 0, \forall u \in V \backslash \verb|{| s, t \verb|}| \end{cases}<br>  }<br>$$</li>
<li>事实上，使用 <strong>单纯形法</strong> 解决网络最大流问题非常直观：<ol>
<li>从零流量开始</li>
<li>重复下述过程：<ul>
<li>选择一条从源点 s 到汇点 t 的合适路径</li>
<li>将该路径的流量增加到无法增加为止</li>
</ul>
</li>
</ol>
</li>
<li>每次迭代单纯形法寻找到 s→t 的一条路径，路径中的边有两种类型（如下图(b)中右图所示，可以同时存在这两种类型的边）：<br>  　　① 边在最初的网络中，且未达到最大流量，如下图(b)右图中的边 <strong>a→d</strong>；<br>  　　② 边的反向边在最初的网络中，如下图(c)右图中的边 <strong>d→a</strong>。<br><center><img src="/img/Algorithms/0013_residualGraphSketch.png" width="540px"/></center><ul>
<li>如果当前的流为 $f$，则对于第①种情况，边 $(u, v)$ 最多还能接受 $c_{uv} - f_{u, v}$ 的多余流量；而在第②种情况，最多增加的流量为 $f_{vu}$（取消 $(v, u)上的全部或部分流量$ ）。</li>
<li>这类增加流量的机会可以由 <strong>残量网络</strong> $G^f=(V, E^f)$ 来判定，该网络包含了所有的以上两种边，并标出了每条边的剩余流量：<br>$$<br>c^f =<br> \begin{cases} c_{uv} - f_{uv}, \quad 若(u, v) \in E 且 f_{uv} \lt c_{uv} \cr<br>f_{vu}, \qquad \quad 若(v, u) \in E 且 f_{uv} \gt 0 \end{cases}<br>$$</li>
</ul>
</li>
</ul>
<h4 id="最大流基本方法（Ford-Fulkerson）"><a href="#最大流基本方法（Ford-Fulkerson）" class="headerlink" title="最大流基本方法（Ford-Fulkerson）"></a>最大流基本方法（Ford-Fulkerson）</h4><ul>
<li>通过模拟单纯形法，我们得到了一个解决最大流问题的直接算法（Ford-Fulkerson）。该算法采取迭代的方式进行，每次先构造一个 $G^f$，然后在 $G^f$ 中寻找 s 到 t 的一条可行的增广（能够继续提高流量的）路径，找不到任何这样的路径时算法停止。</li>
<li>Ford-Fulkerson 方法<ul>
<li>Ford-Fulkerson 方法，即增广路方法，是一种迭代的方法，之所以称之为方法，而不是算法，因为FF(Ford-Fulkerson) 包含不同运行时间的几种实现。</li>
<li>Ford-Fulkerson 方法伪代码如下，解决了以下三个子问题：①<strong>while</strong>：要增广多少次？②<strong>augmenting path</strong>：如何找到一条增广路径？③<strong>update</strong>：如何增广？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FORD-FULKERSON-METHOD(G, s, t): </div><div class="line">   initialize flow f to <span class="number">0</span></div><div class="line">   <span class="keyword">while</span> there exists an augmenting path p, path-flow as its remaining capacity</div><div class="line">     <span class="keyword">do</span> augment flow path-flow along p to flow f</div><div class="line">     update residual graph</div><div class="line">   <span class="keyword">return</span> flow f</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>最大流算法 Ford-Fulkerson 方法最优性验证<ul>
<li>最大流最小割定理：设 $f$ 为流网络 $G = (V, E)$ 中的一个流，该流网络的源点为 s，汇点为t，则下面的条件是等价的：<ul>
<li>$f$ 是 $G$ 的一个最大流</li>
<li>残量网络 $G^f$ 不包含任何增广路径</li>
<li>$|f| = |C(S, T)|$，即最大流流量等于割 $C$ 的容量，割 $C=(S, T)$ 是流网络 $G$ 的最小割</li>
</ul>
</li>
<li>找到最大流 $f$ $\Longrightarrow$ 残量网络 $G^f$ 中已经无法找到任何由 s 到 t 的路径 $\Longrightarrow$ $(L, R)$ 为图 $G$ 的一个分割 $\begin{cases} L为 G^f 中 s 可达的所有节点集合 \cr R=V-L 为剩余的节点 \end{cases}$</li>
<li>对于任意流 $f$ 和任意 $(s, t)$ 分割 $(L, R)$，$流量(f) \leq 容量(L, R)$，由最大流最小割定理，最大流算法产生最小割，最小割对应于流的上限，这就是所求得流的最优性的保证。</li>
</ul>
</li>
<li>最大流算法的运行效率<ul>
<li>FORD-FULKERSON-METHOD 每个单次循环都是效率很高的，无论通过使用 <a href="http://durant35.github.io/2017/03/15/Algorithms_DFS/">DFS</a> 还是 <a href="http://durant35.github.io/2017/03/22/Algorithms_BFS/">BFS</a>，每次循环都只需要 $O(|E|)$ 的时间，但问题是，我们一共需要循环多少次呢？可以看出，循环次数的上线是所有边流量的最大值 C（每次循环只能增加 1 个流量），算法最坏情况为 $O(C|E|)$，然而 C 可能是一个很大的值！</li>
<li>采用广度优先搜索将使得找到的增广路径包含最少的边，则不管边的容量如何，C 如何，最终的迭代次数将不超过 $O(|V|·|E|)$（所有可能的路径总和）。因此，通过仔细地选择增广路径，可以将循环次数限制在 $O(|V|·|E|)$ 之内，在这种情况下，整个算法的时间复杂度为 $O(|V|·|E|^2)$。在 FORD-FULKERSON-METHOD 中通过 BFS 搜索增广路径，这就是<strong>Edmonds-Karp</strong> 算法（最短路径增广算法），其算法实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MaxFlow.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>			<span class="comment">/* setw */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> capacity;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, capacity;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; capacity;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;capacity = capacity;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data </div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;capacity &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span>* prevs, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="comment">// no previous node ==&gt; reach starting node </span></div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != <span class="number">-1</span>) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx].data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>** graph, <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx, <span class="keyword">int</span>* prevs)</span> </span>&#123;</div><div class="line">  <span class="comment">// cout &lt;&lt; "BFS" &lt;&lt; endl;</span></div><div class="line">  <span class="comment">// for(int u=0; u&lt;vertexNum; u++) &#123;</span></div><div class="line">  <span class="comment">// 	for(int v=0; v&lt;vertexNum; v++) &#123;</span></div><div class="line">  <span class="comment">// 		if(graph[u][v] &gt; 0) &#123;</span></div><div class="line">  <span class="comment">// 			cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; v &lt;&lt; "(" &lt;&lt; graph[u][v] &lt;&lt; ") ";</span></div><div class="line">  <span class="comment">// 		&#125;</span></div><div class="line">  <span class="comment">// 	&#125;</span></div><div class="line">  <span class="comment">// 	cout &lt;&lt; endl;</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="keyword">bool</span> visited[vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;vertexNum; vertexIdx++) &#123;</div><div class="line">    visited[vertexIdx] = <span class="literal">false</span>;</div><div class="line">    prevs[vertexIdx] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertexIdxQueue;</div><div class="line">  vertexIdxQueue.push(fromIdx);</div><div class="line">  visited[fromIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span> (!vertexIdxQueue.empty()) &#123;</div><div class="line">    <span class="keyword">int</span> u = vertexIdxQueue.front();</div><div class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " ";</span></div><div class="line">    <span class="keyword">if</span>(u == toIdx) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    vertexIdxQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[v] &amp;&amp; graph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        vertexIdxQueue.push(v);</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">        prevs[v] = u;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> visited[toIdx];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FordFulkerson</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">const</span> VertexNode&amp; source, <span class="keyword">const</span> VertexNode&amp; sink)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxFlow = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> flowGraph[g.vertexNum][g.vertexNum];</div><div class="line">  <span class="comment">// initialize the residual graph</span></div><div class="line">  <span class="keyword">int</span>** residualGraph = <span class="keyword">new</span> <span class="keyword">int</span>*[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    residualGraph[u] = <span class="keyword">new</span> <span class="keyword">int</span>[g.vertexNum];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      residualGraph[u][v] = <span class="number">0</span>;</div><div class="line">      flowGraph[u][v] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;g.vertexNum; vertexIdx++) &#123;</div><div class="line">    adjVertexNode* head = g.VertexNodes[vertexIdx].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// cout &lt;&lt; vertexIdx &lt;&lt; "--&gt;" &lt;&lt; head-&gt;adjVertexIdx &lt;&lt; endl;</span></div><div class="line">      residualGraph[vertexIdx][head-&gt;adjVertexIdx] = head-&gt;capacity;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// prevs array for storing the augmenting path</span></div><div class="line">  <span class="keyword">int</span> prevs[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> iter = <span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Algorithm Process:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// Augment the flow while there is a path from source to sink</span></div><div class="line">  <span class="keyword">while</span>(BFS(residualGraph, g.vertexNum, source.vertexIdx, sink.vertexIdx, prevs)) &#123;</div><div class="line">    <span class="comment">// find the maximum flow(minimum residual capacity) through the path found</span></div><div class="line">    <span class="keyword">int</span> pathFlow = INT_MAX;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sink.vertexIdx; v!=source.vertexIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      <span class="keyword">if</span>(residualGraph[u][v] &lt; pathFlow) &#123;</div><div class="line">        pathFlow = residualGraph[u][v];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update residual capacities of the edges &amp; reverse edges along the augmenting path</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sink.vertexIdx; v!=source.vertexIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      residualGraph[u][v] -= pathFlow;</div><div class="line">      residualGraph[v][u] += pathFlow;</div><div class="line">      <span class="comment">// record flows</span></div><div class="line">      flowGraph[u][v] += pathFlow;</div><div class="line">    &#125;</div><div class="line">    maxFlow += pathFlow;</div><div class="line">    <span class="comment">// print current iteration's info</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t#"</span> &lt;&lt; iter++ &lt;&lt; <span class="string">" flow: "</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; pathFlow &lt;&lt; <span class="string">" Augmenting-path: "</span>;</div><div class="line">    PrintPath(g, prevs, sink.vertexIdx);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// memory release</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">delete</span>[] residualGraph[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>[] residualGraph;</div><div class="line"> </div><div class="line">  <span class="comment">// show the flows</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">bool</span> noflow;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    noflow = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> &lt;&lt; g.VertexNodes[u].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(flowGraph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; g.VertexNodes[v].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; flowGraph[u][v] &lt;&lt; <span class="string">")\t"</span>;</div><div class="line">        noflow = <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(noflow) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> maxFlow;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_FLOW1</span></div><div class="line">    freopen(<span class="string">"flow1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"flow2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_FLOW1</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow: "</span> &lt;&lt; FordFulkerson(g, g.VertexNodes[<span class="number">0</span>], g.VertexNodes[<span class="number">6</span>]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow: "</span> &lt;&lt; FordFulkerson(g, g.VertexNodes[<span class="number">0</span>], g.VertexNodes[<span class="number">5</span>]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="red">算法实现细节分析如下：</font><ul>
<li><code>bool BFS(int** graph, int vertexNum, int fromIdx, int toIdx, int* prevs)</code> 函数通过广度优先搜索算法寻找边数目最少的增广路径，返回值表示能否寻找到这样的一条路径；假如存在这样的一条增广路径，<code>prevs</code> 数组则记录这样的一条增广路径：<strong>toIdx → prevs[toIdx] → prevs[prevs[toIdx]] → … → fromIdx</strong>。</li>
<li><code>residualGraph[u][v]</code> 通过邻接矩阵的方式维护一个残量网络，<code>flowGraph</code>则维护了流量网络的情况。</li>
<li><code>pathFlow</code> 则用于获取每次迭代寻找到的该增广路径的残存容量，用于更新残量网络和流量网络。<code>maxFlow</code> 则保留了最终的最大流量值。</li>
</ul>
</li>
<li>算法运行实例（一）<br>  <center><img src="/img/Algorithms/0013_demoFlow1.png" width="540px"/></center><ul>
<li>上图网络流对应的输入文件 <strong>flow1.txt</strong> 如下：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span> <span class="number">11</span></div><div class="line">s a b c d e t</div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">4</span></div><div class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">10</span></div><div class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></div><div class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">5</span></div><div class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">2</span></div><div class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<ul>
<li>编译构建，运行结果如下，过程可视化如上图。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_FLOW1 MaxFlow.cpp -o MaxFlow</div><div class="line">$ ./MaxFlow </div><div class="line">The adjacent list for graph is:</div><div class="line"> s-&gt;c(4) b(3) a(3) </div><div class="line"> a-&gt;d(2) </div><div class="line"> b-&gt;d(1) a(10) </div><div class="line"> c-&gt;e(5) </div><div class="line"> d-&gt;t(2) e(1) c(1) </div><div class="line"> e-&gt;t(5) </div><div class="line"> t-&gt;NULL</div><div class="line"> </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   2 Augmenting-path: s-&gt;a-&gt;d-&gt;t</div><div class="line">  #2 flow:   4 Augmenting-path: s-&gt;c-&gt;e-&gt;t</div><div class="line">  #3 flow:   1 Augmenting-path: s-&gt;b-&gt;d-&gt;e-&gt;t</div><div class="line"> Maximum Flow Graph:</div><div class="line">   s: -&gt;a(2)	-&gt;b(1)	-&gt;c(4)	</div><div class="line">   a: -&gt;d(2)	</div><div class="line">   b: -&gt;d(1)	</div><div class="line">   c: -&gt;e(4)	</div><div class="line">   d: -&gt;e(1)	-&gt;t(2)	</div><div class="line">   e: -&gt;t(5)	</div><div class="line">   t: NULL</div><div class="line"> Maximum Flow: 7</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>算法运行实例（二）<br>  <center><img src="/img/Algorithms/0013_demoFlow2.png" width="420px"/></center><ul>
<li>上图网络流对应的输入文件 <strong>flow2.txt</strong> 如下：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span> <span class="number">10</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">16</span></div><div class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">13</span></div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">10</span></div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">12</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">14</span></div><div class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">9</span></div><div class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">20</span></div><div class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">7</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></div></pre></td></tr></table></figure>
<ul>
<li>编译构建，运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ g++ MaxFlow.cpp -o MaxFlow</div><div class="line">$ ./MaxFlow </div><div class="line">The adjacent list for graph is:</div><div class="line"> 0-&gt;2(13) 1(16) </div><div class="line"> 1-&gt;3(12) 2(10) </div><div class="line"> 2-&gt;4(14) 1(4) </div><div class="line"> 3-&gt;5(20) 2(9) </div><div class="line"> 4-&gt;5(4) 3(7) </div><div class="line"> 5-&gt;NULL</div><div class="line"> </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:  12 Augmenting-path: 0-&gt;1-&gt;3-&gt;5</div><div class="line">  #2 flow:   4 Augmenting-path: 0-&gt;2-&gt;4-&gt;5</div><div class="line">  #3 flow:   7 Augmenting-path: 0-&gt;2-&gt;4-&gt;3-&gt;5</div><div class="line"> Maximum Flow Graph:</div><div class="line">   0: -&gt;1(12)	-&gt;2(11)	</div><div class="line">   1: -&gt;3(12)	</div><div class="line">   2: -&gt;4(11)	</div><div class="line">   3: -&gt;5(19)	</div><div class="line">   4: -&gt;3(7)	-&gt;5(4)	</div><div class="line">   5: NULL</div><div class="line"> Maximum Flow: 23</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li>基本概念：<ul>
<li><a href="http://blog.csdn.net/xzz_hust/article/details/22041173">网络流：最大流，最小割 基本概念及算法</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9275177">图的匹配问题与最大流问题(一)</a><ul>
<li>最大流问题跟线性规划又是如何产生联系的呢？</li>
</ul>
</li>
</ul>
</li>
<li>算法涉及概念补充：<a href="http://www.jianshu.com/p/1451e70909c8">最大流, 最小割问题及算法实现</a></li>
<li>算法实现细节：<ul>
<li><a href="http://www.cnblogs.com/gaochundong/p/ford_fulkerson_maximum_flow_algorithm.html">Ford-Fulkerson 最大流算法</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9293805">图的匹配问题与最大流问题（三）——最大流问题Ford-Fulkerson方法Java实现</a></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络流：最大流问题&quot;&gt;&lt;a href=&quot;#网络流：最大流问题&quot; class=&quot;headerlink&quot; title=&quot;网络流：最大流问题&quot;&gt;&lt;/a&gt;网络流：最大流问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;所谓网络：&lt;ul&gt;
&lt;li&gt;一个有向图 $G=(V, E)$&lt;/li&gt;
&lt;li&gt;G中有两个特殊节点 $s, t \in V$，分别称为 G 中的源点(source) 和汇点(sink)。&lt;/li&gt;
&lt;li&gt;G中每条边都有容量 $c_e \lt 0$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所谓流是指一种特定的输送方式，其中对每条边赋予一个变量 $f_e$，使其满足如下三个基本性质：
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CPU 扫盲（核心数/线程数）</title>
    <link href="http://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/"/>
    <id>http://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/</id>
    <published>2017-05-16T07:33:00.000Z</published>
    <updated>2017-05-16T08:02:16.497Z</updated>
    
    <content type="html"><![CDATA[<p>　　处理器（CPU）决定了电脑的性能等级，是一个需要考虑的核心因素。CPU 从早期的单核，发展到现在的双核，多核。除了<strong>核心数</strong>之外，还有<strong>线程数</strong>之说，下面会对这两个概念进行扫盲。
　　</p>
<h4 id="CPU-个数"><a href="#CPU-个数" class="headerlink" title="CPU 个数"></a>CPU 个数</h4><p>　CPU 的个数是指物理上，也就是硬件上存在着几颗物理 CPU，指的是真实存在的处理器的个数，1个代表1颗、2个代表2颗 CPU 处理器。<br><a id="more"></a></p>
<h4 id="CPU-核心数"><a href="#CPU-核心数" class="headerlink" title="CPU 核心数"></a>CPU 核心数</h4><p>　一个核心就是一个物理线程，<strong>单核</strong>、<strong>双核</strong>、<strong>多核</strong>，指的就是物理核心的数目。
　　</p>
<h4 id="CPU-线程数"><a href="#CPU-线程数" class="headerlink" title="CPU 线程数"></a>CPU 线程数</h4><p>　CPU 的线程数概念仅仅只针对 Intel 的 CPU 才有用，因为它是通过 Intel 超线程技术来实现的，最早应用在 Pentium4 上。如果没有超线程技术，一个 CPU 核心对应一个线程（因此对于一个CPU，线程数总是大于或等于核心数的）。所以，对于 AMD 的 CPU 来说，只有核心数的概念，没有线程数的概念。<br>　CPU 之所以要增加线程数，是源于多任务处理的需要：线程数越多，越有利于同时运行多个程序，因为线程数等同于在某个瞬间 CPU 能同时并行处理的任务数。<br>　因此，线程数是一种逻辑的概念，简单地说，就是模拟出的 CPU 核心数。一个核心最少对应一个线程，但英特尔有个超线程技术可以把一个物理线程模拟出两个线程来用，充分发挥 CPU 性能，即一个核心可以有两个到多个线程。</p>
<h4 id="Linux-中获取处理器信息"><a href="#Linux-中获取处理器信息" class="headerlink" title="Linux 中获取处理器信息"></a>Linux 中获取处理器信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看 cpu 型号</span></div><div class="line">sudo dmidecode <span class="_">-s</span> processor-version</div><div class="line"><span class="comment"># 查看 cpu 个数</span></div><div class="line">grep <span class="string">'physical id'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div><div class="line"><span class="comment"># 查看核心数</span></div><div class="line">grep <span class="string">'core id'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div><div class="line"><span class="comment"># 查看线程数</span></div><div class="line">grep <span class="string">'processor'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div></pre></td></tr></table></figure>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　处理器（CPU）决定了电脑的性能等级，是一个需要考虑的核心因素。CPU 从早期的单核，发展到现在的双核，多核。除了&lt;strong&gt;核心数&lt;/strong&gt;之外，还有&lt;strong&gt;线程数&lt;/strong&gt;之说，下面会对这两个概念进行扫盲。
　　&lt;/p&gt;
&lt;h4 id=&quot;CPU-个数&quot;&gt;&lt;a href=&quot;#CPU-个数&quot; class=&quot;headerlink&quot; title=&quot;CPU 个数&quot;&gt;&lt;/a&gt;CPU 个数&lt;/h4&gt;&lt;p&gt;　CPU 的个数是指物理上，也就是硬件上存在着几颗物理 CPU，指的是真实存在的处理器的个数，1个代表1颗、2个代表2颗 CPU 处理器。&lt;br&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="体系结构" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>一张图带你看 Ubuntu(Linux) 系统启动过程</title>
    <link href="http://durant35.github.io/2017/05/13/hsw_UbuntuSystemBootSequence/"/>
    <id>http://durant35.github.io/2017/05/13/hsw_UbuntuSystemBootSequence/</id>
    <published>2017-05-13T14:04:00.000Z</published>
    <updated>2017-05-13T14:21:12.278Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="/img/hsw/BootProcess4Ubuntu.png" width="1600px"/></center><br><a id="more"></a></p>
<h3 id="计算机系统的启动过程"><a href="#计算机系统的启动过程" class="headerlink" title="计算机系统的启动过程"></a>计算机系统的启动过程</h3><blockquote>
<p><a href="https://blog.auroraka.com/2017/02/02/%e5%a4%9a%e7%b3%bb%e7%bb%9f%e6%8a%98%e8%85%be%e8%ae%b0/">Auroraka’s Blog：多系统折腾记——总结</a></p>
</blockquote>
<ol>
<li>计算机通电</li>
<li>CPU读取内置ROM芯片中的数据，BIOS或UEFI进行系统自检，并按照预先设置的优先级依次尝试寻找各储存器，并将控制权交给该储存设备(硬盘)</li>
<li>如果是BIOS启动，系统确定储存器分区表的分区以及操作系统所在的分区，并将控制权转交给操作系统。如果是EFI启动，系统首先确定分区表的分区，接着寻找文件系统格式为FAT32的分区，并按照其中的内容启动EFI系统，接着按照情况启动操作系统的boot loader，将控制权转交给操作系统</li>
<li>操作系统启动</li>
</ol>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/hsw/BootProcess4Ubuntu.png&quot; width=&quot;1600px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="体系结构" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0012] Dynamic Programming(IV)（Longest Palindromic Subsequence）</title>
    <link href="http://durant35.github.io/2017/05/12/Algorithms_LongestPalindromicSubsequence/"/>
    <id>http://durant35.github.io/2017/05/12/Algorithms_LongestPalindromicSubsequence/</id>
    <published>2017-05-12T06:00:22.000Z</published>
    <updated>2017-05-25T13:27:37.091Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong><a href="https://leetcode.com/problems/longest-palindromic-subsequence/#/description"> 516. Longest Palindromic Subsequence </a></strong> 分析。<br><a id="more"></a></p>
<h4 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h4><p><a href="https://leetcode.com/problems/longest-palindromic-substring/#/description">5. Longest Palindromic Substring</a></p>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/#/description"> 516. Longest Palindromic Subsequence </a> 解题思路</p>
<ul>
<li>思路一：递归方法</li>
<li>思路二：动态规划</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-subsequence/#/description&quot;&gt; 516. Longest Palindromic Subsequence &lt;/a&gt;&lt;/strong&gt; 分析。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）</title>
    <link href="http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/"/>
    <id>http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/</id>
    <published>2017-05-03T06:00:22.000Z</published>
    <updated>2017-05-15T13:06:15.880Z</updated>
    
    <content type="html"><![CDATA[<p>　　子序列和子字符串的不同之处在于，子序列不需要是原序列上连续的字符。对于 <a href="http://www.lintcode.com/en/problem/longest-common-substring/">Longest Common Substring</a> 以及 <a href="http://www.lintcode.com/en/problem/longest-common-subsequence/"> Longest Common Subsequence</a> 这类题目，大多数需要用到 DP 的思想，其中，状态转移是关键。<br><a id="more"></a></p>
<h4 id="最长公共子字符串"><a href="#最长公共子字符串" class="headerlink" title="最长公共子字符串"></a>最长公共子字符串</h4><blockquote>
<p>Given two strings, find the longest common substring.<br>Return the length of it.</p>
<ul>
<li><strong>Example</strong><br>　Given A = “ABCD”, B = “CBCE”, return 2.</li>
</ul>
</blockquote>
<ul>
<li>$L(idxA, idxB)$：以 $A[idxA]$ 和 $B[idxB]$ 结尾的相同子字符串的最长长度。最长公共子字符串必然存在所有情况中以 A 序列中某个字符结尾，以 B 序列中某个字符结尾的一种情况，所以<strong>取所有可能情况中的最大值</strong>即为 Longest Common Substring 的长度。<ul>
<li>因为要求子串连续，所以对于 $A_{idxA}$ 与 $B_{idxB}$ 来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串。<br>$$ L(idxA, idxB) =  \begin{cases}<br>  if（idxA==0||idxB==0）: \begin{cases} 1, A[idxA]==B[idxB] \cr 0, others \end{cases} \cr<br>  else-if（A[idxA]==B[idxB]）: L(idxA-1, idxB-1) + 1 \cr<br>  else: 0<br>  \end{cases}<br>$$</li>
<li>上述过程的示例图如下，可以看出只有对角线方向上的长度延伸，长度不能保留。<br><center><img src="/img/Algorithms/0011_LCStringProcessDemo.jpg" width="480px"/></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>: </div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two string.</div><div class="line">     * @return: the length of the longest common substring.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the largest length of LCS ending with A[idxA] and B[idxB] </span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                L[idxA][idxB] = A[idxA]==B[idxB]? L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>]+<span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxLenIdx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                    maxLenIdx = idxA;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="blue">提取最长公共子串</font><ul>
<li>使用变量 <code>maxLenIdx</code> 记录最长公共子串（长度 <code>maxLen</code> ）对应的结尾字符下标（序列 A/B 都可以），回退获取 <code>maxLen</code> 个字符即可。</li>
</ul>
</li>
</ul>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><blockquote>
<p>Given two strings, find the longest common subsequence (<em>LCS</em>).<br>Your code should return the length of <em>LCS</em>.</p>
<ul>
<li><strong>Example</strong><br>　For “ABCD” and “EDCA”, the LCS is “A” (or “D”, “C”), return 1.<br>　For “ABCD” and “EACB”, the LCS is “AC”, return 2.</li>
</ul>
</blockquote>
<ul>
<li>$L(idxA, idxB)$：以 $A_{idxA}$ 结尾的子串（$A[0, 1, …, idxA], 0 \leq idxA \lt len_A$） 和 $B_{idxB}$ 结尾的子串（$B[0, 1, …, idxB], 0 \leq idxB \lt len_B$）最长公共子序列的长度。自然地，$L(len_A-1, len_B-1)$ 即为所求的最长公共子序列长度。</li>
<li>与子串不同，子序列可以是不连续的。<ul>
<li>$L(idxA, idxB)$ 与 $L(idxA-1, idxB-1)$ 两者其实只差 $A_{idxA}$ 和 $B_{idxB}$ 这一对字符。</li>
<li>如果 $A_{idxA}$ 和 $B_{idxB}$ 相同，那么就只要在以 $A_{idxA}$ 和以 $B_{idxB}$ 结尾的两个子串的最长公共子序列之后添上这个相同字符即可，这样就可以让长度增加一位。</li>
<li>如果 $A_{idxA}$ 和 $B_{idxB}$ 不同，两个子串在末尾添加一个字符后最长公共子序列并不能得到延伸。考虑到 $A_{idxA}$ 可能与 $B_{idxB-1}$ 相同或者 $B_{idxB}$ 会与 $A_{idxA-1}$ 相同，没能延伸的最长公共子序列只能在 $L(idxA, idxB-1)$ 和 $L(idxA-1, idxB)$ 存在，取更长的那个。</li>
<li>结合边界限制，最终得到的状态转移方程如下：<br>$$ L(idxA, idxB) =  \begin{cases}<br>  if（idxA==0）: \begin{cases} 1, B[idxB]==A[0] \cr L(0, idxB-1), others \end{cases} \cr<br>  else·if（idxB==0）: \begin{cases} 1, A[idxA]==B[0] \cr L(idxA-1, 0), others \end{cases} \cr<br>  else·if（A[idxA]==B[idxB]）: L(idxA-1, idxB-1) + 1 \cr<br>  else: max(L(idxA, idxB-1), L(idxA-1, idxB))<br>  \end{cases}<br>$$</li>
<li>上述过程的示例图如下，可以看出同样只有对角线方向上的长度延伸，不过长度可以在 <strong>上→下</strong> 和 <strong>左→右</strong> 方向上得到保留。<br><center><img src="/img/Algorithms/0011_LCSequenceProcessDemo.png" width="450px"/></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two strings.</div><div class="line">     * @return: The length of longest common subsequence of A and B.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the length of the LCS ending with A[idxA] and B[idxB]</span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="comment">// for recording LCS's tail element index</span></div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, maxLenIdxA = <span class="number">0</span>, maxLenIdxB = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        L[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : L[<span class="number">0</span>][idxB<span class="number">-1</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// for recording LCS's tail element index</span></div><div class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>][idxB] &gt; maxLen) &#123;</div><div class="line">                maxLen = L[<span class="number">0</span>][idxB];</div><div class="line">                maxLenIdxB = idxB;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : L[idxA<span class="number">-1</span>][<span class="number">0</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// for recording LCS's tail element index</span></div><div class="line">            <span class="keyword">if</span>(L[idxA][<span class="number">0</span>] &gt; maxLen) &#123;</div><div class="line">                maxLen = L[idxA][<span class="number">0</span>];</div><div class="line">                maxLenIdxA = idxA;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">                <span class="keyword">if</span>(A[idxA] == B[idxB]) &#123;</div><div class="line">                    L[idxA][idxB] = L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    L[idxA][idxB] = max(L[idxA][idxB<span class="number">-1</span>], L[idxA<span class="number">-1</span>][idxB]);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// for recording LCS's tail element index</span></div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                    maxLenIdxA = idxA;</div><div class="line">                    maxLenIdxB = idxB;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> L[lenA<span class="number">-1</span>][lenB<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="blue">提取最长公共子序列</font><ul>
<li>使用变量 <code>maxLen</code> 记录最长公共子序列的长度，并通过变量 <code>maxLenIdxA</code> 和 <code>maxLenIdxB</code> 记录该最长长度序列末尾字符对应的序列 A 和序列 B 中的字符下标。</li>
<li>在序列 A 和 B 中分别从下标 <code>maxLenIdxA</code> 和 <code>maxLenIdxB</code> 向左挪动，找出  <code>maxLen</code> 个相同字符，即为提取的最长公共子序列。</li>
<li>如何在序列 A 和 B 中向左挪动呢？<ul>
<li><code>A[maxLenIdxA]==B[maxLenIdxB]</code>，当前字符相同，同时左挪（因为公共子序列的特点，此时二者肯定均为到达边界）：<code>maxLenIdxA--</code> &amp; <code>maxLenIdxB--</code>。</li>
<li><code>A[maxLenIdxA]!=B[maxLenIdxB]</code>，当前字符不相同<ul>
<li>有挪动到边界（0）的，只能挪动另一个还没到边界的；假如同时挪动到边界，由于  <code>maxLen</code> 的准确性，说明已经提取出最长公共子序列。</li>
<li><code>L[idxA][idxB-1]</code> 大，说明 <code>A[maxLenIdxA]</code> 可能与序列 B 中下一个字符相同，需要挪动序列 B：<code>maxLenIdxB--</code>；反之，则需要挪动序列 A：<code>maxLenIdxA--</code>。</li>
</ul>
</li>
</ul>
</li>
<li>具体的代码实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> LCS;</div><div class="line"><span class="keyword">while</span>(maxLenIdxA&gt;=<span class="number">0</span> &amp;&amp; maxLenIdxB&gt;=<span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(A[maxLenIdxA] == B[maxLenIdxB]) &#123;</div><div class="line">        LCS += A[maxLenIdxA];</div><div class="line">        maxLenIdxA--;</div><div class="line">        maxLenIdxB--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(maxLenIdxA == <span class="number">0</span>) &#123;</div><div class="line">            maxLenIdxB--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(maxLenIdxB == <span class="number">0</span>) &#123;</div><div class="line">            maxLenIdxA--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(L[maxLenIdxA][maxLenIdxB<span class="number">-1</span>] &lt; L[maxLenIdxA<span class="number">-1</span>][maxLenIdxB]) &#123;</div><div class="line">                maxLenIdxB--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxLenIdxA--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　子序列和子字符串的不同之处在于，子序列不需要是原序列上连续的字符。对于 &lt;a href=&quot;http://www.lintcode.com/en/problem/longest-common-substring/&quot;&gt;Longest Common Substring&lt;/a&gt; 以及 &lt;a href=&quot;http://www.lintcode.com/en/problem/longest-common-subsequence/&quot;&gt; Longest Common Subsequence&lt;/a&gt; 这类题目，大多数需要用到 DP 的思想，其中，状态转移是关键。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0010] Longest Increasing Subsequence（最长递增子序列）</title>
    <link href="http://durant35.github.io/2017/04/28/Algorithms_LongestIncreasingSubsequence/"/>
    <id>http://durant35.github.io/2017/04/28/Algorithms_LongestIncreasingSubsequence/</id>
    <published>2017-04-28T06:00:22.000Z</published>
    <updated>2017-05-15T06:31:11.744Z</updated>
    
    <content type="html"><![CDATA[<h4 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/#/description">300. Longest Increasing Subsequence</a></h4><blockquote>
<p>Given an unsorted array of integers, find the length of longest increasing subsequence.<br>For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. </p>
</blockquote>
<ul>
<li>给出一个序列 $a_1, a_2, …, a_n$，求它的一个子序列（设为 $s_1, s_2, …, s_n$ ），使得这个子序列满足这样的性质：$ s_1 &lt; s_2 &lt; s_3 &lt;…&lt; s_n $ 并且这个子序列的长度最长，输出这个最长的长度。实际上，诸如最长下降子序列，最长不上升子序列等问题都可以看成同一个问题，仔细思考就会发现，这其实只是 $&lt;$ 符号定义上的问题，并不影响问题的实质。<a id="more"></a>
<h4 id="转化为图的最长路径问题（-O-N-2-）"><a href="#转化为图的最长路径问题（-O-N-2-）" class="headerlink" title="转化为图的最长路径问题（$O(N^2)$）"></a>转化为图的最长路径问题（$O(N^2)$）</h4></li>
<li>解决最长递增子序列的一种方法是将其转换为图的最长路径问题（可以说是一种归约思想）<ul>
<li>为序列中的每个元素 $a_i$ 建立一个对应的节点 i。</li>
<li>对于任意两个可能在某递增序列中存在递进关系的元素 $a_i$ 和 $a_j$（即，同时满足 $ i &lt; j $，且 $ a_i &lt; a_j $），增加一条连接二者对应节点的有向边 $i-&gt;j$。</li>
<li>基于简单的动态规划，寻找转化后的图中的最长路径。如下图：<center><img src="/img/Algorithms/0010_LISGraph.png" width="640px"/></center></li>
</ul>
</li>
<li>基于上述思路的代码实现如下：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> graph[<span class="number">10000</span>][<span class="number">10000</span>];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="comment">//sanity check</span></div><div class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;numsSize; fromIdx++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> toIdx=fromIdx+<span class="number">1</span>; toIdx&lt;numsSize; toIdx++) &#123;</div><div class="line">            graph[fromIdx][toIdx] = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// convert the sequence into a directed graph</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;numsSize; fromIdx++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> toIdx=fromIdx+<span class="number">1</span>; toIdx&lt;numsSize; toIdx++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[toIdx] &gt; nums[fromIdx]) &#123;</div><div class="line">                graph[fromIdx][toIdx] = <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// find the longest path &lt;--&gt; LIS</span></div><div class="line">    <span class="keyword">int</span> L[numsSize];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">int</span> localMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;=idx; fromIdx++) &#123;</div><div class="line">            <span class="keyword">if</span>(graph[fromIdx][idx] == <span class="number">1</span>) &#123;</div><div class="line">                <span class="keyword">if</span>(L[fromIdx] &gt; localMax) &#123;</div><div class="line">                    localMax = L[fromIdx];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        L[idx] = localMax + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> globalMax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">if</span>(L[idx] &gt; globalMax) &#123;</div><div class="line">            globalMax = L[idx];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> globalMax;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">需要特别留意的是：</font>存储转换后的图的邻接矩阵 graph，实际上应该是一个动态大小的二维数组，然而，由于 <strong>堆栈内存限制</strong>，只能将其预设为足够大小的二维数组，作为 <strong>全局</strong> 或者 <strong>static</strong> 变量在堆中开辟内存，避免 <strong>Runtime Error</strong>（堆栈溢出）的错误。</li>
<li>在求解转换后的图中的最长路径时，采用了动态规划的方法<ul>
<li>$L[idx]$ ：第 idx 个元素对应的节点的最长路径（从根（序列的第一个元素）出发）；</li>
<li>$L[idx+1]$ 显然为带有最大最长路径的前驱节点的最长路径+1。</li>
</ul>
</li>
<li>算法是可行准确的，但是运行效率就不敢恭维了。<br><img src="/img/Algorithms/0010_LISGraph_result.png" width="720px"/></li>
</ul>
<h4 id="动态规划（-O-N-2-）"><a href="#动态规划（-O-N-2-）" class="headerlink" title="动态规划（$O(N^2)$）"></a>动态规划（$O(N^2)$）</h4><ul>
<li>既然是动态规划法，那么最重要的自然就是寻找子问题，对于这个问题，我们找到他的子问题<ul>
<li>用$dp[idx]$ 来存放以 $a_{idx}$ 结尾的最大递增子序列长度。</li>
</ul>
</li>
<li>找到子问题之后，接下来就是关于子问题如何求解的问题（状态转移方程）<ul>
<li>想求以 $a_{idx}$ 结尾的最大递增子序列的长度，我们就需要遍历 $idx$ 之前的所有位置 $ i, i \in [1, idx-1]$，在这些 $ i $ 中，找出 $ a[i] &lt; a[idx]$，计算能产生最大 $dp[i]$ 的 $i$，之后就可以求出 $dp[idx]$： $dp[idx] = max(dp[i]) + 1, i \in [1, idx-1]  \&amp;\&amp;  a_i &lt; a_{idx}$。</li>
</ul>
</li>
<li>对序列中的每一个元素都计算以他们各自结尾的最大递增子序列的长度，这些长度的最大值，就是我们要求的问题 —— 序列的最大递增子序列。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="comment">// sanity check</span></div><div class="line">    <span class="keyword">if</span>(numsSize &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// dp[idx]: the length of the LIS ending with the idx-th element</span></div><div class="line">    <span class="keyword">int</span> dp[numsSize];</div><div class="line">    <span class="comment">// prev[idx]:record the previous index of the LIS ending with the idx-th element</span></div><div class="line">    <span class="keyword">int</span> prev[numsSize];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="comment">// the maximum length of previous index LIS ending with an element not greater than current element </span></div><div class="line">        <span class="keyword">int</span> localIdxMax = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;idx; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[idx] &amp;&amp; dp[i] &gt; localIdxMax) &#123;</div><div class="line">                localIdxMax = dp[i];</div><div class="line">                prev[idx] = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        dp[idx] = localIdxMax + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// the longest increasing subsequence should ending with one index-th element</span></div><div class="line">    <span class="keyword">int</span> totalMax = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">if</span>(dp[idx] &gt; totalMax) &#123;</div><div class="line">            totalMax = dp[idx];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> totalMax;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>因为避免了将问题转化为图这一繁琐的步骤，所以虽然同为 $O(N^2)$ 的复杂度，这种方法效率明显提升了。<br><img src="/img/Algorithms/0010_dp_result.png" width="720px"/></li>
</ul>
<h4 id="耐心排序法（-O-N-logN-）"><a href="#耐心排序法（-O-N-logN-）" class="headerlink" title="耐心排序法（$O(N logN)$）"></a>耐心排序法（$O(N logN)$）</h4><ul>
<li>上面的解法时间复杂度仍然为 $O(N^2)$，仔细分析一下原因，之所以慢，是因为<font color="blue">对于每一个新的位置 $idx$ 都需要遍历 $idx$ 之前的所有位置 $ i, i \in [1, idx-1]$</font>，找出之前位置的最长递增子序列长度。我们是不是可以有一种方法能不用遍历之前所有的位置，而可以更快的确定 $i$ 的位置呢？<ul>
<li>举个例子，比如序列 $1, 3, 5, 2, 8, 4, 6$ 这个例子中，当到 6 时，我们一共可以有四种(1)不同长度；(2)保证该升序序列在同长度升序序列中末尾最小的升序序列<ul>
<li>1</li>
<li>1,2</li>
<li>1,2,4</li>
<li>1,2,4,6</li>
</ul>
</li>
<li>以上这些序列都是未来有可能成为最长序列的候选序列。这样，每来一个新的数，我们便按照以下规则更新这些序列：<ul>
<li>如果 $idx$ 元素比所有序列的末尾都大，说明有一个更长的递增序列产生，我们把最长的序列复制一遍，并加上这个元素。</li>
<li>如果 $idx$ 元素比所有序列的末尾都小，说明长度为1的序列可以更新了，更新为这个更小的末尾。</li>
<li>如果刚好在中间，则更新那个末尾数字刚刚大于等于自己的那个序列，说明那个长度的序列可以更新了。</li>
</ul>
</li>
</ul>
</li>
<li>基于上面的例子，我们可以推导出这样的一种思路<ul>
<li>$A[i]$ 数组用来记录长度为 $i$ 的递增子序列的末尾元素的最小值<ul>
<li>其中$ i \leq numsSize$</li>
<li>数组 $A[i]$ 的 size 为 $numsSize+1$</li>
<li>我们很容易能够得到关于数组 $A[i]$ 的一个性质：$i &lt; j$ 时，$A[i] &lt; A[j]$</li>
</ul>
</li>
<li>maxLen 变量记录当前的最长递增子序列的长度。</li>
<li>上述的更新规则就转变成对 $A[1, 2, i, maxLen]$ 数组进行更新。<ul>
<li>$A[1, 2, i, maxLen]$ 是有序的</li>
<li>更新操作只需要进行替换而不需要挪动——也就是说，我们可以使用二分查找，将<font color="blue">每个 $idx$ 元素对 $A[1, 2, i, maxLen]$ 数组的更新时间优化到 $O(logN)$（不需要 $O(N)$ 了）</font>，算法的时间复杂度就降低到了$O(N logN)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</div><div class="line"> * finds a minimum value greater than findingNum in findingArray[1, 2, ..., findingArraySize] and returns its position</div><div class="line"> *  findingArray should be in order</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* findingArray, <span class="keyword">int</span> findingArraySize, <span class="keyword">int</span> findingNum)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> begin = <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> end = findingArraySize;</div><div class="line">    <span class="keyword">while</span>(begin &lt;= end) &#123;</div><div class="line">        <span class="keyword">int</span> mid = begin + (end - begin)/<span class="number">2</span>;</div><div class="line">        <span class="keyword">if</span>(findingArray[mid] &gt; findingNum) &#123;</div><div class="line">            end = mid - <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(findingArray[mid] &lt; findingNum) &#123;</div><div class="line">            begin = mid + <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// return the same value position for covering</span></div><div class="line">            <span class="keyword">return</span> mid;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// return postion to insert after</span></div><div class="line">    <span class="keyword">return</span> begin;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="comment">// sanity check</span></div><div class="line">    <span class="keyword">if</span>(numsSize &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// A[i=1, 2, ..., maxLen]: the minimum value of the end element of the i-length increasing sequence</span></div><div class="line">    <span class="keyword">int</span> A[numsSize+<span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> maxLen;</div><div class="line">    </div><div class="line">    maxLen = <span class="number">1</span>;</div><div class="line">    A[<span class="number">1</span>] = nums[<span class="number">0</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">1</span>; idx&lt;numsSize; idx++) &#123;</div><div class="line">        <span class="keyword">if</span>(nums[idx] &gt; A[maxLen]) &#123;</div><div class="line">            maxLen += <span class="number">1</span>;</div><div class="line">            A[maxLen] = nums[idx];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">int</span> pos = binarySearch(A, maxLen, nums[idx]);</div><div class="line">            A[pos] = nums[idx];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> maxLen;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>复杂度从 $O(N^2)$ 缩小到 $O(N logN)$，运行效率得到较大的提升。<br><img src="/img/Algorithms/0010_nlogn_result.png" width="720px"/></li>
</ul>
<h4 id="提取最长递增子序列"><a href="#提取最长递增子序列" class="headerlink" title="提取最长递增子序列"></a>提取最长递增子序列</h4><ul>
<li>规约为图的最长路径问题<ul>
<li>利用 $prev[numsSize]$ 数组记录每个最长路径 $L[idx]$ 的前驱节点元素下标 $prev[idx]$，通过 $prev[idx]$ 迭代还原出最长路径。</li>
<li>具体实现与下面的动态规划类似。</li>
</ul>
</li>
<li>动态规划  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// int totalMaxIdx = &lt;idx for toalMax element index&gt;;</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; nums[totalMaxIdx];</div><div class="line"><span class="keyword">int</span> prevIdx = prev[totalMaxIdx];</div><div class="line"><span class="keyword">while</span>(prevIdx != <span class="number">-1</span>) &#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; nums[prevIdx];</div><div class="line">  prevIdx = prev[prevIdx];</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>耐心排序法<ul>
<li>$A[i=1, 2, …, maxLen]$ 就是满足要求的最长递增子序列。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;300-Longest-Increasing-Subsequence&quot;&gt;&lt;a href=&quot;#300-Longest-Increasing-Subsequence&quot; class=&quot;headerlink&quot; title=&quot;300. Longest Increasing Subsequence&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-increasing-subsequence/#/description&quot;&gt;300. Longest Increasing Subsequence&lt;/a&gt;&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;br&gt;For example, Given [10, 9, 2, 5, 3, 7, 101, 18], The longest increasing subsequence is [2, 3, 7, 101], therefore the length is 4. Note that there may be more than one LIS combination, it is only necessary for you to return the length. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;给出一个序列 $a_1, a_2, …, a_n$，求它的一个子序列（设为 $s_1, s_2, …, s_n$ ），使得这个子序列满足这样的性质：$ s_1 &amp;lt; s_2 &amp;lt; s_3 &amp;lt;…&amp;lt; s_n $ 并且这个子序列的长度最长，输出这个最长的长度。实际上，诸如最长下降子序列，最长不上升子序列等问题都可以看成同一个问题，仔细思考就会发现，这其实只是 $&amp;lt;$ 符号定义上的问题，并不影响问题的实质。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0009] Dynamic Programming(II)（Maximum Sum/Product Subarray）</title>
    <link href="http://durant35.github.io/2017/04/23/Algorithms_Dynamic%20Programming(II)/"/>
    <id>http://durant35.github.io/2017/04/23/Algorithms_Dynamic Programming(II)/</id>
    <published>2017-04-23T06:00:22.000Z</published>
    <updated>2017-05-15T07:05:05.488Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong><a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> &amp; <a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a></strong> 分析根据动态规划思路进行问题求解中的一个关键环节：子问题的拆分和求解。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><ul>
<li>两道题解决的问题相似，都是求解给定序列中满足某种数学特征（和最大/乘积最大）的子序列，虽然不需要将该子序列输出。</li>
</ul>
<blockquote>
<p>Find the contiguous subarray within an array(containing at least one number) which has the largest sum/product.</p>
<ul>
<li>For example, given the array [-2,1,-3,4,-1,2,1,-5,4], the contiguous subarray [4,-1,2,1] has the largest sum = 6. </li>
<li>For example, given the array [2,3,-2,4], the contiguous subarray [2,3] has the largest product = 6. </li>
</ul>
</blockquote>
<ul>
<li>留意的关键字眼是：<code>containing at least one number</code>，所以给定序列至少有一个元素，这也启发我们可以将其作为特殊处理。</li>
</ul>
<h4 id="53-Maximum-Subarray-解题思路"><a href="#53-Maximum-Subarray-解题思路" class="headerlink" title="53. Maximum Subarray 解题思路"></a><a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> 解题思路</h4><ul>
<li>思路一：$sums[j]$ 为序列前 j 个元素的最大子段和作为求解的子问题，则 $sum[n]$ 则为问题的答案。然而，如何利用 $sums[1, 2, …, j-1]$ 对 $sums[j]$ 进行求解呢？显然需要知道前 j 个元素的最大字段和的子段起始和终止位置，求解这个子问题的状态迁移显然比较复杂。</li>
<li>换一种思路。思路二：$sums[j]$ 为以第 j 个元素为结尾的子段的最大子段和作为求解的子问题，$max_{1 \leq j \leq n}(sums[j])$ 即为整个序列的最大子段和。而通过 $sums[j-1]$ 和当前元素 $nums[j]$ 即可计算以第 j 个元素为结尾的最大子段和 $sums[j]$，<code>状态转移方程</code> 如下：<br>$$ sums[j+1] = \begin{cases}  nums[j+1]　　　　　　sums[j] \lt 0 \cr sums[j] + nums[j+1]　others \end{cases}$$</li>
<li>根据思路二，<a href="https://leetcode.com/problems/maximum-subarray/#/description">53. Maximum Subarray</a> 解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> sums[SizeofNums];</div><div class="line">        sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="comment">// sums[i]: The largest sum of subarray ending with the i-th element</span></div><div class="line">            sums[i] = sums[i<span class="number">-1</span>]&lt;<span class="number">0</span> ? nums[i] : sums[i<span class="number">-1</span>]+nums[i]; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// The largest sum of the whole array</span></div><div class="line">        <span class="keyword">int</span> largestSum = sums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(largestSum &lt; sums[i]) &#123;</div><div class="line">                largestSum = sums[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>为了得到 <code>largestSum</code> 对应的子序列，我们可以通过变量 <code>startIdx</code> 记录以第 j 个元素结尾（<code>endIdx</code>）的最大子段和对应子序列的起始位置，$nums[startIdx, …, endIdx]$ 即为对应的子序列；另外，考虑到<strong>当前状态只与前一个状态有关</strong>，所以可以使用变量代替数组，节省内存，同时，避免获取<code>The largest sum of the whole array</code> 时的重复循环。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// largest sum for the subarray ending with current element </span></div><div class="line">        <span class="keyword">int</span> curSum = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// largest sum of subarray for the whole array</span></div><div class="line">        <span class="keyword">int</span> largestSum = curSum;</div><div class="line">        <span class="comment">// subarray[startIdx, endIdx] with largest sum for the whole array</span></div><div class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>, endIdx = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</div><div class="line">                curSum = nums[i];</div><div class="line">                startIdx = i;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                curSum = curSum + nums[i];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curSum &gt; largestSum) &#123;</div><div class="line">                largestSum = curSum;</div><div class="line">                endIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestSum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="152-Maximum-Product-Subarray-解题思路"><a href="#152-Maximum-Product-Subarray-解题思路" class="headerlink" title="152. Maximum Product Subarray 解题思路"></a><a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a> 解题思路</h4><ul>
<li>这一题的解题流程与上一题基本类似，但是要解决的关键问题是：状态转移，即如何根据上一个子问题（以第 j 个元素为结尾的子段的max product）的答案推算出当前子问题的结果。</li>
<li>从上一题的分析可以看出，当前子问题（以第 j 个元素为结尾的子段的max sum）的计算只需考虑上一个子问题的结果 $sum[j-1]$，$sum[j-1] &lt; 0$，因为是加法，显然可以将子问题结果忽略；$sum[j-1] &gt; 0$，$sum[j-1]$ 加上当前元素就是当前子问题的结果。</li>
<li>类似的问题，只不过换成乘积，子问题的求解就变得复杂了，需要考虑以下几种情况：<ul>
<li>当前元素是正数，max product可能是正正得正的情况，因为都是整数，乘积＞1，上一子问题的结果乘上当前元素即为当前子问题的答案</li>
<li>当前元素是负数，max product可能是负负得正的情况，因此需要维护以第 j 个元素为结尾的子段的min product（很大可能是负数）</li>
<li>另外，需要考虑上一个子问题的结果为0的情况</li>
<li>总之，乘积的最大值为上述三种情况之一<br>状态转移方程如下：<br>$$ maxProducts[j+1] = max(maxProducts[j-1]*nums[j], minProducts[j-1]*nums[j], nums[j])$$</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/maximum-product-subarray/#/description">152. Maximum Product Subarray</a> 解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The largest/least product of subarray ending with the i-th element</span></div><div class="line">        <span class="keyword">int</span> maxProducts[SizeofNums];</div><div class="line">        <span class="keyword">int</span> minProducts[SizeofNums];</div><div class="line">        maxProducts[<span class="number">0</span>] = minProducts[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="comment">// positive with positive, negative with negative, ignore previous zero</span></div><div class="line">            maxProducts[i] = max( max(maxProducts[i<span class="number">-1</span>]*nums[i], minProducts[i<span class="number">-1</span>]*nums[i]), nums[i]);</div><div class="line">            <span class="comment">// positive with negative, negative with positive, ignore previous zero</span></div><div class="line">            minProducts[i] = min( min(maxProducts[i<span class="number">-1</span>]*nums[i], minProducts[i<span class="number">-1</span>]*nums[i]), nums[i]);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// getting the largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> largestProduct = maxProducts[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">if</span>(maxProducts[i] &gt; largestProduct) &#123;</div><div class="line">                largestProduct = maxProducts[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> largestProduct;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>与上一题类似，添加额外变量，也能实现节省内存，记录子段最大乘积对应子段（$nums[startIdx, endIdx]$）的起始和终止位置。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> SizeofNums = nums.size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(SizeofNums == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// The largest/least product of subarray ending with the i-th element</span></div><div class="line">        <span class="keyword">int</span> largestProduct = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">int</span> leastProduct = nums[<span class="number">0</span>];</div><div class="line">        <span class="comment">// The largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> maxProduct = largestProduct;</div><div class="line">        <span class="comment">// subarray[startIdx, endIdx] with largest product for the whole array</span></div><div class="line">        <span class="keyword">int</span> startIdx = <span class="number">0</span>, endIdx = <span class="number">0</span>;</div><div class="line">        <span class="comment">// start index for largestProduct/leastProduct</span></div><div class="line">        <span class="keyword">int</span> startIdx_pos = startIdx, startIdx_neg = startIdx;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;SizeofNums; i++) &#123;</div><div class="line">            <span class="keyword">int</span> largestProduct_pre = largestProduct;</div><div class="line">            <span class="keyword">int</span> leastProduct_pre = leastProduct;</div><div class="line">            </div><div class="line">            <span class="comment">// positive with positive, negative with negative, ignore previous zero</span></div><div class="line">            largestProduct = max( max(largestProduct_pre*nums[i], leastProduct_pre*nums[i]), nums[i]);</div><div class="line">            <span class="keyword">if</span>((largestProduct_pre != nums[i]) &amp;&amp; (largestProduct == nums[i])) &#123;</div><div class="line">                startIdx_pos = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// positive with negative, negative with positive, ignore previous zero</span></div><div class="line">            leastProduct = min( min(largestProduct_pre*nums[i], leastProduct_pre*nums[i]), nums[i]);</div><div class="line">            <span class="keyword">if</span>((leastProduct_pre != nums[i]) &amp;&amp; (leastProduct == nums[i])) &#123;</div><div class="line">                startIdx_neg = i;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(largestProduct &gt; maxProduct) &#123;</div><div class="line">                maxProduct = largestProduct;</div><div class="line">                <span class="keyword">if</span>(largestProduct_pre*nums[i] &gt; leastProduct_pre*nums[i]) &#123;</div><div class="line">                    startIdx = startIdx_pos;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    startIdx = startIdx_neg;</div><div class="line">                &#125;</div><div class="line">                endIdx = i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> maxProduct;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;&lt;a href=&quot;https://leetcode.com/problems/maximum-subarray/#/description&quot;&gt;53. Maximum Subarray&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode.com/problems/maximum-product-subarray/#/description&quot;&gt;152. Maximum Product Subarray&lt;/a&gt;&lt;/strong&gt; 分析根据动态规划思路进行问题求解中的一个关键环节：子问题的拆分和求解。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0008] Dynamic Programming(I)（Unique Paths）</title>
    <link href="http://durant35.github.io/2017/04/13/Algorithms_Dynamic%20Programming(I)/"/>
    <id>http://durant35.github.io/2017/04/13/Algorithms_Dynamic Programming(I)/</id>
    <published>2017-04-13T06:00:22.000Z</published>
    <updated>2017-05-15T07:04:09.443Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过 <strong>Unique Paths <a href="https://leetcode.com/problems/unique-paths/#/description">[I]</a> &amp; <a href="https://leetcode.com/problems/unique-paths-ii/#/description">[II]</a></strong> 两道题从普通的递归思路到动态规划两种方式的求解尝试，希望能够初步分析如何根据动态规划的思路，进行问题求解。<br><a id="more"></a></p>
<h4 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h4><p><center><img src="/img/Algorithms/0008_robot_maze.png" width="380px"/></center></p>
<ul>
<li>两道题解决的问题相似，都是求解从格网图左上角（Start）→ 右下角（Finish）可行的路径总数，而且行走方向只有向下或者向右移动两种方式，只是在以下两个地方存在一些区别：<ul>
<li><a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a> 行走的格网图不设立障碍，而 <a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 中行走的格网图存在障碍，在可行路径选取上需要考虑避开障碍物的问题。</li>
<li>由于上面的区别，导致在输入上两道题有所不同：前者只需要输入格网图的大小（#row*#column）；后者则需要提供格网图的0-1矩阵（1表示网格存在障碍物）</li>
</ul>
</li>
</ul>
<h4 id="递归思想解答"><a href="#递归思想解答" class="headerlink" title="递归思想解答"></a>递归思想解答</h4><ul>
<li>由于每一步的行走策略只有两种，不是向下走就是向右走，因此，假设当前这一步完成后到达右下角（#row，#column），那么只有（#row-1，#column）向下走和（#row，#column-1）向右走这两种方式，所以可行的路径总数显然就是从起点（1，1）到这两个中间点的可行路径总数之和。</li>
<li>按照上述的思路，很容易通过递归的方式最终会退到起点（递归基），并通过递归函数返回得到总的可行路径数目。</li>
<li>需要注意的一点是，由于每一步只有向右或者向下两种策略，所以，并不需要递归回起点（1，1），当回退到（1，？）或（？，1）时，从起点到当前中间点，有且只有一条路径（一直向右走或者一直想下走）。</li>
<li><a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a>  按照递归思路的解答如下：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// when m==1 or n==1, only directly down or directly right</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// left to right + up to down</span></div><div class="line">        <span class="keyword">return</span> uniquePaths(m, n<span class="number">-1</span>) + uniquePaths(m<span class="number">-1</span>, n);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 则需要进一步考虑当前步是否可行的问题，倘若存在障碍物，显然此路不通，不应计入可行路径的统计，<code>return 0</code>。</li>
<li>另外，与 <a href="https://leetcode.com/problems/unique-paths/#/description">Unique Paths [I]</a> 不同，只有回退到起点，才能判断通过递归历经的网格所构成的路径是可行的。因为，只是回退到（1，？）或（？，1），一旦起点到该中间点的<code>向右直走路径</code>或<code>向下直走路径</code>中间出现任何一个障碍物，该路径都是不可行的。</li>
<li>以下是递归解答，留意与前一道题目在输入上的区别。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(obstacleGrid[m<span class="number">-1</span>][n<span class="number">-1</span>] == <span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// obstacleGrid[0][0] == 0</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> &amp;&amp; n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// left to right</span></div><div class="line">        <span class="keyword">if</span>(m==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m, n<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// up to down</span></div><div class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m<span class="number">-1</span>, n);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// up to down + left to right</span></div><div class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, m<span class="number">-1</span>, n) + uniquePathsWithObstacles(obstacleGrid, m, n<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rowSize = obstacleGrid.size();</div><div class="line">        <span class="keyword">int</span> colSize = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        </div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>((colSize &lt; <span class="number">1</span>) || (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) || (obstacleGrid[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>] == <span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> uniquePathsWithObstacles(obstacleGrid, rowSize, colSize);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">递归思路解答对上述问题并不可行</font><ul>
<li>我们都知道，直接的递归实现，可读性强，但频繁的函数调用会造成一定的时间损耗，因此上述两题都存在 <code>Time Limit Exceeded</code> 的错误。</li>
<li>另一个更为关键的问题是，上述简单的递归实现，每次递归的时候都对从起点到达当前中间网格的可行路径数进行了重复计算，这种重复计算的代价是巨大的，往往需要好几层回退；假如能够避免这种冗余，肯定会带来巨大的提升。</li>
</ul>
</li>
</ul>
<h4 id="动态规划思路解答"><a href="#动态规划思路解答" class="headerlink" title="动态规划思路解答"></a>动态规划思路解答</h4><ul>
<li>动态规划思路就能很好解决上述的问题：回退的方式不好避免重复计算的问题（可能需要维护从起点到达每个网格可行路径总数的表，另外通过是否为<code>Inf</code>避免重复计算，为了让每次递归均能访问操作该表，需要将其置为全局变量），我们干脆换个方向，从起点出发，直到到达右下角；动态规划的过程就像是在填上述这样一个表。</li>
<li>通过递归回退+维护从起点到达每个网格可行路径总数的表避免冗余计算的方式（记忆化搜索），因为只有在右下角到起点的可行路径上的网格才会被计算，能够避开其他不必要的网格；但是，函数的调用显然有一定损耗。</li>
<li>动态规划这种填表的思路，会将所有网格对应的表项填满，但这种顺序进行的操作实现简易（通过一个数组，两三层循环即可实现），耗时也较少，因此在大多数问题（动态规划多余的计算数目并不算多）下较记忆化搜索有一定优势。</li>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 的动态规划解答关键已经在递归思路中体现，即：从起点到当前网格的可行路径总数为到左方网格（向右移动到达当前网格）及上方网格（向下移动达到当前网格）可行路径总数之和。<ul>
<li>需要注意的是，从起点到（1，？）或（？，1）的可行路径显然都只有一条（一直向右移动/一直向下移动）。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="comment">// sanity check</span></div><div class="line">        <span class="keyword">if</span>(m&lt;<span class="number">1</span> || n&lt;<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> paths[m][n];</div><div class="line">        <span class="comment">// paths(1, 1...n), left to right</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;n; col++) &#123;</div><div class="line">            paths[<span class="number">0</span>][col] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// paths(1...n, 1), up to down</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;m; row++) &#123;</div><div class="line">            paths[row][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;m; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;n; col++) &#123;</div><div class="line">                <span class="comment">// left to right + up to down</span></div><div class="line">                paths[row][col] = paths[row][col<span class="number">-1</span>] + paths[row<span class="number">-1</span>][col];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> paths[m<span class="number">-1</span>][n<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><a href="https://leetcode.com/problems/unique-paths-ii/#/description">Unique Paths [[II]</a> 思路基本一致，只是当当前网格存在障碍物，其到起点的可行路径显然不存在。<ul>
<li>另外，对于从起点到（1，？）或（？，1）可行路径的分析与递归思路解答时一致。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rowSize = obstacleGrid.size();</div><div class="line">        <span class="keyword">int</span> colSize = obstacleGrid[<span class="number">0</span>].size();</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>((rowSize &lt; <span class="number">1</span>) || (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) || (obstacleGrid[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>] == <span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> paths[rowSize][colSize];</div><div class="line">        <span class="comment">// obstacleGrid[0][0] == 0 from above</span></div><div class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// paths(1, 1...n)</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;colSize; col++) &#123;</div><div class="line">            paths[<span class="number">0</span>][col] = obstacleGrid[<span class="number">0</span>][col]==<span class="number">0</span> ? paths[<span class="number">0</span>][col<span class="number">-1</span>] : <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// paths(1...n, 1)</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            paths[row][<span class="number">0</span>] = obstacleGrid[row][<span class="number">0</span>]==<span class="number">0</span> ? paths[row<span class="number">-1</span>][<span class="number">0</span>] : <span class="number">0</span>;;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">1</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">1</span>; col&lt;colSize; col++) &#123;</div><div class="line">                <span class="comment">// left to right + up to down</span></div><div class="line">                paths[row][col] = obstacleGrid[row][col]==<span class="number">0</span> ? (paths[row][col<span class="number">-1</span>] + paths[row<span class="number">-1</span>][col]) : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> paths[rowSize<span class="number">-1</span>][colSize<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过 &lt;strong&gt;Unique Paths &lt;a href=&quot;https://leetcode.com/problems/unique-paths/#/description&quot;&gt;[I]&lt;/a&gt; &amp;amp; &lt;a href=&quot;https://leetcode.com/problems/unique-paths-ii/#/description&quot;&gt;[II]&lt;/a&gt;&lt;/strong&gt; 两道题从普通的递归思路到动态规划两种方式的求解尝试，希望能够初步分析如何根据动态规划的思路，进行问题求解。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0007] Minimum Spanning Tree（最小生成树）</title>
    <link href="http://durant35.github.io/2017/04/06/Algorithms_Minimum%20Spanning%20Tree/"/>
    <id>http://durant35.github.io/2017/04/06/Algorithms_Minimum Spanning Tree/</id>
    <published>2017-04-06T06:00:22.000Z</published>
    <updated>2017-05-07T14:59:15.063Z</updated>
    
    <content type="html"><![CDATA[<p>　本文将介绍带权图的最小生成树（Minimum Spanning Tree）算法：给定一个无向图 G，并且它的每条边均有权值，则 MST 是一个包括 G 的所有顶点及边的子集的图，这个子集保证图是连通的，并且子集中所有边的权值之和为所有子集中最小的。<br>　本文中介绍两种求解图的最小生成树的算法：Prim 算法和 Kruskal 算法，这两种算法都是贪心算法。一般而言，贪心策略不一定能保证找到全局最优解，但是对最小生成树问题来说，贪心策略能获得具有最小权值的生成树。<br><a id="more"></a></p>
<h4 id="Minimum-spanning-trees"><a href="#Minimum-spanning-trees" class="headerlink" title="Minimum spanning trees"></a>Minimum spanning trees</h4><ul>
<li>让所有节点都被连接的最佳边集合：不可能包含环。<ul>
<li>移除环中的任何一条边都会降低代价而不破坏<strong>连通性</strong>（所有节点都被连接）。</li>
</ul>
</li>
<li><strong>树</strong>是一种连通且无环的无向图。<ul>
<li>性质①：移除环中的任意一条边不会破坏图的连通性。</li>
<li>性质②：具有 n 个节点的树的边数为 n-1。<ul>
<li>n 个节点，n 个独立的连接部件。</li>
<li>边 ${u, v}$ 的两个顶点分别处于两个独立的连接部件，否则，必然已存在连接两者的一条路径， ${u, v}$ 将导致环的出现。</li>
<li>每添加一条边，总的连接部件数减少了 1，从 n 一步步减少到 1，需要添加 n-1 条边。</li>
</ul>
</li>
<li>性质③：任何一个连通无向图 $G = (V, E)$，若满足 $|E| = |V| - 1$，则其为树。<ul>
<li>如果 G 中包含一个环，则移除该环上任意一边，直到得到一个无环图。</li>
<li>G’ 是连通的（<code>性质①</code>），且无环，故为树，故 $|E’| = |V| - 1$（<code>性质②</code>），实际上并没有移除过任意一条边，其本身就是树，即 $G’ = G$。</li>
</ul>
</li>
<li>性质④：一个无向图是树，当且仅当在其任意两个节点间仅存在唯一路径。<ul>
<li>任意两个节点间都存在一条路径 ===&gt; 连通性</li>
<li>路径唯一 ===&gt; 无环，环必然使得任意两个节点间存在两条路径</li>
</ul>
</li>
</ul>
</li>
<li><strong>最小生成树</strong>：具有最小代价（总权重）的树<ul>
<li>图的生成树是它的一棵含有其所有顶点的无环连通子图，一幅加权图的最小生成树（MST）是它的一棵权值（树中的所有边的权值之和）最小的生成树。</li>
<li>树$T = (V, E’)$，其中 $E \subseteq E’$，使得权重 $weight(T) = \sum_{e \in E’} w_e$ 最小。</li>
</ul>
</li>
</ul>
<h4 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/luweiseu/archive/2012/07/14/2591446.html">6.3.2 最小支撑树树–Prim算法，基于优先队列的Prim算法，Kruskal算法，Boruvka算法，“等价类”UnionFind</a></li>
</ul>
</blockquote>
<ul>
<li>Prim 算法可以说是所有 MST 算法中最简单的，比较适用于稠密图。以图中任意一个顶点 s 开始，MST 初始化为 ：{ V(s), E(none) }（顶点，边），称之为“当前 MST”，选择与当前 MST 中所有顶点相关连的边中权值最小的边，并添加到当前 MST 中。这一过程一直迭代到图中所有顶点都添加到 MST 中为止。<ul>
<li>在迭代时，假设当前 MST 中顶点形成集合 $V(v_0, v_1, …)$，则对 $V(v_0, v_1, …)$ 中的每一个 $v_i$，遍历与其相邻的所有边，并找到权值最小的边。<center><img src="/img/Algorithms/0007_PrimPseudo.png" width="720px"/></center></li>
</ul>
</li>
<li>Prim 最小生成树算法与 <a href="http://durant35.github.io/2017/03/29/Algorithms_Some%20Shortest-path%20Algorithms/#Dijkstra-算法">Dijkstra 最短路径算法</a> 十分相似，只不过 Prim 算法里节点的值是该节点到当前最小生成树中所有节点的边中的最短长度，而 Dijkstra 算法中节点的值是该节点到源节点的当前最短路径长度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> start=<span class="number">0</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].cost = INT_MAX;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"MST constructing:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  g.VertexNodes[start].cost = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNuminMST = <span class="number">0</span>; vertexNuminMST &lt; g.vertexNum; vertexNuminMST++) &#123;</div><div class="line">    <span class="comment">// Pick the node not in current MST with smallest cost</span></div><div class="line">    <span class="keyword">int</span> minCost = INT_MAX;</div><div class="line">    <span class="keyword">int</span> pickIdx = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[i] &amp;&amp; g.VertexNodes[i].cost&lt;minCost) &#123;</div><div class="line">        minCost = g.VertexNodes[i].cost;</div><div class="line">        pickIdx = i;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// other nodes are unreachable</span></div><div class="line">    <span class="keyword">if</span>(pickIdx == <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    visited[pickIdx] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// select an edge</span></div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[pickIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[pickIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[pickIdx].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[pickIdx].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    VertexNode* v = &amp;g.VertexNodes[pickIdx];</div><div class="line"> </div><div class="line">    <span class="comment">// update the cost(cost to current MST) for the successor vertex of current adding node</span></div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// visited to avoid repeatedly update</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx]</div><div class="line">        &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].cost &gt; head-&gt;weight) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].cost = head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].prev = v;</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  Prim(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Prim.cpp -o Prim</div><div class="line">$ ./Prim</div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing:</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 2--&gt;1(8)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 5--&gt;2(4)</div><div class="line">  + 6--&gt;5(2)</div><div class="line">  + 7--&gt;6(1)</div><div class="line">  + 3--&gt;2(7)</div><div class="line">  + 4--&gt;3(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 8&lt;--2(2)</div><div class="line">  + 7&lt;--6(1)</div><div class="line">  + 6&lt;--5(2)</div><div class="line">  + 5&lt;--2(4)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--1(8)</div><div class="line">  + 1&lt;--0(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTPrim.png" width="640px"/></center></li>
<li>上述无向图对应的输入文件 <code>Prim.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">9 26</div><div class="line">0 1 2 3 4 5 6 7 8</div><div class="line">0 1 4</div><div class="line">0 7 8</div><div class="line">1 0 4</div><div class="line">1 2 8</div><div class="line">2 1 8</div><div class="line">2 3 7</div><div class="line">2 5 4</div><div class="line">2 8 2</div><div class="line">3 2 7</div><div class="line">3 4 9</div><div class="line">3 5 14</div><div class="line">4 3 9</div><div class="line">4 5 10</div><div class="line">5 2 4</div><div class="line">5 3 14</div><div class="line">5 4 10</div><div class="line">5 6 2</div><div class="line">6 5 2</div><div class="line">6 7 1</div><div class="line">6 8 6</div><div class="line">7 0 8</div><div class="line">7 6 1</div><div class="line">7 8 7</div><div class="line">8 2 2</div><div class="line">8 6 6</div><div class="line">8 7 7</div></pre></td></tr></table></figure>
<ul>
<li>从上述的实现过程可以发现，在遍历与顶点相邻的所有边寻找与当前 MST 最近的顶点时，需要进行循环判断，选择距离最近的边之后其余边的信息将被舍弃；在下次循环判断时这些舍弃的边又被再次参与“竞选”最近的边，这无疑带来了重复判断。可以引入一个 <strong>最小堆</strong>，堆中存放遍历过的边。在遍历与顶点相邻的所有边时，首先将连边添加到堆中，然后直接将堆顶的边取出并添加到 MST 中。这样就可以避免重复判断。<ul>
<li>基于 <code>std::priority_queue</code> 优先级队列的实现</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>		<span class="comment">/* priority_queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">  <span class="comment">/* reload compare operator for priority queue</div><div class="line">   * In order to achieve the minimum heap(in ascending order)</div><div class="line">   *   reload operator&lt;, redefine the priority to smaller one</div><div class="line">   */</span></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> VertexNode&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> cost &gt; right.cost;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> start=<span class="number">0</span>)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode&gt; vertexQueue;</div><div class="line"> </div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].cost = INT_MAX;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">    visited[g.VertexNodes[i].vertexIdx] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  g.VertexNodes[start].cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// make priority queue, using cost-values as keys</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    vertexQueue.push(g.VertexNodes[i]);</div><div class="line">  &#125;</div><div class="line"> 	</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMST constructing:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    <span class="comment">// print current priority queue</span></div><div class="line">    <span class="comment">// #define PRINT</span></div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    priority_queue&lt;VertexNode&gt; printQueue = vertexQueue;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">while</span>(!printQueue.empty()) &#123;</div><div class="line">      VertexNode tmp = printQueue.top();</div><div class="line">      printQueue.pop();</div><div class="line">      <span class="keyword">if</span>(tmp.cost != INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; tmp.data</div><div class="line">         	 &lt;&lt; <span class="string">"("</span></div><div class="line">           &lt;&lt; tmp.cost</div><div class="line">         	 &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">    VertexNode v = vertexQueue.top();</div><div class="line"> </div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\n\tpop: "</span> &lt;&lt; v.data &lt;&lt; <span class="string">"("</span>;</div><div class="line">    <span class="keyword">if</span>(v.cost != INT_MAX) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; v.cost;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">    vertexQueue.pop();</div><div class="line">  </div><div class="line">    <span class="keyword">int</span> vertexIdx = v.vertexIdx;</div><div class="line">    <span class="comment">// cout &lt;&lt; "[" &lt;&lt; vertexIdx &lt;&lt; "]";</span></div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// an edge is selecting </span></div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[vertexIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[vertexIdx].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[vertexIdx].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"push: "</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">    adjVertexNode* head = v.<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx]</div><div class="line">        &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].cost &gt; head-&gt;weight) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].cost = head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].prev = &amp;g.VertexNodes[v.vertexIdx];</div><div class="line">        vertexQueue.push(g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line"></div><div class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].cost &lt;&lt; <span class="string">")"</span></div><div class="line">           &lt;&lt; <span class="string">" "</span>;</div><div class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> PRINT</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  Prim(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Prim_queue.cpp -o Prim_queue</div><div class="line">$ ./Prim_queue </div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing:</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 7--&gt;0(8)</div><div class="line">  + 6--&gt;7(1)</div><div class="line">  + 5--&gt;6(2)</div><div class="line">  + 2--&gt;5(4)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 3--&gt;2(7)</div><div class="line">  + 4--&gt;3(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 8&lt;--2(2)</div><div class="line">  + 7&lt;--0(8)</div><div class="line">  + 6&lt;--7(1)</div><div class="line">  + 5&lt;--6(2)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--5(4)</div><div class="line">  + 1&lt;--0(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTPrimqueue.png" width="640px"/></center>

</li>
</ul>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/cielosun/p/5654539.html">并查集(union-find set)与Kruskal算法</a></li>
</ul>
</blockquote>
<ul>
<li>Prim 算法的思路是通过一次找出一条边添加到 MST 中，其中每一步都是要找到一条新的边并且关联到不断增长的当前 MST。Kruskal 算法也是一次找到一条边来不断构建 MST，但是与 Prim 算法不同的是，它要找到连接两棵树的一条边，这两棵树处于一个 MST 子树的分离的森林中，其中 MST 子树将不断增长。<ul>
<li>算法由一个包括 N 棵（单个顶点组成的）树的森林开始。然后持续完成合并两棵树的操作（使用最短的边连接它们），直至只剩下一棵树，这棵树就是最终的MST树。</li>
<li>Kruskal 算法的正确性源自所谓的分割性质<ul>
<li><strong>分割性质</strong>：设边集 X 是 $G = (V, E)$ 的某个生成树的一部分，选定任一节点集合 $S \subset V$，使得 X 中没有跨越 S 和 $V - S$ 的边。若 e 是跨越 S 和 $V - S$ 的权重最轻的边，则 $X \cup {e}$ 也是某个 MST 的一部分。<ul>
<li>有：对任意的分割，在 X 不含跨越分割的边（该边的一个端点属于 S，另一个端点属于 $V - S$ ）这一前提下，增加跨越该分割的权重最轻的边 e 总是安全的。</li>
<li>假设 X 是某个 MST T 的一部分，① e 恰好也在 T 中，无需证明；② e 不属于 T，通过改变 T 中的一条边可以构造一个与之不同的 MST T’，使得 T’ 包含  $X \cup {e}$；由于 T 是连通的，在 T 中必然存在一条路径连接 e 的两个端点，故增加 e 将形成一个环，这个环包含另外某条跨越分割 ${S, V - S}$ 的边 e’，将其移除，得到 $T’ = T \cup {e} - {e’}$；③  <code>性质①</code> 可证 T’ 是连通的；另，T’ 和 T 的边数相同，<code>性质②</code> 和 <code>性质③</code> 可知，T’ 也是树。</li>
<li>树T’ 代价：$ weight(T’) = weight(T) + w(e) - w(e’)$，<strong>e 是跨越 S 和 $V - S$ 的权重最轻的边</strong>，有 $w(e) \leq w(e’)$，从而  $weight(T) \leq weight(T’)$，由 T 是 MST，可知 $weight(T) = weight(T’)$，T’ 也是 MST。<center><img src="/img/Algorithms/0007_KruskalPseudo.png" width="720px"/></center></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Kruskal 最小生成树算法实现细节<ul>
<li>起始于一个空的图。</li>
<li>通过逐条增加边来构造最小生成树：假如在构建最小生成树的过程中，我们已经选择了某些边并在向着正确的方向前进，下一步选择那条边呢？<ul>
<li>不断重复地选择未被选中的边中权重最轻的且不会形成环的一条。<ul>
<li>为保证连接等价类边的权值最短，算法首先对图中所有边按照权值进行排序。按权值由小到大一次选择边</li>
<li>不会形成环：每次选择一条边加入到现有的部分解中 ===&gt; 需要检验每一条侯选边(u-&gt;v) 的端点是否属于不同的连通分量，一旦选定了某条边，则将这条边添加到 MST 并将两个相关的连通分量将被合并。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Kruskal 最小生成树算法关键数据结构：并查集/分离集 (union-find/disjoint sets)<ul>
<li>Kruskal 算法开始有 n 个分别包含一个节点的集合（即 n 个分离集）；随着算法的进展，分离集的个数逐渐减少，直到算法的最后一步，分离集的个数变为 1，此时产生最小生成树。</li>
<li>并查集：并查集处理的是集合之间的关系，即 union，find。在这种数据类型中，N个不同元素被分成若干个组，每组是一个集合，这种集合叫做分离集合。并查集支持查找一个元素所属的集合和两个元素分别所属的集合的合并。注意：并查集只能进行合并操作，不能进行分割操作。</li>
<li>并查集支持以下操作：<ul>
<li><code>makeset(x)</code>：创建一个仅包含 x 的独立集合（分离集）；最初每个节点单独构成了一个分离集 ==&gt; 一组分离集</li>
<li><code>find(x)</code>：不断重复地检验节点对，判断其是否属于同一个集合？</li>
<li><code>union(x, y)</code>：每当增加了一条边，将与之相关的两个集合合并。</li>
</ul>
</li>
<li>并查集的实现原理<ul>
<li>并查集是使用树结构实现的<ul>
<li>初始化：准备 N 个节点来表示 N 个元素，最开始没有边。</li>
<li>为避免树的退化，对于每棵树，记录其高度 rank。</li>
<li>查询：查询两个节点是否在同一个集合，只需要查询他们是否具有相同的根。<center><img src="/img/Algorithms/0007_UnionFind_find.png" width="340px"/></center></li>
<li>合并：从一个分离集的根向另一个分离集的根连边，这样两棵树就变为了一棵树，也就把两个集合合并为一个了；除非将要合并的树等高，否则将不会出现合并后总高度增加的情形；如果合并时两棵树高度不同，那么从 rank 小的向 rank 大的连边。<center><img src="/img/Algorithms/0007_UnionFind_union.png" width="580px"/></center></li>
<li>路径压缩：每次 find 操作中，当循着一系列的父指针最终找到树的根后，改变所有这些父指针的目标，使其直接指向树根。<br><center><img src="/img/Algorithms/0007_UnionFind_find2.png" width="420px"/></center><ul>
<li>通过路径压缩，所有节点的等级都不会发生改变；节点的 rank 不再能解释为其下方子树的高度</li>
<li>union 操作只关注树的顶层，路径压缩不会对 union 操作产生影响，它将保持树的顶层不变</li>
<li>find 操作（不论是否采用路径压缩）仅仅触及树的内部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>基于并查集的 Kruskal 算法实现：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>			<span class="comment">/* priority_queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">  <span class="keyword">int</span> fromIdx, toIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> weight &gt; right.weight;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="function">UnionFindSets <span class="title">sets</span><span class="params">(g.vertexNum)</span></span>;</div><div class="line">  <span class="comment">// use priority_queue for sorting the edges E by weight</span></div><div class="line">  priority_queue&lt;Edge&gt; EdgeQueue;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    sets.makeset(g.VertexNodes[i].vertexIdx);</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      Edge e;</div><div class="line">      e.fromIdx = g.VertexNodes[i].vertexIdx;</div><div class="line">      e.toIdx = head-&gt;adjVertexIdx;</div><div class="line">      e.weight = head-&gt;weight;</div><div class="line">      EdgeQueue.push(e);</div><div class="line"></div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMST constructing: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">while</span>(!EdgeQueue.empty()) &#123;</div><div class="line">    Edge e = EdgeQueue.top();</div><div class="line">    EdgeQueue.pop();</div><div class="line">    <span class="comment">// cout &lt;&lt; "\npop: " &lt;&lt; e.fromIdx &lt;&lt; "-&gt;" &lt;&lt; e.toIdx &lt;&lt; "(" &lt;&lt; e.weight &lt;&lt; ")" &lt;&lt; endl;</span></div><div class="line">    <span class="keyword">if</span>(sets.find(e.fromIdx) != sets.find(e.toIdx)) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * 2 edges with same vertex in an undirect graph</div><div class="line">       *	but every VertexNode can only have on prev.</div><div class="line">       */</span></div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[e.toIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      g.VertexNodes[e.toIdx].prev = &amp;g.VertexNodes[e.fromIdx];</div><div class="line">      g.VertexNodes[e.toIdx].cost = e.weight;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[e.fromIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[e.toIdx].data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; e.weight &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">      sets.unite(e.fromIdx, e.toIdx);</div><div class="line">      <span class="comment">// sets.printset();</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  Kruskal(g);</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Kruskal.cpp -o Kruskal</div><div class="line">$ ./Kruskal </div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing: </div><div class="line">  + 6--&gt;7(1)</div><div class="line">  + 5--&gt;6(2)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 2--&gt;5(4)</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 2--&gt;3(7)</div><div class="line">  + 2--&gt;1(8)</div><div class="line">  + 3--&gt;4(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 7&lt;--6(1)</div><div class="line">  + 6&lt;--5(2)</div><div class="line">  + 5&lt;--2(4)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--8(2)</div><div class="line">  + 1&lt;--2(8)</div><div class="line">  + 0&lt;--1(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTKruskal.png" width="640px"/></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文将介绍带权图的最小生成树（Minimum Spanning Tree）算法：给定一个无向图 G，并且它的每条边均有权值，则 MST 是一个包括 G 的所有顶点及边的子集的图，这个子集保证图是连通的，并且子集中所有边的权值之和为所有子集中最小的。&lt;br&gt;　本文中介绍两种求解图的最小生成树的算法：Prim 算法和 Kruskal 算法，这两种算法都是贪心算法。一般而言，贪心策略不一定能保证找到全局最优解，但是对最小生成树问题来说，贪心策略能获得具有最小权值的生成树。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0006] Some Shortest-path Algorithms（最短路径算法）</title>
    <link href="http://durant35.github.io/2017/03/29/Algorithms_Some%20Shortest-path%20Algorithms/"/>
    <id>http://durant35.github.io/2017/03/29/Algorithms_Some Shortest-path Algorithms/</id>
    <published>2017-03-29T06:00:22.000Z</published>
    <updated>2017-05-06T00:55:06.507Z</updated>
    
    <content type="html"><![CDATA[<p>　本文介绍几种常见的最短路径算法：</p>
<ul>
<li>Breadth-first Search 无权最短路径算法；</li>
<li>Dijkstra 带权（非负权）图的单源最短路算法；</li>
<li>Bellman-Ford 带权（可负权）图的单源最短路算法；</li>
<li>Floyd-Warshall 带权（可负权）图的全源最短路算法，<br>　包括它们各自的<strong>使用条件&amp;范围</strong>，<strong>算法原理介绍</strong>以及<strong>代码实现</strong>。<a id="more"></a>
</li>
</ul>
<h4 id="Breadth-first-Search-无权最短路径算法"><a href="#Breadth-first-Search-无权最短路径算法" class="headerlink" title="Breadth-first Search 无权最短路径算法"></a>Breadth-first Search 无权最短路径算法</h4><ul>
<li><strong>BFS</strong> 适合边的权值均是 1（无权图）的最短路径问题，因为，假设 S 为起始点，<strong>BFS</strong> 每次都会先发现距离 S 为 k 的所有顶点，然后才会发现距离 S 为 k+1 的所有顶点。<br><center><img src="/img/Algorithms/0006_BFSPseudo.png" width="640px"/></center><br>① 对于外面的<code>while</code>循环，会执行|V|次，因为每个顶点入队出队一次。<br>② <code>dist(v)==∞</code> 说明节点 v 还没被访问，将其放入队列并更新<code>dist</code>值。<br>③ 里面的<code>for</code>循环一共会执行|E|次，即变长，所以该算法时间复杂度为O(|V|+|E|)。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="built_in">queue</span>&lt;VertexNode*&gt; vertexQueue;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  vertexQueue.push(&amp;Source);</div><div class="line">  <span class="keyword">while</span> (!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode* v = vertexQueue.front();</div><div class="line">    vertexQueue.pop();</div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (g.VertexNodes[head-&gt;adjVertexIdx].dist == INT_MAX) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + <span class="number">1</span>;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">        vertexQueue.push(&amp;g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"BFS.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(VertexNode) &lt;&lt; <span class="keyword">sizeof</span>(adjVertexNode*) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    BFS(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<center><img src="/img/Algorithms/0006_BFSGraph.png" width="640px"/></center>

<ul>
<li>忽略边的权值，该图对应的输入文件 <code>BFS.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">6 18</div><div class="line">S A B C D T</div><div class="line">0 1</div><div class="line">0 3</div><div class="line">0 4</div><div class="line">1 0</div><div class="line">1 2 </div><div class="line">1 4</div><div class="line">2 1</div><div class="line">2 4</div><div class="line">2 5</div><div class="line">3 0</div><div class="line">3 4</div><div class="line">4 0</div><div class="line">4 1</div><div class="line">4 2</div><div class="line">4 3</div><div class="line">4 5</div><div class="line">5 2</div><div class="line">5 4</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>g++</code>进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// -m32 option <span class="keyword">for</span> 32-bit execution</div><div class="line">g++ [-m32] BFS.cpp -o BFS</div></pre></td></tr></table></figure>
<p><a href="http://durant35.github.io/2017/03/22/Algorithms_BFS/#more">更多关于BFS算法的实现，可以点击阅读</a> </p>
<h4 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/skywang12345/p/3711512.html">Dijkstra算法(一)之 C语言详解</a></li>
<li><a href="http://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html">最短路径—Dijkstra算法和Floyd算法</a></li>
</ul>
</blockquote>
<center><img src="/img/Algorithms/0006_DijkstraDerivation.png" width="480px"/></center>

<ul>
<li>Dijkstra <strong>算法推导</strong><ul>
<li>已知区域<code>S</code> 是包含 s 的某个顶点子集。</li>
<li>关于当前最短路径有很多单边扩展路径，其中 <code>u→v</code> 是最短的一条。</li>
<li>上图中，s 到 v 的最短路径即为这样一条路径：基于一条已知的最短路径中的某条边（如上图<code>s→u</code>）的扩展路径。<ul>
<li>推导条件：假设无负权，u 一定比 v 距离 s 更近，这意味着 u 在已知区域 S 中，否则将与 <strong>v 是 S 之外且与 s 距离最近的顶点</strong> 这一假设相矛盾。</li>
</ul>
</li>
<li>检查当前已知最短路径集合 S 的所有单边扩展路径，找到这些扩展路径中的最短路径，该路径的另一个端点即为加入 S 的下一个顶点。</li>
<li>提高算法的执行效率：基于这样一个事实，在算法的任意迭代步骤中，仅有的新扩展路径是那些连接最近加入到 S 中的顶点的路径，其它所有路径的长度之前已经计算过，无需重新计算。</li>
</ul>
</li>
</ul>
<center><img src="/img/Algorithms/0006_DijkstraPseudo.png" width="880px"/></center>

<ul>
<li>Dijkstra <strong>算法思想</strong> ：<ul>
<li>左图：① <code>dist(v)</code>：指向 v 的当前最短单边扩展路径的长度（对于与 S 不相邻的顶点，取值为 ∞）；② 每次 while 循环迭代的末尾，（1）存在一个值 d，使得从 s 到 S 中所有顶点的距离 ≤d。同时 s 到 S 外的所有顶点的距离≥d；（2）对于每个顶点 v，dist(v) 表示一条从 s 到 v 的最短路径的长度，该路径经过的顶点均在 S 中（如果不存在这样的路径，dist 为 ∞）。</li>
<li>右图：设 <code>G=(V，E)</code> 是一个带权有向图（无向可以转化为双向有向），把图中顶点集合<code>V</code>分成两组，第一组为已求出最短路径的顶点集合（用<code>S</code>表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将其加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用<code>U</code>表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离， S 中的顶点的距离就是从 v 到此顶点的最短路径长度， U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。</li>
</ul>
</li>
<li>Dijkstra <strong>算法具体步骤</strong><br>  （1）初始时，S只包含源点，即S＝{v}，v的距离dist[v]为0。U包含除v外的其他顶点，U中顶点u距离dis[u]为边上的权值（若v与u有边）或 ∞（若u不是v的出边邻接点即没有边 <code>&lt;v→u&gt;</code>）。<br>  （2）从U中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离（dist[k]）就是 v 到 k 的最短路径长度）。<br>  （3）以 k 为新考虑的中间点，修改 <code>U</code> 中各顶点的距离（松弛操作）：若从源点v到顶点u（u∈ U）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值等于顶点k的距离加上边上的权（即如果 <code>dist[k]+w[k,u]&lt;dist[u]</code>，那么把dist[u]更新成更短的距离 <code>dist[k]+w[k,u]</code>）。<br>  （4）重复步骤（2）和（3）直到所有顶点都包含在 <code>S</code> 中(要循环n-1次)。</li>
<li>基于数组实现的 Dijkstra 算法（<strong>void Dijkstra(Graph&amp; g, VertexNode&amp; Source)</strong> 函数）<ul>
<li>总共需要循环 |V| 次（步骤（4）），实现将所有节点添加进已知区域 S。</li>
<li>每次循环，需要选取一个距离最小的顶点（步骤（2）），需要对所有节点进行遍历（$O(|V|)$）。</li>
<li>在循环执行的过程中，该循环为了更新距离（步骤（3）），需要访问每条边一次（有向图的情况）或两次（无向图的情况），从而花费了 $O(|E|)$ 的时间。</li>
<li>该算法的整体运行时间为：$O(|V|^2)$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNuminS = <span class="number">0</span>; vertexNuminS &lt; g.vertexNum; vertexNuminS++) &#123;</div><div class="line">    <span class="comment">// Pick the node not in S with smallest dist</span></div><div class="line">    <span class="keyword">int</span> minDist = INT_MAX;</div><div class="line">    <span class="keyword">int</span> pickIdx = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[i] &amp;&amp; g.VertexNodes[i].dist&lt;minDist) &#123;</div><div class="line">        minDist = g.VertexNodes[i].dist;</div><div class="line">        pickIdx = i;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// other nodes are unreachable</span></div><div class="line">    <span class="keyword">if</span>(pickIdx == <span class="number">-1</span>) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    visited[pickIdx] = <span class="literal">true</span>;</div><div class="line">    VertexNode* v = &amp;g.VertexNodes[pickIdx];</div><div class="line"></div><div class="line">    <span class="comment">// update the current new extended path and the predecessor vertex</span></div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// visited to avoid repeatedly enqueue</span></div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v-&gt;dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Dijkstra.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>基于 <a href="http://www.cplusplus.com/reference/queue/priority_queue/">std::priority_queue</a> 实现的 Dijkstra 算法（<strong>void Dijkstra(Graph&amp; g, VertexNode&amp; Source)</strong> 函数）<ul>
<li>由于使用了指针类型（<code>VertexNode*</code>）的优先级队列，需要声明额外的比较方法 <code>struct cmp</code>，重载其 <code>operator()</code>，并按以下方式声明：<code>priority_queue&lt;VertexNode*, vector&lt;VertexNode*&gt;, cmp&gt; vertexQueue;</code>，而不能通过直接重载优先级队列元素类型的比较函数 <code>operator&lt;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line"></div><div class="line">  <span class="comment">/*</div><div class="line">  bool operator&lt; (VertexNode* a, VertexNode* b) &#123;</div><div class="line">    return a-&gt;dist &gt; b-&gt;dist;</div><div class="line">  &#125;;*/</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/* compare struct for priority queue</div><div class="line"> * In order to achieve the minimum heap(in ascending order)</div><div class="line"> *   reload operator&lt;, redefine the priority to smaller one</div><div class="line"> */</span></div><div class="line"><span class="keyword">struct</span> cmp &#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(VertexNode* a, VertexNode* b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> a-&gt;dist &gt; b-&gt;dist;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode*, <span class="built_in">vector</span>&lt;VertexNode*&gt;, cmp&gt; vertexQueue;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  vertexQueue.push(&amp;Source);</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode* v = vertexQueue.top();</div><div class="line">    <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; v-&gt;data &lt;&lt; " ";</span></div><div class="line">    vertexQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> vertexIdx = v - g.VertexNodes;</div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    adjVertexNode* head = v-&gt;<span class="built_in">list</span>;</div><div class="line">    <span class="comment">// cout &lt;&lt; "push: ";</span></div><div class="line">    <span class="comment">// relax operation: update the estimated distance for all adjacent vertex </span></div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span> </div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v-&gt;dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v-&gt;dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = v;</div><div class="line">        vertexQueue.push(&amp;g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">        <span class="comment">// cout &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; " ";</span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Dijkstra.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="comment">//freopen("BellmanFord.txt", "r", stdin);</span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">注意：</font><ul>
<li>基于优先级队列实现的 Dijkstra 算法，为了保证每次迭代均能够获取未知区域中距离源点最近的顶点，存在将一个节点重复入队的情况。当该节点被加入到已知区域时，这种重复入队保证其距离为最短距离；此后，队列中存在该节点的残留节点（距离不是最短距离）的可能，需要滤除这些残留节点。</li>
<li><strong>Dijkstra 算法</strong> 中，已知区域内的顶点距离确定是最短距离，因此不应由于新节点的加入而发生更新。对于正权图，不会对已知区域内的节点进行松弛操作；对于负权图，则可能发生，因此需要对松弛操作节点范围进行限制。<center><img src="/img/Algorithms/0006_DijkstraGraph.png" width="800px"/></center></li>
</ul>
</li>
<li>上图对应的输入文件 <code>Dijkstra.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">6 18</div><div class="line">S A B C D T</div><div class="line">0 1 1</div><div class="line">0 3 2</div><div class="line">0 4 5</div><div class="line">1 0 1</div><div class="line">1 2 2</div><div class="line">1 4 5</div><div class="line">2 1 2</div><div class="line">2 4 1</div><div class="line">2 5 4</div><div class="line">3 0 2</div><div class="line">3 4 3</div><div class="line">4 0 5</div><div class="line">4 1 5</div><div class="line">4 2 1</div><div class="line">4 3 3</div><div class="line">4 5 1</div><div class="line">5 2 4</div><div class="line">5 4 1</div></pre></td></tr></table></figure>
<ul>
<li>通过<code>g++</code>进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ Dijkstra.cpp -o Dijkstra</div></pre></td></tr></table></figure>
<ul>
<li><font color="red">更新：</font>基于优先级队列实现的 Dijkstra 算法存在问题，<code>priority_queue&lt;vertexnode*, vector&lt;vertexnode*=&quot;&quot;&gt;, cmp&gt; vertexQueue;</code> 优先级队列保存的是节点的指针，为了保证从队头都能取得距离源点距离最近的节点，同一个节点（不同的距离值）会被重复入队；然而由于存入的是指针，对即将入队的节点的松弛操作同样会影响到先前入队的同一个节点（不同的距离值），破坏了原先的优先队列顺序（可能是基于 heap 实现），造成优先级队列操作异常，故修正为如下代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">  <span class="comment">/* reload compare operator for priority queue</div><div class="line">   * In order to achieve the minimum heap(in ascending order)</div><div class="line">   *   reload operator&lt;, redefine the priority to smaller one</div><div class="line">   */</span></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> VertexNode&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> dist &gt; right.dist;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  priority_queue&lt;VertexNode&gt; vertexQueue;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="comment">// void push( const value_type&amp; value );</span></div><div class="line">  vertexQueue.push(Source);</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(!vertexQueue.empty()) &#123;</div><div class="line">    VertexNode v = vertexQueue.top();</div><div class="line">    <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; v.data &lt;&lt; " ";</span></div><div class="line">    vertexQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">int</span> vertexIdx = v.vertexIdx;</div><div class="line">    <span class="keyword">if</span>(visited[vertexIdx]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">    adjVertexNode* head = v.<span class="built_in">list</span>;</div><div class="line">    <span class="comment">// cout &lt;&lt; "push: ";</span></div><div class="line">    <span class="comment">// relax operation: update the estimated distance for all adjacent vertex </span></div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * A node with different dist will be pushed repeatedly for smallest one</div><div class="line">       *  use visited(visited[vertexIdx]) flag to avoid not-smallest visit</div><div class="line">       * A node in known-region should't be repeatedly updated </div><div class="line">       *	use visited[head-&gt;adjVertexIdx]</div><div class="line">       */</span> </div><div class="line">      <span class="keyword">if</span>(!visited[head-&gt;adjVertexIdx] &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist </div><div class="line">        &gt; (v.dist + head-&gt;weight)) &#123;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].dist = v.dist + head-&gt;weight;</div><div class="line">        g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = &amp;g.VertexNodes[v.vertexIdx];</div><div class="line">        vertexQueue.push(g.VertexNodes[head-&gt;adjVertexIdx]);</div><div class="line">        <span class="comment">// cout &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; " ";</span></div><div class="line">      &#125;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// cout &lt;&lt; endl;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    Dijkstra(g, g.VertexNodes[from]);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[to].dist == INT_MAX) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[to].dist;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Bellman-Ford-算法"><a href="#Bellman-Ford-算法" class="headerlink" title="Bellman-Ford 算法"></a>Bellman-Ford 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="https://www.renfei.org/blog/weighted-shortest-path.html">带权最短路 Dijkstra, SPFA, Bellman-Ford, ASP, Floyd-Warshall 算法分析</a></li>
</ul>
</blockquote>
<ul>
<li>查看从 <strong>s</strong> 到 <strong>t</strong> 的最短路径<br><center><img src="/img/Algorithms/0006_BellmanFordSketch.png" width="480px"/></center><ul>
<li>该路径最多含有 $|V|-1$ 条边。<ul>
<li>因为最短路径肯定是个简单路径，不可能包含回路的：如果包含回路，且回路的权值和为正的，那么去掉这个回路，可以得到更短的路径；如果回路的权值是负的，那么肯定没有解了</li>
<li>图有 $|V|$ 个点，又不能有回路，所以最短路径最多 $|V|-1$ 边</li>
</ul>
</li>
<li>如果执行的更新操作按照以下顺序 $(s, u_1), (u_, u_2), …, (u_k, t)$（更新序列） 进行（只要保证上述更新操作全部按顺序执行即可，并不要求上述更新操作是连续进行的），最终 t 的最短路径一定是正确的。<ul>
<li>最短路的局部最优性：中间即便穿插其它 update 操作，也不会影响最短路径。</li>
<li>其它 update 操作是否在这些边上进行无关紧要，同样，图上其它部分进行的 update 操作也不对上述最短路产生影响。</li>
<li>即，update 操作是安全的。</li>
</ul>
</li>
<li>Dijkstra 算法所运行的更新序列是经过选择的。<ul>
<li>选择基于这一假设：从起始点 <strong>s</strong> 到任意顶点 <strong>v</strong> 的最短路径一定会经过比 <strong>v</strong> 距离  <strong>s</strong> 更近的顶点。</li>
<li>当边的长度可以为负值时，这一假设将不再成立，如下图：从 S 到 A 的最短路径经过 B，而 B 却比 A 距离 S 更远！<center><img src="/img/Algorithms/0006_DijkstraNegativeEdge.png" width="200px"/></center></li>
</ul>
</li>
<li>为了求出负权图的最短路径，我们需要保证一个合理的更新序列。但是：我们预先并不知道所求的最短路径（如 <code>s-&gt;t</code>），因此不能确保按照正确的顺序更新了正确的边（$s→u_1, u_1→u_2, …, u_k→t$）<ul>
<li>解决方案：<strong>每次迭代更新所有的边</strong><ul>
<li>由于多余的更新操作总是无害的，因此算法（几乎）可以正确运行。</li>
<li>每条边更新 $|V|-1$ 次（任何含有 $|V|$ 个顶点的图两个点之间的最短路最多含有 $|V|-1$ 条边，每次迭代均能找到从起始点 <strong>s</strong> 出发的最短路上的一条边），时间复杂度为 $O(|V|·|E|)$</li>
<li>如果某次循环没有更新操作发生，后续的迭代也不会有更新操作，可以利用这一性质避免无效的计算。<center><img src="/img/Algorithms/0006_BellmanFordPseudo.png" width="640px"/></center></li>
</ul>
</li>
</ul>
</li>
<li>算法实现中唯一一个需要注意的问题就是负值圈 (negative-cost cycle)。<ul>
<li>负值圈指的是，权值总和为负的圈。如果存在这种圈，我们可以在里面滞留任意长而不断减小最短路径长，因此这种情况下最短路径是不存在的。</li>
<li>对于 Bellman-Ford 算法来说，判断负值圈存在的方法是：在 $|V|-1$ 次循环之后再执行一次循环，如果还有更新操作发生，则说明存在负值圈。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="keyword">int</span> dist;</div><div class="line">  <span class="comment">// How to restore a shortest path: recording the pre-visit VertexNode in the path</span></div><div class="line">  VertexNode* preVertexNode;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(Graph&amp; g, VertexNode&amp; Source)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    g.VertexNodes[i].dist = INT_MAX;</div><div class="line">    g.VertexNodes[i].preVertexNode = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  Source.dist = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> vertexNum=<span class="number">0</span>; vertexNum&lt;=g.vertexNum; vertexNum++) &#123;</div><div class="line">    <span class="keyword">bool</span> updated = <span class="literal">false</span>;</div><div class="line">    <span class="comment">// update all edges</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> VertexIdx=<span class="number">0</span>; VertexIdx&lt;g.vertexNum; VertexIdx++) &#123;</div><div class="line">      adjVertexNode* head = g.VertexNodes[VertexIdx].<span class="built_in">list</span>;</div><div class="line">      <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span>(g.VertexNodes[VertexIdx].dist != INT_MAX</div><div class="line">          &amp;&amp; g.VertexNodes[head-&gt;adjVertexIdx].dist &gt; (g.VertexNodes[VertexIdx].dist + head-&gt;weight)) &#123;</div><div class="line">          g.VertexNodes[head-&gt;adjVertexIdx].dist = g.VertexNodes[VertexIdx].dist + head-&gt;weight;</div><div class="line">          g.VertexNodes[head-&gt;adjVertexIdx].preVertexNode = &amp;g.VertexNodes[VertexIdx];</div><div class="line">          updated = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        head = head-&gt;next;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// shortest path got after any round which no update occurred</span></div><div class="line">    <span class="keyword">if</span>(!updated) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// negative cycles exist</span></div><div class="line">    <span class="keyword">if</span>(vertexNum == g.vertexNum &amp;&amp; updated) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// should never reach here</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, VertexNode* target)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (target-&gt;preVertexNode != <span class="literal">NULL</span>) &#123;</div><div class="line">    PrintPath(g, target-&gt;preVertexNode);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; target-&gt;data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">    <span class="keyword">if</span>(!BellmanFord(g, g.VertexNodes[from])) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to find shortest path: negative cycles exist..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">      <span class="keyword">if</span>(from == to) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">        &lt;&lt; <span class="string">"\t\t\t"</span> &lt;&lt; g.VertexNodes[to].dist &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">      PrintPath(g, &amp;g.VertexNodes[to]);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对于非负权图 Bellman-Ford 算法和 Dijkstra 算法都能得到相同的正确解。<center><img src="/img/Algorithms/0006_DijkstraGraph.png" width="800px"/></center><br><center><img src="/img/Algorithms/0006_BellmanFordGraph.png" width="720px"/></center></li>
<li>Dijkstra 算法难以处理负权图的最短路径问题，主要原因便是上面提到的前提假设不成立，比如，S 到 A 的最短路经过 $(S, G)$，然而 $|(S, A)| &lt; |(S, G)|$。 <center><img src="/img/Algorithms/0006_DijkstravsBellmanFord.png" width="720px"/></center></li>
<li>上图对应的输入文件 <code>BellmanFord.txt</code> 如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">8 12</div><div class="line">S A B C D E F G</div><div class="line">0 1 7</div><div class="line">0 7 8</div><div class="line">1 5 2</div><div class="line">2 1 1</div><div class="line">2 3 1</div><div class="line">3 4 3</div><div class="line">4 5 -1</div><div class="line">5 2 -2</div><div class="line">6 1 -4</div><div class="line">6 5 -1</div><div class="line">7 6 1</div></pre></td></tr></table></figure>
<h4 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h4><blockquote>
<p>References:</p>
<ul>
<li><a href="http://www.cnblogs.com/gaochundong/p/floyd_warshall_algorithm.html">Floyd-Warshall 全源最短路径算法</a></li>
<li><a href="http://www.wutianqi.com/?p=1903">最短路径算法—Floyd(弗洛伊德)算法分析与实现(C/C++)</a></li>
<li><a href="https://www.renfei.org/blog/weighted-shortest-path.html">带权最短路 Dijkstra, SPFA, Bellman-Ford, ASP, Floyd-Warshall 算法分析</a></li>
</ul>
</blockquote>
<ul>
<li>解决单源最短路径问题的方案有 Dijkstra 算法和 Bellman-Ford 算法，对于全源最短路径问题（All-Pairs Shortest Paths Problem）可以认为是单源最短路径问题（Single Source Shortest Paths Problem）的推广，即分别以每个顶点作为源顶点并求其至其它顶点的最短距离（如运行<strong>Bellman-Ford 最短路径算法</strong>（由于可能存在负边），这样下来总的运行时间将是$O(|V|^2 E)$，事实上有一种稍好的选择，其运行时间为$O(|V|^3)$，正是本节介绍的基于动态规划的 <strong>Floyd-Warshall 算法</strong>）。</li>
<li>Floyd-Warshall 算法采用动态规划方案来解决在一个有向图（无向图可以转化为双向有向） G = (V, E) 上每对顶点间的最短路径问题，即全源最短路径问题，其中图 G 允许存在权值为负的边，但不存在权值为负的回路。</li>
<li>Floyd-Warshall <strong>算法思想</strong><ul>
<li>最短路径算法中的最优子结构：两顶点之间的最短路径包含路径上其它顶点的最短路径。<ul>
<li>具体描述为：对于给定的带权图 $G = (V, E)$，设 $p = \lt v_1, v_2, …,v_n \gt$ 是从 $v_1$ 到 $v_n$ 的最短路径，那么对于任意 i 和 j，$1≤i≤j≤n, p_{ij} (shortestPath(i, j, k)) = \lt v_i, v_{i+1}, …, v_j \gt$ 为 p 中从顶点 $v_i$ 到 $v_j$ 的一条子路径，那么 $p_{ij}$ 是顶点 $v_i$ 到 $v_j$ 的最短路径。</li>
</ul>
</li>
<li>从任意节点 i 到任意节点 j 的最短路径不外乎2种可能：①直接从 i 到 j；②从 i 经过若干个中间节点 k 到 j。<ul>
<li>dist(i, j, k)：从顶点 i 到 j 的仅使用节点 ${1, 2, …, k}$ 作为中间节点的最短路径长度。</li>
<li>$ dist(i, j, 0) = \begin{cases} |E(i, j)| \cr \infty, else \end{cases} $    </li>
<li>当我们在中间节点集中加入一个新的顶点 k 时，需要对所有的节点对 $(i，j)$ 检查是否使用 k 作为中间节点会得到更短的路径。$i → j $ 的使用了 k 和其它编号较小（＜k）的中间节点的最短路径最多经过 k 一次（假设没有负环），通过使用已经计算得到的 i 到 k 和 k 到 j 的使用了较小编号顶点的最短路径长度能够求解 $i → j $ 的最短路径长度。</li>
<li>$ shortestPath(i, j, k) = min(shortestPath(i, j, k-1), shortestPath(i, k, k-1) + shortestPath(k, j, k-1))$<center><img src="/img/Algorithms/0006_FloydSketch.png" width="540px"/></center></li>
</ul>
</li>
<li>Floyd-Warshall 算法的设计基于了如下观察。设带权图 G = (V, E) 中的所有顶点 V = {1, 2, . . . , n}，考虑一个顶点子集 {1, 2, . . . , k}。对于任意对顶点 i, j，考虑从顶点 i 到 j 的所有路径的中间顶点都来自该子集 {1, 2, . . . , k}，设 p 是该子集中的最短路径。Floyd-Warshall 算法描述了 p 与 i, j 间最短路径及中间顶点集合 {1, 2, . . . , k - 1} 的关系，该关系依赖于 k 是否是路径 p 上的一个中间顶点。<br><center><img src="/img/Algorithms/0006_FloydPseudo.png" width="720px"/></center><ul>
<li>①②：不允许路径 $i → j$ 上出现任何的中间节点；不存在直接连接 i 和 j 的边时，$dist(i, j, 0) = \infty$。</li>
<li>③：注意 k，i，j 三重循环的顺序，算法的时间复杂度为 $O(|V|^3)$；另外，$dist(?, ?, k)$ 只与 $dist(?, ?, k-1)$ 有关，使用二维数组即可维护只使用 {1, 2, …, k-1, k} 作为中间节点的最短距离信息，无需开辟三维空间，空间复杂度为 $O(|V|^2)$。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span>   </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">// for stdin</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">// for INT_MAX</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="comment">// weight: length on edges</span></div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 8(16)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FloydWarshall</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> dists[][MAX_VERTEX_NUM], <span class="keyword">int</span> paths[][MAX_VERTEX_NUM])</span> </span>&#123;</div><div class="line">  <span class="comment">// dists[i][j]=INT_MAX; dists[i][i]=0;</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;g.vertexNum; j++) &#123;</div><div class="line">      dists[i][j] = (i==j)? <span class="number">0</span>:INT_MAX;</div><div class="line">      paths[i][j] = j;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// edge&lt;i,j&gt; exists, update dists[i][j]=|edge&lt;i,j&gt;|</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> VertexIdx=<span class="number">0</span>; VertexIdx&lt;g.vertexNum; VertexIdx++) &#123;</div><div class="line">    adjVertexNode* head = g.VertexNodes[VertexIdx].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      dists[VertexIdx][head-&gt;adjVertexIdx] = head-&gt;weight;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;g.vertexNum; k++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;g.vertexNum; j++) &#123;</div><div class="line">        <span class="keyword">if</span>(dists[i][k] != INT_MAX &amp;&amp; dists[k][j] != INT_MAX</div><div class="line">          &amp;&amp; (dists[i][k] + dists[k][j]) &lt; dists[i][j]) &#123;</div><div class="line">          dists[i][j] = dists[i][k] + dists[k][j];</div><div class="line">          paths[i][j] = k;</div><div class="line">          <span class="comment">// negative cycle exists when and only when dists[i][i]&lt;0</span></div><div class="line">          <span class="keyword">if</span>(i == j &amp;&amp; dists[i][j] &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> paths[][MAX_VERTEX_NUM], <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> vertexIdx = fromIdx;</div><div class="line">  <span class="keyword">while</span>(vertexIdx != toIdx) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    vertexIdx = paths[vertexIdx][toIdx];</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[vertexIdx].data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="comment">//freopen("Dijkstra.txt", "r", stdin);</span></div><div class="line">  freopen(<span class="string">"BellmanFord.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> dists[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> paths[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">if</span>(!FloydWarshall(g, dists, paths)) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to find shortest path: negative cycles exist..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"  Source=&gt;Target\tShortest Distance\tPath"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> from=<span class="number">0</span>; from&lt;g.vertexNum; from++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> to=<span class="number">0</span>; to&lt;g.vertexNum; to++) &#123;</div><div class="line">        <span class="keyword">if</span>(from == to) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[from].data &lt;&lt; <span class="string">"==&gt;"</span> &lt;&lt; g.VertexNodes[to].data </div><div class="line">          &lt;&lt; <span class="string">"\t\t\t"</span>;</div><div class="line">        <span class="keyword">if</span>(dists[from][to] == INT_MAX) &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">"INF"</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; dists[from][to];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" \t\t("</span>;</div><div class="line">        PrintPath(g, paths, from, to);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>dists[][]</code> 数组初始化为各顶点间的原本距离（不存在直连边时距离为 $\infty$），最后存储各顶点间的最短距离。</li>
<li><code>paths[][]</code> 数组保存最短路径，与当前迭代的次数有关。初始化都为目标顶点下标，表示没有中间顶点。在求 <code>dists[i][j]</code> 过程中，<code>paths[i][j]</code> 存放从顶点$v_i$ 到顶点 $v_j$ 的中间顶点编号不大于 <code>k</code> 的最短路径上前一个结点的编号。在算法结束时，由二维数组 <code>paths</code> 的值回溯，可以得到从顶点 $v_i$ 到顶点 $v_j$ 的最短路径。</li>
<li>通过 <code>g++</code> 进行构建</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ FloydWarshall.cpp -o FloydWarshall</div></pre></td></tr></table></figure>
<ul>
<li><strong>Floyd-Warshall 算法</strong> 适用于非负权无向图<center><img src="/img/Algorithms/0006_FloydGraph.png" width="720px"/></center></li>
<li><strong>Floyd-Warshall 算法</strong> 同样适用于负权有向图<center><img src="/img/Algorithms/0006_FloydGraphNegative.png" width="720px"/></center></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文介绍几种常见的最短路径算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Breadth-first Search 无权最短路径算法；&lt;/li&gt;
&lt;li&gt;Dijkstra 带权（非负权）图的单源最短路算法；&lt;/li&gt;
&lt;li&gt;Bellman-Ford 带权（可负权）图的单源最短路算法；&lt;/li&gt;
&lt;li&gt;Floyd-Warshall 带权（可负权）图的全源最短路算法，&lt;br&gt;　包括它们各自的&lt;strong&gt;使用条件&amp;amp;范围&lt;/strong&gt;，&lt;strong&gt;算法原理介绍&lt;/strong&gt;以及&lt;strong&gt;代码实现&lt;/strong&gt;。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0005] Breadth First Search（广度优先搜索）</title>
    <link href="http://durant35.github.io/2017/03/22/Algorithms_BFS/"/>
    <id>http://durant35.github.io/2017/03/22/Algorithms_BFS/</id>
    <published>2017-03-22T06:00:22.000Z</published>
    <updated>2017-03-27T11:52:39.901Z</updated>
    
    <content type="html"><![CDATA[<p>　本文主要介绍 <strong>BFS</strong> 的 <em>C++</em> 和 <em>C</em> 语言实现，并借助 <a href="https://leetcode.com/">LeetCode</a> 上的一道题，说说基本的 <strong>BFS</strong> 在问题求解中的应用。</p>
<h3 id="What’s-B-readth-F-irst-S-earch"><a href="#What’s-B-readth-F-irst-S-earch" class="headerlink" title="What’s B(readth)F(irst)S(earch)"></a>What’s B(readth)F(irst)S(earch)</h3><p>　广度优先搜索算法（Breadth First Search），又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。<br><a id="more"></a></p>
<p><center><img src="/img/Algorithms/0005_binarytree.png" width="480px"/></center><br>　如上图所示的二叉树，A 节点第一个访问的，然后顺序是 B、C，然后再是 D、E、F、G。</p>
<h3 id="BFS（C-）"><a href="#BFS（C-）" class="headerlink" title="BFS（C++）"></a>BFS（C++）</h3><ul>
<li><em>C++</em> 中借助队列数据结构来保证这个访问的顺序。由于队列是先进先出的顺序，因此可以先将左子树入队，然后再将右子树入队，这样一来，左子树结点就存在队头，可以先被访问到（<strong>void breadthFirstSearch(Tree root)</strong> ）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_NUM 15</span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ELEMENT data;</div><div class="line">    <span class="keyword">struct</span> Node* left;</div><div class="line">    <span class="keyword">struct</span> Node* right;</div><div class="line">&#125;* Tree;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Binary Tree Constructor</div><div class="line"> *  1. construct in preorder</div><div class="line"> *  2. '#' means no left child or right child</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeConstructor</span><span class="params">(Tree &amp;root, ELEMENT data[])</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(index &gt;= NODE_NUM) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ELEMENT ele = data[index++];</div><div class="line">    <span class="keyword">if</span>(ele == <span class="string">'#'</span>) &#123;</div><div class="line">        root = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        root-&gt;data = ele;</div><div class="line">        binaryTreeConstructor(root-&gt;left, data);</div><div class="line">        binaryTreeConstructor(root-&gt;right, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">breadthFirstSearch</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;Node *&gt; treeQueue;			<span class="comment">// using queue in STL</span></div><div class="line">    treeQueue.push(root);</div><div class="line">    Node* curNode;</div><div class="line">    <span class="keyword">while</span>(!treeQueue.empty()) &#123;</div><div class="line">        curNode = treeQueue.front();</div><div class="line">        treeQueue.pop();</div><div class="line">        <span class="built_in">printf</span>(FORMAT, curNode-&gt;data);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">            treeQueue.push(curNode-&gt;left);	<span class="comment">// push left child first</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">            treeQueue.push(curNode-&gt;right);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ELEMENT data[NODE_NUM] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'E'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>,<span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'G'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>&#125;;</div><div class="line">    Tree tree;</div><div class="line">    binaryTreeConstructor(tree, data);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Traversal using BFS: "</span>);</div><div class="line">    breadthFirstSearch(tree);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ BFS.cpp -o BFS</div><div class="line">gary@xxx:xxx$ ./BFS </div><div class="line">Traversal using BFS: ABCDEFG</div></pre></td></tr></table></figure></p>
<h3 id="BFS（C）"><a href="#BFS（C）" class="headerlink" title="BFS（C）"></a>BFS（C）</h3><ul>
<li><em>C语言</em> 中采取类似的策略，不过需要手动实现一个队列功能（<strong>void bfs(Node tree[], int vertexIndex, bool visited[])</strong>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// BFS.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODENUM 7            	<span class="comment">// node number</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c "</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</div><div class="line"> </div><div class="line"><span class="comment">// structure for adjacency lists</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AdjList &#123;</div><div class="line">  <span class="keyword">int</span> vertexIndex;</div><div class="line">  <span class="keyword">struct</span> AdjList* next;</div><div class="line">&#125; AdjList;</div><div class="line"> </div><div class="line"><span class="comment">// Graphic node structure</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ELEMENT data;			<span class="comment">// data area</span></div><div class="line">  <span class="keyword">struct</span> AdjList* listAdj; 	<span class="comment">// pointing to neighbouring node</span></div><div class="line">&#125; Node;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="comment">// return the location of current vertex data in array, -1 if not exit. </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">char</span>, Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseBFS</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node[], <span class="keyword">int</span>, <span class="keyword">bool</span>[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  Node tree[NODENUM+<span class="number">1</span>];</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(createTree(tree)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"BFS result as follow:\n"</span>);</div><div class="line">    traverseBFS(tree);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"> </div><div class="line">    treeRelease(tree);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Create graphic fail!\n"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * 1. create a tree by entering all nodes' value and edges of the tree</div><div class="line"> * 2. store the tree in an adjacency list</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,location;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Input all nodes's value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    tree[i].data = getchar();</div><div class="line">    <span class="keyword">if</span>(tree[i].data &lt; <span class="string">'A'</span> || (tree[i].data &gt; <span class="string">'Z'</span> &amp;&amp; tree[i].data &lt; <span class="string">'a'</span>) || tree[i].data &gt; <span class="string">'z'</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Node's value should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// eliminate '\n'</span></div><div class="line">  getchar();</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nInput the directly connected nodes, given a node:\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NODENUM; i++) &#123;</div><div class="line">    <span class="built_in">putchar</span>(tree[i].data);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</div><div class="line">    c = getchar();</div><div class="line">    tree[i].listAdj = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>((location = locate(c, tree)) != <span class="number">-1</span>) &#123;</div><div class="line">      AdjList* newAdjVertex = (AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</div><div class="line">      newAdjVertex-&gt;vertexIndex = location;</div><div class="line">      newAdjVertex-&gt;next = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">      <span class="comment">// insert an adjacent node, as the head need to be dealt with separately </span></div><div class="line">      <span class="keyword">if</span>(tree[i].listAdj == <span class="literal">NULL</span>) &#123;</div><div class="line">        tree[i].listAdj = newAdjVertex;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        AdjList* temp = tree[i].listAdj;</div><div class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">          temp = temp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = newAdjVertex;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      <span class="comment">// '\n' will lead to exit</span></div><div class="line">      c = getchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the index of the given node in the node array, -1 if not exist.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(ELEMENT givenVal, Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> location;</div><div class="line">  <span class="keyword">for</span>(location = NODENUM<span class="number">-1</span>; location&gt;=<span class="number">0</span>; location--) &#123;</div><div class="line">    <span class="keyword">if</span>(tree[location].data == givenVal) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> location;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseBFS</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> visited[NODENUM];</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// need to traverse all nodes, avoid not-connected graph</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</div><div class="line">      bfs(tree, i, visited);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node tree[], <span class="keyword">int</span> vertexIndex, <span class="keyword">bool</span> visited[])</span> </span>&#123;</div><div class="line">  <span class="comment">/*</div><div class="line">   * 采用队列，访问一个节点并让其入队，然后按照同样的方法访问其兄弟节点，访问完毕</div><div class="line">   * 然后再从队列里按顺序再拉出一个节点来，继续访问</div><div class="line">   */</span></div><div class="line">  <span class="keyword">int</span> treeQueue[NODENUM];</div><div class="line">  <span class="keyword">int</span> popIdx=<span class="number">0</span>, pushIdx=<span class="number">0</span>;</div><div class="line">  AdjList *pAdjList;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">  visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line">  treeQueue[<span class="number">0</span>] = vertexIndex;			<span class="comment">// insert the first node</span></div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(popIdx &lt;= pushIdx) &#123;</div><div class="line">    vertexIndex = treeQueue[popIdx++];		<span class="comment">// pop one by one in the queue</span></div><div class="line">    pAdjList = tree[vertexIndex].listAdj;</div><div class="line">    <span class="keyword">while</span>(pAdjList != <span class="literal">NULL</span>) &#123;</div><div class="line">      vertexIndex = pAdjList-&gt;vertexIndex;</div><div class="line">      <span class="keyword">if</span>(!visited[vertexIndex]) &#123;</div><div class="line">        <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">        visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line">        treeQueue[++pushIdx] = vertexIndex;	<span class="comment">// push adjacent nodes into the queue </span></div><div class="line">      &#125;</div><div class="line">      pAdjList = pAdjList-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// reslease the dynamically allocated memory</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  AdjList *p, *temp;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    p = tree[i].listAdj;</div><div class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</div><div class="line">      temp = p;</div><div class="line">      p = p-&gt;next;</div><div class="line">      <span class="built_in">free</span>(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ BFS.c -o BFS</div><div class="line">gary@xxx:xxx$ ./BFS</div><div class="line">Input all nodes<span class="string">'s value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):</div><div class="line">ABCDEFG</div><div class="line"> </div><div class="line">Input the directly connected nodes, given a node:</div><div class="line">A BC</div><div class="line">B ADE</div><div class="line">C AFG</div><div class="line">D B</div><div class="line">E B</div><div class="line">F C</div><div class="line">G C</div><div class="line">BFS result as follow:</div><div class="line">A B C D E F G</span></div></pre></td></tr></table></figure></p>
<h3 id="102-amp-107-Binary-Tree-Level-Order-Traversal-I-amp-II"><a href="#102-amp-107-Binary-Tree-Level-Order-Traversal-I-amp-II" class="headerlink" title="102&amp;107. Binary Tree Level Order Traversal I&amp;II"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/#/description">102&amp;107. Binary Tree Level Order Traversal I&amp;II</a></h3><ul>
<li>Description<blockquote>
<p>　Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).<br>　For example:<br>　Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  <span class="number">3</span></div><div class="line"> / \</div><div class="line"><span class="number">9</span>  <span class="number">20</span></div><div class="line">  /  \</div><div class="line"> <span class="number">15</span>   <span class="number">7</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>　return its level order traversal as:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">   [<span class="number">3</span>],</div><div class="line">   [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">   [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>　即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">给定一个二叉树，返回按层级顺序遍历的每个节点的值。</div><div class="line"> </div><div class="line">从左到右，逐层遍历。</div><div class="line"> </div><div class="line">例如：</div><div class="line">给定一个二叉树 &#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,#,#,<span class="number">15</span>,<span class="number">7</span>&#125;，</div><div class="line">    <span class="number">3</span></div><div class="line">   / \</div><div class="line">  <span class="number">9</span>  <span class="number">20</span></div><div class="line">    /  \</div><div class="line">   <span class="number">15</span>   <span class="number">7</span></div><div class="line">返回它的层级顺序遍历结果为：</div><div class="line">[</div><div class="line">  [<span class="number">3</span>],</div><div class="line">  [<span class="number">9</span>,<span class="number">20</span>],</div><div class="line">  [<span class="number">15</span>,<span class="number">7</span>]</div><div class="line">]</div><div class="line"><span class="number">102</span>&amp;<span class="number">107</span> 都是这样的问题，只不过前者返回从上至下每一层的所有节点，后者则按照从下到上的顺序。</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>解题思路<ul>
<li>是一个典型的 <strong>BFS</strong> 遍历的问题，因为 <strong>BFS</strong> 遍历的过程就是一个按层由上至下访问的过程；问题的难点在于，如何区分哪些节点属于哪一层，然后，按照遍历顺序（已经是满足要求的从左到右的顺序），将节点的值插入到每一层对应的向量里面</li>
<li>一开始想到的方式是，<strong>BFS</strong> 遍历通过队列 <strong>queue</strong> 实现，基本的 <strong>BFS</strong> 遍历队列维护的只有节点，想要知道每个节点对应的深度，可以维护一个既包含节点又包含节点深度的队列，可以考虑使用 <strong>map</strong> 字典。</li>
</ul>
</li>
<li>Solution &amp; Analysis<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        <span class="comment">// pair's int for recording depth</span></div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, TreeNode*&gt;&gt; treeQueue;</div><div class="line">        treeQueue.push(make_pair(<span class="number">0</span>, root));</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(!treeQueue.empty()) &#123;</div><div class="line">            <span class="keyword">int</span> curDepth = treeQueue.front().first;</div><div class="line">            TreeNode* curNode = treeQueue.front().second;</div><div class="line">            treeQueue.pop();</div><div class="line">            </div><div class="line">            <span class="keyword">while</span>(result.size() &lt; curDepth+<span class="number">1</span>) &#123;</div><div class="line">                result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">            &#125;</div><div class="line">            result[curDepth].push_back(curNode-&gt;val);</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">                treeQueue.push(make_pair(curDepth+<span class="number">1</span>, curNode-&gt;left));</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">                treeQueue.push(make_pair(curDepth+<span class="number">1</span>, curNode-&gt;right));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　另外需要注意的是  <strong>Line: 27-29</strong>。一开始我们并不知道这个树有多少层，即 <strong>result</strong> 结果集的大小，可以利用 <strong>vector</strong> 自带的动态增长功能灵活检测。<br>　<strong>Accepted</strong>，不过耗时：6ms，感觉挺长的…</p>
<ul>
<li>问题 <strong>107</strong> 只需要将上述得到的结果集反转一下就可以了，可以直接使用 <code>&lt;algorithm&gt;</code> 库中的 <strong>reverse</strong> 函数直接调用（如下），不过耗时较大。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reverse(result.begin(), result.end());</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　使用自己实现的反转函数（如下）效率更高，提交信息号称快了 <strong>3ms</strong>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">orderReverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> depth;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">        <span class="keyword">for</span>(depth=<span class="number">0</span>; depth&lt;result.size()/<span class="number">2</span>; depth++) &#123;</div><div class="line">            tmp = result[result.size()<span class="number">-1</span> - depth];</div><div class="line">            result[result.size()<span class="number">-1</span> - depth] = result[depth];</div><div class="line">            result[depth] = tmp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>其他思路的实现<br>　采用递归实现的 <strong>DFS</strong> 同样能获取树节点的分层信息。 在 <strong>DFS</strong> 的过程中可以直接记录一下当前递归到第几层，就可能找到当前节点对应着哪一行向量；为了满足在同一层中，所有节点按照从左到右的顺序排列，我们需要让遍历节点的顺序也同样满足先到左边子树的节点，再到右边子树的节点，可以通过先递归处理左子树，再处理右子树来实现。<br>　此外，与上面解答类似的，由于我们一开始并不知道整个子树的层数，所以需要根据当前的层数去动态结果集中每层节点对应的向量数量。<br>　代码实现起来比较简单，不过，由于频繁的递归调用，运行时间较长，耗时：<strong>9ms</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!root) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// dynamically increase the size of result</span></div><div class="line">        <span class="keyword">if</span> (result.size() &lt;= depth)&#123;</div><div class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// put current node's value into corresponding depth index</span></div><div class="line">        result[depth].push_back(root-&gt;val);</div><div class="line">        </div><div class="line">        <span class="comment">// recursive to child nodes, first left child, then right</span></div><div class="line">        dfs(root-&gt;left, depth+<span class="number">1</span>, result);</div><div class="line">        dfs(root-&gt;right, depth+<span class="number">1</span>, result);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        dfs(root, <span class="number">0</span>, result);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　下面这一种实现，思路则更加直接：假如每次循环都把上一层的所有节点的左右子树（假如存在）遍历一遍，则会把当前层中的所有节点也遍历一遍；遍历是从根节点出发的，按照这一思路进行迭代，每次循环中将当前循环遍历的当前层所有节点更新成上一层节点；先左子树后右子树以及从0开始遍历上一层的所有节点信息可以保证每一层的节点符合从左往右的顺序。<br>　这种方式，感觉每个节点都需要遍历两次（一次通过上一层节点左右子树的方式；一次为了遍历下一层节点所作的遍历），所以时间也比较长，耗时：<strong>6ms</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// record last-layer nodes</span></div><div class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; lastDepth;</div><div class="line">        lastDepth.push_back(root);</div><div class="line">        </div><div class="line">        <span class="keyword">while</span>(lastDepth.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">            <span class="built_in">vector</span>&lt;TreeNode*&gt; curDepth;</div><div class="line">            </div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;lastDepth.size(); i++) &#123;</div><div class="line">                TreeNode* curNode = lastDepth[i];</div><div class="line">                tmp.push_back(curNode-&gt;val);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">                    curDepth.push_back(curNode-&gt;left);</div><div class="line">                &#125;</div><div class="line">                 <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">                    curDepth.push_back(curNode-&gt;right);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(tmp.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                result.push_back(tmp);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            lastDepth = curDepth;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　最后一种方法，利用这样一种特点：每一层所有节点的左右子树遍历完，则下一层的所有所有节点也被遍历一遍。使用队列这种数据结构实现 <strong>BFS</strong>，通过向队列中插入额外分割符作为实现层与层之间节点的区分，问题变成何时能够插入这样一个分隔符？这就用到上面的特点，即，当我从队列中取出一个分隔符时，说明上一层的所有节点已经从队列中取出，而且根据上一层所有节点遍历到的所有下一层的节点已经放入队列，因此，此时就需要插入一个分隔符。<br>　这种方法与普通的 <strong>BFS</strong> 遍历过程几乎一样，每个节点也只是遍历一遍（额外的分隔符其实并不多吧…），耗时最少：<strong>3ms</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</div><div class="line">    result.clear();</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; S;</div><div class="line">    S.push(root);</div><div class="line">    S.push(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="keyword">while</span>(!S.empty())&#123;</div><div class="line">      <span class="comment">// travesal current level</span></div><div class="line">      TreeNode* curNode = S.front();</div><div class="line">      S.pop();</div><div class="line">      <span class="keyword">if</span>(curNode != <span class="literal">NULL</span>) &#123;</div><div class="line">        tmp.push_back(curNode-&gt;val);</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">          S.push(curNode-&gt;left);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">          S.push(curNode-&gt;right);</div><div class="line">        &#125;</div><div class="line">      &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(!tmp.empty()) &#123;	</div><div class="line">          S.push(<span class="literal">NULL</span>);</div><div class="line">          result.push_back(tmp);</div><div class="line">          tmp.clear();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>　
　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文主要介绍 &lt;strong&gt;BFS&lt;/strong&gt; 的 &lt;em&gt;C++&lt;/em&gt; 和 &lt;em&gt;C&lt;/em&gt; 语言实现，并借助 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt; 上的一道题，说说基本的 &lt;strong&gt;BFS&lt;/strong&gt; 在问题求解中的应用。&lt;/p&gt;
&lt;h3 id=&quot;What’s-B-readth-F-irst-S-earch&quot;&gt;&lt;a href=&quot;#What’s-B-readth-F-irst-S-earch&quot; class=&quot;headerlink&quot; title=&quot;What’s B(readth)F(irst)S(earch)&quot;&gt;&lt;/a&gt;What’s B(readth)F(irst)S(earch)&lt;/h3&gt;&lt;p&gt;　广度优先搜索算法（Breadth First Search），又叫宽度优先搜索，或横向优先搜索。是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0004] Depth First Search（深度优先搜索）</title>
    <link href="http://durant35.github.io/2017/03/15/Algorithms_DFS/"/>
    <id>http://durant35.github.io/2017/03/15/Algorithms_DFS/</id>
    <published>2017-03-15T06:00:22.000Z</published>
    <updated>2017-03-27T12:39:55.370Z</updated>
    
    <content type="html"><![CDATA[<p>　本文主要介绍 <strong>DFS</strong> 的 <em>C++</em> 和 <em>C</em> 语言实现，并借助 <a href="https://leetcode.com/">LeetCode</a> 上的一道题，说说基本的 <strong>DFS</strong> 在问题求解中的应用。</p>
<h3 id="What’s-D-epth-F-irst-S-earch"><a href="#What’s-D-epth-F-irst-S-earch" class="headerlink" title="What’s D(epth)F(irst)S(earch)"></a>What’s D(epth)F(irst)S(earch)</h3><p>　深度优先搜索算法（Depth First Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 <strong>N</strong> 的所有边都己被探寻过，搜索将回溯到发现节点 <strong>N</strong> 的那条边的起始节点，这一过程一直进行到已发现从源节点可达的所有节点为止。<br>　如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<br><a id="more"></a></p>
<p><center><img src="/img/Algorithms/0004_binarytree.png" width="480px"/></center><br>　如上图所示的二叉树，A 是第一个访问的，然后顺序是 B、D，然后是 E。接着再是 C、F、G。</p>
<h3 id="DFS（C-）"><a href="#DFS（C-）" class="headerlink" title="DFS（C++）"></a>DFS（C++）</h3><ul>
<li><em>C++</em> 中借助堆栈数据结构来保证这个访问的顺序。由于堆栈是后进先出的顺序，由此可以先将右子树压栈，然后再对左子树压栈，这样一来，左子树结点就存在了栈顶上，因此某结点的左子树能在它的右子树遍历之前被遍历。这样一来，在遍历了根结点后，就开始遍历左子树，最后才是右子树（v<strong>oid depthFirstSearch(Tree root) </strong>）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DFS.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODE_NUM 15</span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Node &#123;</div><div class="line">    ELEMENT data;</div><div class="line">    <span class="keyword">struct</span> Node* left;</div><div class="line">    <span class="keyword">struct</span> Node* right;</div><div class="line">&#125;* Tree;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Binary Tree Constructor</div><div class="line"> *  1. construct in preorder</div><div class="line"> *  2. '#' means no left child or right child</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreeConstructor</span><span class="params">(Tree &amp;root, ELEMENT data[])</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(index &gt;= NODE_NUM) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ELEMENT ele = data[index++];</div><div class="line">    <span class="keyword">if</span>(ele == <span class="string">'#'</span>) &#123;</div><div class="line">        root = <span class="literal">NULL</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        root = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</div><div class="line">        root-&gt;data = ele;</div><div class="line">        binaryTreeConstructor(root-&gt;left, data);</div><div class="line">        binaryTreeConstructor(root-&gt;right, data);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">(Tree root)</span> </span>&#123;</div><div class="line">    <span class="built_in">stack</span>&lt;Node *&gt; treeStack;                    <span class="comment">// using stack in STL</span></div><div class="line">    treeStack.push(root);</div><div class="line">    Node* curNode;</div><div class="line">    <span class="keyword">while</span>(!treeStack.empty()) &#123;</div><div class="line">        curNode = treeStack.top();</div><div class="line">        treeStack.pop();</div><div class="line">        <span class="built_in">printf</span>(FORMAT, curNode-&gt;data);</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(curNode-&gt;right) &#123;</div><div class="line">            treeStack.push(curNode-&gt;right);     <span class="comment">// push right child first</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(curNode-&gt;left) &#123;</div><div class="line">            treeStack.push(curNode-&gt;left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    ELEMENT data[NODE_NUM] = &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'E'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'C'</span>, <span class="string">'F'</span>,<span class="string">'#'</span>, <span class="string">'#'</span>, <span class="string">'G'</span>, <span class="string">'#'</span>, <span class="string">'#'</span>&#125;;</div><div class="line">    Tree tree;</div><div class="line">    binaryTreeConstructor(tree, data);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Traversal using DFS: "</span>);</div><div class="line">    depthFirstSearch(tree);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ DFS.cpp -o DFS</div><div class="line">gary@xxx:xxx$ ./DFS</div><div class="line">Traversal using DFS: ABDECFG</div></pre></td></tr></table></figure></p>
<h3 id="DFS（C）"><a href="#DFS（C）" class="headerlink" title="DFS（C）"></a>DFS（C）</h3><ul>
<li><em>C语言</em> 中采取类似的策略，使用的是递归调用这个“堆栈”（<strong>void dfs(Node tree[], int vertexIndex, bool visited[])</strong>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DFS.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NODENUM 7            	<span class="comment">// node number</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ELEMENT char</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FORMAT <span class="meta-string">"%c "</span></span></div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;<span class="literal">false</span>, <span class="literal">true</span>&#125; <span class="keyword">bool</span>;</div><div class="line"></div><div class="line"><span class="comment">// structure for adjacency lists</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> AdjList &#123;</div><div class="line">  <span class="keyword">int</span> vertexIndex; </div><div class="line">  <span class="keyword">struct</span> AdjList* next;</div><div class="line">&#125; AdjList;</div><div class="line">  </div><div class="line"><span class="comment">// Graphic node structure</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">  ELEMENT data;			<span class="comment">// data area</span></div><div class="line">  <span class="keyword">struct</span> AdjList* listAdj; 	<span class="comment">// pointing to neighbouring node</span></div><div class="line">&#125; Node;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="comment">// return the location of current vertex data in array, -1 if not exit. </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(<span class="keyword">char</span>, Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseDFS</span><span class="params">(Node[])</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node[], <span class="keyword">int</span>, <span class="keyword">bool</span>[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node[])</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</div><div class="line">  Node tree[NODENUM+<span class="number">1</span>];</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(createTree(tree)) &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"DFS result as follow:\n"</span>);</div><div class="line">    traverseDFS(tree);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</div><div class="line"> </div><div class="line">    treeRelease(tree);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Create graphic fail!\n"</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * 1. create a tree by entering all nodes' value and edges of the tree</div><div class="line"> * 2. store the tree in an adjacency list</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">createTree</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i,location;</div><div class="line">  <span class="keyword">char</span> c;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"Input all nodes's value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    tree[i].data = getchar();</div><div class="line">    <span class="keyword">if</span>(tree[i].data &lt; <span class="string">'A'</span> || (tree[i].data &gt; <span class="string">'Z'</span> &amp;&amp; tree[i].data &lt; <span class="string">'a'</span>) || tree[i].data &gt; <span class="string">'z'</span>) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"Node's value should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]\n"</span>);</div><div class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// eliminate '\n'</span></div><div class="line">  getchar();</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\nInput the directly connected nodes, given a node:\n"</span>);</div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NODENUM; i++) &#123;</div><div class="line">    <span class="built_in">putchar</span>(tree[i].data);</div><div class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</div><div class="line">    c = getchar();</div><div class="line">    tree[i].listAdj = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>((location = locate(c, tree)) != <span class="number">-1</span>) &#123;</div><div class="line">      AdjList* newAdjVertex = (AdjList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(AdjList));</div><div class="line">      newAdjVertex-&gt;vertexIndex = location;</div><div class="line">      newAdjVertex-&gt;next = <span class="literal">NULL</span>;</div><div class="line"> </div><div class="line">      <span class="comment">// insert an adjacent node, as the head need to be dealt with separately </span></div><div class="line">      <span class="keyword">if</span>(tree[i].listAdj == <span class="literal">NULL</span>) &#123;</div><div class="line">        tree[i].listAdj = newAdjVertex;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        AdjList* temp = tree[i].listAdj;</div><div class="line">        <span class="keyword">while</span>(temp-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">          temp = temp-&gt;next;</div><div class="line">        &#125;</div><div class="line">        temp-&gt;next = newAdjVertex;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">      <span class="comment">// '\n' will lead to exit</span></div><div class="line">      c = getchar();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the index of the given node in the node array, -1 if not exist.</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">locate</span><span class="params">(ELEMENT givenVal, Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> location;</div><div class="line">  <span class="keyword">for</span>(location = NODENUM<span class="number">-1</span>; location&gt;=<span class="number">0</span>; location--) &#123;</div><div class="line">    <span class="keyword">if</span>(tree[location].data == givenVal) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> location;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverseDFS</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> visited[NODENUM];</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    visited[i] = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// need to traverse all nodes, avoid not-connected graph</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++)&#123;</div><div class="line">    <span class="keyword">if</span>(!visited[i]) &#123;</div><div class="line">      dfs(tree, i, visited);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node tree[], <span class="keyword">int</span> vertexIndex, <span class="keyword">bool</span> visited[])</span> </span>&#123;</div><div class="line">  AdjList *pAdjList;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(FORMAT, tree[vertexIndex].data);</div><div class="line">  visited[vertexIndex] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">  pAdjList = tree[vertexIndex].listAdj;</div><div class="line">  <span class="keyword">while</span>(pAdjList != <span class="literal">NULL</span>) &#123;</div><div class="line">    vertexIndex = pAdjList-&gt;vertexIndex;</div><div class="line">    <span class="keyword">if</span>(!visited[vertexIndex]) &#123;</div><div class="line">      dfs(tree, vertexIndex, visited);</div><div class="line">    &#125;</div><div class="line">    pAdjList = pAdjList-&gt;next;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// reslease the dynamically allocated memory</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">treeRelease</span><span class="params">(Node tree[])</span> </span>&#123;</div><div class="line">  AdjList *p, *temp;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;NODENUM; i++) &#123;</div><div class="line">    p = tree[i].listAdj;</div><div class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</div><div class="line">      temp = p;</div><div class="line">      p = p-&gt;next;</div><div class="line">      <span class="built_in">free</span>(temp);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　构建运行，结果如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">gary@xxx:xxx$ g++ DFS.c -o DFS</div><div class="line">gary@xxx:xxx$ ./DFS</div><div class="line">Input all nodes<span class="string">'s value(should be in [A&lt;sub&gt;Z]||[a&lt;/sub&gt;z]):</div><div class="line">ABCDEFG</div><div class="line"> </div><div class="line">Input the directly connected nodes, given a node:</div><div class="line">A BC</div><div class="line">B ADE</div><div class="line">C AFG</div><div class="line">D B</div><div class="line">E B</div><div class="line">F C</div><div class="line">G C</div><div class="line">DFS result as follow:</div><div class="line">A B D E C F G</span></div></pre></td></tr></table></figure></p>
<h3 id="112-amp-113-Path-Sum-I-amp-II"><a href="#112-amp-113-Path-Sum-I-amp-II" class="headerlink" title="112.&amp;113. Path Sum I&amp;II"></a><a href="https://leetcode.com/problems/path-sum/#/description">112.&amp;113. Path Sum I&amp;II</a></h3><ul>
<li>Description<blockquote>
<p>　Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>　For example:<br>　Given the below binary tree and sum = 22,</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">      <span class="number">5</span></div><div class="line">     / \</div><div class="line">    <span class="number">4</span>   <span class="number">8</span></div><div class="line">   /   / \</div><div class="line">  <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line"> /  \      \</div><div class="line"><span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>return true, as there exist a root-to-leaf path <strong>5-&gt;4-&gt;11-&gt;2</strong> which sum is 22.<br>　即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">给定一个二叉树root和一个和sum，</div><div class="line"> </div><div class="line">决定这个树是否存在一条从根到叶子的路径使得沿路所有节点的和等于给定的sum。</div><div class="line"> </div><div class="line">例如：</div><div class="line">给定如下二叉树和sum=<span class="number">22</span>，</div><div class="line">              <span class="number">5</span></div><div class="line">             / \</div><div class="line">            <span class="number">4</span>   <span class="number">8</span></div><div class="line">           /   / \</div><div class="line">          <span class="number">11</span>  <span class="number">13</span>  <span class="number">4</span></div><div class="line">         /  \      \</div><div class="line">        <span class="number">7</span>    <span class="number">2</span>      <span class="number">1</span></div><div class="line">返回真，因为这里存在一条根叶路径（<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">11</span>-&gt;<span class="number">2</span>），它的和为<span class="number">22</span>。</div><div class="line"> </div><div class="line"><span class="number">112</span>&amp;<span class="number">113</span> 都是这样的问题，只不过前者只需要判断是否存在，后者则需要遍历所有节点以得到所有满足条件情况：</div><div class="line">　<span class="keyword">return</span></div><div class="line">　[</div><div class="line">   　[<span class="number">5</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>],</div><div class="line">   　[<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line">　]</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>解题思路<ul>
<li>是一个典型的 <strong>DFS</strong> 遍历的问题，因为需要遍历 <strong>root-&gt;leaf</strong> 这样一类路径，通过递归实现。</li>
<li>需要考虑的是在 path 上传递的变量（递归调用过程中传递的参数），<strong>问题 112</strong> 只需要传递 <strong>root-&gt;当前节点</strong> 的求和（这里通过 <strong>Sum</strong> 减去当前节点值的方式），如下：</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</div><div class="line">        <span class="comment">// 1. An empty tree</span></div><div class="line">        <span class="keyword">if</span>(!root) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 2. A leaf, check sum</span></div><div class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">return</span> (root-&gt;val == sum);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. Not a leaf, recursive to a child node(|| for "exist")</span></div><div class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum-(root-&gt;val)) || hasPathSum(root-&gt;right, sum-(root-&gt;val));</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><strong>问题 113</strong> 除了传递 <strong>Sum</strong> 外，还需要传递 <strong>root-&gt;leaf</strong> 路径上的节点值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</div><div class="line"> * Definition for a binary tree node.</div><div class="line"> * struct TreeNode &#123;</div><div class="line"> *     int val;</div><div class="line"> *     TreeNode *left;</div><div class="line"> *     TreeNode *right;</div><div class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</div><div class="line"> * &#125;;</div><div class="line"> */</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSet;</div><div class="line">        <span class="comment">// 1. An empty tree, return empty path Set</span></div><div class="line">        <span class="keyword">if</span>(root) &#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</div><div class="line">            dfs(root, sum, path, pathSet);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> pathSet;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curPath, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pathSet)</span> </span>&#123;</div><div class="line">        curPath.push_back(root-&gt;val);</div><div class="line">        sum -= root-&gt;val;</div><div class="line">        </div><div class="line">        <span class="comment">// 2. A leaf reached</span></div><div class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</div><div class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>) &#123;</div><div class="line">                pathSet.push_back(curPath);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. Recursive to a child node</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(root-&gt;left) &#123;</div><div class="line">                dfs(root-&gt;left, sum, curPath, pathSet);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(root-&gt;right) &#123;</div><div class="line">                dfs(root-&gt;right, sum, curPath, pathSet);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// backtracking</span></div><div class="line">        curPath.pop_back();</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>　此外还需要留意 <strong>backtracking</strong> 部分，因为对于 <strong>Sum</strong>，是一个形式参数，当递归函数返回时，不影响调用函数中的 <strong>Sum</strong>，但对于引用参数 <strong>curPath</strong> 就不一样了，因此，需要在递归函数返回前进行回溯，保证 <strong>curPath</strong> 始终记录 <strong>root-&gt;当前节点</strong> 路径上的节点值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文主要介绍 &lt;strong&gt;DFS&lt;/strong&gt; 的 &lt;em&gt;C++&lt;/em&gt; 和 &lt;em&gt;C&lt;/em&gt; 语言实现，并借助 &lt;a href=&quot;https://leetcode.com/&quot;&gt;LeetCode&lt;/a&gt; 上的一道题，说说基本的 &lt;strong&gt;DFS&lt;/strong&gt; 在问题求解中的应用。&lt;/p&gt;
&lt;h3 id=&quot;What’s-D-epth-F-irst-S-earch&quot;&gt;&lt;a href=&quot;#What’s-D-epth-F-irst-S-earch&quot; class=&quot;headerlink&quot; title=&quot;What’s D(epth)F(irst)S(earch)&quot;&gt;&lt;/a&gt;What’s D(epth)F(irst)S(earch)&lt;/h3&gt;&lt;p&gt;　深度优先搜索算法（Depth First Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点 &lt;strong&gt;N&lt;/strong&gt; 的所有边都己被探寻过，搜索将回溯到发现节点 &lt;strong&gt;N&lt;/strong&gt; 的那条边的起始节点，这一过程一直进行到已发现从源节点可达的所有节点为止。&lt;br&gt;　如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0003] 一道阿里巴巴面试题（2017） </title>
    <link href="http://durant35.github.io/2017/03/10/Algorithms_An%20Alibaba%20Interview%20Question/"/>
    <id>http://durant35.github.io/2017/03/10/Algorithms_An Alibaba Interview Question/</id>
    <published>2017-03-10T06:00:22.000Z</published>
    <updated>2017-03-12T14:54:00.786Z</updated>
    
    <content type="html"><![CDATA[<p>　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。</p>
<p><center><img src="/img/Algorithms/0003_alibaba_2017.png" width="1024px"/></center><br><a id="more"></a></p>
<h4 id="转化问题1：求一个字符串中连续出现次数最多的子串"><a href="#转化问题1：求一个字符串中连续出现次数最多的子串" class="headerlink" title="转化问题1：求一个字符串中连续出现次数最多的子串"></a>转化问题1：求一个字符串中连续出现次数最多的子串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"string.h"</span></span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line"><span class="keyword">char</span> sub_str[<span class="number">2000</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_substr</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> str_len = <span class="built_in">strlen</span>(str);</div><div class="line">     <span class="keyword">int</span> i, j, k;</div><div class="line">     <span class="keyword">int</span> tmp_cnt = <span class="number">0</span>;</div><div class="line"> </div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i++) &#123;</div><div class="line">         <span class="keyword">for</span> (j = i+<span class="number">2</span>; j &lt; str_len; j++) &#123;</div><div class="line">             <span class="keyword">int</span> n = j-i;                                                     <span class="comment">//sub string length</span></div><div class="line">             tmp_cnt = <span class="number">1</span>;</div><div class="line">             <span class="keyword">if</span> (<span class="built_in">strncmp</span>(&amp;str[i], &amp;str[j], n) == <span class="number">0</span>) &#123;  <span class="comment">//compare n-lengths strings</span></div><div class="line">                 tmp_cnt++;                                             <span class="comment">//they are equal, so add count</span></div><div class="line">                 <span class="keyword">for</span> (k = j+n; k &lt; str_len; k += n) &#123;      <span class="comment">//consecutive checking</span></div><div class="line">                     <span class="keyword">if</span> (<span class="built_in">strncmp</span>(&amp;str[i], &amp;str[k], n) == <span class="number">0</span>) &#123;</div><div class="line">                         tmp_cnt++;</div><div class="line">                     &#125;</div><div class="line">                     <span class="keyword">else</span> &#123;</div><div class="line">                         <span class="keyword">break</span>;</div><div class="line">                     &#125;</div><div class="line">                 &#125;</div><div class="line">                 <span class="keyword">if</span> (count &lt; tmp_cnt) &#123;</div><div class="line">                     count = tmp_cnt;</div><div class="line">                     <span class="built_in">memcpy</span>(sub_str, &amp;str[i], n);        <span class="comment">//record the sub string</span></div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">     <span class="keyword">char</span> str[<span class="number">2000</span>];</div><div class="line">     <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</div><div class="line">     find_substr(str);</div><div class="line">     <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, sub_str);</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析：</p>
<ul>
<li>对于连续出现的子串，我们可以以候选子串长度作为step</li>
<li>通过指定step长度的滑动窗口，统计候选子串出现的次数，并计数</li>
<li>维护出现次数最多的子串<h4 id="转化问题2：求一个字符串中出现次数最多的子串-不一定是连续的"><a href="#转化问题2：求一个字符串中出现次数最多的子串-不一定是连续的" class="headerlink" title="转化问题2：求一个字符串中出现次数最多的子串(不一定是连续的)"></a>转化问题2：求一个字符串中出现次数最多的子串(不一定是连续的)</h4>　假设存在一个长度为 N 的子串 S 出现的次数最多。那么它具有哪些特点呢？</li>
<li>S的任一子串的出现次数不少于 S 的出现次数 </li>
<li>S中不会出现重复的子串字符 </li>
<li>S中不会出现重复的字符 </li>
<li>组成 S 的每一个字符、每一个子串的出现次数都和 S 一样<br>　“S 中不会出现重复的字符”，“组成 S 的每一个字符、每一个子串的出现次数都和 S 一样”！有了这个结论，问题就简单了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// mostTimesSubstring.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 1024</span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</div><div class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">deque</span>;</div><div class="line"> </div><div class="line"><span class="keyword">typedef</span> <span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; strlist;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> npos = <span class="number">-1</span>;</div><div class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">ignoreChars</span><span class="params">(<span class="string">" /t/n/r"</span>)</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IgnoreChar</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (ignoreChars.find(c) != npos);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// return the max count</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">TextSummary</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">unsigned</span> usecount[], <span class="keyword">int</span> Num4Chars)</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> max_count, i;</div><div class="line"> </div><div class="line">    <span class="built_in">memset</span>(usecount, <span class="number">0</span>, Num4Chars*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</div><div class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; text.length(); usecount[<span class="keyword">unsigned</span>(text[i++])]++);</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(max_count = i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)&#123;</div><div class="line">        <span class="keyword">if</span>(IgnoreChar(i)) <span class="keyword">continue</span>;</div><div class="line">        <span class="keyword">if</span>(usecount[i] &gt; max_count) max_count = usecount[i];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> max_count;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// check whether current substring splicing one more char also reach max count</span></div><div class="line"><span class="function"><span class="keyword">char</span> <span class="title">StringTryGrowthOneChar</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span> maxcount, <span class="keyword">unsigned</span>* usecount)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="built_in">string</span>::size_type pos;</div><div class="line">    <span class="keyword">char</span> c = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    pos = text.find(str);</div><div class="line">    <span class="keyword">if</span>(pos == npos)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// not the max count char</span></div><div class="line">    c = text[pos + str.length()];</div><div class="line">    <span class="keyword">if</span>(usecount[<span class="keyword">unsigned</span>(c)] &lt; maxcount)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// make sure every char in this growing substring also reach max count</span></div><div class="line">    <span class="keyword">for</span>(count = <span class="number">0</span>; pos + str.length() + <span class="number">1</span> &lt; text.length(); pos += str.length())&#123;</div><div class="line">        pos = text.find(str, pos);</div><div class="line">        <span class="keyword">if</span>(pos == npos) <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">if</span>(c != text[pos + str.length()]) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintResult</span><span class="params">(<span class="keyword">const</span> strlist&amp; result)</span></span>&#123;</div><div class="line">    strlist::const_iterator citer;</div><div class="line"> </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"The result substrings :"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">for</span>(citer = result.begin(); citer != result.end(); citer++)&#123;</div><div class="line">        <span class="comment">// substring should longer than 2 chars</span></div><div class="line">        <span class="keyword">if</span>((*citer).length() &gt; <span class="number">1</span>)</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">'"'</span> &lt;&lt; *citer &lt;&lt; <span class="string">'"'</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Total : "</span> &lt;&lt; result.size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span>&#123;</div><div class="line">    <span class="keyword">unsigned</span> usecount[<span class="number">256</span>];</div><div class="line">    <span class="keyword">char</span> buffer[BUFFSIZE], c;</div><div class="line">    <span class="keyword">unsigned</span> count, i;</div><div class="line">    <span class="built_in">string</span> text;</div><div class="line">    strlist result;</div><div class="line"> </div><div class="line">    <span class="keyword">while</span>(!feof(<span class="built_in">stdin</span>))&#123;</div><div class="line">        <span class="keyword">if</span>(fgets(buffer, <span class="keyword">sizeof</span>(buffer), <span class="built_in">stdin</span>))</div><div class="line">            text = buffer;</div><div class="line"> </div><div class="line">        <span class="comment">// Count the number of occurrences of characters</span></div><div class="line">        count = TextSummary(text, usecount, <span class="keyword">sizeof</span>(usecount)/<span class="keyword">sizeof</span>(*usecount));</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Max count :"</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">        <span class="keyword">if</span>(<span class="number">1</span> &gt;= count)&#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"No longest substring!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// result holds the substring reach max count</span></div><div class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(usecount)/<span class="keyword">sizeof</span>(*usecount); i++)&#123;</div><div class="line">            <span class="keyword">if</span>(usecount[i] == count)</div><div class="line">                result.push_back(<span class="built_in">string</span>(<span class="number">1</span>, <span class="keyword">char</span>(i)));</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// substring growing for more substrings</span></div><div class="line">        <span class="keyword">for</span>(strlist::iterator iter = result.begin(); iter != result.end(); iter++)&#123;</div><div class="line">            c = StringTryGrowthOneChar(text, *iter, count, usecount);</div><div class="line">            <span class="keyword">if</span>(c)</div><div class="line">                result.push_back(*iter + <span class="built_in">string</span>(<span class="number">1</span>, c));</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        PrintResult(result);</div><div class="line">        result.clear();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>编译构建：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -o mostTimesSubstring mostTimesSubstring.cpp</div></pre></td></tr></table></figure></p>
<p>算法分析：</p>
<ul>
<li>找到文本中的出现次数最高的单个字符组成的子串，放入一个队列中</li>
<li>从队列的头部开始，对每一个子串 S 进行处理，找到文本中该子串出现的任意一个位置 P，判断文本中紧随 S 之后的字符 C 是否的出现次数是最多的<ul>
<li>如果 C 的出现次数不是最多的，结束。</li>
<li>如果 C 的出现次数是最多的，搜索文本中的每一个 S 并判断紧随其后的字符是否是 C <ul>
<li>如果文本中的每一个 S 之后都存在字符 C ，将 S + C 生成的子串放入结果集中</li>
<li>如果文本中出现 S 之后的字符不是 C ，结束。 </li>
</ul>
</li>
<li>如此，直至到达队列尾。</li>
</ul>
</li>
</ul>
<h4 id="回到这道面试题"><a href="#回到这道面试题" class="headerlink" title="回到这道面试题"></a>回到这道面试题</h4><ul>
<li>该题统计的是：子串出现次数与子串长度的乘积，问题是，是否这个乘积的最大值总是：（1）出现次数最多的；（2）长度最长的，显然不是</li>
<li>问题分析1：我们需要穷举所有子串并计数各自出现的次数，最终获取乘积最大的子串</li>
<li>问题分析2：能否不穷举，对上述算法进行变形？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文通过一道阿里面试题（下图），说说关于该题的字符串最长子串的查找问题。&lt;/p&gt;
&lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0003_alibaba_2017.png&quot; width=&quot;1024px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0002] Divide and Conquer——FFT（快速傅里叶变换）</title>
    <link href="http://durant35.github.io/2017/03/04/Algorithms_FFT/"/>
    <id>http://durant35.github.io/2017/03/04/Algorithms_FFT/</id>
    <published>2017-03-04T06:00:22.000Z</published>
    <updated>2017-03-12T09:52:51.505Z</updated>
    
    <content type="html"><![CDATA[<p>　本文介绍 <strong>Divide and Conquer（分而治之）</strong> 的一种典型算法，<strong>FFT</strong>（快速傅里叶变换）。</p>
<h3 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h3><p>DFT：$X[k] = \sum_{n=0}^{N-1} x[n] e^{-j \frac{2 \pi k}{N} n}, k = 0, 1, 2, …, N-1$</p>
<ul>
<li>for each k: <strong>N</strong> complex mults, <strong>N-1</strong> complex adds</li>
<li>$e^{-j \frac{2 \pi k}{N} n}$ 预计算并保存在计算机中</li>
<li>$O(N^2)$ computations for direct <strong>DFT</strong> $\Longrightarrow$ $O(N log_2 N)$ for <strong>FFT</strong><a id="more"></a>
<h3 id="FFT-算法原理"><a href="#FFT-算法原理" class="headerlink" title="FFT 算法原理"></a>FFT 算法原理</h3>　做出如下定义：$W_N = e^{-j \frac{2 \pi}{N}}$，则：$W_N^{kn} = e^{-j \frac{2 \pi k}{N} n}$，具有如下性质：</li>
</ul>
<ol>
<li>$W_N^{kN} = e^{-j 2 \pi k } = 1$</li>
<li>复共轭对称：$W_N^{k(N-n)} = W_N^{-kn)} = (W_N^{kn})^{*}$</li>
<li>周期性：$W_N^{kn} = W_N^{k(N+n))} = W_N^{(k+N)n}$</li>
</ol>
<p>　假设 $N = 2^m$，separate $x[n]$ into even and odd-indexed subsequences<br>　$ X[k] = \sum_{n=0}^{N-1} x[n] W_N^{kn} =  \sum_{n \in even} x[n] W_N^{kr} + \sum_{n \in odd} x[n] W_N^{kr} $<br>　$ X[k] = \sum_{r=0}^{\frac{N}{2}-1} x[2r] W_N^{k 2r} +  \sum_{r=0}^{\frac{N}{2}-1} x[2r+1] W_N^{k(2r+1)} $<br>　　　$ = \sum_{r=0}^{\frac{N}{2}-1} x[2r] (W_N^2)^{kr} +  W_N^k \sum_{r=0}^{\frac{N}{2}-1} x[2r+1] (W_N^2)^{kr} $<br>　But：$W_N^2 = e^{-j \frac{2 \pi}{N} 2} = e^{-j \frac{2 \pi}{\frac{N}{2}}} = W_{\frac{N}{2}}$<br>　$ X[k] = \sum_{r=0}^{\frac{N}{2}-1} x[2r] W_{\frac{N}{2}}^{kr} +  W_N^k \sum_{r=0}^{\frac{N}{2}-1} x[2r+1] W_{\frac{N}{2}}^{kr} $<br>　　　$ = X_e[k]  + W_N^k X_o[k]$<br>　其中，$X_e[k]$：N/2 DFT of even samples，$X_o[k]$：N/2 DFT of odd samples，$X[k] \Rightarrow$ sum of 2 N/2 point DFTs<br>　<br>　举$N=8$作为一个例子，根据上述的思路进行一次二分，如下图：</p>
<center><img src="/img/Algorithms/0002_FFT complexity 1.png" width="720px"/></center><br>　左边按照普通的 <strong>DFT</strong> 计算（$O(n^2)$的时间复杂度）得到$x_e[0…3]$和$x_o[0…3]$，需要$(\frac{N}{2})^2·2$ 次乘法；$W_8^{0…7}$ 的预计算需要 $N$ 次乘法；最后的 $X[0…7]$ 的计算每一项都需要一次乘法，总共需要 $N$ 次乘法。故通过一次二分得出的计算复杂度估计为 $\frac{N^2}{2} + N$<br><center><img src="/img/Algorithms/0002_FFT complexity 2.png" width="720px"/></center><br>　按照这种思路，继续二分下去（如下图），得到 <strong>FFT</strong> 算法的最终时间复杂度：$O(N log_2 N)$<br><center><img src="/img/Algorithms/0002_FFT diagram(N=8).png" width="800px"/></center>

<h3 id="FFT算法实现"><a href="#FFT算法实现" class="headerlink" title="FFT算法实现"></a>FFT算法实现</h3><ul>
<li>源代码<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// FFT.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> M_PI  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI 3.14159265358979323846  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 1024*16</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> VALUE_MAX 1000</span></div><div class="line"> </div><div class="line"><span class="comment">// define a complex structure</span></div><div class="line"><span class="keyword">struct</span> Complex_ &#123; </div><div class="line">    <span class="keyword">double</span> real; </div><div class="line">    <span class="keyword">double</span> imagin; </div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Complex_ Complex;</div><div class="line"><span class="comment">// define complex computation: add/subtract/multiply</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex_Add</span><span class="params">(Complex* src1, Complex* src2, Complex* dst)</span></span>&#123; </div><div class="line">    dst-&gt;real = src1-&gt;real + src2-&gt;real; </div><div class="line">    dst-&gt;imagin = src1-&gt;imagin + src2-&gt;imagin; </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex_Sub</span><span class="params">(Complex* src1, Complex* src2, Complex* dst)</span></span>&#123; </div><div class="line">    dst-&gt;real = src1-&gt;real - src2-&gt;real; </div><div class="line">    dst-&gt;imagin = src1-&gt;imagin - src2-&gt;imagin; </div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Complex_Multiply</span><span class="params">(Complex* src1, Complex* src2, Complex* dst)</span></span>&#123;</div><div class="line">    <span class="keyword">double</span> r1 = <span class="number">0.0</span>, r2 = <span class="number">0.0</span>; </div><div class="line">    <span class="keyword">double</span> i1 = <span class="number">0.0</span>, i2 = <span class="number">0.0</span>;</div><div class="line">    r1 = src1-&gt;real; </div><div class="line">    i1 = src1-&gt;imagin; </div><div class="line">    r2 = src2-&gt;real; </div><div class="line">    i2 = src2-&gt;imagin;</div><div class="line">    dst-&gt;real = r1*r2 - i1*i2;</div><div class="line">    dst-&gt;imagin = i1*r2 + r1*i2; </div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// get W_N^k </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getWN</span><span class="params">(<span class="keyword">double</span> k, <span class="keyword">double</span> N, Complex* dst)</span></span>&#123; </div><div class="line">    <span class="keyword">double</span> x = <span class="number">2.0</span>*M_PI*k/N; </div><div class="line">    dst-&gt;real = <span class="built_in">cos</span>(x);</div><div class="line">    dst-&gt;imagin = -<span class="built_in">sin</span>(x); </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// input generator</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_generator</span><span class="params">(<span class="keyword">double</span>* data, <span class="keyword">int</span>  n)</span></span>&#123; </div><div class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>)); </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;SIZE; i++)&#123; </div><div class="line">        data[i] = rand()%VALUE_MAX;  </div><div class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,data[i]);  </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * normal DFT algorithm, with O(n^2) complexity</div><div class="line"> */</span> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFT</span><span class="params">(<span class="keyword">double</span>* src, Complex* dst, <span class="keyword">int</span> size)</span> </span>&#123; </div><div class="line">    <span class="keyword">clock_t</span> start, end; </div><div class="line">    start = clock(); </div><div class="line">    <span class="comment">// 2 cycle, each with step of 1, size n, so O(n*n)</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;size; m++)&#123; </div><div class="line">        <span class="keyword">double</span> real = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">double</span> imagin = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;size; n++)&#123;  </div><div class="line">            <span class="keyword">double</span> x = M_PI*<span class="number">2</span>*m*n;  </div><div class="line">            real += src[n]*<span class="built_in">cos</span>(x/size);  </div><div class="line">            imagin += src[n]*(-<span class="built_in">sin</span>(x/size));  </div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        dst[m].imagin = imagin;  </div><div class="line">        dst[m].real = real;  </div><div class="line">        <span class="keyword">if</span>(imagin &gt;= <span class="number">0.0</span>)</div><div class="line">        	<span class="built_in">printf</span>(<span class="string">"%lf+%lfj\n"</span>, real, imagin); </div><div class="line">        <span class="keyword">else</span> </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lf%lfj\n"</span>, real, imagin);</div><div class="line">    &#125; </div><div class="line">    end = clock(); </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"DFT use time :%lf for Datasize of:%d\n"</span>,(<span class="keyword">double</span>)(end-start)/CLOCKS_PER_SEC, size); </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">IDFT</span><span class="params">(Complex* src, Complex* dst, <span class="keyword">int</span> size)</span> </span>&#123; </div><div class="line">    <span class="keyword">clock_t</span> start, end; </div><div class="line">    start = clock(); </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">0</span>; m&lt;size; m++) &#123; </div><div class="line">        <span class="keyword">double</span> real = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">double</span> imagin = <span class="number">0.0</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;size; n++) &#123;  </div><div class="line">            <span class="keyword">double</span> x = M_PI*<span class="number">2</span>*m*n/size;  </div><div class="line">            real += src[n].real*<span class="built_in">cos</span>(x)-src[n].imagin*<span class="built_in">sin</span>(x);  </div><div class="line">            imagin += src[n].real*<span class="built_in">sin</span>(x)+src[n].imagin*<span class="built_in">cos</span>(x);  </div><div class="line">                </div><div class="line">        &#125;  </div><div class="line">        real /= SIZE;  </div><div class="line">        imagin /= SIZE;</div><div class="line">  </div><div class="line">        <span class="keyword">if</span>(dst != <span class="literal">NULL</span>)&#123;  </div><div class="line">            dst[m].real = real;  </div><div class="line">            dst[m].imagin = imagin;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">if</span>(imagin &gt;= <span class="number">0.0</span>)  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lf+%lfj\n"</span>, real, imagin);  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%lf%lfj\n"</span>, real, imagin);  </div><div class="line">    &#125;</div><div class="line">  </div><div class="line">    end=clock(); </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"IDFT use time :%lfs for Datasize of:%d\n"</span>, (<span class="keyword">double</span>)(end-start)/CLOCKS_PER_SEC,size); </div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="comment">// define FFT initialization data, remapping</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FFT_remap</span><span class="params">(<span class="keyword">double</span>* src, <span class="keyword">int</span> N)</span> </span>&#123; </div><div class="line">    <span class="keyword">if</span>(N == <span class="number">1</span>) </div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">  </div><div class="line">    <span class="keyword">double</span>* temp = (<span class="keyword">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*N); </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) </div><div class="line">        <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)  </div><div class="line">            temp[i/<span class="number">2</span>] = src[i];  </div><div class="line">        <span class="keyword">else</span>  </div><div class="line">            temp[(N+i)/<span class="number">2</span>] = src[i];</div><div class="line">  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) </div><div class="line">        src[i] = temp[i];</div><div class="line">  </div><div class="line">    <span class="built_in">free</span>(temp);</div><div class="line">  </div><div class="line">    FFT_remap(src, N/<span class="number">2</span>); </div><div class="line">    FFT_remap(src+N/<span class="number">2</span>, N/<span class="number">2</span>);</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">double</span>* src, Complex* dst, <span class="keyword">int</span> N)</span></span>&#123; </div><div class="line">    FFT_remap(src, N);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) </div><div class="line">    	<span class="built_in">printf</span>(<span class="string">"%lf\n"</span>, src[i]);</div><div class="line"> </div><div class="line">    <span class="keyword">clock_t</span> start, end; </div><div class="line">    start = clock(); </div><div class="line">    <span class="keyword">int</span> n = N;</div><div class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// get number of stage</span></div><div class="line">    <span class="keyword">int</span> stage = <span class="number">0</span>; </div><div class="line">    <span class="keyword">while</span>(n /= <span class="number">2</span>) &#123; </div><div class="line">        stage++;  </div><div class="line">    &#125;</div><div class="line">    n = stage; </div><div class="line">    <span class="keyword">if</span>(N != (<span class="number">1</span>&lt;&lt;n)) </div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</div><div class="line"> </div><div class="line">    Complex* src_complex = (Complex*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Complex)*N);</div><div class="line">    <span class="keyword">if</span>(src_complex == <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);  </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123; </div><div class="line">        src_complex[i].real = src[i];  </div><div class="line">        src_complex[i].imagin = <span class="number">0</span>;  </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123; </div><div class="line">        k = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++) &#123; </div><div class="line">            <span class="keyword">if</span>((j/(<span class="number">1</span>&lt;&lt;i))%<span class="number">2</span> == <span class="number">1</span>) &#123;  </div><div class="line">                Complex WNk;  </div><div class="line">                getWN(k, N, &amp;WNk);</div><div class="line"> </div><div class="line">                Complex_Multiply(&amp;src_complex[j], &amp;WNk, &amp;src_complex[j]);  </div><div class="line">                k += <span class="number">1</span>&lt;&lt;(k-i<span class="number">-1</span>);</div><div class="line">                Complex temp;  </div><div class="line">                <span class="keyword">int</span> neighbour = j-(<span class="number">1</span>&lt;&lt;(i));  </div><div class="line">                temp.real = src_complex[neighbour].real;  </div><div class="line">                temp.imagin = src_complex[neighbour].imagin;  </div><div class="line">                Complex_Add(&amp;temp, &amp;src_complex[j], &amp;src_complex[neighbour]);  </div><div class="line">                Complex_Sub(&amp;temp, &amp;src_complex[j], &amp;src_complex[j]);  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                k = <span class="number">0</span>;  </div><div class="line">        &#125;  </div><div class="line">       </div><div class="line">    &#125; </div><div class="line">     </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">   		<span class="keyword">if</span>(src_complex[i].imagin &gt;= <span class="number">0.0</span>) &#123; </div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%lf+%lfj\n"</span>, src_complex[i].real, src_complex[i].imagin); </div><div class="line">    &#125; </div><div class="line">    <span class="keyword">else</span> </div><div class="line">      <span class="built_in">printf</span>(<span class="string">"%lf%lfj\n"</span>, src_complex[i].real, src_complex[i].imagin);	</div><div class="line">    &#125; </div><div class="line"> </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++)&#123;</div><div class="line">    dst[i].imagin = src_complex[i].imagin;  </div><div class="line">    dst[i].real = src_complex[i].real;  </div><div class="line">  &#125;</div><div class="line">    end = clock();</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"FFT use time :%lfs for Datasize of:%d\n"</span>,(<span class="keyword">double</span>)(end-start)/CLOCKS_PER_SEC, N); </div><div class="line">       </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123; </div><div class="line">    <span class="keyword">double</span> input[SIZE]; </div><div class="line">    Complex dst[SIZE]; </div><div class="line">    input_generator(input, SIZE); </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</div><div class="line">    DFT(input, dst, SIZE);</div><div class="line"> </div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n\n"</span>); </div><div class="line">    FFT(input, dst, SIZE);</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　</p>
<ul>
<li>编译构建<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcc -o FFT FFT.cpp -lm</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　</p>
<ul>
<li>测试结果<blockquote>
<p>DFT use time :33.963164 for Datasize of:16384<br>FFT use time :0.090624s for Datasize of:16384</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文介绍 &lt;strong&gt;Divide and Conquer（分而治之）&lt;/strong&gt; 的一种典型算法，&lt;strong&gt;FFT&lt;/strong&gt;（快速傅里叶变换）。&lt;/p&gt;
&lt;h3 id=&quot;DFT&quot;&gt;&lt;a href=&quot;#DFT&quot; class=&quot;headerlink&quot; title=&quot;DFT&quot;&gt;&lt;/a&gt;DFT&lt;/h3&gt;&lt;p&gt;DFT：$X[k] = \sum_{n=0}^{N-1} x[n] e^{-j \frac{2 \pi k}{N} n}, k = 0, 1, 2, …, N-1$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for each k: &lt;strong&gt;N&lt;/strong&gt; complex mults, &lt;strong&gt;N-1&lt;/strong&gt; complex adds&lt;/li&gt;
&lt;li&gt;$e^{-j \frac{2 \pi k}{N} n}$ 预计算并保存在计算机中&lt;/li&gt;
&lt;li&gt;$O(N^2)$ computations for direct &lt;strong&gt;DFT&lt;/strong&gt; $\Longrightarrow$ $O(N log_2 N)$ for &lt;strong&gt;FFT&lt;/strong&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0001] Divide and Conquer </title>
    <link href="http://durant35.github.io/2017/02/26/Algorithms_Divide%20and%20Conquer/"/>
    <id>http://durant35.github.io/2017/02/26/Algorithms_Divide and Conquer/</id>
    <published>2017-02-26T06:00:22.000Z</published>
    <updated>2017-02-26T06:56:45.425Z</updated>
    
    <content type="html"><![CDATA[<p>　本周的 part 是 <strong>Divide and Conquer（分而治之）</strong>。<br><a id="more"></a></p>
<h4 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element "></a><a href="https://leetcode.com/problems/majority-element/?tab=Description">169. Majority Element </a></h4><ul>
<li>Level: Easy</li>
<li>Description<blockquote>
<p>　Given an array of size n, find the <strong>majority element</strong>. The <strong>majority element</strong> is the element that appears more than $⌊ n/2 ⌋$ times.<br>　You may assume that the array is non-empty and the majority element always exist in the array.</p>
</blockquote>
</li>
<li>解题思路<ul>
<li><strong>Majority Element</strong>: A majority element in an array A[] of size n is an element that appears more than n/2 times（显然，只有唯一一个）</li>
<li>可以通过构造 size 为 n 的向量表计数每个数字出现的次数（$O(n)$ 线性时间复杂度），在计数过程中，一旦发现 $count &gt; n/2$ 即可返回，该数字即为要找的 <strong>Majority Element</strong></li>
<li>细想发现，使用数组构建的向量表，通过下标直接访问的方式，必须满足一个前提条件：n 个元素必须 $\in [0, n)$，所以感觉需要维护两个 size 为 n 的数组，一个保存出现的数字 $elements[0…n)$，另一个是对应的计数 $count[0…n)$，但是这样问题就出现了：在一遍遍历计数每个数字出现的次数过程中，为了找到对应的 $count[0…n)$ 下标，需要对  $elements[0…n)$ 进行查找</li>
<li>考虑了以上的情况，决定使用 C++ 中的 <strong>map</strong> 字典来实现上述的想法，避免手动维护这样一个字典功能带来的低效率和繁琐工作量（毕竟是 Easy）</li>
</ul>
</li>
<li>Solution &amp; Analysis<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(<span class="number">1</span> == nums.size()) &#123;</div><div class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; table;</div><div class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator table_iter = table.end();</div><div class="line"> </div><div class="line">        <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter=nums.begin(); iter!=nums.end(); iter++)&#123;</div><div class="line">            <span class="keyword">if</span>(table.end() == table.find(*iter))&#123;</div><div class="line">                table.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(*iter, <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                table[*iter]++;</div><div class="line">                <span class="keyword">if</span>(table[*iter] &gt; nums.size()/<span class="number">2</span>)&#123;</div><div class="line">                    <span class="keyword">return</span> (*iter);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　<font color="green">Accepted</font>，不过耗时：<strong>38ms</strong>，应该有更高效的方式。</p>
<ul>
<li>补充<ul>
<li>有一种算法：<a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/">A Linear Time Majority Vote Algorithm</a> ，其思路如下<blockquote>
<ol>
<li>Initialize index and count of majority element:  majorityElement = 0, count = 0</li>
<li>Loop for n = 0 to size – 1<br>　(c)If count == 0<br>　　majorityElement = a[n]<br>　　count = 1<br>　(b)If majorityElement == a[n]<br>　　count++<br>　(b)Else<br>　　count–;</li>
<li>Return majorityElement</li>
</ol>
</blockquote>
</li>
<li>代码实现如下，其时间复杂度只有：13 ms，大大降低了<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, n, majorityElement;</div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; numsSize; n++) &#123;</div><div class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</div><div class="line">      majorityElement = nums[n];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (nums[n] == majorityElement) &#123;</div><div class="line">      count++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">      count--;</div><div class="line">  &#125;</div><div class="line">    &#125;</div><div class="line">    count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; numsSize; n++)&#123;</div><div class="line">  <span class="keyword">if</span> (nums[n] == majorityElement) &#123;</div><div class="line">      count++;</div><div class="line">  &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (count &gt; numsSize/<span class="number">2</span>)&#123;</div><div class="line">  <span class="keyword">return</span> majorityElement;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>+ </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本周的 part 是 &lt;strong&gt;Divide and Conquer（分而治之）&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Digital Image Process</title>
    <link href="http://durant35.github.io/2017/02/04/cv_Digital-Image-Process(pg_2016)/"/>
    <id>http://durant35.github.io/2017/02/04/cv_Digital-Image-Process(pg_2016)/</id>
    <published>2017-02-04T09:53:31.000Z</published>
    <updated>2017-02-20T06:06:07.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Books：<a href="http://durant35.github.io/pdf/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(%E5%86%88%E8%90%A8%E9%9B%B7%E6%96%AF)%E4%B8%AD%E8%AF%91%E7%AC%AC%E4%B8%89%E7%89%88.pdf" alt="数字图像处理（冈萨雷斯）">数字图像处理（冈萨雷斯）</a><br>Codes：<a href="https://github.com/Durant35/Courses/tree/master/dip">https://github.com/Durant35/Courses/tree/master/dip</a></p>
</blockquote>
<h3 id="第2章-数字图像基础"><a href="#第2章-数字图像基础" class="headerlink" title="第2章 数字图像基础"></a>第2章 数字图像基础</h3><ul>
<li>取样和量化</li>
<li>空间和灰度分辨率<ul>
<li>空间分辨率：空间分辨率是图像在单位面积内像素的个数，表示了图像的空间细节分辨能力</li>
<li>灰度分辨率：灰度分辨率指的是在纯黑和纯白之间灰度级别的多少，指的是图像对灰度变化细节的分辨能力<a id="more"></a></li>
</ul>
</li>
<li>图像内插</li>
<li>像素间的一些基本关系<ul>
<li>$N_4(p)$；$N_8(p) = N_4(p) + N_D(p)$（对角像素） 4领域/8领域</li>
<li>距离度量 $D_e(p, q)$<ul>
<li>城市街区距离：$p(x, y)$；$q(s, t)$；$D_4(p, q) = |x-s| + |y-t|$</li>
<li>棋盘距离：$p(x, y)$；$q(s, t)$；$D_4(p, q) = |x-s| + |y-t|$</li>
<li>邻接性：</li>
<li>4 邻接；8邻接：二义性（像素到另一个像素有多条路径）</li>
<li>m 邻接：p是q的m邻接，首先p，q具有V中的数值；<br>-（i）p在$N_4(q)$中或<br>-（ii）p在$N_D(q)$且$N_4(p)∩N_4(q)$中没有V值（为空或不为空但没有V值）</li>
</ul>
</li>
<li>Path：从一个像素到另一个像素的一个像素序列<ul>
<li>4-path：一个路径上的相邻像素互为4邻接</li>
<li>8-path：一个路径上的相邻像素互为8-neighbors</li>
<li>闭合通路：一个有限区域的边界形成一条闭合通路</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第6章-彩色图像处理"><a href="#第6章-彩色图像处理" class="headerlink" title="第6章 彩色图像处理"></a>第6章 彩色图像处理</h3><ul>
<li>人眼对彩色的敏感程度要远远高于对灰度级别的敏感程度</li>
<li>CMY/CMYK（青色 深红色 黄色 黑色）$\begin{bmatrix} C\\ M \\Y \end{bmatrix} = \begin{bmatrix} 1 \\1 \\1\end{bmatrix} - \begin{bmatrix} R \\G \\B\end{bmatrix}$</li>
<li>HSI（色调 饱和度 强度）<ul>
<li>色调，饱和度和强度<ul>
<li>色调（Hue）：与光波的波长有关，它表示人的感官对不同颜色的感受</li>
<li>饱和度（Saturation）：表示颜色的纯度，纯光谱色是完全饱和的</li>
<li>强度（Intensity）：颜色的明亮程度</li>
</ul>
</li>
<li>强度轴：$(0, 0, 0) \rightarrow (1, 1, 1) $</li>
<li>色调平面<ul>
<li>$强度轴 + 彩色点 \Rightarrow 三角面$</li>
<li>$R(0°) \rightarrow G(120°) \rightarrow B(240°)$</li>
</ul>
</li>
<li>饱和度（纯度）<ul>
<li>纯色被白光稀释的程度</li>
<li>以与强度轴的距离为函数</li>
</ul>
</li>
<li>$RGB \rightarrow HSI$　RGB归一化到$[0, 1]$<ul>
<li>$ H[0, 360] = \begin{cases} \theta, &amp;B \leq G \cr 360 - \theta, &amp;B \gt G \end{cases} $，其中$ \theta = arccos\{\frac{\frac{1}{2}[(R-G)+(R-B])}{[(R-G)^2 + (R-B)(G-B)]^\frac{1}{2}} \}$</li>
<li>$ S[0, 1] = 1 - \frac{3}{R+G+B}[min(R, G, B)] $，纯色值为 1</li>
<li>$ I[0, 1] = \frac{1}{3}(R + G + B) $，黑色值为 0/白色值为 1</li>
</ul>
</li>
<li>$HSI \rightarrow RGB$　$H[0, 360]; S[0, 1]; I[0, 1]$<ul>
<li>$ 0° \leq H \le 120°，\begin{cases} B = I(1-S) \cr R = I[1 + \frac{ScosH}{cos(60° - H)}] \cr G = 3I - (R+B) \end{cases} $</li>
<li>$ 120° \leq H \le 240°，H = H - 120°，\begin{cases} R = I(1-S) \cr G = I[1 + \frac{ScosH}{cos(60° - H)}] \cr B = 3I - (R+G) \end{cases} $</li>
<li>$ 240° \leq H \le 360°，H = H - 240°，\begin{cases} G = I(1-S) \cr B = I[1 + \frac{ScosH}{cos(60° - H)}] \cr R = 3I - (G+B) \end{cases} $</li>
</ul>
</li>
<li>HSI 模型更符合人眼对颜色的解释，该模型可以在彩色图像中从携带的彩色信息中将色度信息（色调和饱和度）和强度信息的分量分开</li>
</ul>
</li>
<li>伪彩色：基于一种指定的规则对灰度值赋以颜色的处理<ul>
<li>一幅单色图像<center><img src="/img/CV/dip/PseudoColorProcessing_single.png" width="360px"/></center></li>
<li>多幅单色图像<center><img src="/img/CV/dip/PseudoColorProcessing_multiple.png" width="420px"/></center></li>
</ul>
</li>
<li>全彩色图像：全彩色传感器采集的图像<br>$ \begin{cases} 分别处理每一个向量 \cr 直接处理彩色像素 \end{cases} \Longleftarrow[条件] \begin{cases} ①处理必须对于向量和标量都可用 \cr ②对向量的每一个分量的操作对于其他分量必须是独立的 \end{cases} $</li>
<li>独立于设备的彩色模型：<code>CIEL*a*b*</code>（亮度；红减绿；绿减蓝）<ul>
<li>没有可直接显示的格式（需要变换到另外的彩色空间），但其色域包括整个可见光谱，并可以准确地表示任何显示设备，打印设备或输入设备的颜色</li>
<li>通常的彩色显设备是不能显示自然界所有颜色，仅限于该显示器的三原色所构成的三角形内，不能完全覆盖整个色度图</li>
</ul>
</li>
<li>色调范围（主调类型）：颜色强度的基本分布<ul>
<li>高主调：高（亮）强度处</li>
<li>中主调</li>
<li>低主调：低（暗）亮度处</li>
</ul>
</li>
<li>单独对彩色图像的分量进行直方图均衡通常是不明智的，应当均匀地展开这种彩色灰度，而保持彩色本身（即色调）不变$ \Rightarrow $ 转换到HSI彩色空间进行直方图处理</li>
<li>彩色图像的噪声内容在每个彩色通道中具有相同的特性，但噪声对不同的彩色通道所造成的影响不同</li>
<li>彩色图像平滑<ul>
<li>领域平均平滑可以在每个彩色平面的基础上执行，其结果与使用RGB彩色向量执行平均效果是相同的</li>
</ul>
</li>
<li>彩色图像锐化<ul>
<li>一个向量的拉普拉斯被定义为一个向量，其分量等于输入向量的各个标量分量的拉普拉斯</li>
</ul>
</li>
</ul>
<h3 id="第3章-灰度变换与空间滤波"><a href="#第3章-灰度变换与空间滤波" class="headerlink" title="第3章 灰度变换与空间滤波"></a>第3章 灰度变换与空间滤波</h3><ul>
<li>空间域 vs 变换域<ul>
<li>空间域：直接以图像中的像素操作为基础</li>
<li>空间域处理$ \begin{cases} 灰度变换：在图像的单个像素上操作，主要以对比度/阈值处理为目的（图像增强/图像分割） \cr 空间滤波：图像中每一个像素的领域处理 \end{cases} $</li>
<li>变换域：先把一幅图像变换到变换域，在变换域中进行处理，然后反变换把处理的结果返回到空间域</li>
</ul>
</li>
<li>点处理技术 vs 领域处理技术</li>
<li>图像增强<ul>
<li>对图像进行加工，使其结果对于特定的应用比原始图像更合适的一种处理</li>
<li>“特定”：面向问题，没有通用的“理论”；效果没办法量化</li>
</ul>
</li>
<li>基本的灰度变换函数<ul>
<li>图像反转<ul>
<li>$ S = L - 1 - r，（r \in [0, L-1]）$</li>
<li>增强嵌入在一幅图像的暗区域中的白色或灰色细节，特别是当黑色面积在尺寸上占主导地位时</li>
</ul>
</li>
<li>对数变换<ul>
<li>$ S = clog(1+r)，（c为常数，r \geq 0） $</li>
<li>扩展图像中的暗像素的值，同时压缩更高灰度级的值 $\Longleftrightarrow$ 反对数</li>
<li>压缩像素值变化较大的图像的动态范围，如傅里叶频谱$（0，10^6）\Longrightarrow$ 图像显示系统通常不能如实地再现如此大的范围</li>
</ul>
</li>
<li>幂律（伽马）变换<ul>
<li>$ S = cr^{\gamma}，（c，\gamma为正常数） $</li>
<li>参数性质<ul>
<li>$ \gamma \gt 1 $，（越大越）扩展高灰度级值（亮部的细节）</li>
<li>$ \gamma \lt 1 $，（越小越）扩展低灰度级值（暗部的细节）</li>
</ul>
</li>
<li>有些计算机系统内置部分伽马校正，因为计算机屏幕内部自带伽马校正，改变伽马值不仅会改变亮度，而且会改变彩色图像中的 R，G，B 比率<ul>
<li>整体偏暗的对比度增强</li>
<li>“冲淡”外观的灰度级压缩</li>
</ul>
</li>
</ul>
</li>
<li>分阶级性变换函数<ul>
<li>对比度拉伸：特定灰度级范围斜率变化大（低于 k 的灰度级更暗，高于 k 的灰度级更亮）</li>
<li>灰度级分层：特定灰度级范围的亮度进行不同赋值（例如二值化）</li>
<li>比特平面分层<ul>
<li>$ \begin{cases} 高阶比特：视觉上很重要的大部分数据 \cr 低阶比特：更精细的灰度细节 \end{cases} $ $\Longrightarrow$ 图像压缩：4个高阶比特平面将允许我们从可接受的细节来重建原图像</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>直方图处理<ul>
<li>概述<ul>
<li>灰度级范围为$[0, L-1]$的数字图像的直方图：$h(r_k) = n_k$，$r_k$ 是第 k 级灰度值，$n_k$ 是 $r_k$ 的像素个数</li>
<li>归一化：$p(r_k) = \frac{n_k}{MN}$，灰度级 $r_k$ 在图像中出现的概率</li>
<li>图像的直方图反映了图像的明暗程度以及对比强度，对比度适中的图像通常具有均匀分布的直方图<ul>
<li>低对比度图像具有较窄的直方图，且集中于灰度级的中部；高对比度图像中直方图的分量覆盖了很宽的灰度级范围，而且像素的分布没有太不均匀</li>
<li>若一幅图像的像素倾向于占据整个可能灰度级并且分布均匀，则该图像会有高对比度的外观并展示灰色调的较大变化</li>
</ul>
</li>
</ul>
</li>
<li>直方图均衡化<ul>
<li>直方图均衡化变换（直方图线性变换）<br>　　$ S_k = T(r_k) = (L-1) \sum_{j=0}^k p_r(r_j) = \frac{L-1}{MN}  \sum_{j=0}^k n_j，k=0, 1, 2, 3, …, L-1$</li>
<li>“自动的”：因为图像有相同的内容，直方图均衡导致的对比度增强足以补偿图像在视觉上难以区分灰度级的差别</li>
</ul>
</li>
<li>直方图匹配（直方图规定化）<ul>
<li>Histogram Matching（Specification）：是指对一副图像进行变换，使其直方图与另一幅图像的直方图或特定函数形式的直方图匹配；是用户处理图像后，产生特殊直方图的方法</li>
<li>步骤<ol>
<li>计算直方图 $p_r(r)$，获取直方图均衡变换 $S_k$，把 $S_k$ 四舍五入到 $[0, L-1]$ 范围内的整数</li>
<li>计算变换函数：$G(z_q) = (L-1) \sum_{i=0}^{q} p_z(z_i)$，其中 $q=0, 1, 2, 3, …, L-1$，$p_z(z_i)$ 是规定的直方图</li>
<li>把 G 的值四舍五入到 $[0, L-1]$ 范围整数，存储在查找表中</li>
<li>满足最接近 $S_k$ 的 $G(z_q)$ 的 $z_q$ 值即为直方图规定化后的像素值（当满足给定的 $S_k$ 的 $z_q$ 值多于一个时，选择最小的 $z_q$ 值）</li>
</ol>
</li>
</ul>
</li>
<li>局部直方图均衡化：增强小区域的细节</li>
<li>在图像增强中使用直方图统计<ul>
<li>统计量<ul>
<li>平均灰度：$m = \sum_{i=0}^{L-1} r_i p(r_i)$ 或（取样均值）$m = \frac{1}{MN} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y)$</li>
<li>灰度方差：$\mu_2(r) = \sum_{i=0}^{L-1} (r_i - m)^2 p(r_i)$ 或（取样方差）$\sigma^2 = \frac{1}{MN} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} [f(x, y) - m]^2$</li>
<li>n阶矩：$\mu_{n}(r) = \sum_{i=0}^{L-1} (r_i - m)^n p(r_i)$</li>
</ul>
</li>
<li>根据统计量判断<ul>
<li>判断一个区域在点 $(x, y)$ 是暗还是亮：$m_{S_{xy}} \leq km_G$，其中 $m_{S_{xy}}$ 为局部平均灰度，$m_G$ 为全局均值</li>
<li>判断一个区域的对比度是否可作为低对比度区域：$k_1 \sigma_G \leq \sigma_{S_{xy}} \leq k_2 \sigma_G$（标准差为 0 的区域需排除）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>空间滤波（线性空间滤波器；非线性空间滤波器）<ul>
<li>一个邻域（典型的是一个较小的矩形；奇数尺寸，最小 $3x3$）</li>
<li>对该邻域包围的图像像素执行的预定义操作<ul>
<li>一个 mxn 的滤波器 $\omega(x, y), m=2a+1, n=2b+1$</li>
<li>操作：$g(x, y) = \sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x+s, y+t) $（一般空间滤波器旋转180°后保持不变）</li>
</ul>
</li>
</ul>
</li>
<li>相关 vs 卷积<ul>
<li>1D<ul>
<li>要求：n 必须满足 $g(n)$ 完全滑过 $f(n)$</li>
<li>卷积需要将 $g(n)$ 旋转180°（怎么补零？）$ \Longleftarrow \begin{cases} 卷积：(f \otimes g)[n] = \sum_{m=0}^{N-1} f(m)g(n-m)  \cr 相关：(f \circ g)[n] = \sum_{m=0}^{N-1} f(m)g(n+m) \end{cases} $</li>
</ul>
</li>
<li>2D<ul>
<li>对所有位移变量 x 和 y 求值，以便 $\omega$ 的所有元素访问 $f$ 的每一个像素</li>
<li>$ \Longrightarrow \begin{cases}  卷积：\omega (x, y) \otimes f(x, y) =  \sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x-s, y-t) \cr  相关：\omega (x, y) \circ f(x, y) =  \sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x+s, y+t)  \end{cases} $</li>
</ul>
</li>
</ul>
</li>
<li>平滑空间滤波器：用于模糊处理 $\Rightarrow$ 降低噪声<ul>
<li>平滑线性滤波器（均值滤波器）：响应是包含在滤波器模板邻域内的像素的简单平均值</li>
<li>降低了图像灰度的“尖锐”变化，比如典型的随机噪声就由灰度级急剧变化组成</li>
<li>图像边缘也是由图像灰度尖锐变化带来的特性 $\Rightarrow$ 边缘模糊的负面效应</li>
</ul>
</li>
<li>盒状滤波器 vs 加权平均<ul>
<li>随着距中心点的距离的增加而减小系数值的加权策略 $\Rightarrow$ 降低模糊<br>　　$g(x, y) = \frac{\sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)f(x+s, y+t)}{\sum_{s=-a}^a \sum_{t=-b}^b \omega(s, t)}$</li>
<li>空间均值处理：模糊图像，较小物体的灰度与背景混在一起，较大物体变得像“斑点”而易于检测</li>
</ul>
</li>
<li>统计排序（非线性）滤波器<ul>
<li>响应以滤波器包围的区域中所包含像素的排序为基础，使用统计排序结果决定的值代替中心像素的值</li>
<li>中值滤波器 最大值滤波器</li>
</ul>
</li>
<li>锐化空间滤波器：突出灰度的过渡部分<ul>
<li>$ \begin{cases}  图像模糊：通过在空间域用像素邻域平均法实现 \Rightarrow 积分 \cr  锐化可以用空间微分来实现 \Rightarrow 增强边缘和其它突变（如噪声），而削弱灰度变化缓慢的区域 \end{cases} $<center><img src="/img/CV/dip/Grayscale_changes.png" width="540px"/></center></li>
<li>微分<ul>
<li>一阶微分：$\frac{\partial f}{\partial x} = f(x+1) - f(x)$，用到下一个点，“预测未来”</li>
<li>二阶微分：$\frac{\partial^2 f}{\partial^2 x} = f(x+1) + f(x-1) - 2f(x)$</li>
<li>数字图像中的边缘在灰度上常常类似于斜坡过渡，一阶微分会产生较粗的边缘，二阶微分产生由零分开的一个像素宽的双边缘。二阶微分在增强细节方面要比一阶微分好的多，适合锐化图像</li>
</ul>
</li>
<li>拉普拉斯算子：$\nabla^2 f = \frac{\partial^2 f}{\partial^2 x} + \frac{\partial^2 f}{\partial^2 y}$<ul>
<li>是一个各向同性滤波器：响应与作用的图像的突变方向无关；将原图像旋转后进行滤波处理给出的结果与先滤波再旋转的结果相同</li>
<li>$\nabla^2 f(x, y) = f(x+1, y) + f(x-1, y) + f(x, y+1) + f(x, y-1) - 4f(x, y)$</li>
<li>上面公式只是四种算子中的一个<br>　　$\begin{bmatrix} 0 &amp; 1 &amp; 0 \\  1 &amp; -4 &amp; 1 \\  0 &amp; 1 &amp; 0 \end{bmatrix}$ $\begin{bmatrix} 1 &amp; 1 &amp; 1 \\  1 &amp; -8 &amp; 1 \\  1 &amp; 1 &amp; 1 \end{bmatrix}$ $\begin{bmatrix} 0 &amp; -1 &amp; 0 \\  -1 &amp; 4 &amp; -1 \\  0 &amp; -1 &amp; 0 \end{bmatrix}$ $\begin{bmatrix} -1 &amp; -1 &amp; -1 \\  -1 &amp; 8 &amp; -1 \\  -1 &amp; -1 &amp; -1 \end{bmatrix}$</li>
<li>输入图像 $f(x, y)$，锐化后的图像 $g(x, y)$：$g(x, y) = f(x, y) + c[\nabla^2 f(x, y)]$，c 的符号与中心系数 $[f(x, y)]$ 的符号相反<ol>
<li>任意阶微分都是线性操作，$\nabla^2 f(x, y)$ 也是一个线性算子</li>
<li>将原图像和拉普拉斯图像叠加，可以复原背景特性并保持拉普拉斯锐化处理的结果（强调灰度的突变，并不强调灰度缓慢变化的区域）</li>
<li>通过拉普拉斯变换增强了图像中灰度突变处的对比度，使图像中的细节部分得到了增强，并良好地保留了图像的基本色调</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>非锐化掩蔽<ul>
<li>从原图像中减去一幅非锐化（平滑/模糊过的）图像 $\bar{f}(x, y) \leftarrow$ 高斯滤波器模糊</li>
<li>非锐化模板：$g_{mask}(x, y) = f(x, y) - \bar{f}(x, y)$</li>
<li>$g(x, y) =  f(x, y) + k * g_{mask}(x, y)$<ul>
<li>$k = 1$：非锐化掩蔽</li>
<li>$k \gt 1$：高提升滤波</li>
</ul>
</li>
</ul>
</li>
<li>梯度与 Sobel 算子<ul>
<li>梯度<ul>
<li>$\nabla f = grad(f) = \begin{bmatrix} \frac{\partial f}{\partial x} \\ \frac{\partial f}{\partial y} \end{bmatrix}$</li>
<li>$\nabla f $ 为向量，幅度值 $M(x, y) = mag(\nabla f) = \sqrt{g_x^2 + g_y^2}$，不是线性算子，因为做了平方和平方根操作</li>
<li>$\Longrightarrow M(x, y) ≈|g_x| + |g_y|$，仍保留灰度的相对变化，虽然通常丢失了方向性</li>
</ul>
</li>
<li>Sobel 算子<ul>
<li>$M(x, y) ≈|(z_7 + 2z_8 + z_9) - (z_1 + 2z_2 + z_3)| + |(z_3 + 2z_6 + z_9) - (z_1 + 2z_4 + z_7)|$</li>
<li>矩阵形式：$\begin{bmatrix} z_1 &amp; z_2 &amp; z_3 \\  z_4 &amp; z_5 &amp; z_6 \\  z_7 &amp; z_8 &amp; z_9 \end{bmatrix}$ $\begin{bmatrix} -1 &amp; -2 &amp; -1 \\  0 &amp; 0 &amp; 0 \\  1 &amp; 2 &amp; 1 \end{bmatrix}$ $\begin{bmatrix} -1 &amp; 0 &amp; 1 \\  -2 &amp; 0 &amp; 2 \\  -1 &amp; 0 &amp; 1 \end{bmatrix}$</li>
</ul>
</li>
</ul>
</li>
<li>应用多种互补的图像增强技术<ol>
<li><font color="green">拉普拉斯操作</font>作为一种二阶微分算子在图像细节增强方面，它是最好的，但这会导致产生比梯度操作更多的噪声</li>
<li><font color="green">梯度操作（Sobel 算子）</font>对噪声和小细节响应要比拉普拉斯变换操作的响应弱，而且可以通过<font color="green">均值滤波器</font>进行平滑而进一步降低</li>
<li>拉普拉斯图像与平滑处理后的梯度图像相乘，<font color="green">乘积</font>会保留灰度变化强烈区域的细节，同时降低灰度变化相对平坦区域的噪声</li>
<li>具有重要边缘内容的梯度图像，边缘要比拉普拉斯图像突出，乘积的关键目的：强边缘的优势和可见噪声的减少</li>
<li>锐化/平滑过程从感知方法上没有影响图像灰度的动态变化，通过<font color="green">幂律变换</font>可以增大锐化后图像的动态范围</li>
</ol>
</li>
</ul>
<h3 id="第4章-频率域滤波"><a href="#第4章-频率域滤波" class="headerlink" title="第4章 频率域滤波"></a>第4章 频率域滤波</h3><ul>
<li>一维连续<ul>
<li>傅里叶变换对<br>$ F(\mu) = \zeta\{f(t)\} = \int_{-\infty}^{\infty} f(t) e^{-j2\pi \mu t}\, dt$<br>$ f(t) = \zeta^{-1}\{F(\mu)\} = \int_{-\infty}^{\infty} F(\mu) e^{j2\pi \mu t}\, d\mu$</li>
<li>卷积<br>$ f(t) \bigotimes h(t) = \int_{-\infty}^{\infty} f(\tau) h(t- \tau) \, d\tau = F(\mu)H(\mu) = \sum_{n=-\infty}^{\infty}f(n\Delta T)h(t - n\Delta T)$</li>
</ul>
</li>
<li>一维离散<ul>
<li>$f(t)$ 的 M 个样本组成集合 $\{f_n\} = f(x)$</li>
<li>$M$ 个复数离散值的傅里叶变换样本集合 ${f_m} = F(\mu)$<br>$ F(\mu) = \sum_{x=0}^{M-1} f(x) e^{-j2\pi \frac{\mu x}{M} }，\mu = 0, 1, 2, …, M-1$<br>$ f(x) = \frac{1}{M}\sum_{\mu =0}^{M-1} F(\mu) e^{j2\pi \frac{\mu x}{M} }，x = 0, 1, 2, …, M-1$</li>
</ul>
</li>
<li>二维<ul>
<li>连续<br>$ F(\mu, \nu) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} f(x, y) e^{-j2\pi(\mu t + \nu z)}\, dt\, dz$<br>$ f(t, z) = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty} F(\mu, \nu) e^{j2\pi(\mu t + \nu z)}\, d\mu \, d\nu$</li>
<li>离散<br>$ F(\mu, \nu) = \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x, y) e^{-j2\pi(\frac{\mu x}{M} + \frac{\nu y}{N})}$<br>$ f(x, y) = \frac{1}{MN}\sum_{\mu =0}^{M-1} \sum_{\nu =0}^{N-1} F(\mu, \nu) e^{j2\pi(\frac{\mu x}{M} + \frac{\nu y}{N})}$</li>
</ul>
</li>
<li>使用DFT时，图像和滤波器的大小必须相同<ol>
<li>$MxN$ 的图像 $f$</li>
<li>进行 $PxQ$ 填充成 $f_p$（$P\geq2M-1, Q\geq2N-1$）</li>
<li>$(-1)^{x+y}$ 乘以 $f_p$</li>
<li>$f_p$ 的傅里叶变换（DFT）生成 $F_p$</li>
<li>滤波器扩容成 $PxQ$，关于中心对称化后生成 $H(u, v)$</li>
<li>$H(u, v)F_p \Rightarrow G(u, v)$</li>
<li>计算 $G(u, v)$ 的 IDFT，得到 $\zeta^{-1}[G(u, v)]$</li>
<li>处理后得到图像 $g_p = \{ real[\zeta^{-1}[G(u, v)]] \}(-1)^{x+y}$</li>
<li>裁剪 $g_p$ 的前 M 行和前 N 列得到最终的结果</li>
</ol>
</li>
<li>空间模板 [转换]$\Longrightarrow$ 频率域滤波器 $H(u, v)$<ol>
<li>$h(x, y)$ 扩充成 $h_p(x, y)$</li>
<li>$(-1)^{x+y}$ 乘以 $h_p(x, y)$ 以便频率域滤波器“中心化”</li>
<li>计算上述结果的 DFT</li>
<li>滤波器 $H(u, v)$ 必须是纯虚函数，将得到的 DFT 实部置零</li>
<li>$H(u, v)$ 等于 $(-1)^{x+y}$ 乘以上述结果，隐含着 $h(x, y)$ 被移到 $h_p(x, y)$ 的中心</li>
</ol>
</li>
<li>傅里叶频谱<ul>
<li>傅里叶频谱中心点对应于空间域的平均灰度或背景灰度</li>
<li>从中心点离开，低频信息对应慢变化的分量，如大体轮廓，背景等平滑部分</li>
<li>进一步离开中心点，较高频率对应变化越来越快的灰度级，如边缘，细节，噪声</li>
</ul>
</li>
</ul>
<h3 id="第5章-图像复原与重建"><a href="#第5章-图像复原与重建" class="headerlink" title="第5章 图像复原与重建"></a>第5章 图像复原与重建</h3><ul>
<li>图像退化/复原过程的模型<ul>
<li>$G(u, v) = H(u, v)F(u, v) + N(u, v)$<center><img src="/img/CV/dip/restoration_model.png" width="580px"/></center></li>
</ul>
</li>
<li>图像增强 vs 图像复原<ul>
<li>图像增强主要是一个主观过程，首要目标是处理图像，使其比原始图像更适合于特定应用，如对比度增强</li>
<li>图像复原大部分过程是一个客观过程，利用退化现象的先验知识来重建或复原被退化的原始图像</li>
</ul>
</li>
<li>噪声模型<ul>
<li>高斯噪声<br><center><img src="/img/CV/dip/Noise_Gaussian.png" width="780px"/></center><ul>
<li>去噪：均值，中点</li>
</ul>
</li>
<li>瑞利噪声<br><center><img src="/img/CV/dip/Noise_Rayleigh.png" width="620px"/></center><ul>
<li>近似歪斜，比较胖</li>
<li>去噪：</li>
</ul>
</li>
<li>伽马噪声<br><center><img src="/img/CV/dip/Noise_Gamma.png" width="640px"/></center><ul>
<li>比较尖</li>
<li>去噪：</li>
</ul>
</li>
<li>指数噪声<br><center><img src="/img/CV/dip/Noise_Exp.png" width="580px"/></center><ul>
<li>去噪：</li>
</ul>
</li>
<li>均匀噪声<br><center><img src="/img/CV/dip/Noise_Uniform.png" width="580px"/></center><ul>
<li>去噪：中点</li>
</ul>
</li>
<li>脉冲噪声<br><center><img src="/img/CV/dip/Noise_Impulse.png" width="540px"/></center><ul>
<li>去噪：谐波均值，逆谐波均值，中值，最大值/最小值</li>
</ul>
</li>
<li>周期噪声<ul>
<li>傅里叶共轭点，近似圆</li>
<li>去噪：低通，带通……</li>
</ul>
</li>
<li>如何获取$ N(u, v) $？<ul>
<li>在图像的平坦区域取一小块自图像做直方图，与已有的噪声模型作对比</li>
</ul>
</li>
</ul>
</li>
<li>常见滤波器降噪情况<ul>
<li>高斯或者均匀随机噪声 $ \Longleftarrow  \begin{cases} 均值滤波平滑一幅图像中的局部变化，虽然模糊了结果，但降低了噪声 \cr 几何均值丢失的图像细节更少 \end{cases} $ </li>
<li>谐波均值对盐噪声较好，不适用于椒噪声，善于处理像高斯噪声</li>
<li>逆谐波均值，$ Q \gt 0 $，椒噪声；$ Q \lt 0 $，盐噪声；$ Q = 0 $为算数均值滤波</li>
<li>中值滤波器：比相同尺寸的线性平滑滤波器引起的模糊更小，在存在单极或双极脉冲噪声（椒噪声 and/or 盐噪声）的情况下，尤其有效</li>
<li>最大值降椒噪声，最小值降盐噪声</li>
<li>中点滤波器对于随机分布噪声工作得最好（高斯/均匀）</li>
</ul>
</li>
<li>高斯噪声和椒盐噪声混合的情况<ol>
<li>修正的阿尔法均值滤波器，降噪方面更好</li>
<li>算术均值和几何均值由于脉冲噪声的存在并没有起到良好的作用</li>
<li>使用中值滤波器重复地进行处理$\Longrightarrow$会使得图像变模糊，细节损失<br>$\Longrightarrow$ 自适应中值滤波器：<br><center><img src="/img/CV/dip/AdaptiveMidianFilter.png" width="580px"/></center><ul>
<li>A层确保$Z_{med}（Z_{min} \lt Z_{med} \lt Z_{max}）$ 不是脉冲，B层确保$Z_{xy}（Z_{min} \lt Z_{xy} \lt Z_{max}）$不是脉冲</li>
<li>动态增大窗口</li>
<li>不改变“中心灰度级”，减少图像中的失真</li>
<li>去除椒盐噪声（脉冲噪声），平滑其他非脉冲噪声，并减少诸如物体边界细化或粗化等失真</li>
</ul>
</li>
<li>自适应局部降噪降噪：$\hat{f}(x, y) = g(x, y) \frac{ \sigma^2_{\eta} }{ \sigma^2_L }[g(x, y) - m_L]$<ul>
<li>参数说明<ul>
<li>滤波器作用于局部区域$S_{xy}$</li>
<li>$\sigma^2_{\eta}$ ：污染 $f(x, y)$ 以形成 $g(x, y)$ 的噪声的方差</li>
<li>$m_L$ ：$S_{xy}$中像素的局部均值</li>
<li>$\sigma^2_L$ ：$S_{xy}$中像素的局部方差</li>
</ul>
</li>
<li>计算结果为局部均值或保留原始像素</li>
<li>高局部方差与边缘相关，因此能够保护边缘</li>
</ul>
</li>
</ol>
</li>
<li>逆滤波存在的问题<br>$$ \hat{F}(u, v) = F(u, v) + \frac{N(u, v)}{H(u, v)} $$<ul>
<li>$H(u, v)$ 为零或为非常小的值</li>
<li>解决问题的一种方法是限制滤波的频率，使其接近于频谱原点</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Books：&lt;a href=&quot;http://durant35.github.io/pdf/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86(%E5%86%88%E8%90%A8%E9%9B%B7%E6%96%AF)%E4%B8%AD%E8%AF%91%E7%AC%AC%E4%B8%89%E7%89%88.pdf&quot; alt=&quot;数字图像处理（冈萨雷斯）&quot;&gt;数字图像处理（冈萨雷斯）&lt;/a&gt;&lt;br&gt;Codes：&lt;a href=&quot;https://github.com/Durant35/Courses/tree/master/dip&quot;&gt;https://github.com/Durant35/Courses/tree/master/dip&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;第2章-数字图像基础&quot;&gt;&lt;a href=&quot;#第2章-数字图像基础&quot; class=&quot;headerlink&quot; title=&quot;第2章 数字图像基础&quot;&gt;&lt;/a&gt;第2章 数字图像基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;取样和量化&lt;/li&gt;
&lt;li&gt;空间和灰度分辨率&lt;ul&gt;
&lt;li&gt;空间分辨率：空间分辨率是图像在单位面积内像素的个数，表示了图像的空间细节分辨能力&lt;/li&gt;
&lt;li&gt;灰度分辨率：灰度分辨率指的是在纯黑和纯白之间灰度级别的多少，指的是图像对灰度变化细节的分辨能力
    
    </summary>
    
      <category term="CV" scheme="http://durant35.github.io/categories/CV/"/>
    
      <category term="dip" scheme="http://durant35.github.io/categories/CV/dip/"/>
    
    
      <category term="CV" scheme="http://durant35.github.io/tags/CV/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令小纸条</title>
    <link href="http://durant35.github.io/2017/02/04/linux_Linux%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BA%B8%E6%9D%A1/"/>
    <id>http://durant35.github.io/2017/02/04/linux_Linux命令小纸条/</id>
    <published>2017-02-04T07:20:59.000Z</published>
    <updated>2017-03-20T09:13:00.275Z</updated>
    
    <content type="html"><![CDATA[<h3 id="压缩-解压"><a href="#压缩-解压" class="headerlink" title="压缩/解压"></a>压缩/解压</h3><ul>
<li><strong>tar</strong> 压缩</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -zcvf dst.tar.gz /src-dir</div></pre></td></tr></table></figure>
<ul>
<li><strong>tar</strong> 解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar -xvf src.tar.gz</div></pre></td></tr></table></figure>
<ul>
<li><strong>zip</strong> 压缩<a id="more"></a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ zip -r dst.zip /src-dir</div></pre></td></tr></table></figure>
<ul>
<li><strong>zip</strong> 解压</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ unzip src.zip <span class="_">-d</span> .</div></pre></td></tr></table></figure>
<h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><ul>
<li><strong>scp</strong> 上传</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp  -P port-number -rp host-path-src user@remote:/path-dst</div></pre></td></tr></table></figure>
<ul>
<li><strong>scp</strong> 下载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ scp -r user@remote:/path-src host-path-dst</div></pre></td></tr></table></figure>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ul>
<li>查看进程信息（如：<strong>PID</strong>）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ps -aux [| grep key-word]</div></pre></td></tr></table></figure>
<ul>
<li>查看 线程-资源 使用情况</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ top -c <span class="_">-d</span> 1</div></pre></td></tr></table></figure>
<h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><ul>
<li><strong>端口</strong> 占用情况</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ netstat -anp [| grep target-port]</div></pre></td></tr></table></figure>
<ul>
<li>查看监听端口<center><img src="/img/programPearls/linux/netstat.jpg" alt="netstat" width="720px"/></center>

</li>
</ul>
<h3 id="挂载-解挂"><a href="#挂载-解挂" class="headerlink" title="挂载/解挂"></a>挂载/解挂</h3><ul>
<li>解挂</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo umount <span class="_">-l</span> mount-dir</div></pre></td></tr></table></figure>
<ul>
<li>挂载</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看挂载设备 /dev/sd?</span></div><div class="line">$ sudo fdisk <span class="_">-l</span></div><div class="line"><span class="comment"># 需要时创建挂载点</span></div><div class="line">$ mkdir mount-point-dir</div><div class="line"><span class="comment"># 挂载设备</span></div><div class="line">$ sudo mount /dev/sd? mount-point-dir</div></pre></td></tr></table></figure>
<h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><ul>
<li>文件名查找</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find <span class="string">"name-string"</span> find-path</div></pre></td></tr></table></figure>
<ul>
<li>文件内容查找</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ grep -r -i <span class="string">"content-string"</span> find-path</div></pre></td></tr></table></figure>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><ul>
<li>批量重命名（<strong>*.cpp</strong>全部变成<strong>*.c</strong>）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># "\" 指代相同内容</span></div><div class="line">$ rename -v s/\.cpp/\.c/ *</div></pre></td></tr></table></figure>
<h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul>
<li>内核版本信息</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ uname -r</div></pre></td></tr></table></figure>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><ul>
<li>查看文件权限信息（注意文件夹和文件的区别）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ls -al</div><div class="line">total 36</div><div class="line">drwxrwxr-x 8 gary gary 4096 3月  17 15:19 .</div><div class="line">drwxrwxr-x 4 gary gary 4096 3月   9 14:13 ..</div><div class="line">drwxrwxr-x 3 gary gary 4096 3月  19 14:38 carControl</div><div class="line">-rw-rw-rw- 1 gary gary 1029 3月   9 14:15 emergencyBrake.ino</div><div class="line">[   权限 ][link][拥有者][群组][文件容量][修改日期][    文件名     ]</div></pre></td></tr></table></figure>
<p><center><img src="/img/programPearls/linux/file_permission.png" alt="file permission" width="540px"/></center></p>
<ul>
<li>修改文件<code>rwx</code>权限，常见的有：777（所有权限）；666（可读写）；用户可执行</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo chmod 777 [-R] file-name</div><div class="line">$ sudo chmod u+x file-name</div></pre></td></tr></table></figure>
<ul>
<li>文件拥有者:群组</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo chown owner:group file-name</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;压缩-解压&quot;&gt;&lt;a href=&quot;#压缩-解压&quot; class=&quot;headerlink&quot; title=&quot;压缩/解压&quot;&gt;&lt;/a&gt;压缩/解压&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tar&lt;/strong&gt; 压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ tar -zcvf dst.tar.gz /src-dir&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;tar&lt;/strong&gt; 解压&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ tar -xvf src.tar.gz&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;zip&lt;/strong&gt; 压缩
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Linux" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Linux/"/>
    
    
      <category term="CMD" scheme="http://durant35.github.io/tags/CMD/"/>
    
      <category term="Linux" scheme="http://durant35.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>vim几步走</title>
    <link href="http://durant35.github.io/2017/02/04/tool_vim%E5%87%A0%E6%AD%A5%E8%B5%B0/"/>
    <id>http://durant35.github.io/2017/02/04/tool_vim几步走/</id>
    <published>2017-02-04T06:07:18.000Z</published>
    <updated>2017-03-31T07:14:06.624Z</updated>
    
    <content type="html"><![CDATA[<p>　通过 <strong>sudo apt-get install vim</strong> 即可安装 <strong>vim</strong>，也能通过 <a href="https://github.com/amix/vimrc">vimrc</a> 之类安装大神们的各种自适配的高级 <strong>vim</strong>。<br>　本文旨在记录开发过程中用过的 <strong>vim</strong> 操作。　　<br><a id="more"></a></p>
<blockquote>
<p>Reference: <a href="http://www.cnblogs.com/wsine/p/5517005.html">Wsnie’s Linux之Vim学习</a></p>
</blockquote>
<h3 id="一般模式下的常见操作"><a href="#一般模式下的常见操作" class="headerlink" title="一般模式下的常见操作"></a>一般模式下的常见操作</h3><ul>
<li>光标移动</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">j或down方向键</td>
<td style="text-align:center">向下移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">k或up方向键</td>
<td style="text-align:center">向上移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">h或left方向键</td>
<td style="text-align:center">向左移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">l或right方向键</td>
<td style="text-align:center">向右移动一个字符</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+f或PageUp键</td>
<td style="text-align:center">屏幕向前移动一页</td>
</tr>
<tr>
<td style="text-align:center">Ctrl+b或PageDown键</td>
<td style="text-align:center">屏幕向后移动一页</td>
</tr>
<tr>
<td style="text-align:center">w</td>
<td style="text-align:center">向后移动一个词</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">向前移动一个词</td>
</tr>
<tr>
<td style="text-align:center">e</td>
<td style="text-align:center">向后移动一个词到词尾</td>
</tr>
<tr>
<td style="text-align:center">ge</td>
<td style="text-align:center">向前移动一个词到词头</td>
</tr>
<tr>
<td style="text-align:center">g_</td>
<td style="text-align:center">到本行最后一个不是blank字符的位置</td>
</tr>
<tr>
<td style="text-align:center">0或Shift+6</td>
<td style="text-align:center">移动到行首</td>
</tr>
<tr>
<td style="text-align:center">$或Shift+4</td>
<td style="text-align:center">移动到行尾</td>
</tr>
<tr>
<td style="text-align:center">gg</td>
<td style="text-align:center">移动到首行</td>
</tr>
<tr>
<td style="text-align:center">G</td>
<td style="text-align:center">移动到尾行</td>
</tr>
<tr>
<td style="text-align:center">nG</td>
<td style="text-align:center">移动到第n行</td>
</tr>
</tbody>
</table>
<ul>
<li>增删改查</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">向后删除一个字符</td>
</tr>
<tr>
<td style="text-align:center">X</td>
<td style="text-align:center">向前删除一个字符</td>
</tr>
<tr>
<td style="text-align:center">dd</td>
<td style="text-align:center">删除/剪切当前所在的行</td>
</tr>
<tr>
<td style="text-align:center">ndd</td>
<td style="text-align:center">删除/剪切当前行及其之后的共n行</td>
</tr>
<tr>
<td style="text-align:center">dw</td>
<td style="text-align:center">向后删除一个词</td>
</tr>
<tr>
<td style="text-align:center">i</td>
<td style="text-align:center">在当前字符前插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">在当前字符后插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">I</td>
<td style="text-align:center">在当前行的行首插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">在当前行的行尾插入，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">在当前行的下一行插入新的一行，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">O</td>
<td style="text-align:center">在当前行的上一行插入新的一行，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">r</td>
<td style="text-align:center">再输入一个字符，向后替换一个字符</td>
</tr>
<tr>
<td style="text-align:center">R</td>
<td style="text-align:center">连续输入字符，向后连续替换字符，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">yy</td>
<td style="text-align:center">复制当前行</td>
</tr>
<tr>
<td style="text-align:center">nyy</td>
<td style="text-align:center">在当前行开始，向下复制n行</td>
</tr>
<tr>
<td style="text-align:center">np</td>
<td style="text-align:center">在当前行开始，向下粘贴已经复制的内容n次</td>
</tr>
<tr>
<td style="text-align:center">P</td>
<td style="text-align:center">在当前行开始，向上粘贴已经复制的内容</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:center">进入选定模式，移动光标选定字符，可复制剪切删除，按esc退出</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">还原上一步的操作</td>
</tr>
</tbody>
</table>
<h3 id="命令模式下的常见操作"><a href="#命令模式下的常见操作" class="headerlink" title="命令模式下的常见操作"></a>命令模式下的常见操作</h3><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/word</td>
<td style="text-align:center">向后搜索字符串word，按n继续搜索</td>
</tr>
<tr>
<td style="text-align:center">?word</td>
<td style="text-align:center">向前搜索字符串word，按n继续搜索</td>
</tr>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">保存文本</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">退出</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">放弃修改，强制退出</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">保存并退出</td>
</tr>
</tbody>
</table>
<h3 id="我的典型操作"><a href="#我的典型操作" class="headerlink" title="我的典型操作"></a>我的典型操作</h3><table>
<thead>
<tr>
<th style="text-align:center">按键</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0y$</td>
<td style="text-align:center">拷贝当前行</td>
</tr>
<tr>
<td style="text-align:center">ye</td>
<td style="text-align:center">从当前位置拷贝到本单词的最后一个字符</td>
</tr>
<tr>
<td style="text-align:center">gU</td>
<td style="text-align:center">变大写</td>
</tr>
<tr>
<td style="text-align:center">gu</td>
<td style="text-align:center">变小写</td>
</tr>
<tr>
<td style="text-align:center">在 Insert 模式下，你可以输入一个词的开头，按如下组合键，ctrl+x ctrl+n 或者 ctrl+x ctrl+p</td>
<td style="text-align:center">自动补齐</td>
</tr>
<tr>
<td style="text-align:center">v<strong>→</strong>d/y<strong>→</strong>p</td>
<td style="text-align:center">剪切/复制粘贴</td>
</tr>
</tbody>
</table>
<h3 id="第三方参考"><a href="#第三方参考" class="headerlink" title="第三方参考"></a>第三方参考</h3><ul>
<li>RiHui-Song’s Blog 的 <a href="https://rh-song.github.io/2016/07/15/vim/#more">本文意在记录vim的使用以及相关的配置</a><ul>
<li>在linux下vim中文出现乱码问题</li>
<li>vim：MarkDown preview</li>
<li>vim添加markdown语法高亮</li>
</ul>
</li>
<li><a href="http://coolshell.cn/articles/5426.html">简明 VIM 练级攻略</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　通过 &lt;strong&gt;sudo apt-get install vim&lt;/strong&gt; 即可安装 &lt;strong&gt;vim&lt;/strong&gt;，也能通过 &lt;a href=&quot;https://github.com/amix/vimrc&quot;&gt;vimrc&lt;/a&gt; 之类安装大神们的各种自适配的高级 &lt;strong&gt;vim&lt;/strong&gt;。&lt;br&gt;　本文旨在记录开发过程中用过的 &lt;strong&gt;vim&lt;/strong&gt; 操作。　　&lt;br&gt;
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="小工具" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vim" scheme="http://durant35.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Summer-trainning in July, 2016</title>
    <link href="http://durant35.github.io/2017/02/04/TACourses_Summer-trainning-in-July,2016/"/>
    <id>http://durant35.github.io/2017/02/04/TACourses_Summer-trainning-in-July,2016/</id>
    <published>2017-02-04T03:21:01.000Z</published>
    <updated>2017-02-04T06:05:48.070Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>摘自 <a href="https://rh-song.github.io/2016/07/18/Summer-training/#more">RiHui-Song’s Blog：Summer-training</a></p>
</blockquote>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>　本文主要记录SMIE最后一次初级实训学习的主要内容。包括了大概是三个阶段：</p>
<ul>
<li>准备阶段：学习测量仪器，回顾C语言编程；</li>
<li>熟悉阶段：在FPGA上运行HelloWorld，开发小应用，如跑马灯等，最后还了解了uc/os这样一个实时操作系统；</li>
<li>开发阶段：使用PWM波以及H桥控制车轮，使用超声模块控制让小车感知外界状况，从而进行控制，最后可以使用PID控制理论优化小车的控制。<a id="more"></a>
</li>
</ul>
<h3 id="学习仪器"><a href="#学习仪器" class="headerlink" title="学习仪器"></a>学习仪器</h3><ul>
<li>学会使用示波器，可以用来观察从ADC，PWM波等等信号。</li>
<li>学会使用万用表测电压，电阻，电流。<center><img src="/img/TA-Cources/Summer-training2016/Oscilloscope.png" width="420px"/></center>

</li>
</ul>
<h3 id="回顾c语言编程"><a href="#回顾c语言编程" class="headerlink" title="回顾c语言编程"></a>回顾c语言编程</h3><ul>
<li>条件判断</li>
<li>循环：for loop &amp; while loop</li>
<li>数组：<ul>
<li>使用下标访问</li>
<li>使用指针访问</li>
</ul>
</li>
<li>函数使用：<ul>
<li>递归</li>
<li>迭代</li>
</ul>
</li>
<li>链表：<ul>
<li>结构体声明和使用</li>
<li>指针使用</li>
<li>链表结构和基本操作</li>
</ul>
</li>
<li>位操作<ul>
<li>位操作将十进制表示成二进制数</li>
<li>位操作实现某一位的反转，或者某一位不变其它位反转等</li>
</ul>
</li>
</ul>
<h3 id="C语言进阶"><a href="#C语言进阶" class="headerlink" title="C语言进阶"></a>C语言进阶</h3><ul>
<li>使用header file，source file以及main file。尝试尽可能的复用。</li>
<li>C语言与安全性<ul>
<li>数组越界</li>
<li>判断逻辑不全</li>
<li>变量没有初始化</li>
<li>内存泄露</li>
<li>没有考虑非法输入</li>
</ul>
</li>
</ul>
<h3 id="FPGA编程"><a href="#FPGA编程" class="headerlink" title="FPGA编程"></a>FPGA编程</h3><ul>
<li>FPGA：DE0-Nano board<center><img src="/img/TA-Cources/Summer-training2016/DE0-Nano.jpg" width="340px"/></center></li>
<li>使用自带软件测试FPGA完好</li>
<li>在FPGA上运行HelloWorld工程</li>
<li>实现LED Sliding Pattern（闪烁模式之类）</li>
<li>使用中断<ul>
<li>中断的原理和运行机制</li>
</ul>
</li>
</ul>
<h3 id="FPGA上编程进阶"><a href="#FPGA上编程进阶" class="headerlink" title="FPGA上编程进阶"></a>FPGA上编程进阶</h3><ul>
<li>在IDE：eclipse上进行Debug</li>
<li>ADC:<ul>
<li>FPDA上有一个ADC的硬件模块</li>
</ul>
</li>
</ul>
<h3 id="PWM-Pulse-Width-Modulation"><a href="#PWM-Pulse-Width-Modulation" class="headerlink" title="PWM(Pulse Width Modulation)"></a>PWM(Pulse Width Modulation)</h3><ul>
<li>Duty cycle 占空比<center><img src="/img/TA-Cources/Summer-training2016/what_is_PWM.png"  width="640px"/></center></li>
<li>Why PWM?<ul>
<li>Digital voltage control: 只能控制1和0</li>
<li>需要最大电压的x%则让占空比为x%</li>
</ul>
</li>
<li>产生PWM的方法：<ul>
<li>软件方法<ul>
<li>使用计数器</li>
<li>使用中断？</li>
</ul>
</li>
<li>硬件方法<ul>
<li>Hardware PWM IP &lt;– NIOS core</li>
<li>moto_setting(),能产生2个PWM波</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="H桥"><a href="#H桥" class="headerlink" title="H桥"></a>H桥</h3><ul>
<li>低电流做控制，产生大电流去驱动电机</li>
<li>PWM波控制H桥驱动电机，使小车前进，后退，转弯等<center><img src="/img/TA-Cources/Summer-training2016/H-Bridge.png"  width="720px"/></center>

</li>
</ul>
<h3 id="超声模块"><a href="#超声模块" class="headerlink" title="超声模块"></a>超声模块</h3><ul>
<li>超声模块是：KS103<br><center><img src="/img/TA-Cources/Summer-training2016/KS103.png"  width="360px"/></center><ul>
<li>VCC: Power Pin</li>
<li>SDA/TX: data pin in I2C bus/TX pin in uart bus</li>
<li>SCL/RX: clock pin in I2C bus/RX pin in uart bus</li>
<li>GND: power ground pin</li>
<li>Mode: Select the communication mode.<ul>
<li>High Level(VCC): I2C</li>
<li>Low Level (GND): Uart</li>
</ul>
</li>
</ul>
</li>
<li>使用流程：<center><img src="/img/TA-Cources/Summer-training2016/how_to_use_KS103.png"  width="480px"/></center></li>
<li>接线：<ul>
<li>使用Uart模式：<ul>
<li>超声TX接入FPGA的RX，超声的RX接入FPGA的TX</li>
</ul>
</li>
<li>使用I2C模式：<ul>
<li>data pin &amp; clock pin</li>
</ul>
</li>
</ul>
</li>
<li>编程时的端口查找：<ul>
<li>结合QSF文件以及FPGA用户手册</li>
</ul>
</li>
</ul>
<h3 id="uc-OS-实时嵌入式操作系统"><a href="#uc-OS-实时嵌入式操作系统" class="headerlink" title="uc/OS 实时嵌入式操作系统"></a>uc/OS 实时嵌入式操作系统</h3><ul>
<li>以上都是bare metal hardware（裸跑）上编程，然后编译我们需要的程序</li>
<li>如果需要完成复杂的多任务，可以考虑跑在一个操作系统上（嵌入式操作系统，如uc/OS）<ul>
<li>多任务（线程）</li>
<li>信号量</li>
<li>临界区访问<center><img src="/img/TA-Cources/Summer-training2016/uc-OS.png"  width="480px"/></center>

</li>
</ul>
</li>
</ul>
<h3 id="PID控制"><a href="#PID控制" class="headerlink" title="PID控制"></a>PID控制</h3><ul>
<li>p：比例系数，I：积分系数，D：微分系数</li>
<li>使用PI控制，因为高阶噪声，所以不使用D</li>
<li>如下图，其中e(t) = r(t) - y(t)<center><img src="/img/TA-Cources/Summer-training2016/PID.png"  width="480px"/></center>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;摘自 &lt;a href=&quot;https://rh-song.github.io/2016/07/18/Summer-training/#more&quot;&gt;RiHui-Song’s Blog：Summer-training&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h3&gt;&lt;p&gt;　本文主要记录SMIE最后一次初级实训学习的主要内容。包括了大概是三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段：学习测量仪器，回顾C语言编程；&lt;/li&gt;
&lt;li&gt;熟悉阶段：在FPGA上运行HelloWorld，开发小应用，如跑马灯等，最后还了解了uc/os这样一个实时操作系统；&lt;/li&gt;
&lt;li&gt;开发阶段：使用PWM波以及H桥控制车轮，使用超声模块控制让小车感知外界状况，从而进行控制，最后可以使用PID控制理论优化小车的控制。
    
    </summary>
    
      <category term="TA Cources" scheme="http://durant35.github.io/categories/TA-Cources/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo，md源文件内容修改预览页面刷新无效</title>
    <link href="http://durant35.github.io/2017/02/02/hexo-md%E6%BA%90%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E4%BF%AE%E6%94%B9%E9%A2%84%E8%A7%88%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%97%A0%E6%95%88/"/>
    <id>http://durant35.github.io/2017/02/02/hexo-md源文件内容修改预览页面刷新无效/</id>
    <published>2017-02-02T12:42:12.000Z</published>
    <updated>2017-02-02T15:02:38.380Z</updated>
    
    <content type="html"><![CDATA[<p>　　之前在 <strong>Window</strong> 下面通过 <strong>hexo s</strong> 启动本地服务器，通过浏览器预览，对md源文件的当前修改能够通过网页刷新出来。这段时间在 <strong>Linux</strong> 上部署，就一直出现刷新页面无效的情况，必须重新启动服务器才能刷新，有时甚至还需要通过 <strong>hexo g</strong> 重新解析源文件才能成功刷新。之前有段时间也以为是 <strong>Linux</strong> 对带有中文名称的md源文件支持不好的缘故，因为将那些不能成功刷新的源文件的文件名修改下，去掉所有的中文字符后，就可以刷新有效了。</p>
<p>　　不过，今天尝试了这个方法，居然不行了，不知道是不是因为升级了 <strong>Hexo</strong> 的缘故，不过，却发现了更有效的解决方法，可以不用考虑源文件文件名的问题。</p>
<a id="more"></a>
<p>　　解决办法很简单，就是通过使用 <strong>hexo generate</strong> 的 <strong>watch</strong> 参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo g --watch</div></pre></td></tr></table></figure></p>
<p>　　开启 <strong>hexo generate</strong> 的实时监控，对当前修改的源文件进行实时解析，这样浏览器刷新预览的就是最新的源文件解析的结果了。<br>　　<br>　　注意：<br>　　+ 使用 <strong>Typora</strong>编辑器 <strong>Hexo</strong> 的md源文件进行编写，在上述操作中会有奇怪的现象，详见 <a href="https://github.com/hexojs/hexo/issues/2245">hexo server 运行时自动更新出错把页面文章全部清空</a>。<br>　　+ <strong>hexo s</strong> 命令好像默认是会自动开启 <strong>hexo generate</strong> 的实时监控，上述操作显得画蛇添足；不过，万一像我一样呢？可能你就需要尝试一下上面的命令了。<br>　　+ 笔者最后放弃了 <strong>Typora</strong>编辑器，也没选择安装 <strong>Markdown</strong> 预览插件的 <strong>Sublime Text</strong>，而是选择了<a href="https://remarkableapp.github.io/linux/download.html">Remarkable</a>，下载官网提供的.deb，按照下面命令即可安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo dpkg -i remarkable_*.deb</div><div class="line">$ sudo apt-get install -f</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　之前在 &lt;strong&gt;Window&lt;/strong&gt; 下面通过 &lt;strong&gt;hexo s&lt;/strong&gt; 启动本地服务器，通过浏览器预览，对md源文件的当前修改能够通过网页刷新出来。这段时间在 &lt;strong&gt;Linux&lt;/strong&gt; 上部署，就一直出现刷新页面无效的情况，必须重新启动服务器才能刷新，有时甚至还需要通过 &lt;strong&gt;hexo g&lt;/strong&gt; 重新解析源文件才能成功刷新。之前有段时间也以为是 &lt;strong&gt;Linux&lt;/strong&gt; 对带有中文名称的md源文件支持不好的缘故，因为将那些不能成功刷新的源文件的文件名修改下，去掉所有的中文字符后，就可以刷新有效了。&lt;/p&gt;
&lt;p&gt;　　不过，今天尝试了这个方法，居然不行了，不知道是不是因为升级了 &lt;strong&gt;Hexo&lt;/strong&gt; 的缘故，不过，却发现了更有效的解决方法，可以不用考虑源文件文件名的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="Hexo" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://durant35.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
