<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tarantula-7&#39;s Blog</title>
  <subtitle>　　你永远流淌在我的记忆里？River flows in you</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://durant35.github.io/"/>
  <updated>2017-07-12T09:28:34.375Z</updated>
  <id>http://durant35.github.io/</id>
  
  <author>
    <name>Gary</name>
    <email>chenshj35@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JPEG编码&amp;算术编码、LZW编码</title>
    <link href="http://durant35.github.io/2017/07/11/programPearls_JPEG&amp;Arithmetic&amp;LZW/"/>
    <id>http://durant35.github.io/2017/07/11/programPearls_JPEG&amp;Arithmetic&amp;LZW/</id>
    <published>2017-07-11T10:02:16.000Z</published>
    <updated>2017-07-12T09:28:34.375Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文介绍 JPEG 编解码过程（附简单的<code>cpp</code>实现）。JPEG 中常用到的熵编码是变长编码：Huffman 编码，本文也对算术编码（附<code>cpp</code>实现）、LZW 编码（附<code>py</code>实现）两种熵编码进行介绍。<a id="more"></a></p>
<h4 id="JPEG-编解码过程"><a href="#JPEG-编解码过程" class="headerlink" title="JPEG 编解码过程"></a>JPEG 编解码过程</h4><ul>
<li>JPEG 编码过程<br>  <center><img src="/img/programPearls/jpeg/JPEG_Diagram.jpg" width="480px" alt=""/></center><ul>
<li>色彩空间转换<br>$\quad$ 将 RGB 色彩空间转换到其他色彩空间，比如 YUV 色彩空间，根据人对亮度更敏感些，增加亮度的信号，减少颜色的信号，以这样“欺骗”人的眼睛的手段来节省空间。YUV 的格式也很多，常见的有 420 和 422 格式。在 420 格式中，<font color="blue">每四个 Y 共用一组  UV 分量</font>，每个 YUV 分量和 RGB 一样都用 8 位来表示，YUV 色彩空间就比 RGB 色彩空间所需的存储空间少一半，数据就被压缩到了一半。</li>
<li>将图像 8×8 分块<br>$\quad$ 对图像按一定的采样格式进行采样，常见的格式有 4:4:4、4:2:2 和 4:2:0，采样完成后，将图像按 8×8(pixel) 划分成 MCU。</li>
<li>离散余弦变换 DCT<ul>
<li>DCT 将时间或空间数据变成频率数据，利用人的听觉或视觉对高频信号（的变化）不敏感和对不同频带数据的感知特征不一样等特点，可以对多媒体数据进行压缩。</li>
<li>DCT 是数码率压缩需要常用的一个变换编码方法：①任何连续的实对称函数的傅里叶变换中只含余弦项，因此余弦变换与傅里叶变换一样有明确的物理意义；②由于大多数图像的高频分量较小，相应于图像高频分量的系数经常为零，加上人眼对高频成分的失真不敏感，所以可用更粗的量化。</li>
<li>传送变换系数的数码率要大大小于传送图像像素所用的数码率，到达接收端后通过反离散余弦变换回到样值，虽然会有一定的失真，但人眼是可以接受的。</li>
<li>二维正反离散余弦变换（FDCT/IDCT）的公式如下：<br>$$C(\omega) = \begin{cases} \frac{1}{\sqrt{2}}, \space\space \omega = 0 \cr 1, \quad \omega \gt 0 \end{cases}$$ $$ FDCT: F(u, v) = \frac{2}{N} C(u)C(v) \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} f(x, y) cos[\frac{(2x+1)u \pi}{2N}] cos[\frac{(2y+1)v \pi}{2N}]$$ $$IDCT: f(x, y) = \frac{2}{N} \sum_{u=0}^{N-1} \sum_{v=0}^{N-1} C(u)C(v)F(u, v) cos[\frac{(2x+1)u \pi}{2N}] cos[\frac{(2y+1)v \pi}{2N}]$$<ul>
<li>其中 $N$ 是像块的水平、垂直像素数，一般取 $N=8$。$N$ 大于 8 时效率增加不多但复杂性大为增加。8×8 的二维数据块经 DCT 后变成 8×8 个变换系数，这些系数都有明确的意义：$F(u=0, v=0)$ 是原 64 个样值的平均，相当于直流分量；随着 $u$、$v$ 值增加，相应系数分别代表逐步增加的水平空间频率和垂直空间频率分量的大小，如下图：<center><img src="/img/programPearls/jpeg/DCT_schematic.png" width="440px" alt=""/></center></li>
<li>图像信号被分解成直流信号+从低频到高频的各种余弦成分；DCT 系数只是表示了该种成分所占原图像信号的份额大小；显然，恢复图像信息可以表示这样一个矩阵形式：$f(x, y) = F(u, v) * C(u, v)$，$C(u, v)$ 是一个基底，$F(u, v)$ 是 DCT 系数，$f(x, y)$ 则是图像信号。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>FDCT</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> w&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="keyword">double</span>(<span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">2</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">func_F</span><span class="params">(<span class="keyword">int</span> f[][<span class="number">8</span>], <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</div><div class="line">      sum += f[i][j]*<span class="built_in">cos</span>((<span class="number">2</span>*i+<span class="number">1</span>)*u*M_PI/<span class="number">16</span>)*<span class="built_in">cos</span>((<span class="number">2</span>*j+<span class="number">1</span>)*v*M_PI/<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0.25</span>*C(u)*C(v)*sum;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// DCT transform </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fdct</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      F[row][col] = func_F(f, row, col);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>量化（quantization）<ul>
<li>量化是对经过 FDCT 变换后的频率系数进行量化，是一个将信号的幅度离散化的过程，离散信号经过量化后变为数字信号；量化的目的是减少非“0”系数的幅度以及增加“0”值系数的数目，利用人眼对高频部分不敏感的特性来舍去高频部分。</li>
<li>对于有损压缩算法，JPEG 算法使用均匀量化器进行量化，量化步距是按照系数所在的位置和每种颜色分量的色调值来确定的，因为人眼对亮度信号比对色差信号敏感，因此使用了如下两种量化表：标准亮度量化表（<code>bright_table.txt</code>）和标准色差量化表（<code>color_diff_table.txt</code>）。</li>
</ul>
</li>
<li><figure class="highlight cpp"><figcaption><span>bright_table.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">17</span>	<span class="number">18</span>	<span class="number">24</span>	<span class="number">47</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">18</span>	<span class="number">21</span>	<span class="number">26</span>	<span class="number">66</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">24</span>	<span class="number">26</span>	<span class="number">56</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">47</span>	<span class="number">66</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight cpp"><figcaption><span>color_diff_table.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">16</span>	<span class="number">11</span>	<span class="number">10</span>	<span class="number">16</span>	<span class="number">24</span>	<span class="number">40</span>	<span class="number">51</span>	<span class="number">61</span></div><div class="line"><span class="number">12</span>	<span class="number">12</span>	<span class="number">14</span>	<span class="number">19</span>	<span class="number">26</span>	<span class="number">58</span>	<span class="number">60</span>	<span class="number">55</span></div><div class="line"><span class="number">14</span>	<span class="number">13</span>	<span class="number">16</span>	<span class="number">24</span>	<span class="number">40</span>	<span class="number">57</span>	<span class="number">69</span>	<span class="number">56</span></div><div class="line"><span class="number">14</span>	<span class="number">17</span>	<span class="number">22</span>	<span class="number">29</span>	<span class="number">51</span>	<span class="number">87</span>	<span class="number">80</span>	<span class="number">62</span></div><div class="line"><span class="number">18</span>	<span class="number">22</span>	<span class="number">37</span>	<span class="number">56</span>	<span class="number">68</span>	<span class="number">109</span>	<span class="number">103</span>	<span class="number">77</span></div><div class="line"><span class="number">24</span>	<span class="number">35</span>	<span class="number">55</span>	<span class="number">64</span>	<span class="number">81</span>	<span class="number">104</span>	<span class="number">113</span>	<span class="number">92</span></div><div class="line"><span class="number">49</span>	<span class="number">64</span>	<span class="number">78</span>	<span class="number">87</span>	<span class="number">103</span>	<span class="number">121</span>	<span class="number">120</span>	<span class="number">101</span></div><div class="line"><span class="number">72</span>	<span class="number">92</span>	<span class="number">95</span>	<span class="number">98</span>	<span class="number">112</span>	<span class="number">100</span>	<span class="number">103</span>	<span class="number">99</span></div></pre></td></tr></table></figure>
<ul>
<li>由于人眼对低频分量的图像比对高频分量更敏感，因此左上角的量化步距要比右下角的量化步距小；把 DCT 系数块的数值除以对应量化表位置上的数值，并四舍五入到最近的整数；解码的时候，反量化步骤会乘回量化表相应值，但是四舍五入导致低频有所损失，高频“0”字段被舍弃；这一步为有损运算，会导致图像质量变低，量化是图像质量下降的最主要原因，所以说 JPEG 编码是有损压缩。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Q[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"><span class="keyword">int</span> Sq[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">color_diff_quantization_table_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>&#123;</div><div class="line">  <span class="function">ifstream <span class="title">in</span><span class="params">(filename)</span></span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>; col++)&#123;</div><div class="line">      in &gt;&gt; Q[row][col];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  in.close();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Sq(u,v) = round(F(u,v) / Q(u,v))</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quantilize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="comment">//color_diff_quantization_table_init("bright_table.txt");</span></div><div class="line">  color_diff_quantization_table_init(<span class="string">"color_diff_table.txt"</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      Sq[row][col] = round(F[row][col] / Q[row][col]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>zig-zag Z 字形游程编码<br>$\quad$ 量化后的数据还可以通过以下 ZigZag 表的规则进行重排后，重排后的结果中可以看到出现连续的多个 0，达到简化、更大程度的去压缩，这样有利于进行游程编码。<center><img src="/img/programPearls/jpeg/zig-zagTable.png" width="720px" alt=""/></center></li>
<li>使用差分脉冲编码调制（DPCM）对直流系数（DC）进行编码<br>$\quad$ 8×8 图像经过 DCT 变换之后得到的 DC 直流系数有两个特点：一是系数的数值比较大；二是相邻 8×8 图像块的 DC 系数值变化不大。根据这两个特点，JPEG 算法使用了差分脉冲调制编码（DPCM）技术，对相邻图像块之间量化的 DC 系数的差值（Delta）进行编码：$Delta = DC(0, 0)_k - DC(0, 0)_{k-1}$</li>
<li>使用行程长度编码（RLE）对交流系数（AC）进行编码<ul>
<li>Z 字形读出的量化后的 AC 系数的特点是 1×64 矢量中包含有许多“0”系数并且许多“0”是连续的，因此使用非常简单和直观的游程长度编码（RLE）对它们进行编码：只将“0”作为重复的内容，JPEG 使用了一个字节的高4位来表示连续“0”的个数（最多重复内容可以记录数量为 15，超过 15 次要进行分段处理），而使用它的低4位来表示编码下一个非“0”系数所需要的位数；特别到最后，如果都是“0”，在读到最后一个数后，只要给出“快结束”（EOB）码字，就可以结束输出，因此节省了很多码率。</li>
<li>如下面的 4×4 图像块 $\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 2 &amp; 4 &amp; 0 &amp; 0 \\ 5 &amp; 0 &amp; 0 &amp; 0 \\ 8 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$，按 Z 字形抽取得到的码字是：$\verb|{| 1, 0, 2, 5, 4, 0, 0, 0, 0, 8, 0, …, 0 \verb|}|$，经过游程编码得到的码值为：<code>(0,1,0)(1,2,0)(0,5,0)(0,4,0)(4,8,1)EOB</code></li>
</ul>
</li>
<li>熵编码（Huffman或算术）<ul>
<li>使用熵编码还可以对 DPCM 编码后的直流 DC 系数和 RLE 编码后的交流 AC 系数作进一步的压缩；常用的熵编码有变长编码，即 哈弗曼（Huffman）编码。</li>
<li>Huffman 编码的基本原理：根据数据中元素出现的基本频率，调整元素的编码长度，以得到更高的压缩比；编码方法：对出现概率大的符号分配短字长的二进制码，对出现概率小的符号分配长字长的二进制码，得到符号的平均码长最短的码。</li>
<li>Huffman 编码的步骤：<ol>
<li>将符号按概率从小到大顺序从左至右排列叶节点；</li>
<li>连接两个概率最小的顶层节点来组成一个父节点，并在到左右子节点的两条连线上分别标记“0”和“1”（可以对概率大的赋值“0”，小的赋值“1”）；</li>
<li>重复步骤<code>2</code>，直到得到根节点，形成一棵二叉树；</li>
<li>从根节点开始到相应于每个符号的叶节点的 0/1 串，就是该符号的二进制编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;climits&gt; // for CHAR_BIT</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"> </div><div class="line">const int UniqueSymbols = 1 &lt;&lt; CHAR_BIT;</div><div class="line">const char* SampleString = "this is an example for huffman encoding";</div><div class="line"> </div><div class="line">typedef std::vector&lt;bool&gt; HuffCode;</div><div class="line">typedef std::map&lt;char, HuffCode&gt; HuffCodeMap;</div><div class="line"> </div><div class="line">class INode &#123;</div><div class="line">public:</div><div class="line">    const int f;</div><div class="line">    virtual ~INode() &#123;&#125;</div><div class="line">protected:</div><div class="line">    INode(int f) : f(f) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">class InternalNode : public INode &#123;</div><div class="line">public:</div><div class="line">    INode *const left;</div><div class="line">    INode *const right;</div><div class="line">    InternalNode(INode* c0, INode* c1) : INode(c0-&gt;f + c1-&gt;f), left(c0), right(c1) &#123;&#125;</div><div class="line">    ~InternalNode()&#123;</div><div class="line">        delete left;</div><div class="line">        delete right;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">class LeafNode : public INode &#123;</div><div class="line">public:</div><div class="line">    const char c;</div><div class="line">    LeafNode(int f, char c) : INode(f), c(c) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">struct NodeCmp&#123;</div><div class="line">    bool operator() (const INode* lhs, const INode* rhs) const &#123; return lhs-&gt;f &gt; rhs-&gt;f; &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">INode* BuildTree(const int (&amp;frequencies)[UniqueSymbols]) &#123;</div><div class="line">    std::priority_queue&lt;INode*, std::vector&lt;INode*&gt;, NodeCmp&gt; trees;</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; UniqueSymbols; ++i) &#123;</div><div class="line">        if(frequencies[i] != 0)</div><div class="line">            trees.push(new LeafNode(frequencies[i], (char)i));</div><div class="line">    &#125;</div><div class="line">    while (trees.size() &gt; 1) &#123;</div><div class="line">        INode* childR = trees.top();</div><div class="line">        trees.pop();</div><div class="line"> </div><div class="line">        INode* childL = trees.top();</div><div class="line">        trees.pop();</div><div class="line"> </div><div class="line">        INode* parent = new InternalNode(childR, childL);</div><div class="line">        trees.push(parent);</div><div class="line">    &#125;</div><div class="line">    return trees.top();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void GenerateCodes(const INode* node, const HuffCode&amp; prefix, HuffCodeMap&amp; outCodes) &#123;</div><div class="line">    if (const LeafNode* lf = dynamic_cast&lt;const LeafNode*&gt;(node)) &#123;</div><div class="line">        outCodes[lf-&gt;c] = prefix;</div><div class="line">    &#125;</div><div class="line">    else if (const InternalNode* in = dynamic_cast&lt;const InternalNode*&gt;(node)) &#123;</div><div class="line">        HuffCode leftPrefix = prefix;</div><div class="line">        leftPrefix.push_back(false);</div><div class="line">        GenerateCodes(in-&gt;left, leftPrefix, outCodes);</div><div class="line"> </div><div class="line">        HuffCode rightPrefix = prefix;</div><div class="line">        rightPrefix.push_back(true);</div><div class="line">        GenerateCodes(in-&gt;right, rightPrefix, outCodes);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main() &#123;</div><div class="line">    // Build frequency table</div><div class="line">    int frequencies[UniqueSymbols] = &#123;0&#125;;</div><div class="line">    const char* ptr = SampleString;</div><div class="line">    while (*ptr != '\0')</div><div class="line">        ++frequencies[*ptr++];</div><div class="line"> </div><div class="line">    INode* root = BuildTree(frequencies);</div><div class="line"> </div><div class="line">    HuffCodeMap codes;</div><div class="line">    GenerateCodes(root, HuffCode(), codes);</div><div class="line">    delete root;</div><div class="line"> </div><div class="line">    for (HuffCodeMap::const_iterator it = codes.begin(); it != codes.end(); ++it) &#123;</div><div class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; " ";</div><div class="line">        std::copy(it-&gt;second.begin(), it-&gt;second.end(),</div><div class="line">                  std::ostream_iterator&lt;bool&gt;(std::cout));</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>组成位数据流<br>$\quad$ JPEG 编码的最后一个步骤是把各种标记代码和编码后的图像数据组成一帧一帧的数据，这样做的目的是为了便于传输、存储和译码器进行译码，这样组织的数据通常称为 JPEG 位数据流（JPEG bitstream）。</li>
</ul>
</li>
<li>JPEG 解码过程<br>  <center><img src="/img/programPearls/jpeg/JPEG_Decompression.jpg" width="640px" alt=""/></center><ul>
<li>AC 系数、DC 系数的解码<br>$\quad$ 每个颜色分量单元都应该由两部分组成：1 个直流分量和 63 个交流分量。</li>
<li>直流系数的差分编码</li>
<li>反量化</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// inverse quantization</span></div><div class="line"><span class="keyword">int</span> invSq[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"> </div><div class="line"><span class="comment">// invSq(u,v) = Sq(u,v) * Q(u,v)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse_quantilize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      invSq[row][col] = Sq[row][col] * Q[row][col];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>反 Zig-Zag 编码</li>
<li>反离散余弦变换（Inverse DCT）</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reconstructed sample data</span></div><div class="line"><span class="keyword">int</span> invV[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">func_f</span><span class="params">(<span class="keyword">int</span> F[][<span class="number">8</span>], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u&lt;<span class="number">8</span>; u++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;<span class="number">8</span>; v++)&#123;</div><div class="line">      sum += C(u)*C(v)*F[u][v]*<span class="built_in">cos</span>((<span class="number">2</span>*i+<span class="number">1</span>)*u*M_PI/<span class="number">16</span>)*<span class="built_in">cos</span>((<span class="number">2</span>*j+<span class="number">1</span>)*v*M_PI/<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;	</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0.25</span>*sum;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reconstruct</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="comment">// inverse DCT transform</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      invV[row][col] = func_f(invSq, row, col);</div><div class="line">      <span class="comment">// inverse of pre process</span></div><div class="line">      invV[row][col] += <span class="number">128</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>YCrCb（YUV） 向 RGB 转换</li>
</ul>
</li>
</ul>
<h4 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h4><ul>
<li>算术编码克服了 Huffman 编码必须为整数位，这与实数的概率值相差大的缺点，如在 Huffman 编码中，本来只需要 0.1 位就可以表示的符号，却必须用 1 位来表示，结果造成 10 倍的浪费。算术编码所采用的解决办法是，不用二进制代码来表示符号，而改用 $[0，1)$ 中的一个宽度等于其出现概率的实数区间来表示一个符号，符号表中的所有符号刚好布满整个 $[0，1)$ 区间（概率之和为 1，不重不漏），<font color="blue">把输入符号串（数据流）映射成 $[0，1)$ 区间中的一个实数值</font>。</li>
<li>编码方法<ul>
<li>符号串编码方法：将串中使用的符号表按原编码（如字符的ASCII编码、数字的二进制编码）从小到大顺序排列成表，计算表中每种符号 $s_i$ 出现的概率 $p_i$，然后依次根据这些符号概率大小 $p_i$ 来确定其在 $[0, 1)$ 期间中对应的小区间范围 $[x_i, y_i)$<br>$$ x_i = \sum_{j=0}^{i-1} p_j, y_i = x_i + p_i, i=1, …, m$$</li>
<li>对输入符号串进行编码<ul>
<li>设串中第 $j$ 个符号 $c_j$ 为符号表中的第 $i$ 个符号 $s_i$，则可根据 $s_i$ 在符号表中所对应区间的上下限 $x_i$ 和 $y_i$，来计算编码区间 $I_j = [l_j, r_j)$：$l_j = l_{j-1} + d_{j-1}·x_i$，$r_j = l_{j-1} + d_{j-1}·y_i$；</li>
<li>其中，$d_j = r_j - l_j$ 为区间 $I_j$ 的宽度，$l_0 = 0，r_0 = 1，d_0 = 1$。显然，$l_j$↑而 $d_j$ 与 $r_j$↓。串的最后一个符号所对应区间的下限 $l_n$ 就是该符号串的算术编码值。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STRLEN 100</span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> str[STRLEN], source_str[STRLEN];</div><div class="line">  <span class="keyword">int</span> str_len;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input a string..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cin</span>.getline(str, STRLEN);</div><div class="line"></div><div class="line">  str_len = <span class="built_in">strlen</span>(str);</div><div class="line">  <span class="built_in">strcpy</span>(source_str, str);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"*input string length: "</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; str_len &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"*sorting string letters in dictionary order: "</span>);</div><div class="line">  sort(str, str+str_len);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\"%s\"\n"</span>, str);</div><div class="line"> </div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; word;				<span class="comment">//存放字符串中的字符word[i]</span></div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; freq;				<span class="comment">//存放word[i]字符所对应的频率freq[i]</span></div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; endpoint;			<span class="comment">//每个字符word[i]对应频率区间的左右点[endpoint[2i], endpoint[2i+1]);</span></div><div class="line">   </div><div class="line">  <span class="comment">// 计算每个字母的频率(by dictionary order)</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len;)&#123;</div><div class="line">    <span class="keyword">int</span> tmp_num = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> cur_word = str[i];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; str_len; j++)&#123;</div><div class="line">      <span class="keyword">if</span> (str[j] == cur_word)&#123;</div><div class="line">        tmp_num++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    word.push_back(cur_word);</div><div class="line">    freq.push_back(<span class="keyword">double</span>(tmp_num) / str_len);</div><div class="line">    i += tmp_num;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//for (int i = 0; i &lt; word.size(); i++)&#123;</span></div><div class="line">  <span class="comment">//	cout &lt;&lt; word[i]&lt;&lt; " " &lt;&lt; freq[i] &lt;&lt; endl;</span></div><div class="line">  <span class="comment">//&#125;</span></div><div class="line">   </div><div class="line">  <span class="comment">// 计算每个字母的频率区间的左右端点</span></div><div class="line">  <span class="keyword">double</span> left_endpoint = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</div><div class="line">    endpoint.push_back(left_endpoint);</div><div class="line">    left_endpoint += freq[i];</div><div class="line">    endpoint.push_back(left_endpoint);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n----------- Symbol Table -----------\n"</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\'%c\' %8.6lf [%8.6lf, %8.6lf)\n"</span>, word[i], freq[i], endpoint[<span class="number">2</span>*i], endpoint[<span class="number">2</span>*i+<span class="number">1</span>]);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 编码</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n----------- Arithmetic Coding -----------\n"</span>);</div><div class="line">  <span class="keyword">double</span> left = <span class="number">0.</span>, right = <span class="number">1.</span>, delta = <span class="number">1.</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++)&#123;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.size(); j++)&#123;</div><div class="line">      <span class="keyword">if</span> (source_str[i] == word[j])&#123;</div><div class="line">        index = j;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    left = left + delta*endpoint[<span class="number">2</span> * index];</div><div class="line">    right = left + delta*endpoint[<span class="number">2</span> * index + <span class="number">1</span>];</div><div class="line">    <span class="comment">// delta = right - left = delta * (endpoint[2 * index + 1] - endpoint[2 * index]) = delta * freq[index]</span></div><div class="line">    delta = delta*freq[index];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c %0.18lf %0.18lf %0.18lf\n"</span>, source_str[i], left, right, delta);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"*Arithmetic Coding Result: %.18lf\n"</span>, left);</div><div class="line">  </div><div class="line">  <span class="comment">//...</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>解码方法<ul>
<li>由符号表（包括符号对应的概率与区间）和实数编码 $l_n$，可以按下面的解码算法来重构输入符号串。<ul>
<li>① 设 $v_1 = l_n = \space$码值；</li>
<li>② 若 $v_j \in [x_i, y_j) \Longrightarrow c_j = s_i, j = 1, …, n$；</li>
<li>③ $v_{j+1} = \frac{v_j - x_i}{p_j}, j = 1, …, n-1$，重复步骤②、③。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; word;				<span class="comment">//存放字符串中的字符word[i]</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; freq;				<span class="comment">//存放word[i]字符所对应的频率freq[i]</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; endpoint;			<span class="comment">//每个字符word[i]对应频率区间的左右点[endpoint[2i], endpoint[2i+1]);</span></div><div class="line"> </div><div class="line"><span class="built_in">printf</span>(<span class="string">"*Arithmetic Coding Result: %.18lf\n"</span>, left);</div><div class="line"> </div><div class="line"><span class="built_in">printf</span>(<span class="string">"\n----------- Arithmetic Decoding -----------\n"</span>);</div><div class="line"><span class="keyword">double</span> v = left;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++)&#123;</div><div class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.size(); j++)&#123;</div><div class="line">    <span class="keyword">if</span> (v &lt; endpoint[<span class="number">2</span> * j + <span class="number">1</span>])&#123;</div><div class="line">      index = j;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%.18lf %d \'%c\'\n"</span>, v, index+<span class="number">1</span>, word[index]);</div><div class="line">  v = (v - endpoint[<span class="number">2</span> * index]) / freq[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="LZW编码"><a href="#LZW编码" class="headerlink" title="LZW编码"></a>LZW编码</h4><ul>
<li>LZW 编码和 Huffman编码、算术编码一样，是无损压缩中的一种；该算法通过建立字典，实现字符重用与编码，适用于 source 中重复率很高的文本压缩。<ul>
<li>LZW 算法是一种基于字典的编码——将变长的输入符号串映射成定长的码字——形成一本短语词典索引（串表），利用字符出现的频率冗余度及串模式高使用率冗余度达到压缩的目的。该算法只需一遍扫描，且具有自适应的特点（从空表开始逐步生成串表，码字长从 1 逐步增加到12），</font color="blue">不需保存和传送串表</font>。</li>
<li>串表具有前缀性——若串 $wc$（$c$ 为字符）在串表中，则串 $w$ 也在串表中（所以，可初始化串表为含所有单个字符的串）。</li>
<li>匹配采用贪婪算法——每次只识别与匹配串表中最长的已有串 $w$（输出对应的码字）、并可与下一输入字符 $c$ 拼成一个新的码字 $wc$。</li>
</ul>
</li>
<li>LZW 压缩算法<ul>
<li>初始化<ul>
<li>①将所有单个字符（$n$ 个不同字符）的串放入串表 ST 中（共 $n$ 项[码字为$1~n$]，实际操作时不必放入，只需空出串表的前 $n$ 项，字符对应码字所对应的串表索引即可）；</li>
<li>②读首字符入前缀串 $w$；</li>
<li>③设置码长 $codeBits = n+1$；</li>
<li>④设置串表中当前表项的索引值 $next = 初始码字 = n+1$</li>
</ul>
</li>
<li>循环<ul>
<li>⑤读下一输入字符 $c$；</li>
<li>⑥若 $c=EOF$（文件结束符），则输出 $w$ 的码字 $dict[w]$，结束循环（输出结束码字）；</li>
<li>⑦若 $wc$ 已在串表中，则 $w = wc$，转到循环开始处⑤；否则，输出 $w$ 的码字 $dict[w]$，将 $wc$ 放入 ST 中的 $next$ 处，$next++$；令 $w=c$，转到循环开始处⑤；</li>
<li>⑧若 $next$ 的位数超过码长（$\gt codeBits$），则 $codeBits++$；若串表已满（$next$ 的位数已超过最大码长 12），则清空串表，输出清表码字，转到初始化开始处①（一般不太可能发生）。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment"># coding= utf-8</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> sys</div><div class="line"> </div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"> </div><div class="line">input = raw_input(<span class="string">u"请输入字符串："</span>.encode(<span class="string">'mbcs'</span>))</div><div class="line"><span class="keyword">print</span> <span class="string">u"编码过程："</span></div><div class="line">inputlist = list(input)</div><div class="line"> </div><div class="line">wclist = list(set(inputlist))</div><div class="line">diclen = len(wclist)</div><div class="line">wclist.sort()</div><div class="line">phrases_dict = &#123;&#125;</div><div class="line"> </div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, diclen+<span class="number">1</span>):</div><div class="line">    phrases_dict[x] = wclist[x<span class="number">-1</span>]</div><div class="line"> </div><div class="line">nextlist = range(<span class="number">1</span>, len(wclist)+<span class="number">1</span>)</div><div class="line">wlist = [<span class="string">'--'</span>] * len(wclist)</div><div class="line">procedurelist = [<span class="string">'--'</span>] * len(wclist)</div><div class="line">poslist = [<span class="string">'--'</span>]*len(wclist)</div><div class="line">mstr = <span class="string">''</span></div><div class="line">nstr = <span class="string">''</span></div><div class="line">k = <span class="number">0</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(inputlist)):</div><div class="line">    nstr = nstr + inputlist[i]</div><div class="line">    <span class="keyword">if</span> nstr <span class="keyword">in</span> wclist:</div><div class="line">        mstr = nstr</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        k = k+<span class="number">1</span></div><div class="line">        wclist.append(nstr)</div><div class="line">        nextlist.append(len(nextlist)+<span class="number">1</span>)</div><div class="line">        a = wclist.index(mstr)</div><div class="line">        wlist.append(a+<span class="number">1</span>)</div><div class="line">        procedurelist.append(k)</div><div class="line">        poslist.append(i-len(nstr)+<span class="number">2</span>)</div><div class="line">        mstr = inputlist[i]</div><div class="line">        nstr = inputlist[i]</div><div class="line"> </div><div class="line">wclist.append(<span class="string">'--'</span>)</div><div class="line">nextlist.append(<span class="string">'--'</span>)</div><div class="line">a = wclist.index(mstr)</div><div class="line">wlist.append(a+<span class="number">1</span>)</div><div class="line">procedurelist.append(k+<span class="number">1</span>)</div><div class="line">poslist.append(<span class="string">'--'</span>)</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'步 骤  位 置   Next      Wc      输出W'</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(wclist)):</div><div class="line">    <span class="keyword">print</span> <span class="string">'%s\t %s\t %s\t %s\t %s\t'</span>%(procedurelist[i], poslist[i], nextlist[i], wclist[i], wlist[i])</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>LZW 还原算法<ul>
<li>初始化<ul>
<li>①将所有单个字符（$n$ 个不同字符）的串放入串表 ST 中（共 $n$ 项[码字为$1~n$]，实际操作时不必放入，只需空出串表的前 $n$ 项，字符对应码字所对应的串表索引即可）；</li>
<li>②设置码长 $codeBits = n+1$；</li>
<li>③设置串表中当前表项的索引值 $next = 初始码字 = n+1$</li>
<li>④读首个码字（所对应的单个字符）入老串 $old$，输出该字符；</li>
</ul>
</li>
<li>循环<ul>
<li>⑤读下一码字 $new$：若 $new$ 为结束码字，结束循环；若 $new$ 为清表码字，清空串表，转到初始化开始处①；</li>
<li>⑥若 $new \geq next$，则输出串 $newStr = old + old[0]$（例外处理）；若 $new \lt next$，则输出串 $newStr = ST[new]$；</li>
<li>⑦将 $old + newStr[0]$ 放入串表 ST[next] 中，$next++$；</li>
<li>⑧若 $next$ 的位数超过码长（$\gt codeBits$），则 $codeBits++$；若加一后 $codeBits \gt 12$，则重新让 $codeBits = 12$；</li>
<li>⑨$old = newStr$，转到循环开始处⑤。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_before_decode</span><span class="params">(phrases_dict)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">u'步骤 码字   词 典    输 出'</span></div><div class="line">    keys = sorted(list(phrases_dict.keys()))</div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys:</div><div class="line">        <span class="keyword">print</span> <span class="string">'%-4s %-4s %-4s %-5s %-4s'</span> % \</div><div class="line">            (<span class="string">''</span>, <span class="string">''</span>, <span class="string">'('</span> + str(key) + <span class="string">')'</span>, phrases_dict[key], <span class="string">''</span>)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeLZW</span><span class="params">(codes, phrases_dict)</span>:</span></div><div class="line">    step = <span class="number">1</span></div><div class="line">    next = len(phrases_dict) + <span class="number">1</span></div><div class="line">    old = phrases_dict[codes[<span class="number">0</span>]]</div><div class="line">    <span class="keyword">print</span> <span class="string">'%-4s %-4s %-4s %-5s %-4s'</span> % \</div><div class="line">        (step, <span class="string">'(1)'</span>, <span class="string">'-'</span>, <span class="string">'-'</span>, old)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(codes)):</div><div class="line">        new = codes[i]</div><div class="line">        <span class="keyword">if</span> new &gt;= next:</div><div class="line">            newStr = old + old[<span class="number">0</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            newStr = phrases_dict[new]</div><div class="line">        phrases_dict[next] = old + newStr[<span class="number">0</span>]</div><div class="line">        step += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'%-4s %-4s %-4s %-5s %-4s'</span> % \</div><div class="line">            (step, <span class="string">'('</span> + str(new) + <span class="string">')'</span>, <span class="string">'('</span> + str(next) + <span class="string">')'</span>,</div><div class="line">             phrases_dict[next], newStr)</div><div class="line">        next += <span class="number">1</span></div><div class="line">        old = newStr</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u"解码过程："</span></div><div class="line">codes = wlist[diclen:]</div><div class="line">print_before_decode(phrases_dict)</div><div class="line">decodeLZW(codes, phrases_dict)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Felix: jpeg编码学习笔记</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_61d40cc30100f5e1.html">quennel的博客: JPEG编解码过程详解（一）</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_61d40cc30100f5e6.html">quennel的博客: JPEG编解码过程详解（二）</a></li>
<li><a href="http://edwin-wang.com/2006/06/jpeg%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/">EdwinWang.com: JPEG 压缩编码笔记</a></li>
<li>《多媒体技术基础：李才伟编著》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文介绍 JPEG 编解码过程（附简单的&lt;code&gt;cpp&lt;/code&gt;实现）。JPEG 中常用到的熵编码是变长编码：Huffman 编码，本文也对算术编码（附&lt;code&gt;cpp&lt;/code&gt;实现）、LZW 编码（附&lt;code&gt;py&lt;/code&gt;实现）两种熵编码进行介绍。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="C/C++" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/C-C/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>密码学：DES、3DES、AES</title>
    <link href="http://durant35.github.io/2017/07/11/programPearls_DES&amp;3DES&amp;AES/"/>
    <id>http://durant35.github.io/2017/07/11/programPearls_DES&amp;3DES&amp;AES/</id>
    <published>2017-07-11T10:02:16.000Z</published>
    <updated>2017-07-12T01:09:42.750Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义（定义性声明）</span></div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="comment">// 声明（引用性声明）</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> j;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line"><span class="keyword">int</span> k = <span class="number">7</span>;</div><div class="line"><span class="comment">// 默认初始化</span></div><div class="line"><span class="keyword">int</span> l;</div><div class="line"><span class="comment">// 赋值</span></div><div class="line">l = <span class="number">100</span>;</div></pre></td></tr></table></figure>
<ul>
<li>引用性<font color="red">声明</font>不分配存储空间，如：<code>extern int x;</code>只是告诉编译器变量<code>x</code>是整型，已经在其它地方定义了。</li>
<li><font color="red">定义</font>是在内存中确定变量的位置、大小。</li>
<li><font color="red">初始化</font>是定义变量的时候赋给变量的值，强调从无到有这一过程。</li>
<li><font color="red">赋值</font>是初始化后用到该变量，赋给该变量新的值。<a id="more"></a>
</li>
</ul>
<h4 id="定义-vs-声明"><a href="#定义-vs-声明" class="headerlink" title="定义 vs 声明"></a>定义 vs 声明</h4><ul>
<li>变量的声明有两种情况<ul>
<li>一种是需要建立存储空间的：<code>int a;</code></li>
<li>另一种是不需要建立存储空间的：<code>extern int b;</code></li>
<li>前者是<strong>定义性声明(defining declaration)</strong>，或者称为<strong>定义(definition)</strong>，而后者是<strong>引用性声明(referencing declaration)</strong>。从广义的角度讲，声明中包含着定义，但不是所有的声明都是定义，因此这里所说的声明和定义，都是狭义上的，声明特指不需要建立存储空间的引用性声明；定义则指需要建立存储空间的定义性声明。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明</span></div><div class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明</span></div><div class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 定义</span></div><div class="line"><span class="keyword">int</span> a;</div></pre></td></tr></table></figure>
<ul>
<li>外部变量（普通全局变量）的定义只能有一次，其位置肯定在函数之外；而同一个文件中对一个外部变量的声明可以有多次，既可以在函数之内（哪个函数要用到就在那个函数中声明），也可以在函数之外（在外部变量的定义点之前）。</li>
</ul>
</li>
<li>函数的声明和定义则相对区分明显。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStringLen</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 函数定义（实现）</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStringLen</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://boyishachang.blog.51cto.com/3485129/1285493">声明、定义、初始化、赋值的区别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义（定义性声明）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明（引用性声明）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认初始化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 赋值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;l = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;引用性&lt;font color=&quot;red&quot;&gt;声明&lt;/font&gt;不分配存储空间，如：&lt;code&gt;extern int x;&lt;/code&gt;只是告诉编译器变量&lt;code&gt;x&lt;/code&gt;是整型，已经在其它地方定义了。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;定义&lt;/font&gt;是在内存中确定变量的位置、大小。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;初始化&lt;/font&gt;是定义变量的时候赋给变量的值，强调从无到有这一过程。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;赋值&lt;/font&gt;是初始化后用到该变量，赋给该变量新的值。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="C/C++" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/C-C/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0022] BST（二叉查找树）和 R-B Tree（红黑树）</title>
    <link href="http://durant35.github.io/2017/07/08/Algorithms_BST&amp;R-B%20Tree/"/>
    <id>http://durant35.github.io/2017/07/08/Algorithms_BST&amp;R-B Tree/</id>
    <published>2017-07-08T04:02:22.000Z</published>
    <updated>2017-07-11T03:52:16.963Z</updated>
    
    <content type="html"><![CDATA[<p>　一些计算机程序设计中常用的线性数据结构：<code>Array</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>List</code>、<code>Stack</code>、<code>Queue</code>、<code>Hashtable</code> 和<code>Dictionary</code>。为了更高效的进行数据的查找和访问，例如避免普通数据查找的 $O(N)$ 线性时间复杂度，常用树这种数据结构保存数据。<br>　树（Tree）是由多个节点（Node）的集合组成，每个节点又有多个与其关联的子节点（Child Node）；子节点就是直接处于节点之下的节点，而父节点（Parent Node）则位于节点直接关联的上方；树的根（Root）指的是一个没有父节点的单独的节点。所有的树都呈现了一些共有的性质：<font color="blue">①只有一个根节点；②除了根节点，所有节点都有且只有一个父节点；③无环。将任意一个节点作为起始节点，都不存在任何回到该起始节点的路径（正是前两个性质保证了无环的成立）</font>。<br>　更高效同时也相对更加复杂的树型数据结构包括 <strong>BST</strong>（二叉查找树）、<strong>R-B Tree</strong>（红黑树）、<strong>AVL Tree</strong>（平衡二叉树：父节点的左子树和右子树的高度之差不能大于1）、<strong>Treap</strong>（树堆：满足①二叉查找树的性质；满足②堆的性质）、<strong>Splay Tree</strong>（伸展树：在一次搜索后，会对树进行一些特殊的操作，这些操作的理念与AVL树有些类似，即通过旋转，来改变树节点的分布，并减小树的深度；伸展树并没有AVL树的平衡要求，任意节点的左右子树可以相差任意深度）、<strong>B-Tree</strong>（B树：多叉平衡查找树，<strong>B$^{+}$-Tree</strong>（B+树）是B树的变体）等。<br>　本文主要介绍基础的 <font color="red">BST（二叉查找树）</font>以及提升搜索效率的更高级的数据结构：<font color="red">R-B Tree（红黑树）</font>。<a id="more"></a></p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ul>
<li>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值</li>
<li>任意节点的左、右子树也分别为二叉查找树</li>
</ul>
</li>
<li>二叉查找树的一般结构：</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TreeNode &#123;</div><div class="line">  <span class="comment">// 节点关键字</span></div><div class="line">  <span class="keyword">int</span> key;</div><div class="line">  <span class="comment">// 节点卫星数据</span></div><div class="line">  type val;</div><div class="line">  <span class="comment">// 指向父节点</span></div><div class="line">  TreeNode* parent;</div><div class="line">  <span class="comment">// 指向左子树</span></div><div class="line">  TreeNode* left;</div><div class="line">  <span class="comment">// 指向右子树</span></div><div class="line">  TreeNode* right;</div><div class="line">  TreeNode(<span class="keyword">int</span> key): key(key), val(<span class="literal">NULL</span>), parent(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="查询二叉查找树"><a href="#查询二叉查找树" class="headerlink" title="查询二叉查找树"></a>查询二叉查找树</h4><p>　查询某元素、最大最小节点、前驱后继节点。</p>
<ul>
<li>查询某元素<ul>
<li>在二叉查找树中查询某个元素k<ul>
<li>若k大于当前节点关键字，则搜索其右子树；</li>
<li>若k小于当前节点关键字，则搜索其左子树；</li>
<li>若k等于当前节点关键字或者当前节点为空，返回当前节点。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>递归版本</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：node二叉查找树的根节点，k为待查找元素</span></div><div class="line"><span class="comment">//输出：查找到的对应节点</span></div><div class="line">Tree-Search(node, k)</div><div class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span> || k==node-&gt;key)</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">  <span class="keyword">if</span>(k &lt; node-&gt;key)</div><div class="line">    <span class="keyword">return</span> Tree-Search(node-&gt;left, k);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> Tree-Search(node-&gt;right, k);</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>非递归版本</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：node二叉查找树的根节点，k为待查找元素</span></div><div class="line"><span class="comment">//输出：查找到的对应节点</span></div><div class="line">Tree-Search(node, k)</div><div class="line">  <span class="keyword">while</span>(node!=<span class="literal">NULL</span> &amp;&amp; k!=node-&gt;key) &#123;</div><div class="line">    <span class="keyword">if</span>(k &lt; node-&gt;key)</div><div class="line">      node = node-&gt;left;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      node = node-&gt;right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> node;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>查询最大最小节点<ul>
<li>最大节点：二叉查找树最右侧节点</li>
<li>最小节点：二叉查找树最左侧节点</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Tree-Minimum(node)</div><div class="line">  <span class="keyword">while</span>(node-&gt;left != <span class="literal">NULL</span>)</div><div class="line">    node = node-&gt;left;</div><div class="line">  <span class="keyword">return</span> node;</div><div class="line"> </div><div class="line">Tree-Maximum(node)</div><div class="line">  <span class="keyword">while</span>(node-&gt;right != <span class="literal">NULL</span>)</div><div class="line">    node = node-&gt;right;</div><div class="line">  <span class="keyword">return</span> node;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>查询前驱后继节点<ul>
<li>后继：指关键字大于某节点<code>key[x]</code>的所有节点中，关键字最小的节点，即对树进行中序遍历，紧随其后的节点。</li>
<li>前驱：小于某节点<code>key[x]</code>的关键字中最大的那个节点，即树的中序遍历中，排在其前的节点。</li>
<li>求某个节点的后继节点分为三种情况：<ul>
<li>该节点有右子树，则其后继节点是其右子树的最左侧节点，即右子树的最小节点。</li>
<li>该节点无右子树，但是父节点的左孩子，则该节点的后继节点是该父节点。</li>
<li>该节点无右子树，且是父节点的右孩子，则需要一直向上搜索，直到它的<code>n-1</code>代祖先是它第<code>n</code>代祖先的左孩子，则它的后继就是第<code>n</code>个祖先。如果一直搜索到根节点，也没有找到<code>n-1</code>代祖先是它第<code>n</code>代祖先的左孩子，则该节点是整个树的中序遍历中的最后一个节点，即它没有后继。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Tree-Successor(node)</div><div class="line">  <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> Tree-Minimum(node-&gt;right)</div><div class="line">  <span class="comment">//x用来保存待确定的节点</span></div><div class="line">  <span class="comment">//y为x的父节点</span></div><div class="line">  x = node;</div><div class="line">  TreeNode y = x-&gt;parent;</div><div class="line">  <span class="comment">// x==y-&gt;right &lt;==&gt; x!=y-&gt;left</span></div><div class="line">  <span class="keyword">while</span>(y!=<span class="literal">NULL</span> &amp;&amp; x==y-&gt;right)</div><div class="line">    x = y;</div><div class="line">    y = x-&gt;parent;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> y;</div></pre></td></tr></table></figure>
<ul>
<li>求某个节点的前驱节点与求后继节点类似：<ul>
<li>该节点有左子树，则其前驱节点是其左子树的最右侧节点，即左子树的最大节点。</li>
<li>该节点无左子树，但是父节点的右孩子，则该节点的前驱节点是该父节点。</li>
<li>该节点无左子树，且是父节点的左孩子，则需要一直向上搜索，直到它的<code>n-1</code>代祖先是它第<code>n</code>代祖先的右孩子，则它的后继就是第<code>n</code>个祖先。如果一直搜索到根节点，也没有找到<code>n-1</code>代祖先是它第<code>n</code>代祖先的右孩子，则该节点是整个树的中序遍历中的第一个节点，即它没有前驱。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Tree-Predecessor(node)</div><div class="line">  <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> Tree-Maximum(node-&gt;right)</div><div class="line">  <span class="comment">//x用来保存待确定的节点</span></div><div class="line">  <span class="comment">//y为x的父节点</span></div><div class="line">  x = node;</div><div class="line">  TreeNode y = x-&gt;parent;</div><div class="line">  <span class="comment">// x==y-&gt;left &lt;==&gt; x!=y-&gt;right</span></div><div class="line">  <span class="keyword">while</span>(y!=<span class="literal">NULL</span> &amp;&amp; x==y-&gt;left)</div><div class="line">    x = y;</div><div class="line">    y = x-&gt;parent;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> y;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>　插入和删除需要在保持二叉查找树性质的情况下，对树进行修改。</p>
<ul>
<li>插入<ul>
<li>若为空树，则直接将插入的节点作为根节点；</li>
<li>若插入节点关键字小于当前节点关键字，应插入在当前节点左子树中；否则应插入在右子树中；</li>
<li>直到当前节点为叶子节点，则将插入节点变成当前节点的左孩子或右孩子。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Tree-Insert(root, node)</div><div class="line">  curNode = root</div><div class="line">  leafNode = <span class="literal">NULL</span></div><div class="line">  <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)</div><div class="line">    leafNode = curNode</div><div class="line">    <span class="keyword">if</span>(node-&gt;key &gt;= curNode-&gt;key)</div><div class="line">      curNode = curNode-&gt;right</div><div class="line">    <span class="keyword">else</span></div><div class="line">      curNode = curNode-&gt;left</div><div class="line"> </div><div class="line">  node-&gt;parent = leafNode</div><div class="line">  <span class="comment">// 当前树为空树</span></div><div class="line">  <span class="keyword">if</span>(leafNode==<span class="literal">NULL</span>)</div><div class="line">    root = node</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">if</span>(node-&gt;key &gt;= leafNode-&gt;key)</div><div class="line">      leafNode-&gt;right = node</div><div class="line">    <span class="keyword">else</span></div><div class="line">      leafNode-&gt;left = node</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>删除<ul>
<li>相比插入，删除操作较为复杂。删除操作分为三种情况：<ul>
<li>若删除节点为叶子节点（没有左右子树），此时删除该节点不会破坏二叉查找树的结构，则直接将其删除；</li>
<li>若删除节点只有一个子节点，则用子节点<strong>替代</strong>删除节点的位置（直接删除该节点，并将其左子树或者右子树设置为其父节点的左子树或者右子树即可，此操作不会破坏二叉查找树的结构），此时该子节点称为“替代节点”；</li>
<li>若删除节点有两个子节点，一般的删除策略是用其右子树的最小数据（容易找到）代替要删除的节点数据，并删除该节点（此时为<code>NULL</code>）：因为右子树的最小节点不可能有左孩子，所以第二次删除较为容易。<br><center><img src="/img/Algorithms/0022_BSTDeletewithLeftRight.png" width="640px" alt=""/></center><ul>
<li>右子树的最小数据即为当前节点的<strong>后继节点</strong>，$z$ 的左子树和右子树均不空，找到 $z$ 的后继 $y$，用 $y$ 的值代替 $z$ 的值；因为 $y$ 一定没有左子树，所以可以删除 $y$，并让 $y$ 的父亲节点成为 $y$ 的右子树的父亲节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">Tree-Delete(root, node)</div><div class="line">  curNode = root;</div><div class="line">  parent = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">NULL</span> != node) &#123;</div><div class="line">    <span class="keyword">if</span>(node-&gt;key &lt; curNode-&gt;key) &#123;</div><div class="line">      parent = curNode;</div><div class="line">      curNode = curNode-&gt;left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &gt; curNode-&gt;key) &#123;</div><div class="line">      parent = curNode;</div><div class="line">      curNode = curNode-&gt;right;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// found</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 叶子节点</span></div><div class="line">      <span class="keyword">if</span>(<span class="literal">NULL</span>==curNode-&gt;left &amp;&amp; <span class="literal">NULL</span>==curNode-&gt;right) &#123;</div><div class="line">        <span class="comment">// 根结点</span></div><div class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>) &#123; </div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 非根结点</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 父节点的左子树部分还是右子树部分</span></div><div class="line">          (parent-&gt;left==curNode)? (parent-&gt;left=<span class="literal">NULL</span>) : (parent-&gt;right=<span class="literal">NULL</span>);</div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 只有左孩子</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span>!=curNode-&gt;left &amp;&amp; <span class="literal">NULL</span>==curNode-&gt;right) &#123;</div><div class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>) &#123;</div><div class="line">          TreeNode tmp = curNode;</div><div class="line">          curNode = curNode-&gt;left;</div><div class="line">          <span class="keyword">delete</span> tmp;</div><div class="line">          tmp = <span class="literal">NULL</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 父节点的左子树部分还是右子树部分</span></div><div class="line">          (parent-&gt;left==curNode)?(parent-&gt;left=curNode-&gt;left):(parent-&gt;right=curNode-&gt;left);</div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 只有右孩子</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span>==curNode-&gt;left &amp;&amp; <span class="literal">NULL</span>!=curNode-&gt;right) &#123;</div><div class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>) &#123;</div><div class="line">          TreeNode tmp = curNode;</div><div class="line">          curNode = curNode-&gt;right;</div><div class="line">          <span class="keyword">delete</span> tmp;</div><div class="line">          tmp = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 父节点的左子树部分还是右子树部分</span></div><div class="line">          (parent-&gt;left==curNode)?(parent-&gt;left=curNode-&gt;right):(parent-&gt;right=curNode-&gt;right);</div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 既有左孩子又有右孩子</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        TreeNode* rightNode = curNode;</div><div class="line">        <span class="keyword">while</span>(rightNode-&gt;left != <span class="literal">NULL</span>) &#123;</div><div class="line">          parent = rightNode;</div><div class="line">          rightNode = rightNode-&gt;left;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 交换rightNode与curNode</span></div><div class="line">        <span class="keyword">int</span> swapKey = rightNode-&gt;key;</div><div class="line">        rightNode-&gt;key = curNode-&gt;key;</div><div class="line">        curNode-&gt;key = swapKey;</div><div class="line"> </div><div class="line">        <span class="comment">// 删除rightNode，parent肯定不为空</span></div><div class="line">        <span class="comment">// 后继节点没有右孩子</span></div><div class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == rightNode-&gt;right) &#123;</div><div class="line">          parent-&gt;left = <span class="literal">NULL</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          parent-&gt;left = rightNode-&gt;right;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">delete</span> rightNode;</div><div class="line">        rightNode = <span class="literal">NULL</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="满二叉树-amp-完全二叉树"><a href="#满二叉树-amp-完全二叉树" class="headerlink" title="满二叉树&amp;完全二叉树"></a>满二叉树&amp;完全二叉树</h4><ul>
<li>满二叉树（Full Binary Tree）<ul>
<li>官方解释<blockquote>
<p>A full binary tree is a tree in which every node other than the leaves has two children.</p>
</blockquote>
</li>
<li>总节点数 $k$：深度为 $h$，有 $k = 2^h - 1$</li>
<li>树高 $h$：$h = log_2 (k+1)$<center><img src="/img/Algorithms/0022_FBT&CBT.jpg" width="420px" alt=""/></center></li>
</ul>
</li>
<li>完全二叉树（Complete Binary Tree）<ul>
<li>官方解释<blockquote>
<p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>
</blockquote>
</li>
<li>深度为 $h$，有 $n$ 个节点的二叉树，当且仅当其每一个节点都与深度为 $h$ 的满二叉树中，序号为 $1$ 至 $n$ 的节点对应时，为一棵<strong>完全二叉树</strong>。</li>
<li>总节点数 $k$：深度为 $h$，有 $2^{h-1} \leq k \lt 2^h - 1$</li>
<li>树高 $h$：$h = log_2 k + 1$</li>
</ul>
</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>　一棵由 $N$ 个节点的随机构造的二叉查找树的高度为 $logN$，所以顺理成章，二叉查找树的一般操作（主要是查找）的执行时间为 $O(logN)$。但二叉查找树若退化成了一棵具有 $N$ 个节点的线性链后，这些操作就变成最坏情况，运行时间变成 $O(N)$。<br>　红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的插入、删除、主要是查找的时间复杂度最坏为 $O(logN)$。</p>
<ul>
<li>R-B Tree(Red-Black Tree)，它是一种特殊的二叉查找树，红黑树的每个节点除了包含<code>key</code>、<code>left</code>、<code>right</code>、<code>parent</code>外，还有存储位表示节点的颜色，可以是红(Red)或黑(Black)。但它是如何保证一棵 $N$ 个节点的红黑树的高度始终在 $logN$ 的呢？这就引出了红黑树的 5 个性质：<br>  <center><img src="/img/Algorithms/0022_R-B Tree.png" width="480px" alt=""/></center><ul>
<li>①每个节点不是黑色便是红色；</li>
<li>②根节点为黑色；</li>
<li>③每个叶子节点（<font color="red">即指树尾端那些空(<code>NIL</code>/<code>NULL</code>)的叶子节点</font>）是黑色的；</li>
<li>④如果一个节点是红色的，则它的子节点（两个子节点）必须是黑色的（<font color="red">即从每个叶子节点到根的所有路径上不能有两个连续的红色节点</font>）；</li>
<li>⑤从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<ul>
<li>对于任意节点而言，其到其子孙叶子节点树尾端<code>NIL</code>指针的每条路径都包含相同数目的黑节点。</li>
<li>确保没有一条路径会比其它路径长出两个节点（一红一黑），因此，红黑树相对是接近平衡的二叉树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　正是红黑树的这 5 条性质，使一棵 $N$ 个节点的红黑树始终保持了 $logN$ 的高度，也即</font color="blue">“保证了红黑树的插入、删除、主要是查找的时间复杂度最坏为 $O(logN)$”</font>。<br>　红黑树的应用比较广泛，主要用它来存储有序的数据，例如，Java 集合中的 TreeSet、TreeMap，C++ STL 中的 set、map，以及 Linux虚拟内存的管理，都是通过红黑树去实现的，它的时间复杂度是 $O(logN)$，效率非常之高。</p>
<h4 id="红黑树的搜索时间复杂度"><a href="#红黑树的搜索时间复杂度" class="headerlink" title="红黑树的搜索时间复杂度"></a>红黑树的搜索时间复杂度</h4><ul>
<li>下面通过<strong>数学归纳法</strong>证明定理：一棵含有$N$个节点的红黑树的高度至多为$2log(N+1)$<ul>
<li>转化为证明逆否命题<blockquote>
<p> “一棵含有 $N$ 个节点的红黑树的高度至多为 $2log(N+1)$” 的<font color="red">逆否命题</font>是：”高度为 $h$ 的红黑树，它包含的节点个数至少为 $2^{h/2}$-1 个”。我们只需要证明逆否命题，即可证明原命题为真，即只需证明 “高度为 $h$ 的红黑树，它包含的节点个数至少为 $2^{h/2}$-1 个”。</p>
</blockquote>
</li>
<li>从某个节点 $x$ 出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的<strong>黑高度(x’s black height)</strong>，记为 $bh(x)$。关于 $bh(x)$ 有两点需要说明：<ul>
<li>第1点：根据上述红黑树的<code>性质⑤</code>可知，从节点 $x$ 出发到达的所有的叶节点具有相同数目的黑节点，这也就意味着，$bh(x)$ 的值是唯一的！</li>
<li>第2点：根据上述红黑树的<code>性质④</code>可知，从节点 $x$ 出发达到叶节点：$所经历的黑色节点数目 \geq 所经历的红节点的数目$。假设 $x$ 是根节点，则可以得出结论：$bh(x=root) \geq h/2$。进而，我们只需证明：<font color="red">“高度为 $h$ 的红黑树，它包含的黑色节点个数至少为 $2^{bh(x)}$-1个”</font> 即可。</li>
</ul>
</li>
<li><strong>“数学归纳法”</strong> 论证：<font color="blue">“高度为 $h$ 的红黑树，它包含的黑色节点个数至少为 $2^{bh(x)}$-1个”</font><ul>
<li>①当树的高度 $h=0$ 时，节点个数是 0，$bh(x)$ 为 0，$2^{bh(x)}$-1 也为 0。显然，原命题成立。</li>
<li>②当 $h \gt 0$，无妨设树的高度为 $h$-1 时，它包含的节点个数至少为 $2^{bh(x)-1}$-1。<ul>
<li>当树的高度为 $h$ 时，对于节点 $x$（$x$ 为根节点），其黑高度为 $bh(x)$；对于节点 $x$ 的左右子树，它们黑高度为 $bh(x)$ 或者 $bh(x)$-1；</li>
<li>根据假设条件，我们已知 <font color="blue">“$x$ 的左右子树，即高度为 $h$-1 的节点，它包含的节点至少为 $2^{bh(x)-1}$-1 个” </font>；</li>
<li>所以，节点 $x$ 所包含的节点至少为：$(2^{bh(x)-1}-1) + (2^{bh(x)-1}-1) + 1 = 2^{bh(x)}-1$，即节点 $x$ 所包含的节点至少为 $2^{bh(x)}$-1。因此，原命题成立。</li>
</ul>
</li>
<li>结合①、②，得出：<font color="blue">“高度为 $h$ 的红黑树，它包含的黑色节点个数至少为 $2^{bh(x)}$-1个”</font>，因此，<font color="red">“一棵含有 $N$ 个节点的红黑树的高度至多为 $2log(N+1)$”</font>。</li>
</ul>
</li>
</ul>
</li>
<li>上述定理说明：一棵 $N$ 个节点的红黑树始终能保持 $logN$ 的高度，故</font color="blue">红黑树的各操作时间复杂度最坏为 $O(logN)$</font>，红黑树的搜索时间复杂度为：$logN$。</li>
</ul>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>当对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对树进行相关的<font color="blue">旋转操作（修改树的指针结构）</font>，以及对节点进行<font color="blue">重新着色（修改树中某些节点的颜色）</font>，来达到对红黑树进行插入或删除等操作后继续保持它的性质 $\Longrightarrow$ 平衡的目的。  <center><img src="/img/Algorithms/0022_LeftRightRotate.png" width="640px" alt=""/></center></li>
<li>如上图所示，从左图到右图的过程为左旋，反之为右旋。旋转前后 $x$、$y$ 与三棵子树 $\alpha$、$\beta$、$\gamma$ 之间的大小关系均满足红黑树的搜索性质：$\alpha \lt x \lt \beta \lt y \lt \gamma$ </li>
<li>左旋转：以 $y$ 节点为中心，将 $x$、$y$ 之间的轴（蓝色箭头）左旋（逆时针旋转），这使得 $y$ 称为该子树的新根；对 $x$ 进行左旋，意味着将 $x$ 变成一个左节点，显然是新根（即原本 $x$ 的右孩子 $y$）的左节点。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：root为树的根节点，x与x的右子节点为待左旋的节点</span></div><div class="line"><span class="comment">//输出：旋转后的树结构</span></div><div class="line">Left-Rotate(root, x)</div><div class="line">  <span class="comment">// 前提</span></div><div class="line">  y = x-&gt;right</div><div class="line">  </div><div class="line">  <span class="comment">// 将β设为x的右孩子</span></div><div class="line">  x-&gt;right = y-&gt;left</div><div class="line">  <span class="comment">// 将β的父亲设为x</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> != y-&gt;left)</div><div class="line">    y-&gt;left-&gt;parent = x</div><div class="line">  </div><div class="line">  <span class="comment">// 情况1：x的父节点为空，即x原先为根节点，将y设为根节点</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == x-&gt;parent)</div><div class="line">    root = y</div><div class="line">  <span class="comment">// 情况2：子树的根x原先是它的父亲的左孩子，将y设为x的父亲的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">    x-&gt;parent-&gt;left = y</div><div class="line">  <span class="comment">// 情况3：子树的根x原先是它的父亲的右孩子，将y设为x的父亲的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    x-&gt;parent-&gt;right = y</div><div class="line">   </div><div class="line">  <span class="comment">// 将x设为y的左孩子</span></div><div class="line">  y-&gt;left = x</div><div class="line">  <span class="comment">// 将x的父节点设为y</span></div><div class="line">  x-&gt;parent = y</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>右旋转</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：root为树的根节点，y与y的左子节点为待右旋的节点</span></div><div class="line"><span class="comment">//输出：旋转后的树结构</span></div><div class="line">Right-Rotate(root, y)</div><div class="line">  <span class="comment">// 前提</span></div><div class="line">  x = y-&gt;left</div><div class="line"> </div><div class="line">  <span class="comment">// 将β设为y的左孩子</span></div><div class="line">  y-&gt;left = x-&gt;right</div><div class="line">  <span class="comment">// 将β的父亲设为x</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> != x-&gt;right)</div><div class="line">    x-&gt;right-&gt;parent = y</div><div class="line"> </div><div class="line">  <span class="comment">// 情况1：y的父节点为空，即y原先为根节点，将x设为根节点</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == y-&gt;parent)</div><div class="line">    root = x</div><div class="line">  <span class="comment">// 情况2：子树的根y原先是它的父亲的左孩子，将x设为y的父亲的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;left)</div><div class="line">    y-&gt;parent-&gt;left = x</div><div class="line">  <span class="comment">// 情况3：子树的根y原先是它的父亲的右孩子，将x设为y的父亲的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    x-&gt;parent-&gt;right = y</div><div class="line"> </div><div class="line">  <span class="comment">// 将y设为x的右孩子</span></div><div class="line">  x-&gt;right = y</div><div class="line">  <span class="comment">// 将y的父节点设为x</span></div><div class="line">  y-&gt;parent = x</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>一棵红黑树在经过左旋和右旋之后，树的搜索性质（二叉查找树性质）保持不变，但树的红黑性质则被破坏了，因此需要通过重新着色来恢复树的红黑性质。</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>　将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当做一棵二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一棵红黑树。</p>
<ul>
<li>将红黑树当做一棵二叉查找树，将节点插入。<ul>
<li>无论是左旋还是右旋，若旋转之前这棵树是一棵二叉查找树，旋转之后它一定还是二叉查找树；任何的旋转和重新着色操作，都不会改变它仍然是一棵二叉查找树的事实。</li>
<li>红黑树本身就是一棵二叉查找树，将节点插入后，该树仍然是一棵二叉查找树，即树的键值仍然是有序的。</li>
</ul>
</li>
<li>将插入的节点着色为“红色”。为什么着色成红色，而不是黑色呢？因为将着色为“红色”，不会违背红黑树<code>性质⑤</code>：从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点；少违背一条特性，就意味着我们需要处理的情况越少，接下来只需要使其满足其它性质即可。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// root为红黑树的树根，z为要插入的新节点</span></div><div class="line">RB-Insert(root, z)</div><div class="line">  <span class="comment">// 新建节点y，将y设为空节点</span></div><div class="line">  y = <span class="literal">NULL</span>;</div><div class="line">  <span class="comment">// 设红黑树的根节点为x</span></div><div class="line">  x = root;</div><div class="line"> </div><div class="line">  <span class="comment">// 找出要插入新节点z在二叉树中的位置y</span></div><div class="line">  <span class="keyword">while</span>(<span class="literal">NULL</span> != x)</div><div class="line">    y = x;</div><div class="line">    <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)</div><div class="line">      x = x-&gt;left;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      x = x-&gt;right;</div><div class="line"> </div><div class="line">  <span class="comment">// 设z的父亲为y</span></div><div class="line">  z-&gt;parent = y;</div><div class="line">  <span class="comment">// 情况1：y是空节点，将z设为根</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == y)</div><div class="line">    root = z;</div><div class="line">  <span class="comment">// 情况2：z设为y的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key)</div><div class="line">    y-&gt;left = z;</div><div class="line">  <span class="comment">// 情况3：z设为y的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    y-&gt;right = z;</div><div class="line"> </div><div class="line">  <span class="comment">// z的左右孩子设为空格</span></div><div class="line">  z-&gt;left = <span class="literal">NULL</span>;</div><div class="line">  z-&gt;right = <span class="literal">NULL</span>;</div><div class="line">  <span class="comment">// 至此，已经完成将新节点z插入到二叉树中</span></div><div class="line"> </div><div class="line">  <span class="comment">// 将z着色为“红色”</span></div><div class="line">  z-&gt;color = RED;</div><div class="line">  <span class="comment">// 通过RB-Insert-Fixup对红黑树的节点进行颜色修改以及旋转，让树仍然是一棵红黑树</span></div><div class="line">  RB-Insert-Fixup(root, z);</div></pre></td></tr></table></figure>
<ul>
<li>接下来的问题就是：想方设法地旋转以及重新着色，是这棵树重新称为一棵红黑树！</li>
</ul>
</li>
<li>通过一系列的旋转或重新着色操作，使之重新成为一棵红黑树。<ul>
<li>将插入节点着色为“红色”之后，不会违背<code>性质⑤</code>，那它到底会违背哪些性质呢？<ul>
<li>对于<code>性质①</code>，因为已经将它涂成红色了，显然不会违背；</li>
<li>对于<code>性质②</code>，在上面步骤中我们将红黑树当做二叉查找树，然后执行插入操作；根据二叉查找树的特点，除非是根节点，插入操作不会改变根节点，所以，根节点仍然是黑色，除非插入的就是根节点；</li>
<li>对于<code>性质③</code>，显然不会违背，这里的叶子节点是指空叶子节点，插入非空节点（其左右空叶子节点初始化即为黑色的）并不会对它们造成影响；</li>
<li>对于<code>性质④</code>，很有可能违背！接下来是想办法使这棵树满足<code>性质④</code>，将树重新构造成红黑树。</li>
</ul>
</li>
<li>根据被插入节点 $N$ 的父节点的情况，可以划分为以下三类情况处理：<ul>
<li>第一类：被插入的节点是根节点 $\Longrightarrow$ 直接把新节点涂为黑色</li>
<li>第二类：被插入节点的父节点是黑色节点 $\Longrightarrow$ 新节点被插入后，仍然是红黑树</li>
<li>第三类：被插入节点的父节点是红色节点 $\Longrightarrow$ 显然与<code>性质⑤</code>冲突，这种情况下，新节点一定存在非空祖父节点（肯定有黑色的节点作为父节点的父节点）；新节点也一定存在叔叔节点，即使叔叔节点为空叶子节点，其本身也是黑色节点，视之为存在。对于这类情况，需要依据“叔叔节点的情况”，进一步划分为一下三种情况（这三种情况可能存在一定转换关系）。<ul>
<li>Case 1：叔叔节点 $U$ 是红色节点<br><center><img src="/img/Algorithms/0022_RBInsertCase1.png" width="720px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $P$ 设为黑色节点；</li>
<li>将叔叔节点 $U$ 设为黑色节点；</li>
<li>将祖父节点 $G$ 设为红色节点；</li>
<li>将祖父节点设为“当前节点”$N$，之后继续对“当前节点”进行操作。</li>
</ol>
</li>
<li>Case 2：叔叔节点 $14$ 是黑色节点，且当前节点 $N$ 是右孩子<br><center><img src="/img/Algorithms/0022_RBInsertCase2.png" width="720px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $2$ 作为新的“当前节点”$N$；</li>
<li>以新的“当前节点”$N$ 为支点进行左旋。</li>
</ol>
</li>
<li>Case 3：叔叔节点 $14$ 是黑色节点，且当前节点 $N$ 是左孩子<br><center><img src="/img/Algorithms/0022_RBInsertCase3.png" width="720px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $7$ 设为黑色节点；</li>
<li>将祖父节点 $11$ 设为红色节点；</li>
<li>以祖父节点 $11$ 为支点进行右旋。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// root为红黑树的树根，z为要插入的新节点</span></div><div class="line">RB-Insert-Fixup(root, z)</div><div class="line">  <span class="comment">// 若当前节点z的父节点是红色，则进行以下处理</span></div><div class="line">  <span class="keyword">while</span>(RED == z-&gt;parent-&gt;color)</div><div class="line">    <span class="comment">// 若z的父节点是z的祖父节点的左孩子</span></div><div class="line">    <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)</div><div class="line">      <span class="comment">// 将y设置为z的叔叔节点（z的祖父节点的右孩子）</span></div><div class="line">      y = z-&gt;parent-&gt;parent-&gt;right;</div><div class="line"> </div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == y-&gt;color)</div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        y-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        z = z-&gt;parent-&gt;parent;</div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(z == z-&gt;parent-&gt;right)</div><div class="line">        Left-Rotate(root, z);</div><div class="line">      <span class="comment">// Case 3</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        Right-Rotate(root, z-&gt;parent-&gt;parent);</div><div class="line">    <span class="comment">// z在父节点是z的祖父节点的右孩子，与左子树原理相同，将right与left互换即可</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment">// 将y设置为z的叔叔节点（z的祖父节点的左孩子）</span></div><div class="line">      y = z-&gt;parent-&gt;parent-&gt;left;</div><div class="line"> </div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == y-&gt;color)</div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        y-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        z = z-&gt;parent-&gt;parent;</div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(z == z-&gt;parent-&gt;left)</div><div class="line">        Right-Rotate(root, z);</div><div class="line">      <span class="comment">// Case 3</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        Left-Rotate(root, z-&gt;parent-&gt;parent);</div><div class="line">  <span class="comment">// 被插入的节点是根节点</span></div><div class="line">  root-&gt;color = BLACK;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>　将红黑树内的某一个节点删除，需要执行的操作依次是：首先将红黑树当做一棵二叉查找树，将该节点从二叉查找树中删除；然后，通过“旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</p>
<ul>
<li>将红黑树当做一棵二叉查找树，将节点删除，这和在常规二叉查找树中删除节点的方法一样，分3种情况：<ul>
<li>①被删除节点没有儿子，即为叶子节点，那么，直接将该节点删除；</li>
<li>②被删除节点只有一个儿子，那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置；</li>
<li>③被删除节点有两个儿子，那么，先找出它的后继节点，然后把该后继节点的“内容”复制给该节点的“内容”，之后删除该后继节点。<ul>
<li>该后继节点相当于替身，在将后继节点的“内容”赋值给被删除节点之后，再将后继节点删除，这样就巧妙地将问题转换为“删除后继节点”的情况了；</li>
<li>在被删除节点有两个非空子节点的情况下，它的后继节点不可能是双子非空的（至少左孩子为空，否则显然不可能是后继节点）：若没有儿子，则按<code>情况①</code>进行处理；若只有一个儿子，则按<code>情况②</code>进行处理。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">RB-Delete(root, z)</div><div class="line">  <span class="comment">// 若z的左孩子或右孩子为空</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span>==z-&gt;left || <span class="literal">NULL</span>==z-&gt;right)</div><div class="line">    y = z;</div><div class="line">  <span class="comment">// 将z的后继节点赋值给y</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    y = Tree-Successor(z);</div><div class="line"> </div><div class="line">  <span class="comment">// y至少一个孩子为空</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> != y-&gt;left)</div><div class="line">    x = y-&gt;left;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    x = y-&gt;right;</div><div class="line"> </div><div class="line">  <span class="comment">// 将y的父节点设置为x的父节点</span></div><div class="line">  x-&gt;parent = y-&gt;parent;</div><div class="line"> </div><div class="line">  <span class="comment">// 情况1：y的父节点为空，则设置x为根节点</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == y-&gt;parent)</div><div class="line">    root = x;</div><div class="line">  <span class="comment">// 情况2：y是它父节点的左孩子，则设置x为y的父节点的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(y == y&gt;parent-&gt;left)</div><div class="line">    y-&gt;parent-&gt;left = x;</div><div class="line">  <span class="comment">// 情况3：y是它父节点的右孩子，则设置x为y的父节点的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    y-&gt;parent-&gt;right = x;</div><div class="line"> </div><div class="line">  <span class="comment">// 将z的后继节点y的值赋值给z，这里只拷贝z的值给y，而没有拷贝z的颜色!!!</span></div><div class="line">  <span class="keyword">if</span>(y != z)</div><div class="line">    z-&gt;key = y-&gt;key;</div><div class="line">    <span class="comment">//copy y's satelite date into z;</span></div><div class="line"> </div><div class="line">  <span class="comment">// 若y为黑色节点</span></div><div class="line">  <span class="keyword">if</span>(BLACK == y-&gt;color)</div><div class="line">    RB-Delete-Fixup(root, x);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>上一步中删除节点之后，可能会违背红黑树的性质，所以需要通过“旋转和重新着色”来修正该树，使之重新成为一棵红黑树。<ul>
<li>由上面的算法，我们知道：删除节点 $y$ 之后，$x$ 占据了原本节点 $y$ 的位置。既然删除 $y$（$y$ 是黑色节点），意味着减少一个黑色节点，那么，再在该位置上增加一个黑色节点即可，即假设“$x$ 包含一个额外的黑色节点”（$x$ 最终需要变成一个黑色节点），就正好弥补了“删除 $y$ 所丢失的黑色节点”，也就不会违反<code>性质⑤</code>；<ul>
<li>现在，$x$ 不仅包含它原本的颜色属性，还包含一个额外的颜色，即 $x$ 的颜色属性是“红+黑”或者“黑+黑”，它违反了<code>性质①</code>；我们面临的问题，由解决“违反<code>性质②</code>、<code>性质④</code>、<code>性质⑤</code>”转换成了解决违反<code>性质①</code>、<code>性质②</code>、<code>性质④</code>”；</li>
</ul>
</li>
<li>解决的思想是：将 $x$ 所包含的额外的黑色属性不断沿树上移（向根方向移动：<code>Case 2</code>），直到出现下面的情况：<ul>
<li>第一类：$x$ 是“红+黑”节点，此时，直接将 $x$ 设为一个“黑”节点即可，红黑树的性质全部恢复；<ul>
<li>如果删除的节点是红色节点，则删除后，树依然能够保持红黑性？？？（<font color="red">错误的命题？</font>）<ol>
<li>树中各节点的黑高度不会发生变化？可能会发生变化；</li>
<li>不存在父子节点都是红色节点的情况；</li>
<li>根依然是黑色节点。</li>
</ol>
</li>
</ul>
</li>
<li>第二类：$x$是“黑+黑”节点且 $x$ 是根，此时，将 $x$ 设为一个“黑”节点即可，红黑树的性质全部恢复；</li>
<li>第三类：$x$是“黑+黑”节点但 $x$ 不是根，这种情况又可以划分为以下 4 种情况：<ul>
<li>Case 1：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是红色（此时 $A$ 的父节点 $B$ 和 $A$ 的兄弟节点的子节点 $C$、$E$ 都是黑色）<br><center><img src="/img/Algorithms/0022_RBDeleteCase1.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将 $A$ 的兄弟节点 $D$ 设为黑色节点；</li>
<li>将 $A$ 的父节点 $B$ 设为红色节点；</li>
<li>对 $A$ 的父节点 $B$ 进行左旋（BD为轴）；</li>
<li>左旋后，由于 $A$ 的兄弟节点发生了变化，需要更新 $A$ 的兄弟节点（由 $D$ 变成 $C$），继续进行后续处理（Case 1 转换为 Case 2、Case 3 或 Case 4）。</li>
</ol>
</li>
<li>Case 2：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是黑色，$A$ 的兄弟节点的两个孩子 $C$、$E$ 都是黑色<br><center><img src="/img/Algorithms/0022_RBDeleteCase2.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将兄弟节点 $D$ 设为红色节点；</li>
<li>将父节点 $B$ 设为新的“当前节点”$N$，之后继续对“当前节点”进行操作。</li>
</ol>
</li>
<li>Case 3：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是黑色；$A$ 的兄弟节点的左孩子 $C$ 是红色节点、右孩子 $E$ 是黑色节点<br><center><img src="/img/Algorithms/0022_RBDeleteCase3.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将兄弟节点 $D$ 的左孩子 $C$ 设为黑色节点；</li>
<li>将兄弟节点 $D$ 设为红色节点；</li>
<li>对兄弟节点 $D$ 进行右旋；</li>
<li>右旋后，需要更新 $A$ 的兄弟节点（由 $D$ 变成 $C$），继续进行后续处理（Case 3 转换为 Case 4）。</li>
</ol>
</li>
<li>Case 4：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是黑色；$A$ 的兄弟节点的右孩子 $E$ 是红色节点、左孩子 $C$ 可以是任意颜色<br><center><img src="/img/Algorithms/0022_RBDeleteCase4.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $B$ 的颜色赋值给兄弟节点 $D$；</li>
<li>将父节点 $B$ 设为黑色节点；</li>
<li>将兄弟节点 $D$ 的右孩子 $E$ 设为黑色节点；</li>
<li>对父节点 $B$ 进行左旋；</li>
<li>设置 $x$ 设为根节点，就可以跳出<code>while</code>循环，即完成了全部处理。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>上述<code>Case 1-4</code>都只是树的局部，并非树的整体部分；且删除后红黑树恢复<code>Case 3</code>、<code>Case 4</code>在经过上面的调整后，还要继续调整直至重新恢复平衡。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x：被删除节点位置的替换节点</span></div><div class="line">RB-Delete-Fixup(root, x)</div><div class="line">  <span class="comment">// 删除节点x是根节点或删除节点x是红色节点，红黑树的性质都能保持!!!</span></div><div class="line">  <span class="keyword">while</span>(x!=root &amp;&amp; BLACK==x-&gt;color)</div><div class="line">    <span class="comment">// x是它父节点的左孩子，w为x叔叔，即父节点的右孩子</span></div><div class="line">    <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">      w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == w-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为黑色</span></div><div class="line">        w-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的父节点设为红色</span></div><div class="line">        x-&gt;parent-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的父节点进行左旋</span></div><div class="line">        Left-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 左旋后，重新设置x的兄弟节点</span></div><div class="line">        w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 1 ==&gt; Case 2、3、4</span></div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">if</span>(BLACK==w-&gt;left-&gt;color &amp;&amp; BLACK==w-&gt;right-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 设置x的父节点为新一轮迭代的x节点，向上转移</span></div><div class="line">        x = x-&gt;parent;</div><div class="line">      <span class="comment">// Case 3：x的兄弟节点左孩子是红色，右孩子是黑色</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(BLACK==w-&gt;right-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点的左孩子设为黑色</span></div><div class="line">        w-&gt;left-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的兄弟节点进行右旋</span></div><div class="line">        Right-Rotate(root, w);</div><div class="line">        <span class="comment">// 右旋后，重新设置x的兄弟节点，进行下一轮迭代 ==&gt; Case 4</span></div><div class="line">        w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 4：z的兄弟节点右孩子是红色，左孩子任意颜色</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="comment">// 将x父节点的颜色赋值给x的兄弟节点</span></div><div class="line">        w-&gt;color = x-&gt;parent-&gt;color;</div><div class="line">        <span class="comment">// 将x父节点设为黑色</span></div><div class="line">        x-&gt;parent-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 将x兄弟节点的右孩子设为黑色</span></div><div class="line">        w-&gt;right-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 对x的父节点进行左旋</span></div><div class="line">        Left-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 设置x为根节点，退出while循环</span></div><div class="line">        x = root;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment">// z是父节点的右孩子，与左子树原理相同，将right与left互换即可</span></div><div class="line">      w = x-&gt;parent-&gt;left;</div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == w-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为黑色</span></div><div class="line">        w-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的父节点设为红色</span></div><div class="line">        x-&gt;parent-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的父节点进行右旋</span></div><div class="line">        Right-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 右旋后，重新设置x的兄弟节点</span></div><div class="line">        w = x-&gt;parent-&gt;left;</div><div class="line">      <span class="comment">// Case 1 ==&gt; Case 2、3、4</span></div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">if</span>(BLACK==w-&gt;left-&gt;color &amp;&amp; BLACK==w-&gt;right-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 设置x的父节点为新一轮迭代的x节点，向上转移</span></div><div class="line">        x = x-&gt;parent;</div><div class="line">      <span class="comment">// Case 3：x的兄弟节点右孩子是红色，左孩子是黑色</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(BLACK==w-&gt;left-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点的右孩子设为黑色</span></div><div class="line">        w-&gt;right-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的兄弟节点进行左旋</span></div><div class="line">        Left-Rotate(root, w);</div><div class="line">        <span class="comment">// 左旋后，重新设置x的兄弟节点，进行下一轮迭代 ==&gt; Case 4</span></div><div class="line">        w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 4：z的兄弟节点左孩子是红色，右孩子任意颜色</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="comment">// 将x父节点的颜色赋值给x的兄弟节点</span></div><div class="line">        w-&gt;color = x-&gt;parent-&gt;color;</div><div class="line">        <span class="comment">// 将x父节点设为黑色</span></div><div class="line">        x-&gt;parent-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 将x兄弟节点的左孩子设为黑色</span></div><div class="line">        w-&gt;left-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 对x的父节点进行右旋</span></div><div class="line">        Right-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 设置x为根节点，退出while循环</span></div><div class="line">        x = root;</div><div class="line"> </div><div class="line">  x-&gt;color = BLACK;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html">浅谈算法和数据结构: 七 二叉查找树</a></li>
<li><a href="http://www.cnblogs.com/gaochundong/p/binary_search_tree.html">Scale-out Thinking：二叉查找树</a></li>
<li><a href="http://blog.csdn.net/u014593748/article/details/72857498">二叉搜索树</a></li>
<li><a href="http://blog.csdn.net/lalor/article/details/7621239">求一棵二叉树中任意节点的后继节点（后继节点是指在中序遍历中紧随其后的节点）</a></li>
<li><a href="http://blog.csdn.net/dengzhilong_cpp/article/details/6669641">二叉查找树后继节点和前驱节点查找</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3245399.html">Sky Wang ：红黑树(一)之 原理和算法详细介绍</a></li>
<li><a href="http://blog.csdn.net/u014593748/article/details/72864573">KDK‘s CSDN：红黑树</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6105630">July’s CSDN：教你初步了解红黑树</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　一些计算机程序设计中常用的线性数据结构：&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;LinkedList&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Stack&lt;/code&gt;、&lt;code&gt;Queue&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt; 和&lt;code&gt;Dictionary&lt;/code&gt;。为了更高效的进行数据的查找和访问，例如避免普通数据查找的 $O(N)$ 线性时间复杂度，常用树这种数据结构保存数据。&lt;br&gt;　树（Tree）是由多个节点（Node）的集合组成，每个节点又有多个与其关联的子节点（Child Node）；子节点就是直接处于节点之下的节点，而父节点（Parent Node）则位于节点直接关联的上方；树的根（Root）指的是一个没有父节点的单独的节点。所有的树都呈现了一些共有的性质：&lt;font color=&quot;blue&quot;&gt;①只有一个根节点；②除了根节点，所有节点都有且只有一个父节点；③无环。将任意一个节点作为起始节点，都不存在任何回到该起始节点的路径（正是前两个性质保证了无环的成立）&lt;/font&gt;。&lt;br&gt;　更高效同时也相对更加复杂的树型数据结构包括 &lt;strong&gt;BST&lt;/strong&gt;（二叉查找树）、&lt;strong&gt;R-B Tree&lt;/strong&gt;（红黑树）、&lt;strong&gt;AVL Tree&lt;/strong&gt;（平衡二叉树：父节点的左子树和右子树的高度之差不能大于1）、&lt;strong&gt;Treap&lt;/strong&gt;（树堆：满足①二叉查找树的性质；满足②堆的性质）、&lt;strong&gt;Splay Tree&lt;/strong&gt;（伸展树：在一次搜索后，会对树进行一些特殊的操作，这些操作的理念与AVL树有些类似，即通过旋转，来改变树节点的分布，并减小树的深度；伸展树并没有AVL树的平衡要求，任意节点的左右子树可以相差任意深度）、&lt;strong&gt;B-Tree&lt;/strong&gt;（B树：多叉平衡查找树，&lt;strong&gt;B$^{+}$-Tree&lt;/strong&gt;（B+树）是B树的变体）等。&lt;br&gt;　本文主要介绍基础的 &lt;font color=&quot;red&quot;&gt;BST（二叉查找树）&lt;/font&gt;以及提升搜索效率的更高级的数据结构：&lt;font color=&quot;red&quot;&gt;R-B Tree（红黑树）&lt;/font&gt;。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>声明/定义/初始化/赋值</title>
    <link href="http://durant35.github.io/2017/07/07/programPearls_declaration&amp;definition&amp;initialization&amp;assignment/"/>
    <id>http://durant35.github.io/2017/07/07/programPearls_declaration&amp;definition&amp;initialization&amp;assignment/</id>
    <published>2017-07-07T06:02:16.000Z</published>
    <updated>2017-07-07T06:36:05.935Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义（定义性声明）</span></div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="comment">// 声明（引用性声明）</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> j;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line"><span class="keyword">int</span> k = <span class="number">7</span>;</div><div class="line"><span class="comment">// 默认初始化</span></div><div class="line"><span class="keyword">int</span> l;</div><div class="line"><span class="comment">// 赋值</span></div><div class="line">l = <span class="number">100</span>;</div></pre></td></tr></table></figure>
<ul>
<li>引用性<font color="red">声明</font>不分配存储空间，如：<code>extern int x;</code>只是告诉编译器变量<code>x</code>是整型，已经在其它地方定义了。</li>
<li><font color="red">定义</font>是在内存中确定变量的位置、大小。</li>
<li><font color="red">初始化</font>是定义变量的时候赋给变量的值，强调从无到有这一过程。</li>
<li><font color="red">赋值</font>是初始化后用到该变量，赋给该变量新的值。<a id="more"></a>
</li>
</ul>
<h4 id="定义-vs-声明"><a href="#定义-vs-声明" class="headerlink" title="定义 vs 声明"></a>定义 vs 声明</h4><ul>
<li>变量的声明有两种情况<ul>
<li>一种是需要建立存储空间的：<code>int a;</code></li>
<li>另一种是不需要建立存储空间的：<code>extern int b;</code></li>
<li>前者是<strong>定义性声明(defining declaration)</strong>，或者称为<strong>定义(definition)</strong>，而后者是<strong>引用性声明(referencing declaration)</strong>。从广义的角度讲，声明中包含着定义，但不是所有的声明都是定义，因此这里所说的声明和定义，都是狭义上的，声明特指不需要建立存储空间的引用性声明；定义则指需要建立存储空间的定义性声明。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明</span></div><div class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明</span></div><div class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 定义</span></div><div class="line"><span class="keyword">int</span> a;</div></pre></td></tr></table></figure>
<ul>
<li>外部变量（普通全局变量）的定义只能有一次，其位置肯定在函数之外；而同一个文件中对一个外部变量的声明可以有多次，既可以在函数之内（哪个函数要用到就在那个函数中声明），也可以在函数之外（在外部变量的定义点之前）。</li>
</ul>
</li>
<li>函数的声明和定义则相对区分明显。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStringLen</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 函数定义（实现）</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStringLen</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://boyishachang.blog.51cto.com/3485129/1285493">声明、定义、初始化、赋值的区别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义（定义性声明）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明（引用性声明）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认初始化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 赋值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;l = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;引用性&lt;font color=&quot;red&quot;&gt;声明&lt;/font&gt;不分配存储空间，如：&lt;code&gt;extern int x;&lt;/code&gt;只是告诉编译器变量&lt;code&gt;x&lt;/code&gt;是整型，已经在其它地方定义了。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;定义&lt;/font&gt;是在内存中确定变量的位置、大小。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;初始化&lt;/font&gt;是定义变量的时候赋给变量的值，强调从无到有这一过程。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;赋值&lt;/font&gt;是初始化后用到该变量，赋给该变量新的值。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="C/C++" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/C-C/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>C/C++常见修饰符（inline&amp;static&amp;const&amp;extern&amp;volatile）</title>
    <link href="http://durant35.github.io/2017/07/06/programPearls_inline&amp;static&amp;const&amp;extern&amp;volatile/"/>
    <id>http://durant35.github.io/2017/07/06/programPearls_inline&amp;static&amp;const&amp;extern&amp;volatile/</id>
    <published>2017-07-06T08:02:16.000Z</published>
    <updated>2017-07-08T00:58:08.415Z</updated>
    
    <content type="html"><![CDATA[<p>　本文是关于C/C++语言中常见的五个修饰符：<code>static</code>、<code>const</code>、<code>extern</code>、<code>inline</code>、<code>volatile</code>的含义和用法，在阅读本文前，建议先通过<a href="https://durant35.github.io/2017/07/07/programPearls_declaration&amp;definition&amp;initialization&amp;assignment/">《声明/定义/初始化/赋值》</a>了解有关C/C++中定义、声明等概念以及变量声明和定义的区别。<br><a id="more"></a></p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul>
<li>关键字static有着不同不同寻常的历史。起初，在C中引入关键字<code>static</code>是为了表示退出一个块后仍然存在的局部变量；随后，<code>static</code>在C中有了第二种含义：用来表示不能被其它文件访问的全局变量和函数。为了避免引入新的关键字，所以仍使用static关键字来表示这第二种含义。</li>
<li>static的三个作用<ul>
<li>①控制存储方式（生命周期）：函数内部的<code>static</code>变量，即静态局部变量，因为是局部变量，已经是内部连接了。<ul>
<li>控制存储方式 $\Longrightarrow$ 静态存储区：持久性+默认值为0。<ul>
<li>①存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。</li>
<li>②在静态数据区，内存中所有的字节默认值都是<code>0x00</code>（对于整型为0；对于字符数组为<code>&#39;\0&#39;</code>），某些时候这一特点可以减少程序员的工作量。</li>
</ul>
</li>
<li><code>static</code>修饰局部变量<ul>
<li>一般情况下，局部变量是放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了；如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束 $\Longrightarrow$ 生命周期及其存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。</li>
<li>在用<code>static</code>修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次。</li>
</ul>
</li>
</ul>
</li>
<li>②控制可见性与连接类型（作用域）：<code>static</code>全局变量，因为是全局变量，已经是静态存储了。<ul>
<li>控制可见性 $\Longrightarrow$ 隐藏<ul>
<li>当我们同时编译多个文件时，所有未加<code>static</code>前缀的全局变量和函数都具有全局可见性（源程序中的其它文件也能访问）。</li>
<li><code>static</code>修饰函数和修饰全局变量<ul>
<li>函数/全局变量只能用在它所在的编译单元</li>
<li><strong>编译单元</strong>：当一个<code>.c</code>或<code>.cpp</code>文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件，这个源文件就是一个编译单元。这个编译单元会被编译成为一个同名的目标文件（<code>.o</code>或<code>.obj</code>），链接程序把不同编译单元中产生的符号联系起来，构成一个可执行程序。</li>
</ul>
</li>
</ul>
</li>
<li>利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突；对于函数来讲，<code>static</code>的作用仅限于隐藏。</li>
<li>静态全局变量，作用域仅限于变量被定义的文件中，其它文件中即使用<code>extern</code>（下文会介绍）声明也无法使用它；准确地说，作用域是从声明之处开始，到文件结尾处结束：在定义之处前面的同一文件的那些代码行也不能使用它，想要使用就得在前面再加<code>extern</code>。</li>
</ul>
</li>
<li>③C++类中的static成员<ul>
<li>设计思路：将和某些类紧密相关的全局变量或函数写在类里面，使其看上去像一个整体，易于理解和维护。</li>
<li>访问方式：可以想访问普通成员函数和变量一样通过对象访问，但常直接用<code>类名::???</code>的方式访问。</li>
<li>静态成员变量：必须在类声明体外的某个地方（一般是实现文件<code>.cpp</code>）初始化。静态成员变量本质上是全局变量，在类的所有实例对象中共享一份。</li>
<li>静态成员函数：本质上是全局函数，并不具体作用于某个对象，不需要对象也可以访问。静态成员函数中不能访问非静态成员变量，也不能调用非静态成员函数。</li>
</ul>
</li>
</ul>
</li>
<li>static全局变量 vs 普通全局变量<ul>
<li>全局变量本身就是静态存储方式，两者在存储方式上并无不同</li>
<li>普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通（非静态的）全局变量在各个源文件中都是有效的；静态全局变量限制了其作用域，只在定义该变量的源文件内有效，在同一源程序的其它源文件中无效；由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起的错误。 <font color="blue">如果在不同源文件中出现了用<code>static</code>修饰的同名全局变量，那么这些变量互不干扰。</font></li>
<li>把全局变量改变成静态变量后改变了变量的作用域，限制了变量的使用范围。</li>
</ul>
</li>
<li>static局部变量 vs 普通局部变量<ul>
<li>把局部变量改变为静态变量后改变了变量的存储方式，即改变了变量的生存期。</li>
<li>static局部变量只被初始化一次，下一次访问依据上一次结果值。</li>
</ul>
</li>
<li>static函数 vs 普通函数<ul>
<li>只在当前源文件中使用的函数应该声明为内部函数（static函数），内部函数应该在当前源文件中声明和实现；对于可在当前源文件以外使用的函数，应该在一个头文件中声明，要使用这些函数的源文件（包括函数实现）要包含这个头文件</li>
</ul>
</li>
</ul>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><ul>
<li>被<code>const</code>修饰的东西（变量/函数）都受到强制保护，程序中使用<code>const</code>可以预防意外的变动，在一定程度上提高程序的健壮性，但是程序中使用过多的<code>const</code>，可能加大代码的阅读难度。</li>
<li><code>const</code>修饰普通变量<ul>
<li>C的<code>#define</code>预处理指令，只是简单的值替代，缺乏类型的检测机制；C++引入<code>const</code>关键字：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> datatype name=value;</div></pre></td></tr></table></figure>
<ul>
<li>不仅满足了使用预处理指令的要求：①不可变性；②避免意义模糊的数字出现，方便参数调整和修改，同时：③编译器不为普通<code>const</code>常量分配存储空间，而是将它们保存在符号表中 $\Longrightarrow$ 编译期间的常量，没有了内存存储等操作，效率更高。</li>
<li>用<code>const</code>修饰的变量（用来修饰函数的形参除外）必须在声明时进行初始化；一旦一个变量被<code>const</code>修饰，在程序中除初始化外对这个变量进行的赋值都是错误的。</li>
</ul>
</li>
<li><code>const</code>修饰指针：指针常量 vs 常量指针<ul>
<li>指针本身也是一个变量，只不过这个变量存放的是地址而已。</li>
<li>指针常量：是一个常量，这个常量本身是一个指针，即指针本身的值不可变，指针只能指向固定的存储单元 $\Longrightarrow$ 指针指向的变量的值（这个固定存储单元保存的值）是可以改变的。</li>
<li>常量指针：是一个指针，这个指针指向的变量是一个常量，该变量的值不可变 $\Longrightarrow$ 指针本身的值是可以改变的，即指针可以指向其它存储单元。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指针常量</span></div><div class="line"><span class="keyword">int</span>* <span class="keyword">const</span> a;</div><div class="line"><span class="comment">// 常量指针</span></div><div class="line"><span class="keyword">int</span> <span class="keyword">const</span> *a;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>* a;</div></pre></td></tr></table></figure>
<ul>
<li><code>const</code>是一个左结合的类型修饰符，它与其左侧的类型合为一个类型修饰符。</li>
</ul>
</li>
<li><code>const</code>修饰函数的参数</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 常量指针：以防意外改动指针指向数据内容</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">stringCopy</span><span class="params">(<span class="keyword">char</span>* strDest, <span class="keyword">const</span> <span class="keyword">char</span>* strSrc)</span></span>;</div><div class="line"><span class="comment">// 指针常量：以防意外改动指针本身</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p1, <span class="keyword">int</span>* <span class="keyword">const</span> p2)</span></span>;</div><div class="line"><span class="comment">// 非内部数据类型的引用传递</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> MyClass&amp; a)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>“值传递”函数将自动产生临时变量用于复制该参数，该输入参数无需保护；临时对象的构造、复制、析构都将消耗时间；内部数据类型不存在构造析构的过程，复制也非常快。</li>
<li>“引用传递”仅借用一下参数的别名而已，不需要产生临时对象；“引用传递”有可能会改变参数，可以通过<code>const</code>限定。</li>
</ul>
</li>
<li><code>const</code>修饰函数的返回值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getString</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="comment">// 函数返回值采用值传递，加 const 没有任何意义</span></div><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div><div class="line"><span class="function"><span class="keyword">const</span> Myclass&amp; <span class="title">getObj</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li><code>const</code>限定类的成员函数</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> MyClass &#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getXXX</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li><code>const</code>只能放在函数声明的尾部，大概是因为其它地方被占用了。</li>
<li>只读函数：函数不能改变类对象的状态（只能由常量对象（实例）调用）；不能修改类的数据成员，不能在函数中调用其它非<code>const</code>函数。</li>
</ul>
</li>
<li>C和C++中的<code>const</code>有很大区别：在C语言中用<code>const</code>修饰的变量仍然是一个变量；而在C++中用<code>const</code>修饰后，就变成常量了。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> n=<span class="number">5</span>;</div><div class="line"><span class="keyword">int</span> a[n];</div></pre></td></tr></table></figure>
<ul>
<li>这种方式在C语言中会报错，原因是声明数组时其长度必须为一个常量；但是在C++中就不会报错。</li>
</ul>
</li>
</ul>
<h4 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h4><ul>
<li>在C语言中，修饰符<code>extern</code>用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处<font color="red">引用</font>”<ul>
<li><code>extern</code>置于变量或者函数前，标识变量或者函数的定义在别的文件中，提示编译器遇到此变量或函数时在其他模块（其他<code>.o</code>文件）中寻找其定义。</li>
<li>关于<code>extern</code>的作用域<ul>
<li>对外部变量的引用不只是取决于<code>extern</code>声明，还取决于外部变量本身是否能够被引用到，即变量的作用域：要求被引用的变量的链接属性必须是外链接的，通常是全局变量。<ul>
<li><code>extern</code>声明的位置对其作用域也有关系，例如在某个函数中的声明就只能在该函数中调用，在其它函数中不能调用。</li>
</ul>
</li>
</ul>
</li>
<li>为啥要用<code>extern</code>？因为用<code>extern</code>会加速程序的编译过程，这样能节省时间。<ul>
<li>对其它模块中函数的引用，最常用的方法是<code>#include</code>这些函数声明的头文件，<code>extern</code>的引用方式要直截了当、简洁的多：想引用哪个函数就用<code>extern</code>声明哪个函数，这会加速程序编译，确切的说预处理过程，节省时间；在大型C程序编译过程中，这种加速会更加明显。</li>
</ul>
</li>
<li>正确使用<code>extern</code>共享全局函数/全局变量<ul>
<li>供其他文件调用的外部函数和变量在<code>.h</code>文件中通过<code>extern</code>修饰进行声明，在<code>.c</code>/<code>.cpp</code>文件的变量定义与函数实现与普通变量、普通函数一致；要调用该文件中的函数和变量，只需要把<code>.h</code>文件用<code>#include</code>包含进来即可。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>file1.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 声明全局变量</span></div><div class="line"><span class="keyword">int</span> i, j;</div><div class="line"><span class="keyword">char</span> c;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>file2.c</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 外部变量声明</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i, j;</div><div class="line"><span class="keyword">extern</span> <span class="keyword">char</span> c;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对外部变量的声明和定义不是一回事。对外部变量的声明，只是声明该变量是在外部定义过的一个全局变量，在这里引用；而外部变量的定义，即对该全局变量的定义，则要分配存储空间；一个全局变量只能定义一次，却可以有多次外部引用。</li>
</ul>
</li>
<li>在C++中<code>extern</code>还有另外一个作用：用于指示C或者C++函数的调用规范。<ul>
<li>C++和C程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。<ul>
<li>C++语言在编译的时候为了解决函数的多态问题，会<font color="blue">将函数名和参数联合起来生成一个中间的函数名称（重命名）</font>，而C语言则不会，因此会造成链接时找不到对应函数的情况。</li>
</ul>
</li>
<li><font color="red">在C++中调用C库函数，需要在C++程序中<code>extern &quot;C&quot;{...}</code>声明要引用的函数</font>，这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>;</div><div class="line">  <span class="comment">// 或者</span></div><div class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"func1.h"</span></span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  func1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在C++中导出C函数，用<code>extern &quot;C&quot;{...}</code>进行链接指定，告诉编译器，请保持我的函数名，不要进行任何重命名。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>xxx.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>;</div><div class="line">  <span class="comment">// ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><ul>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> expression(x,y) (x+y)*(x-y)</span></div></pre></td></tr></table></figure>
<ul>
<li>A. 形式和使用上像一个函数，<font color="blue">使用预处理器实现，没有参数压栈等一系列操作 $\Longrightarrow$ 效率很高</font></li>
<li>B. 使用（说调用不太准确）它时，只是做预处理器符号表中的简单替换 $\Longrightarrow$ 无严格类型检查，返回值也不能被强制转换为可转换的合适的类型。</li>
<li>C. C++类及类的访问控制的存在，这种方式无法访问类的保护成员或私有成员。</li>
</ul>
</li>
<li><code>inline</code>修饰全局函数，保留了上述方式的优点，又能有效避免相应的不足。<ul>
<li><code>inline</code>内联函数代码被<font color="blue">放入符号表中，调用时直接进行替换（像宏一样展开）</font>，没有了调用的开销，效率也很高。<ul>
<li><font color="red">栈空间</font>是指放置程序局部数据也就是函数内数据的内存空间，系统下的栈空间是有限的，假如频繁大量地使用（递归死循环调用）就会造成因栈空间不足所造成的程序出错。</li>
<li>函数被调用，函数入栈，即函数栈，会消耗栈空间（栈内存）。</li>
</ul>
</li>
<li>编译器像对待普通函数一样 $\Longrightarrow$ 参数类型检测…</li>
<li><code>inline</code>成员函数 $\Longrightarrow$ 访问保护成员或私有成员</li>
</ul>
</li>
<li><code>inline</code>内联函数函数体应简单<ul>
<li><code>inline</code>函数足够简单：不能包含复杂的结构控制语句（while/switch），不能出现递归。</li>
<li>原因：内联函数会在任何调用它的地方展开，如果太复杂，代码膨胀（程序总代码量增大，消耗更多的内存空间）$\Longrightarrow$ 效率反而得不偿失。</li>
<li>内联函数常用在类的<code>set/get</code>函数。</li>
</ul>
</li>
<li><code>inline</code>函数声明和定义（实现）放在头文件中最合适<ul>
<li>省却每个文件实现一次的麻烦</li>
<li>避免实现存在不一致的问题</li>
</ul>
</li>
</ul>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><ul>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> a=i;</div><div class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></div><div class="line">...</div><div class="line"><span class="keyword">int</span> b=i;</div></pre></td></tr></table></figure>
<ul>
<li><code>volatile</code>指出变量是随时可能发生变化的，每次使用该变量的时候都必须从其地址中读取，因此编译器生成的<code>int b=i;</code>的汇编代码会重新从变量 i 的地址读取数据放在变量 b 中；优化的做法（没有<code>volatile</code>）是：编译器发现两次从变量 i 读数据的代码间没有对 i 进行过操作，会自动把上次读的 i 的数据（一般的编译器可能会将其拷贝放在寄存器中以加快指令的执行速度）放在变量 b 中 $\Longrightarrow$ <code>volatile</code>可以保证对特殊地址的稳定访问。</li>
</ul>
</li>
<li><code>volatile</code>与编译器优化<ul>
<li>提高执行速度的两个方面<ul>
<li>硬件级别的优化：由于内存访问速度远不及CPU处理速度，为提高机器整体性能，在硬件上引入高速缓存cache，加速对内存的访问；另外在现代CPU中指令的执行并不一定按照顺序执行（in-order），没有相关性的指令可以乱序执行（out-of-order），以充分利用CPU的指令流水线，提高执行速度</li>
<li>软件级别的优化：一种是在编写代码时由程序员优化；另一种则是由编译器进行优化。编译器优化常用的方法有：<ul>
<li>①将内存变量缓存到寄存器；</li>
<li>②调整指令顺序以充分利用CPU指令流水线，常见的是重新排序读写指令（可能是<code>load</code>/<code>store</code>指令）。</li>
</ul>
</li>
</ul>
</li>
<li><code>volatile</code>总是与优化有关，编译器有一项技术叫做<strong>数据流分析</strong>，分析程序中的变量在哪里赋值？在哪里使用？在哪里失效，分析结果可以用于常量合并、常量传播等优化，进一步可以死代码消除。编译器对常规内存进行优化的时候，这些优化是透明的，而且效率很好；但有时候这些优化不是程序所需要的，这时可以用<code>volatile</code>禁止这些优化：<ul>
<li>不要在两个操作之间把<code>volatile</code>变量缓存在寄存器中：在多任务、中断等环境下，变量可能被其他程序改变。</li>
<li>不做常量合并、常量传播等优化。</li>
<li>对<code>volatile</code>变量的读写不会被优化掉：如果你对一个变量赋值但后面没用到，编译器常常可以省略那个赋值操作，然而万一这个赋值是对 Memory Mapped的 IO 资源（比如LEDs）进行操作呢！</li>
</ul>
</li>
</ul>
</li>
<li>一般说来，<code>volatile</code>用在如下几个地方：<ul>
<li>中断服务程序中修改的供其它程序检测的变量需要加<code>volatile</code>。</li>
<li>多任务环境下各任务间共享的标志应该加<code>volatile</code>。</li>
<li>存储器映射（Memory Mapped）的硬件寄存器通常也要加<code>volatile</code>说明，因为每次对它的读写都可能有不同的意义。</li>
</ul>
</li>
<li>频繁地使用<code>volatile</code>很可能会增加代码尺寸和降低性能！</li>
<li>一个参数可能既是<code>const</code>又是<code>volatile</code>，比如只读的状态寄存器。</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://blog.csdn.net/zqixiao_09/article/details/50877383">内联函数 —— C 中关键字 inline 用法解析</a></li>
<li><a href="http://blog.csdn.net/lemonrabbit1987/article/details/48621149">C++类的const, static 和inline成员函数（变量）</a></li>
<li><a href="http://www.cnblogs.com/stoneJin/archive/2011/09/21/2183313.html">C语言static作用（修饰函数、局部变量、全局变量）</a></li>
<li><a href="http://c.biancheng.net/cpp/html/436.html">C语static关键字—言最名不符实的关键字</a></li>
<li><a href="http://developer.51cto.com/art/201104/256820.htm">浅谈C/C++中的static和extern关键字</a></li>
<li><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html">C/C++中extern关键字详解</a></li>
<li><a href="http://blog.csdn.net/zcywell/article/details/7416488">C语言中extern修饰符的用法</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/archive/2011/04/18/2020248.html">浅谈C和C++中的const关键字</a></li>
<li><a href="http://blog.xieyc.com/const-in-detail/">const 详解（修饰变量、输入参数、返回值、成员函数</a></li>
<li><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">C/C++中volatile关键字详解</a></li>
<li><a href="http://blog.csdn.net/tigerjibo/article/details/7427366">C语言中volatile关键字的作用</a></li>
<li><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/06/24/1764231.html">详解C中volatile关键字</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　本文是关于C/C++语言中常见的五个修饰符：&lt;code&gt;static&lt;/code&gt;、&lt;code&gt;const&lt;/code&gt;、&lt;code&gt;extern&lt;/code&gt;、&lt;code&gt;inline&lt;/code&gt;、&lt;code&gt;volatile&lt;/code&gt;的含义和用法，在阅读本文前，建议先通过&lt;a href=&quot;https://durant35.github.io/2017/07/07/programPearls_declaration&amp;amp;definition&amp;amp;initialization&amp;amp;assignment/&quot;&gt;《声明/定义/初始化/赋值》&lt;/a&gt;了解有关C/C++中定义、声明等概念以及变量声明和定义的区别。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="C/C++" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/C-C/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0021] Some Algorithms Basic Details Review（课程总结）</title>
    <link href="http://durant35.github.io/2017/07/02/Algorithms_BasicMiscs/"/>
    <id>http://durant35.github.io/2017/07/02/Algorithms_BasicMiscs/</id>
    <published>2017-07-02T07:26:22.000Z</published>
    <updated>2017-07-06T08:51:13.140Z</updated>
    
    <content type="html"><![CDATA[<h4 id="如何对-vector-初始化"><a href="#如何对-vector-初始化" class="headerlink" title="如何对 vector 初始化"></a>如何对 <strong>vector</strong> 初始化</h4><ul>
<li>大小为<code>size</code>的一维向量，二位向量</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;what-type&gt; var-name(what-size);</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;what-type&gt;&gt; var-name(rowSize, <span class="built_in">vector</span>&lt;what-type&gt;(colSize));</div></pre></td></tr></table></figure>
<ul>
<li>数组转 vector</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> rowSize = ?;</div><div class="line"><span class="keyword">int</span> colSize = ?;</div><div class="line">what-type A_[rowSize][colSize] = &#123;</div><div class="line">  &#123;element1, elment2, ..., element&#125;,</div><div class="line">  &#123;&#125;,</div><div class="line">  ...</div><div class="line">  &#123;&#125;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;what-type&gt;&gt; A(rowSize, <span class="built_in">vector</span>&lt;what-type&gt;(colSize));</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rowSize; row++) &#123;</div><div class="line">  A[row].assign(A_[row], A_[row] + colSize);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="对-vector-等-STL-标准容器进行排序操作"><a href="#对-vector-等-STL-标准容器进行排序操作" class="headerlink" title="对 vector 等 STL 标准容器进行排序操作"></a>对 vector 等 STL 标准容器进行排序操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#inlcude <span class="meta-string">&lt;algorithm&gt;</span>	<span class="comment">/* sort */</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareFunc</span><span class="params">(<span class="keyword">int</span> before, <span class="keyword">int</span> after)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> (before &lt; after);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> compareClass &#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> before, <span class="keyword">int</span> after)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (before &lt; after);</div><div class="line">  &#125;</div><div class="line">&#125; compareObj;</div><div class="line"> </div><div class="line"><span class="comment">// using default comparison(operator &lt;)</span></div><div class="line">sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end());</div><div class="line">sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.begin() + length);</div><div class="line"> </div><div class="line"><span class="comment">// using comparison function</span></div><div class="line">sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end(), compareFunc);</div><div class="line"> </div><div class="line"> <span class="comment">// using comparison object</span></div><div class="line">sort(<span class="built_in">vector</span>.begin(), <span class="built_in">vector</span>.end(), compareObj);</div></pre></td></tr></table></figure>
<ul>
<li>上述的 <code>sort(begin, end, comparison)</code> 函数，其中<code>[before]</code>元素与<code>[after]</code>元素满足<code>comparison</code>关系</li>
<li>一些自带的 comparison 函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 相等</span></div><div class="line">equal_to&lt;&gt;()</div><div class="line">not_equal_to&lt;&gt;()</div><div class="line">less&lt;&gt;() </div><div class="line">greater&lt;&gt;()</div><div class="line"><span class="comment">// ≤</span></div><div class="line">less_equal&lt;&gt;()</div><div class="line"><span class="comment">// ≥</span></div><div class="line">greater_equal&lt;&gt;()</div></pre></td></tr></table></figure>
<h4 id="使用二维-vector-维护邻接列表"><a href="#使用二维-vector-维护邻接列表" class="headerlink" title="使用二维 vector 维护邻接列表"></a>使用二维 vector 维护邻接列表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; graph;</div><div class="line">graph.resize(vertex-number);</div><div class="line"><span class="comment">// vector&lt;pair&lt;int, int&gt;&gt; edges;</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> edgeIdx=<span class="number">0</span>; edgeIdx&lt;edges.size(); edgeIdx++) &#123;</div><div class="line">  graph[edges[edgeIdx].first].push_back(edges[edgeIdx].second);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="STL-常见容器关键操作"><a href="#STL-常见容器关键操作" class="headerlink" title="STL 常见容器关键操作"></a>STL 常见容器关键操作</h4><ul>
<li>vector $\begin{cases} push\_back \cr pop\_back \end{cases}$　　list $\begin{cases} push\_back \cr pop\_back \cr push\_front \cr pop\_front \end{cases}$</li>
<li>stack $\begin{cases} push \cr pop \cr top \end{cases}$　　queue $\begin{cases} push \cr pop \cr front \cr back \end{cases}$</li>
<li>map, set  $\begin{cases} insert \cr erase \cr \color{red}{find} \end{cases}$</li>
</ul>
<h4 id="DFS-amp-BFS-的快速实现"><a href="#DFS-amp-BFS-的快速实现" class="headerlink" title="DFS&amp;BFS 的快速实现"></a>DFS&amp;BFS 的快速实现</h4><ul>
<li>DFS 递归</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> 节点 ? :</div><div class="line">    <span class="keyword">if</span>(!visited[?]) &#123;</div><div class="line">      dfs(?, visited);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(startIdx, visited[])</span> </span>&#123;</div><div class="line">  visited[startIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span> 节点 startIdx 的邻接边 startIdx-&gt;?:</div><div class="line">    <span class="keyword">if</span>(!visited[?]) &#123;</div><div class="line">      dfs(?, visited);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>DFS 堆栈</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(root)</span> </span>&#123;</div><div class="line">  nodeStack.push(root);</div><div class="line">  visited[root] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span>(!nodeStack.empty()) &#123;</div><div class="line">    curNode = nodeStack.top();</div><div class="line">    nodeStack.pop();</div><div class="line">    <span class="keyword">for</span> curNode 的邻接边 curNode-&gt;?:</div><div class="line">      <span class="keyword">if</span>(!visited[?]) &#123;</div><div class="line">        nodeStack.push(?);</div><div class="line">        visited[?] = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>BFS 队列</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(root)</span> </span>&#123;</div><div class="line">  nodeQueue.push(root);</div><div class="line">  visited[root] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span>(!nodeQueue.empty()) &#123;</div><div class="line">    curNode = nodeQueue.front();</div><div class="line">    nodeStack.pop();</div><div class="line">    <span class="keyword">for</span> curNode 的邻接边 curNode-&gt;?:</div><div class="line">      <span class="keyword">if</span>(!visited[?]) &#123;</div><div class="line">        nodeQueue.push(?);</div><div class="line">        visited[?] = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h4><ul>
<li>带正权（不可带负权）的图</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(source)</span> </span>&#123;</div><div class="line">  visited[] = <span class="literal">false</span>;</div><div class="line">  prevs[] = <span class="literal">NULL</span>;</div><div class="line">  dists[] = INT_MAX;</div><div class="line"> </div><div class="line">  dists[source] = <span class="number">0</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> 完成所有节点挑选:</div><div class="line">    curMinDist = INT_MAX;</div><div class="line">    pickNode = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> 所有节点?:</div><div class="line">      <span class="keyword">if</span>(!visited[?] &amp;&amp; dists[?] &lt; curMinDist) &#123;</div><div class="line">        curMinDist = dists[?];</div><div class="line">        pickNode = ?;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(pickNode == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// 存在节点不可达</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    visited[pickNode] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> pickNode 所有邻接边 pickNode-&gt;?:</div><div class="line">      <span class="keyword">if</span>(!visited[?] </div><div class="line">        &amp;&amp; dists[?] &gt; (dists[pickNode] + 边权)) &#123;</div><div class="line">        dists[?] = dists[pickNode] + 边权;</div><div class="line">        prevs[?] = pickNode;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可带负权的图 $\longrightarrow$ 可以检测是否有负环</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BellmanFord</span><span class="params">(source)</span> </span>&#123;</div><div class="line">  visited[] = <span class="literal">false</span>;</div><div class="line">  prevs[] = <span class="literal">NULL</span>;</div><div class="line">  dists[] = INT_MAX;</div><div class="line"> </div><div class="line">  dists[source] = <span class="number">0</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> 完成所有节点[<span class="number">0</span>-N<span class="number">-1</span>]挑选:</div><div class="line">    updated = <span class="literal">false</span>;</div><div class="line">    <span class="comment">// 更新所有节点</span></div><div class="line">    <span class="keyword">for</span> 所有节点?:</div><div class="line">      <span class="keyword">for</span> ?的所有邻接边?-&gt;△:</div><div class="line">        <span class="keyword">if</span>(dists[△] != INT_MAX </div><div class="line">          &amp;&amp; dists[△] &gt; (dists[?] + 边权)) &#123;</div><div class="line">          dists[△] = dists[?] + 边权;</div><div class="line">          prevs[△] = ?;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(!updated) &#123;</div><div class="line">      <span class="comment">// 完成最短路径搜索</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(已经挑选了所有节点 &amp;&amp; updated) &#123;</div><div class="line">      <span class="comment">// 存在负环</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h4><ul>
<li>Prim 算法，与 Dijkstra 类似，只不过代价是到当前生成树的，而不是到源的代价</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(root = <span class="number">0</span>)</span> </span>&#123;</div><div class="line">  visited[] = <span class="literal">false</span>;</div><div class="line">  prevs[] = <span class="literal">NULL</span>;</div><div class="line">  costs[] = INT_MAX;</div><div class="line"> </div><div class="line">  costs[root] = <span class="number">0</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> 完成所有节点挑选:</div><div class="line">    curMinCost = INT_MAX;</div><div class="line">    pickNode = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> 所有节点?:</div><div class="line">      <span class="keyword">if</span>(!visited[?] &amp;&amp; costs[?] &lt; curMinCost) &#123;</div><div class="line">        curMinCost = costs[?];</div><div class="line">        pickNode = ?;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(pickNode == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// 节点不可达</span></div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    visited[pickNode] = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// 更新 cost</span></div><div class="line">    <span class="keyword">for</span> pickNode 所有邻接边 pickNode-&gt;?:</div><div class="line">      <span class="keyword">if</span>(!visited[?] </div><div class="line">        &amp;&amp; costs[?] &gt; (dists[pickNode] + 边权)) &#123;</div><div class="line">        costs[?] = costs[pickNode] + 边权;</div><div class="line">        prevs[?] = pickNode;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="关于子串、子序列的动态规划问题"><a href="#关于子串、子序列的动态规划问题" class="headerlink" title="关于子串、子序列的动态规划问题"></a>关于子串、子序列的动态规划问题</h4><ul>
<li><code>dp[i]</code>：转化到以 [i] 结尾或者 [0, …, i] 这样的子串/子序列的子问题</li>
<li><code>dp[i][j]</code>：转化到 [i, …, j] 这样的子串/子序列的子问题<ul>
<li>以长度递增为填表方向<ul>
<li>长度为 1，需作为基单独计算</li>
<li>长度为 2，可能需要作为基单独计算</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="动态规划：编辑距离（Edit-distance）"><a href="#动态规划：编辑距离（Edit-distance）" class="headerlink" title="动态规划：编辑距离（Edit distance）"></a>动态规划：编辑距离（Edit distance）</h4><ul>
<li>设需要计算编辑距离的两个字符串分别为 <strong>x[1…m]</strong> 和 <strong>y[1…n]</strong></li>
<li>$E(i, j)$：<strong>x[1…i]</strong> 和 <strong>y[1…j]</strong> 的编辑距离</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i = <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, ..., m</div><div class="line">  <span class="comment">// y 插入操作</span></div><div class="line">  j=<span class="number">0</span>: <span class="comment">// x 为空</span></div><div class="line">    E(i, j) = i;</div><div class="line"> </div><div class="line"><span class="keyword">for</span> j = <span class="number">1</span>, <span class="number">2</span>, ..., n</div><div class="line">  <span class="comment">// y 删除操作</span></div><div class="line">  i=<span class="number">0</span>: <span class="comment">// y 为空</span></div><div class="line">    E(i, j) = j;</div><div class="line"> </div><div class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">2</span>, ..., m</div><div class="line">  <span class="keyword">for</span> j = <span class="number">1</span>, <span class="number">2</span>, ..., n</div><div class="line">    E(i, j) = min&#123;</div><div class="line">      <span class="number">1</span> + E(i<span class="number">-1</span>, j),	<span class="comment">// y 删除操作</span></div><div class="line">      <span class="number">1</span> + E(i, j<span class="number">-1</span>),	<span class="comment">// y 插入操作</span></div><div class="line">      diff(i, j) + E(i<span class="number">-1</span>, j<span class="number">-1</span>),	<span class="comment">// y 替换操作</span></div><div class="line">    &#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> E(m, n)</div></pre></td></tr></table></figure>
<ul>
<li>其中，$diff(i, j) = \begin{cases} 0, x[i]=y[j] \cr 1, else \end{cases}$</li>
</ul>
<h4 id="动态规划：最长路"><a href="#动态规划：最长路" class="headerlink" title="动态规划：最长路"></a>动态规划：最长路</h4><ul>
<li>保证在计算<code>dist(v)</code>时，<code>v</code>的前驱节点<code>u</code>的最短/长路已经算出来 $\Longrightarrow$ 按照拓扑排序的顺序来计算每个点<code>v</code>的最长/短路<code>dist(v)</code></li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">initialize all dist(·) value to ∞</div><div class="line">dists[source] = 0</div><div class="line">for v∈V\&#123;source&#125;, in topological order:</div><div class="line">  dist(v) = max/min \_&#123;(u, v) ∈ E&#125; &#123;dist(u) + weight(u, v)&#125;</div></pre></td></tr></table></figure>
<ul>
<li>有点复杂的动态规划思路<ul>
<li>$ans[j][i]$：以 j 点为起点，经过点集 i 中的点恰好一次而不经过其他点的路径长度的最大值，不存在则为-∞</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A. i 只包含一个点，ans[j][i] = <span class="number">0</span></div><div class="line">B. 否则，ans[j][i] = max(graph[j][k] + ans[k][s])</div><div class="line">  S 表示 i 集合中去掉了 j 点的集合</div><div class="line">  k 遍历集合 S 中的点，点 j 到点 k 有边存在，权值为 graph[j][k]</div><div class="line">C. 所有 ans[j][i] 的最大值即为最长路</div></pre></td></tr></table></figure>
<h4 id="动态规划：最短可靠路径"><a href="#动态规划：最短可靠路径" class="headerlink" title="动态规划：最短可靠路径"></a>动态规划：最短可靠路径</h4><ul>
<li>从 s 到 t 的不超过 k 条边的最短路</li>
<li><code>dist(v, i)</code>：从起点 s 到 v 点恰好经过 i 条边的最短路</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">i = 0, dist(s, i) = 0, 其他为∞</div><div class="line">for 所有顶点 v</div><div class="line">  dist(v, i) = min&#123;(u, v) \in E&#125; &#123;dist(u, i-1) + weight(u, v)&#125;</div></pre></td></tr></table></figure>
<h4 id="动态规划：最长递增序列"><a href="#动态规划：最长递增序列" class="headerlink" title="动态规划：最长递增序列"></a>动态规划：最长递增序列</h4><ul>
<li>转化为最长路径问题（容易提取）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(fromIdx=<span class="number">0</span>; fromIdx&lt;n; fromIdx++) &#123;</div><div class="line">  <span class="keyword">for</span>(toIdx=fromIdx+<span class="number">1</span>; toIdx&lt;n; toIdx++) &#123;</div><div class="line">    <span class="keyword">if</span>(num[toIdx] &gt; num[fromIdx]) &#123;</div><div class="line">      graph[fromIdx].push_back(toIdx);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>动态规划（$O(N^2)$）<ul>
<li>$L(j)$：以第 j 个数结尾的最长递增子序列的长度</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">L(<span class="number">0</span>) = <span class="number">1</span>;</div><div class="line">prevs[] = <span class="number">-1</span>;</div><div class="line"><span class="keyword">for</span> j = <span class="number">1.</span>..n<span class="number">-1</span>:</div><div class="line">  <span class="comment">// 最长递增序列只有 num[j]</span></div><div class="line">  <span class="keyword">int</span> localMax = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> i = <span class="number">0.</span>..j:</div><div class="line">    <span class="comment">// 以比 num[j] 小的数结尾的最长递增子序列长度+1</span></div><div class="line">    <span class="keyword">if</span>(num[i] &lt; num[j] &amp;&amp; L(i) &gt; localMax) &#123;</div><div class="line">      localMax = L(i);</div><div class="line">      prevs[j] = i;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">  L(j) = localMax + <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h4 id="动态规划：矩阵连乘"><a href="#动态规划：矩阵连乘" class="headerlink" title="动态规划：矩阵连乘"></a>动态规划：矩阵连乘</h4><ul>
<li>给定 n 个矩阵构成的一个链 <code>&lt;A1, A2, ..., An&gt;</code>，其中矩阵<code>Ai</code>的大小为 $P_{i-1} * P_{i}, i=1,…n$，找一个计算顺序，使得计算乘积<code>A1A2...An</code>的乘法次数最少。</li>
<li>$m[i, j]$：表示计算 <code>Ai...Aj</code>的最小乘法次数<ul>
<li>$min_{i \leq k \leq j} {m[i, k] + m[k+1, j] + P_{i-1}P_{k}P_{j}}$</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">n = length[p] - <span class="number">1</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> i = <span class="number">1.</span>..n:</div><div class="line">  m[i, i] = <span class="number">0</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> l = <span class="number">2.</span>..n:</div><div class="line">  <span class="keyword">for</span> i = <span class="number">1.</span>..(n-l+<span class="number">1</span>):</div><div class="line">    j = i + l - <span class="number">1</span></div><div class="line">    m[i, j] = ∞</div><div class="line">    <span class="keyword">for</span> k = i...j<span class="number">-1</span>:</div><div class="line">      q = m[i, k] + m[k+<span class="number">1</span>, j] + P[i<span class="number">-1</span>]*P[k]*P[j]</div><div class="line">      <span class="keyword">if</span>(q &lt; m[i, j]) &#123;</div><div class="line">        m[i, j] = q;</div><div class="line">        s[i, j] = k;</div><div class="line">      &#125;</div><div class="line"> </div><div class="line"><span class="keyword">return</span> m[<span class="number">1</span>, n], s[<span class="number">1</span>, n]</div></pre></td></tr></table></figure>
<ul>
<li><code>m[1, n]</code>为最终需要的最小乘法次数，通过<code>s[1, n]</code>可以回溯得到对应的计算顺序</li>
</ul>
<h4 id="期末机考错误题目反思"><a href="#期末机考错误题目反思" class="headerlink" title="期末机考错误题目反思"></a>期末机考错误题目反思</h4><ul>
<li><a href="https://leetcode.com/problems/merge-two-binary-trees/#/description">617. Merge Two Binary Trees</a></li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</div><div class="line">        <span class="comment">// t1==NULL or t1!=NULL</span></div><div class="line">        <span class="keyword">if</span>(t2 == <span class="literal">NULL</span>) &#123;</div><div class="line">        	<span class="keyword">return</span> t1;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// t2!=NULL t1==NULL</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t1 == <span class="literal">NULL</span>) &#123;</div><div class="line">        	t1 = <span class="keyword">new</span> TreeNode(t2-&gt;val);</div><div class="line">        	mergeTrees(t1-&gt;left, t2-&gt;left);</div><div class="line">        	mergeTrees(t1-&gt;right, t2-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// t2!=NULL t1!=NULL</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">        	t1-&gt;val += t2-&gt;val;</div><div class="line">        	mergeTrees(t1-&gt;left, t2-&gt;left);</div><div class="line">        	mergeTrees(t1-&gt;right, t2-&gt;right);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> t1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>反思：<code>t1 = new TreeNode(t2-&gt;val);</code> 之后，损失了该节点与 t1 树的连接关系；需要通过单独开一棵树的方式来解决这个问题。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(t1 == <span class="literal">NULL</span>) &#123;</div><div class="line">        	<span class="keyword">return</span> t2;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(t2 == <span class="literal">NULL</span>) &#123;</div><div class="line">        	<span class="keyword">return</span> t1;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        TreeNode* result = <span class="keyword">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</div><div class="line">        result-&gt;left = mergeTrees(t1-&gt;left, t2-&gt;left);</div><div class="line">        result-&gt;right = mergeTrees(t1-&gt;right, t2-&gt;right);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><a href="https://leetcode.com/problems/01-matrix/#/description">542. 01 Matrix</a></li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> startRowIdx, <span class="keyword">int</span> startColIdx)</span> </span>&#123;</div><div class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; queue_;</div><div class="line">    <span class="comment">// 这里已经很难处理，似乎没办法记录当前层（广度优先搜索的深度）层数，即步数</span></div><div class="line">  &#125;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rowSize = matrix.size();</div><div class="line">        <span class="keyword">int</span> colSize = matrix[<span class="number">0</span>].size();</div><div class="line"> </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; stepMatrix(rowSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(colSize));</div><div class="line"> </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rowSize; row++) &#123;</div><div class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;colSize; col++) &#123;</div><div class="line">        		<span class="keyword">if</span>(matrix[row][col] == <span class="number">0</span>) &#123;</div><div class="line">        			stepMatrix[row][col] = <span class="number">0</span>;</div><div class="line">        		&#125;</div><div class="line">        		<span class="keyword">else</span> &#123;</div><div class="line">        			stepMatrix[row][col] = BFS(matrix, row, col);</div><div class="line">        		&#125;</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> stepMatrix;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>反思：原先的想法是对于那些 1 的位置，进行DFS（现在想想应该BFS），寻找其到达最近的 0 需要的步数；会存在的一个问题（如上）就是，如何得到这些 1 到 0 的步数呢？而且无论是 DFS 还是 BFS，显然都存在重复的搜索操作。那假如换种思路，从那些 0 出发，一层一层向外扩张去更新那些 1 所在位置的步数呢？每一层的扩张显然可以利用上一层扩张的结果去更新，不存在重复的搜索操作。因此，一开始将那些 1 所在位置的到最近 0 所在位置的步数初始化为<code>INT_MAX</code>，然后从那些 0 所在位置开始通过 BFS 一层一层进行扩张，用更小的步数去更新 1 所在位置的值，最终，那些原先为 1 所在位置的值便是其到达最近 0 所在位置需要的步数了。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; updateMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;&amp; matrix) &#123;</div><div class="line">        <span class="keyword">int</span> rowSize = matrix.size();</div><div class="line">        <span class="keyword">int</span> colSize = matrix[<span class="number">0</span>].size();</div><div class="line"> </div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; stepMatrix(rowSize, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(colSize));</div><div class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; queue_;</div><div class="line"> </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rowSize; row++) &#123;</div><div class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;colSize; col++) &#123;</div><div class="line">        		<span class="keyword">if</span>(matrix[row][col] == <span class="number">0</span>) &#123;</div><div class="line">        			stepMatrix[row][col] = <span class="number">0</span>;</div><div class="line">        			queue_.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(row, col));</div><div class="line">        		&#125;</div><div class="line">        		<span class="keyword">else</span> &#123;</div><div class="line">        			stepMatrix[row][col] = INT_MAX;</div><div class="line">        		&#125;</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// up; down; left; right</span></div><div class="line">        <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;</div><div class="line">        	&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, </div><div class="line">        	&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, </div><div class="line">        	&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, </div><div class="line">        	&#123;<span class="number">0</span>, <span class="number">1</span>&#125;</div><div class="line">        &#125;;</div><div class="line"> </div><div class="line">        <span class="keyword">while</span>(!queue_.empty()) &#123;</div><div class="line">        	pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curPos = queue_.front();</div><div class="line">        	queue_.pop();</div><div class="line"> </div><div class="line">        	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</div><div class="line">        		<span class="keyword">int</span> rowIdx = curPos.first + dirs[i][<span class="number">0</span>];</div><div class="line">        		<span class="keyword">int</span> colIdx = curPos.second + dirs[i][<span class="number">1</span>];</div><div class="line">        		<span class="keyword">if</span>(rowIdx&lt;<span class="number">0</span> || colIdx&lt;<span class="number">0</span> || rowIdx&gt;=rowSize || colIdx&gt;=colSize) &#123;</div><div class="line">        			<span class="keyword">continue</span>;</div><div class="line">        		&#125;</div><div class="line">        		<span class="keyword">if</span>(stepMatrix[curPos.first][curPos.second]+<span class="number">1</span> &lt; stepMatrix[rowIdx][colIdx]) &#123;</div><div class="line">        			stepMatrix[rowIdx][colIdx] = stepMatrix[curPos.first][curPos.second]+<span class="number">1</span>;</div><div class="line">        			queue_.push(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(rowIdx, colIdx));</div><div class="line">        		&#125;</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> stepMatrix;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><a href="http://www.lintcode.com/en/problem/longest-common-substring/">Longest Common Substring</a></li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two string.</div><div class="line">     * @return: the length of the longest common substring.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the largest length of LCS ending with A[idxA] and B[idxB] </span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                L[idxA][idxB] = A[idxA]==B[idxB]? L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>]+<span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>反思：子问题定义的时候出现问题，应该是<code>L[idxA][idxB]</code>：the largest length of LCS <font color="red">ending with A[idxA] and B[idxB]</font>，而不是<font color="red">A[0…idxA]和B[0…idxB]</font>的最长公共子串。</li>
</ul>
</li>
<li><a href="https://leetcode.com/problems/house-robber/#/description">198. House Robber</a><ul>
<li>机考时是求数列：A[0], A[1], …, A[n-1] 的最小和，要求A[i]和A[i+1]至少选取一个；打家劫舍这道题类似，相当于在数列中取出一个或多个不相邻数，使其和最大。</li>
<li>打家劫舍要求确保不出现连续相邻的两个数，下面两个子问题都能够保证这样的一个前提条件。<ul>
<li>①<code>money[i]</code>：抢劫完房间 house[i] 后，能够获得的最大金钱数目。</li>
<li>②<code>money[i]</code>：在房间 house[0], …, house[i] 中进行抢劫能够获得的最大金钱数目。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// money[i]: max money after robbing house[i]</span></div><div class="line">        <span class="keyword">int</span> numSize = nums.size();</div><div class="line">        <span class="keyword">if</span>(numSize == <span class="number">0</span>) &#123;</div><div class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; money(nums.size());</div><div class="line">        money[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span>(numSize &gt; <span class="number">1</span>) &#123;</div><div class="line">        	money[<span class="number">1</span>] = nums[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(numSize &gt; <span class="number">2</span>) &#123;</div><div class="line">        	money[<span class="number">2</span>] = nums[<span class="number">0</span>] + nums[<span class="number">2</span>];</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>; i&lt;numSize; i++) &#123;</div><div class="line">        	money[i] = max(money[i<span class="number">-3</span>], money[i<span class="number">-2</span>]);</div><div class="line">        	money[i] += nums[i];</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> largestMoney = money[<span class="number">0</span>];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;numSize; i++) &#123;</div><div class="line">        	<span class="keyword">if</span>(money[i] &gt; largestMoney) &#123;</div><div class="line">        		largestMoney = money[i];</div><div class="line">        	&#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> largestMoney;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// money[i]: max money after reaching house[i], may robbed house[i]</span></div><div class="line">        <span class="keyword">int</span> numSize = nums.size();</div><div class="line">        <span class="keyword">if</span>(numSize == <span class="number">0</span>) &#123;</div><div class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; money(nums.size());</div><div class="line">        money[<span class="number">0</span>] = nums[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span>(numSize &gt; <span class="number">1</span>) &#123;</div><div class="line">        	money[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;numSize; i++) &#123;</div><div class="line">        	money[i] = max(money[i<span class="number">-2</span>]+nums[i], money[i<span class="number">-1</span>]);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">return</span> money[numSize<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>然而，机考时的最小和问题必须满足：不存在相邻两个数不选的情况；显然对于转化为子问题②很难保证这个前提条件。</li>
</ul>
</li>
<li>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#define min(a,b) (a&lt;b?a:b)</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minSum(vector&lt;int&gt;&amp; nums) &#123;</div><div class="line">        // sums[i]: minimum sum ending with nums[i]</div><div class="line">        int numSize = nums.size();</div><div class="line">        if(numSize == 0) &#123;</div><div class="line">        	return 0;</div><div class="line">        &#125;</div><div class="line">        vector&lt;int&gt; sums(nums.size());</div><div class="line">        sums[0] = nums[0];</div><div class="line">        if(numSize &gt; 1) &#123;</div><div class="line">        	sums[1] = nums[1];</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        for(int i=2; i&lt;numSize; i++) &#123;</div><div class="line">        	sums[i] = min(sums[i-2], sums[i-1]);</div><div class="line">        	sums[i] += nums[i];</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        return min(sums[numSize-2], sums[numSize-1]);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;如何对-vector-初始化&quot;&gt;&lt;a href=&quot;#如何对-vector-初始化&quot; class=&quot;headerlink&quot; title=&quot;如何对 vector 初始化&quot;&gt;&lt;/a&gt;如何对 &lt;strong&gt;vector&lt;/strong&gt; 初始化&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;大小为&lt;code&gt;size&lt;/code&gt;的一维向量，二位向量&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;what-type&amp;gt; var-name(what-size);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;what-type&amp;gt;&amp;gt; var-name(rowSize, &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;what-type&amp;gt;(colSize));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;数组转 vector&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; rowSize = ?;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; colSize = ?;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;what-type A_[rowSize][colSize] = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;element1, elment2, ..., element&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;&amp;#125;,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  ...&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;&lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;what-type&amp;gt;&amp;gt; A(rowSize, &lt;span class=&quot;built_in&quot;&gt;vector&lt;/span&gt;&amp;lt;what-type&amp;gt;(colSize));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; row=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; row&amp;lt;rowSize; row++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  A[row].assign(A_[row], A_[row] + colSize);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0020] 几个有关图的问题</title>
    <link href="http://durant35.github.io/2017/06/26/Algorithms_GraphProblems/"/>
    <id>http://durant35.github.io/2017/06/26/Algorithms_GraphProblems/</id>
    <published>2017-06-26T12:26:22.000Z</published>
    <updated>2017-07-06T08:51:01.519Z</updated>
    
    <content type="html"><![CDATA[<h4 id="有向图-vs-无向图"><a href="#有向图-vs-无向图" class="headerlink" title="有向图 vs 无向图"></a>有向图 vs 无向图</h4><ul>
<li>有向图强调<strong>出入度</strong>的概念；无向图，其<strong>邻接矩阵</strong> 是一个对称矩阵。</li>
<li>无向图边的两端是对称的，无向图讲究<strong>连通</strong>这个概念，没有<strong>方向</strong>，没有<strong>拓扑</strong>。</li>
</ul>
<h4 id="判断图是否连通？（一个图有几个连通分量）"><a href="#判断图是否连通？（一个图有几个连通分量）" class="headerlink" title="判断图是否连通？（一个图有几个连通分量）"></a>判断图是否连通？（一个图有几个连通分量）</h4><ul>
<li>从一个指定的点开始，通过不同的策略去遍历这个图，有深度遍历和广度遍历。</li>
<li>每次经过一个节点的时候，首先判断一下这个节点是否已经访问过了，如果没有访问过，则这个节点可以作为下一次继续遍历的候选。</li>
<li>如果这个图是连通的话，这种方法最终会覆盖到整个图。所以可以采用一种计数统计的方式来实现。<ul>
<li>比如说每次访问一个以前没有遍历的节点，则将对应的计数加一。这样当最后遍历结束后，如果统计的节点和图本身的节点一样的话，表示这个图是连通的，否则表示不连通。</li>
</ul>
</li>
<li>这种方法用来判断整个图是否为连通的时候，实际上只要给定一个点，然后按照给定的步骤可以把该点所连接的所有点都涵盖到。如果有其它分隔的部分则不会再处理了，所以，通过这种办法我们在图不是连通的情况下，它只需要涵盖图的一部分就执行结束了。最坏的情况时间复杂度也就是$O(V+E)$。<a id="more"></a></li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">连通分量标识符 counter = <span class="number">1</span>;</div><div class="line">visited[] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">for</span> 所有节点 ?:</div><div class="line">  <span class="keyword">if</span>(!visited[?])</div><div class="line">    dfs(?, visited) 或 bfs(?, visited)</div><div class="line">  counter++;</div><div class="line"> </div><div class="line">counter 为连通分量数目</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="图中任意两个点的连通性"><a href="#图中任意两个点的连通性" class="headerlink" title="图中任意两个点的连通性"></a>图中任意两个点的连通性</h4><ul>
<li>在某些情况下，我们需要考虑的不仅仅是判断整个图是否为连通这么简单，有时候我们需要考虑，给定两个节点$i,  j$，需要判断它们是否相互连接。<ul>
<li>给定两个点，看它们之间是否连通，可能有很多种情况：比如说当整个图是连通的，则它们必然是连通的；而如果整个图不是连通的，但是这两个点是在一个连通的块，它们也是相互连通的。</li>
<li>光遍历一个连通的块是不够的，肯定要遍历完所有的块。另外，如果遍历完一个块仅仅用一个数组来标记是否被访问还是不够的，对于每个不同的连通区域，要进行不同的标识。<ul>
<li>遍历图中间所有节点</li>
<li>所有相通的块必须标识为相同：①遍历一遍所有的节点，对每个节点都调用遍历方法，对于已经访问过的节点则直接跳过；②不管是dfs还是bfs，只要给定一个节点遍历完，这一块连通块我们一路做同样的标记就可以了，只要它们相通那么标记也肯定是一样的</li>
</ul>
</li>
</ul>
</li>
<li>实现的细节上<ul>
<li>考虑用一个计数器和一个数组，对于某个块给计数器设定一个值，然后对应的这个值也放到对应数组的索引的位置里</li>
<li>下一次遍历一个新的块时，对这个计数器加一，这样每次遍历的块的计数器值不同。</li>
<li>给定任意两个节点，只要判断一下数组里对应的计数器值是否相同就可以判断图中任意两个点是否是连通的。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">belongComponent[] = &#123;<span class="number">-1</span>&#125;;</div><div class="line">counter = <span class="number">1</span>;</div><div class="line">visited[] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">for</span> 所有节点?:</div><div class="line">  <span class="keyword">if</span>(!visited[?])</div><div class="line">    dfs(?, visited, belongComponent, counter);</div><div class="line">  counter++;</div><div class="line"> </div><div class="line">判断 belongComponent[i] ?= belongComponent[j]</div><div class="line"> </div><div class="line"><span class="keyword">void</span> dfs(startIdx, visited, belongComponent, counter) &#123;</div><div class="line">  visited[startIdx] = <span class="literal">true</span>;</div><div class="line">  belongComponent[startIdx] = counter;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="深度优先遍历先序-amp-后序"><a href="#深度优先遍历先序-amp-后序" class="headerlink" title="深度优先遍历先序&amp;后序"></a>深度优先遍历先序&amp;后序</h4><ul>
<li>在访问图的时候，假定以深度优先遍历为例。当我们每次遍历到一个节点的时候就访问它，可以称其访问序为前序，而如果等它遍历后递归返回的时候再访问它，这就相当于一个后序。</li>
<li>要实现这两种遍历的方法其实很简单，无非就是在深度优先遍历的时候在访问某个节点前或者在访问结束后将节点加入到队列里。每次在第一次访问某个节点时就往<code>preQueue</code>里面添加元素；而往<code>postQueue</code>里面添加元素，则是在通过该节点以及它所关联的节点都已经遍历结束递归返回的时候。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(graph, startIdx)</span> </span>&#123;</div><div class="line">  <span class="comment">// 先序</span></div><div class="line">  preQueue.push(startIdx);</div><div class="line"> </div><div class="line">  visited[startIdx] = <span class="literal">true</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> 邻接边 startIdx-&gt;?:</div><div class="line">    <span class="keyword">if</span>(!visited[?])</div><div class="line">      dfs(graph, ?)</div><div class="line"> </div><div class="line">  <span class="comment">// 后序</span></div><div class="line">  postQueue.push(startIdx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="图中环的检测"><a href="#图中环的检测" class="headerlink" title="图中环的检测"></a>图中环的检测</h4><ul>
<li>还有一个常见的问题就是检测图中是否存在环？这也是一个很有意思的问题，因为在大多数图的结构中确实是存在环的。<ul>
<li>对于一个连通的图来说，如果它不存在环，则可以称其为树了（如下文），因此环检测的问题在判断一个图是否为树的问题上有很重要的应用。</li>
</ul>
</li>
<li>从图中构成环的任意一个节点开始，如果按照某个方向遍历，最终它某个可以访问的点是它前面已经遍历过的。<ul>
<li>对于一些特殊的情况，比如两个相邻的节点之间的连接，它们不能定义为环，需要被排除：可以增加一个参数，表示访问的当前节点的前一个节点，<font color="green">如果从当前节点所能连接到的节点去遍历的时候，碰到的节点是已经访问过的节点，但是这个节点是它的前一个节点的话，这种情况不能定义为环，我们应该忽略</font>。</li>
<li>如果对于图并不是完全连通的情况呢？为了避免遗漏，肯定要尝试去遍历所有的节点，和前面检测图连通性类似。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">① 遍历所有连通块，记录 prev 节点，同时进行访问标记</div><div class="line">② 如果从当前节点所能连接的节点去遍历时，碰到的节点是已经访问过的</div><div class="line">  (<span class="number">1</span>) 这个节点是当前节点的 prev 节点，不是环</div><div class="line">  (<span class="number">2</span>) 不是 prev 节点，是环</div><div class="line">当环存在时，可以通过 prevs[] 数组返回这个环</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>上述方法仅使用于无向图，对于如下的有向图并不适用：利用上述算法会在节点⑥时检测到环，实际上并不存在环。<center><img src="/img/Algorithms/0020_DG_useless.png" width="420px" alt=""/></center></li>
<li>因此对于有向图，需要对上述算法做以下的补充。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">③ 找到一个还在遍历中的节点，同时在遍历的时候它如果再次被访问到了，则表示找到了环；如果它被访问完了之后返回，则再次碰到它的时候就不是环了</div><div class="line">  (<span class="number">1</span>) <span class="keyword">bool</span> onStack[]：</div><div class="line">    <span class="number">1.1</span> 对这个节点访问前设置，表示在一个递归顺序</div><div class="line">    <span class="number">1.2</span> 访问退出这个递归后，设置回来</div><div class="line">  (<span class="number">2</span>) <span class="keyword">bool</span> visited[]：记录访问过的节点</div><div class="line">  (<span class="number">3</span>) <span class="keyword">int</span> prevs[]：记录环的结果，通过记录前后访问的节点来回溯得到环</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>能够用拓扑排序（下一节）完成对图中所有节点的排序的话，就说明这个图中没有环；如果不能完成，则说明有环。</li>
</ul>
<h4 id="DAG-拓扑排序"><a href="#DAG-拓扑排序" class="headerlink" title="DAG: 拓扑排序"></a>DAG: 拓扑排序</h4><ul>
<li>在一些任务安排和调度的问题里，不同的问题或者任务之间存在一些依赖关系：有的任务需要在某些任务完成之后才能做。像一些学校的教学课程安排：设置某一门课程需要依赖于一个前置的课程，只有学生学习了前置课程之后才能去学习该课程，如果将一门课程当做一个节点，从它引出一个指针指向后序依赖它的课程，就会得到一个有向图。<ul>
<li>对于这种图来说，最大的特点就是它们肯定就不能存在环，不然就有逻辑上的错误。因此，前面检测一个图是否为DAG的方法就是看图中是否有环。</li>
<li>拓扑排序则是在确定没有环的情况下，输出一个正常的序列，这个序列表示从一个不依赖任何元素的节点到后序的节点（这些序列正好符合课程安排或者任务调度的逻辑顺序）。</li>
</ul>
</li>
<li>对于一个有向图来说，如果它不存在环，则它应该为<strong>DAG</strong>。现在的问题是怎么找出这个拓扑序列来？<ul>
<li>基于DFS，结合堆栈的拓扑排序<ul>
<li><strong>证明</strong>：假设对某一已知有向无回路图$G=(V,E)$运行DFS过程，以便确定其顶点的完成时刻。只要证明对任一对不同顶点$u、v∈V$，若$G$中存在一条从$u$到$v$的边，则$finish[v] \lt finish[u]$。考虑过程DFS所探寻的任何边$（u，v）$，当探寻到该边时，顶点$v$必然是已考察完成的顶点或者还未被访问到的顶点：①若$v$是还未被访问到的顶点，则它是$u$的后裔，$finish[v] \lt finish[u]$；②若$v$为已考察完成的顶点，则已完成探索，且$finish[v]$已经设置了。因为仍在探寻$u$，还要为$finish[u]$赋时间戳，同样有$finish[v] \lt finish[u]$。这样一来，对于有向无回路图中任意边$（u, v）$，都有$finish[v]&lt;finish[u]$。</li>
<li><strong>简单解释</strong>：如果存在$u$到$v$的通路，则必然存在$finish[u]&gt;finish[v]$，即$u$肯定在$v$的前面（堆栈先进后出）。</li>
</ul>
</li>
<li>拓扑序列要求的序列必然是开始于一系列入度为０的节点。如果没有入度为０的节点，则表示这个图不是DAG，这样连遍历都没有必要了（<font color="red">当然，如果这个图里有入度为０的节点，并不代表这个图就一定是DAG</font>）。<ul>
<li>怎么来求这些节点的入度：增加一个数组int[] inDegrees，每次我们添加一个边<code>u-&gt;v</code>到图里时，<code>inDegrees[v]++</code>。</li>
<li>取这些入度为０的节点，然后从这些节点遍历图。</li>
</ul>
</li>
<li>实际上，对于深度优先遍历的后序序列，如果我们将它们的顺序完全倒过来，得到的序列就是拓扑排序序列。<ul>
<li>在 DFS 中，依次访问所遍历到的节点；而在拓扑排序时，顶点必须比其邻接点先出现。</li>
<li>用栈来保存拓扑排序的顶点序列，保证在某顶点入栈前，其所有邻接点已入栈。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">对所有入度为<span class="number">0</span>的点</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> startIdx)</span> </span>&#123;</div><div class="line">    visited[startIdx] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> startIdx-&gt;?:</div><div class="line">      <span class="keyword">if</span>(!visited[?])</div><div class="line">        dfs(?);</div><div class="line">    <span class="comment">// 后序深度优先遍历</span></div><div class="line">    topologicalStack.push(startIdx);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>上述算法显然不适用与 <strong>DAG</strong> 不确定的图，假如要检测图中是否存在环，则会最终变成与上一节类似的算法过程。</li>
</ul>
</li>
<li><p>Kahn 算法</p>
<ul>
<li>计算图中所有点的入度，把入度为0的点加入栈</li>
<li>如果栈非空：<ul>
<li>取出栈顶顶点a，输出该顶点的值，删除该顶点</li>
<li>从图中删除所有以a为起始点的边，如果删除边后另一个顶点入度为0，则把它入栈</li>
</ul>
</li>
<li>如果图中还存在顶点，则表示图中存在环；否则输出的顶点就是一个拓扑排序序列</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; setOfZeroIndegree;</div><div class="line"><span class="comment">//stack&lt;int&gt; setOfZeroIndegree;</span></div><div class="line"><span class="comment">// push 所有入度为0的点</span></div><div class="line"><span class="keyword">while</span>(!setOfZeroIndegree.empty()) &#123;</div><div class="line">  <span class="keyword">int</span> vertexIdx = setOfZeroIndegree.front();</div><div class="line">  <span class="comment">//int vertexIdx = setOfZeroIndegree.top();</span></div><div class="line">  setOfZeroIndegree.pop();</div><div class="line"> </div><div class="line">  <span class="comment">// 维护一个拓扑排序序列</span></div><div class="line">  topologicalQueue.push(vertexIdx);</div><div class="line"> </div><div class="line">  <span class="comment">// 遍历由 vertexIdx 引出的所有边 vertexIdx-&gt;?</span></div><div class="line">  <span class="keyword">for</span> ...</div><div class="line">    <span class="comment">// 通过减少边的数量来模拟将邻边 vertexIdx-&gt;? 从图中移除</span></div><div class="line">    edgeNum--;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(<span class="number">0</span> == --inDegrees[graph[vertexIdx][?]]) &#123;</div><div class="line">      setOfZeroIndegree.push(graph[vertexIdx][?]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 如果此时图中还存在边（点），说明图中含有环路</span></div></pre></td></tr></table></figure>
<ul>
<li>顶点进栈出栈，其复杂度为$O(V)$；删除顶点后将邻接点的入度减1，其复杂度为$O(E)$；整个算法的复杂度为$O(V+E)$</li>
<li>如果利用上面的拓扑排序算法求环，可以判断是否有环，但是输出环时有点麻烦（还是上一节的方法比较直接）$Longrightarrow$ 并不是所有最后剩余的点都是环中的顶点，如下图。<center><img src="/img/Algorithms/0020_KahnLoopOutput.png" width="240px" alt=""/></center>

</li>
</ul>
</li>
</ul>
<h4 id="如何判断一个图是否是一棵树？"><a href="#如何判断一个图是否是一棵树？" class="headerlink" title="如何判断一个图是否是一棵树？"></a>如何判断一个图是否是一棵树？</h4><ul>
<li>是连通图</li>
<li>无环</li>
</ul>
<h4 id="判断一个图是否为二分图？"><a href="#判断一个图是否为二分图？" class="headerlink" title="判断一个图是否为二分图？"></a>判断一个图是否为二分图？</h4><ul>
<li>假设我们有一个图，我们尝试用如下的方式去给每个节点着色，总共所有的节点只能着两种颜色中的一种（假设为红色或者蓝色）。对于一个节点来说，假设它着的是某一种颜色，和它相邻的节点只能着另一种颜色。给定一个图，如果这个图满足上述的特性的话，则这个图可以称之为<strong>二分图</strong>。<ul>
<li>判断一个图是否为二分图必然会遍历这个图</li>
<li>每次在判断的时候假定一个节点的颜色为某个值，那么再将它相邻的节点颜色都设置成不同的。因为只是两种颜色，可以直接用布尔值类型来处理。<ul>
<li>对于不属于二分图的情况，肯定是<font color="red">某个节点访问到一个它可以连接到的节点，而这个节点已经被访问过了，但是这个被访问过的节点和当前节点颜色是一样</font>。这样表明它和前面二分图的定义有冲突，所以，我们遍历整个图就是为了判断是否存在这种情况。</li>
</ul>
</li>
</ul>
</li>
<li>实际实现中需要考虑的细节。<ul>
<li>对于所有节点对应的颜色需要定义一个<code>boolean[] color</code>数组</li>
<li>最开始访问一个节点的时候，将其对应<code>color</code>位设置为<code>true</code>，每次访问一个关联的节点时，将关联节点设置成原来节点的相反值。也就是说，比如节点$v$它的颜色为<code>color[v]</code>，那么下一个它被关联的节点$w$的颜色则可以设置成<code>color[w] = !color[v]</code>，正好通过取反实现了颜色的变换。</li>
<li>这里实现的要点还是通过dfs方法<ul>
<li>每次碰到一个节点的时候就要判断一下是否已经访问过：①已经访问过的话，要判断颜色是否相同，相同则表明该图不是一个二分图；②没有访问过的话，则将新节点设置成当前节点的相反值。</li>
<li>然后就是要遍历所有节点，防止遗漏未连接的节点情况。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span>[] color;</div><div class="line">visited[] = <span class="literal">false</span>;</div><div class="line"> </div><div class="line"><span class="keyword">for</span> 所有节点 ?:</div><div class="line">  <span class="keyword">if</span>(!visited[?])</div><div class="line">    color[?] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span>(!dfs(?, visited, color))</div><div class="line">      <span class="comment">// 不是二分图</span></div><div class="line"><span class="comment">// 为二分图</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(startIdx, visited, color)</span> </span>&#123;</div><div class="line">  visited[startIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span> startIdx 邻接边 startIdx-&gt;?:</div><div class="line">    <span class="keyword">if</span>(!visited[?])&#123;</div><div class="line">      color[?] = !color[startIdx];</div><div class="line">      <span class="keyword">if</span>(!dfs(?, visited, color))</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(color[startIdx] == color[?]) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以看出，<font color="red">一个图是不是二分图并不严格要求其必须是一个连通图</font>。</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://shmilyaw-hotmail-com.iteye.com/blog/2113093">无向图的几个基本算法应用</a> </li>
<li><a href="http://shmilyaw-hotmail-com.iteye.com/blog/2116275">有向图的几个算法分析总结</a></li>
<li><a href="http://www.cnblogs.com/dzkang2011/p/toplogicalSort_1.html">图基本算法 拓扑排序（基于dfs)</a></li>
<li><a href="http://www.cnblogs.com/TenosDoIt/p/3644225.html">JustDoIT：判断一个图是否有环</a></li>
<li><a href="http://blog.csdn.net/dm_vincent/article/details/7714519">拓扑排序的原理及其实现</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;有向图-vs-无向图&quot;&gt;&lt;a href=&quot;#有向图-vs-无向图&quot; class=&quot;headerlink&quot; title=&quot;有向图 vs 无向图&quot;&gt;&lt;/a&gt;有向图 vs 无向图&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;有向图强调&lt;strong&gt;出入度&lt;/strong&gt;的概念；无向图，其&lt;strong&gt;邻接矩阵&lt;/strong&gt; 是一个对称矩阵。&lt;/li&gt;
&lt;li&gt;无向图边的两端是对称的，无向图讲究&lt;strong&gt;连通&lt;/strong&gt;这个概念，没有&lt;strong&gt;方向&lt;/strong&gt;，没有&lt;strong&gt;拓扑&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;判断图是否连通？（一个图有几个连通分量）&quot;&gt;&lt;a href=&quot;#判断图是否连通？（一个图有几个连通分量）&quot; class=&quot;headerlink&quot; title=&quot;判断图是否连通？（一个图有几个连通分量）&quot;&gt;&lt;/a&gt;判断图是否连通？（一个图有几个连通分量）&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;从一个指定的点开始，通过不同的策略去遍历这个图，有深度遍历和广度遍历。&lt;/li&gt;
&lt;li&gt;每次经过一个节点的时候，首先判断一下这个节点是否已经访问过了，如果没有访问过，则这个节点可以作为下一次继续遍历的候选。&lt;/li&gt;
&lt;li&gt;如果这个图是连通的话，这种方法最终会覆盖到整个图。所以可以采用一种计数统计的方式来实现。&lt;ul&gt;
&lt;li&gt;比如说每次访问一个以前没有遍历的节点，则将对应的计数加一。这样当最后遍历结束后，如果统计的节点和图本身的节点一样的话，表示这个图是连通的，否则表示不连通。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;这种方法用来判断整个图是否为连通的时候，实际上只要给定一个点，然后按照给定的步骤可以把该点所连接的所有点都涵盖到。如果有其它分隔的部分则不会再处理了，所以，通过这种办法我们在图不是连通的情况下，它只需要涵盖图的一部分就执行结束了。最坏的情况时间复杂度也就是$O(V+E)$。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0019] Greedy Algorithms（贪心策略）</title>
    <link href="http://durant35.github.io/2017/06/26/Algorithms_GreedyAlgorithms/"/>
    <id>http://durant35.github.io/2017/06/26/Algorithms_GreedyAlgorithms/</id>
    <published>2017-06-26T06:00:22.000Z</published>
    <updated>2017-07-06T08:50:42.547Z</updated>
    
    <content type="html"><![CDATA[<h4 id="何为贪心？"><a href="#何为贪心？" class="headerlink" title="何为贪心？"></a>何为贪心？</h4><ul>
<li>贪心算法在解决问题的策略上目光短浅，只根据当前已有的信息就作出选择（下一步的选择总是在当前看来收敛最快和效果最明显的那一个），而且一旦做出了选择，不管将来有什么结果，这个选择策略都不会改变（以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题）。</li>
<li>贪心算法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。</li>
<li>贪心算法对于大部分的优化问题都能产生最优解（如单源最短路径问题，最小生成树等），但不能总获得整体最优解，通常可以获得近似最优解。</li>
<li>贪心策略一旦经过证明成立后，它就是一种高效的算法。<a id="more"></a></li>
</ul>
<h4 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h4><ul>
<li>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// C 是问题的输入集合即候选集合</span></div><div class="line">Greedy(C) &#123;</div><div class="line">  <span class="comment">// 初始解集合 S 为空集</span></div><div class="line">  S = &#123;&#125;;</div><div class="line">  <span class="comment">// 集合 S 没能构成问题的一个解</span></div><div class="line">  <span class="keyword">while</span>(not solution(S)) &#123;</div><div class="line">    <span class="comment">// 在候选集合 C 中做贪心选择</span></div><div class="line">    x = select(C);</div><div class="line">    <span class="comment">// 判断集合 S 加入 x 后的解是否可行</span></div><div class="line">    <span class="keyword">if</span>(feasible(S, x)) &#123;</div><div class="line">      S += &#123;x&#125;;</div><div class="line">      C -= &#123;x&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> S;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><font color="red">候选集合 C</font>：为了构造问题的解决方案，有一个候选集合 C 作为问题的可能解，即问题的最终解均取自于候选集合 C。</li>
<li><font color="red">解集合 S</font>：随着贪心选择的进行，解集和 S 不断扩展，直到构成一个满足问题的完整解。</li>
<li><font color="red">解决函数 solution</font>：检查解集合 S 是否构成问题的完整解？</li>
<li><font color="red">选择函数 select</font>：贪心策略，关键的一步。它指出哪个候选对象最有希望构成问题的解，选择函数通常与目标函数，即求解的问题有关。</li>
<li><font color="red">可行函数 feasible</font>：检查解集合 S 加入候选对象后是否依旧可行？即解集合扩展后是否满足约束条件。</li>
</ul>
<h4 id="贪心算法可行的基本要素"><a href="#贪心算法可行的基本要素" class="headerlink" title="贪心算法可行的基本要素"></a>贪心算法可行的基本要素</h4><blockquote>
<p>是否可用贪心算法求解？</p>
</blockquote>
<ul>
<li><font color="red">子问题</font>：为了解决某一优化问题（目标函数），需要依次作出 n 个决策 $D_1, D_2, …, D_n$，对于任何一次决策 $D_k, 1 \lt k \lt n$，以 $D_k$ 作为问题的初始状态，来进行以后的决策 $D_{k+1}$…，这样的每次决策就成为是原问题的一个子问题；贪心算法以迭代的方式作出相继的贪心选择，每做一次贪心选择，就将所求问题简化成规模更小的子问题。</li>
<li><strong>① 贪心选择性质</strong><ul>
<li>所求问题的整体最优解可以通过一系列局部最优的选择得到，即对于一个具体问题，要确定它是否具有贪心选择的性质，必须证明每一步所做的贪心选择最终导致问题的整体最优解。</li>
<li>当考虑当前问题的做何种选择的时候，只需考虑对当前问题最佳的选择而不用考虑子问题的结果。</li>
</ul>
</li>
<li><strong>② 最优子结构性质</strong>（关键基本元素）<ul>
<li>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</li>
</ul>
</li>
</ul>
<h4 id="活动选择问题"><a href="#活动选择问题" class="headerlink" title="活动选择问题"></a>活动选择问题</h4><ul>
<li>问题描述<blockquote>
<p>假设有一个需要使用某个资源的$n$个活动组成的集合 $S= \verb|{|a1，a2，···，an \verb|}|$，该资源每次只能由一个活动占用。每个活动 $a[i]$ 都有一个开始时间 $s[i]$ 和结束时间 $f[i]$，且 $0 \leq s[i] \lt f[i] \lt ∞$。一旦被选择后，活动 $a[i]$ 就占据半开时间区间 $[s[i], f[i])$。若时间区间 $[s[i], f[i])$ 与区间 $[s[j], f[j])$ 互不重叠，则称活动 $a[i] $与活动 $a[j]$ 是兼容的。也就是说，当 $s[i] \geq f[j]$ 或 $s[j] \geq f[i]$ 时，活动 $a[i]$ 与活动 $a[j]$ 兼容。活动选择问题就是要选择一个由兼容活动构成的最大集合。</p>
</blockquote>
</li>
<li>DP策略：贪心是特殊的 DP<ul>
<li><font color="blue">Step1</font>：活动选择问题就是要选择一个由兼容活动构成的最大集合，子问题是什么，兼容活动集合，这样的子问题有 $2^n$。所以我们才用 <strong>DP</strong> 来优化它，如果子问题的最优解可以构造成原问题的最优解，那么此问题就具有<strong>② 最优子结构性质</strong>。<ul>
<li>定义 $S[i, j] = \verb|{|a[k]∈S: f[i] \leq s[k] &lt; f[k] \leq s[j] \verb|}|$，$S$ 是所有活动集合。$S[i, j]$ 就是原问题集合 $S$ 的子问题，其中的每个活动都是在活动 $a[i]$ 结束之后开始，且在 $a[j]$ 开始之前结束，更重要的是 $S[i, j]$ 中的活动都要相互兼容。</li>
<li>为了表示完整的问题集合，虚构两个活动 $a[0], a[n+1], f[0]=0, s[n+1]=∞$，这样 $S=S[0，n+1]$。</li>
</ul>
</li>
<li><font color="blue">Step2</font>：为了减少问题的处理量，给所有活动按结束时间递增的顺序排序。这样的话如果 $i \geq j, S[i, j] = ∅$。<ul>
<li>假设有一个 $a[k]∈S[i,j], 则 f[i] \leq s[k] \lt f[k] \leq s[j]$。说明 $a[i]$ 活动排在 $a[j]$ 活动前面，也即是 $i \lt j$，这与 $i \geq j$ 矛盾。所以来说，如果将<font color="red">活动按结束时间非递减排序</font>的话，则子问题就是 $S[i, j]$，$0 \leq i \lt j \leq n+1$，其他的 $S[i, j]$ 是空集。</li>
</ul>
</li>
<li><font color="blue">Step3</font>：针对于 $S[i, j]$ 中的 $a[k]$，我们把子问题分成 $S[i, k], S[k, j]$ 和 $a[k]$。则 $S[i, j]$ 的最优解就是 $S[i, k]$ 的最优解加上 $S[k, j]$ 的最优解捎带一个 $a[k]$ 的并集。设 $C[i, j]$ 是 $S[i, j]$ 的最优解，即是 $S[i, j]$ 中最大兼容活动数。<br>$$ C[i, j]  = \begin{cases} 0, S[i, j] = \emptyset \cr max_{i &lt; k &lt; j} \verb|{| C[i, k]+C[k, j]+1 \verb|}|,  S[i, j] != \emptyset \end{cases}$$</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>贪心算法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将活动按结束时间非递减排序</span></div><div class="line"> </div><div class="line">Activity-Selector(s, f, i, j) &#123;</div><div class="line">  m &lt;-- i+<span class="number">1</span></div><div class="line">  <span class="comment">// find the first activity in S[i,j]</span></div><div class="line">  <span class="keyword">while</span> m&lt;j and s[m]&lt;f[i] &#123;&#125;</div><div class="line"> </div><div class="line">  <span class="keyword">if</span>(m&lt;j)</div><div class="line">    <span class="keyword">return</span> &#123;a[m]&#125; ∪ Activity-Selector(s, f, m, j)</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> ∅</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>贪心策略：最早结束的活动肯定就是当前子问题的最优活动。对于任何非空 $S[i,j]$，设 $a[m]$ 是 $S[i, j]$ 中最早结束的一个活动，$f[m] = min{f[k]: a[k]∈S[i, j]}$，则<ul>
<li><strong>① 贪心选择性质</strong>（贪心策略是安全的）：活动 $a[m]$ 被包含在 $S[i, j]$ 的一个（可能有多个）最大兼容活动的子集中<ul>
<li>假设 $a[k]$ 是 $S[i, j]$ 最优解 $C[i, j]$ 的第一个活动（排序之后），如果 $a[m] = a[k]$，结论得证</li>
<li>如果 $a[m], a[k]$ 不相等，那么就用 $a[m]$ 替换 $a[k]$（因为 $a[m]$ 是最早结束的活动，替换之后肯定和其他的兼容），原问题的最大兼容活动数目没变，结论得证。</li>
</ul>
</li>
<li>最早结束的活动 $a[m]$ 肯定就是当前子问题的最优活动！你选择了 $a[m]$，那么剩余问题的最优解就是 $S[m, j]$ 的最优解。</li>
<li>这就是贪心算法，每次都选择当前最好的选择，意思就是已经选定是最优活动，那么之后选择的最优要和之前选定的活动兼容，这样每次选择的活动都是和之前兼容的，那所有的活动也就只是考虑一次而已。</li>
</ul>
</li>
<li>Greedy（贪心） vs DP（动态规划）<ul>
<li>DP 和贪心的区别就是做选择的时候贪心所做出的选择是当前最佳，要依赖已经做出的所有贪心选择，而不依赖有待于做出选择的子问题的解。而 DP 具有无后效性，未来与过去无关，当前的状态是此前历史的一个完整总结，不会依赖已经得到子问题的解，只是和以后的子问题有关系，这点和贪心刚好相反。</li>
<li><font color="red">DP 是通过小问题来得到大问题的解，而贪心是一次一次做出贪心选择，然后不断将给定的问题规约为更小的子问题</font>。<strong>DP要自底向上，贪心可以自顶向下</strong>地解决问题。</li>
<li>DP 还具有重叠子问题的性质，从上面也可以看出来，这点是贪心不具备的。</li>
</ul>
</li>
<li>活动时间安排的例题<ul>
<li><a href="#">Sicily1001. 会议安排</a><blockquote>
<p>N个会议要同时举行，参会人数分别为$A[0], A[1], …, A[N-1]$. 现有M个会议室，会议室可容纳人数分别为$B[0], B[1], …, B[M-1]$. 当$A[i]&lt;=B[j]$时，可以把会议$i$安排在会议室$j$，每间会议室最多安排一个会议，每个会议最多只能安排一个会议室. 求最多安排多少个会议？</p>
<ul>
<li>贪心策略：参会人数少的会议先安排，怎么安排呢？安排到能满足容纳人数的最小的会议室。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Problem#: 20617</span></div><div class="line"><span class="comment">// Submission#: 5148744</span></div><div class="line"><span class="comment">// The source code is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</span></div><div class="line"><span class="comment">// URI: http://creativecommons.org/licenses/by-nc-sa/3.0/</span></div><div class="line"><span class="comment">// All Copyright reserved by Informatic Lab of Sun Yat-sen University</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">assignConferenceRoom</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> conferenceNum = A.size();</div><div class="line">        <span class="keyword">int</span> roomNum = B.size();</div><div class="line">        <span class="keyword">if</span>(conferenceNum==<span class="number">0</span> || roomNum==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// sort conference in conferee increasing order</span></div><div class="line">        sort(A.begin(), A.end(), less&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        <span class="comment">// sort room in room's size increasing order</span></div><div class="line">        sort(B.begin(), B.end(), less&lt;<span class="keyword">int</span>&gt;());</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> conferenceOpenNum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> bIdx=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> aIdx=<span class="number">0</span>; aIdx&lt;conferenceNum; aIdx++) &#123;</div><div class="line">            <span class="keyword">while</span>(bIdx&lt;roomNum) &#123;</div><div class="line">                <span class="keyword">if</span>(A[aIdx]&lt;=B[bIdx++]) &#123;</div><div class="line">                    conferenceOpenNum++;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(bIdx == roomNum) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> conferenceOpenNum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="其他几个经典问题"><a href="#其他几个经典问题" class="headerlink" title="其他几个经典问题"></a>其他几个经典问题</h4><ul>
<li>区间覆盖问题（近似活动选择问题）：多个区间，存在相互覆盖，要求去除多余的空间，使剩下的区间（不存在相互覆盖了）占用长度最大。</li>
<li>线段覆盖（lines cover）：在一维空间中告诉你 N 条线段的起始坐标和终止坐标，要求求出这些线段一共覆盖了多大的长度。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 优先选择：s[i] 由小到大排序</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> pre=<span class="number">0</span>, <span class="keyword">int</span> cur=<span class="number">1</span>; cur&lt;size; cur++) &#123;</div><div class="line">  <span class="comment">// 相邻线段不存在覆盖</span></div><div class="line">  <span class="keyword">if</span>(s[cur] &gt;= f[pre]) &#123;</div><div class="line">    lineCover += f[cur] - s[cur];</div><div class="line">    pre = cur;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 存在相互覆盖</span></div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 不仅覆盖，还被包含，直接丢弃当前线段</span></div><div class="line">    <span class="keyword">if</span>(f[cur]&lt;=f[pre]) &#123;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      lineCover += f[cur] - s[pre];</div><div class="line">      pre = cur;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>数字组合问题：有 N 个正整数，使它们连接在一起成立最大的数字<ul>
<li>冒泡排序：冒泡条件 $\Longrightarrow$ 开头最大的数字</li>
</ul>
</li>
<li>背包问题<ul>
<li>问题描述<blockquote>
<p>有一个背包，背包容量是$M$。有$N$个任意大小 $wi$，价值 $pi$ 的物品。要求尽可能让装入背包中的物品总价值最大，但不能超过背包总容量。<br>目标函数： $\sum_i^N pi$最大<br>约束条件：装入的物品总重量不超过背包容量：$\sum_i^N wi&lt;=M$。</p>
</blockquote>
</li>
<li>根据贪心的策略<ul>
<li>每次挑选价值最大的物品装入背包，得到的结果是否最优？</li>
<li>每次挑选所占重量最小的物品装入是否能得到最优解？</li>
<li>每次选取单位重量价值最大的物品，成为解本题的策略。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html">五大常用算法之三：贪心算法</a></li>
<li><a href="http://www.hahack.com/wiki/algorithms-greedy.html">HaHack：贪婪算法</a></li>
<li><a href="http://blog.csdn.net/effective_coder/article/details/8736718">K神丶的专栏：贪心算法详解</a></li>
<li>活动选择问题：<a href="http://blog.csdn.net/liangbopirates/article/details/10044463">承续缘的信仰：贪心算法详解</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;何为贪心？&quot;&gt;&lt;a href=&quot;#何为贪心？&quot; class=&quot;headerlink&quot; title=&quot;何为贪心？&quot;&gt;&lt;/a&gt;何为贪心？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;贪心算法在解决问题的策略上目光短浅，只根据当前已有的信息就作出选择（下一步的选择总是在当前看来收敛最快和效果最明显的那一个），而且一旦做出了选择，不管将来有什么结果，这个选择策略都不会改变（以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题）。&lt;/li&gt;
&lt;li&gt;贪心算法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。&lt;/li&gt;
&lt;li&gt;贪心算法对于大部分的优化问题都能产生最优解（如单源最短路径问题，最小生成树等），但不能总获得整体最优解，通常可以获得近似最优解。&lt;/li&gt;
&lt;li&gt;贪心策略一旦经过证明成立后，它就是一种高效的算法。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0018] 图的点连通度和边连通度</title>
    <link href="http://durant35.github.io/2017/06/24/Algorithms_Vertex&amp;Edge%20connectivity%20degree/"/>
    <id>http://durant35.github.io/2017/06/24/Algorithms_Vertex&amp;Edge connectivity degree/</id>
    <published>2017-06-24T06:00:22.000Z</published>
    <updated>2017-07-06T08:49:40.478Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念？"><a href="#基本概念？" class="headerlink" title="基本概念？"></a>基本概念？</h4><ul>
<li>点连通度（图的连通度）：对应一个图 $G$，对于所有点集 $U \subset V_G$，也就是 $V_G$ 的子集中，使得 $G-U$（在图 $G$ 中删去 $U$ 和与 $U$ 关联的边）要么是一个非连通图，要么就是一个平凡图，其中最小的集合 $U$ 的大小 $|U|$ 就是图 $G$ 的<strong>点连通度</strong>（有时候也直接称为<strong>图的连通度</strong>）。<a id="more"></a><blockquote>
<p>连通图&amp;非连通图（无向图）</p>
<ul>
<li>如果无向图 $G$ 中任意一对顶点都是连通的，此图是<code>连通图</code>；</li>
<li>相反，如果一个无向图不是连通图，则称为<code>非连通图</code>。</li>
</ul>
<p>强连通&amp;单连通&amp;弱连通（有向图）</p>
<ul>
<li>如果对有向图 $G$ 中任意两个顶点 $u$ 和 $v$，既存在从 $u$ 到 $v$ 的路径，也存在从 $v$ 到 $u$ 的路径，则称该有向图 $G$ 为<code>强连通有向图</code>；</li>
<li>如果仅存在从 $u$ 到 $v$ 的路径，或从 $v$ 到 $u$ 的路径，则称该有向图 $G$ 为<code>单连通有向图</code>；</li>
<li>如果忽略有向图 $G$ 中每条有向边的方向，得到的无向图（即该有向图的基图）是连通图，则称该有向图 $G$ 为<code>弱连通有向图</code>。</li>
</ul>
<p>平凡图&amp;非平凡图</p>
<ul>
<li>只有一个节点，没有边的图为<code>平凡图</code>；</li>
<li>有至少两个节点，一条边的图，为<code>非平凡图</code>。</li>
</ul>
</blockquote>
</li>
</ul>
<p>　　只许删点，求至少要删掉几个点，即一个图 $G$ 最少要去掉多少个点会变成非连通图或者平凡图：对于一个完全图 $K_n$ 来说，它的（点）连通度为 $n-1$。</p>
<blockquote>
<p><code>完全图</code>：若一个图的每一对不同顶点恰有一条边相连。</p>
</blockquote>
<ul>
<li>边连通度：同理，<strong>边连通度</strong>就是对于一个非平凡图 $G$，至少去掉多少条边才能使得该图变成非连通图。<br>　　只许删边，求至少要删掉几条边。</li>
</ul>
<h4 id="如何求解？"><a href="#如何求解？" class="headerlink" title="如何求解？"></a>如何求解？</h4><p>　　对于任意一个图，如何求该<strong>图的（点）连通度</strong>和<strong>边连通度</strong>呢？</p>
<ul>
<li><code>有向图的边连通度</code>其实就是一个<a href="https://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/">最小割问题</a>。<ul>
<li>求解思路<ul>
<li>将原图 $G$ 中每条边$\lt u, v \gt$设置为容量为1的边，其它都不需要修改，即可得到对应的流网络图</li>
<li>任意选取一个节点 $u$ 作为源点，枚举其他所有与节点 $u$ 不相邻的节点作为汇点，求所有汇点情况下的各个最大流</li>
<li>其中最小的那个最大流即为原图的边连通度</li>
</ul>
</li>
<li>最小的最大流中，所有流量为1的边组成的边集即为最小的边割集（割边集/割集）<blockquote>
<p>设 $E’$ 是连通图 $G$ 的边集的子集，在 $G$ 中删去 $E’$ 后图不连通，则称 $E’$ 是 $G$ 的<code>割边集</code></p>
<ul>
<li>如果割边集 $E’$ 的任何真子集都不是割边集，则称 $E’$ 为<code>极小割边集</code></li>
<li>边的数目（图 $G$ 的边连通度）最小的极小割边集称为 <code>最小割边集</code></li>
</ul>
<p>如果割边集中只有一条边，则该边可以称为<code>割边</code>（或<code>桥</code>）</p>
</blockquote>
</li>
</ul>
</li>
<li><code>有向图的点连通度</code><ul>
<li>求解思路<ul>
<li>点连通度的流网络构造方法其实是将点连通度的求解转化为了边连通度的求解；<ul>
<li>对于有向图 $G$，将每个节点 $u$ 拆分成 $u1$ 和 $u2$ 两个节点，并添加一条 $u1$ 到 $u2$ 容量为1的边$\lt u, v \gt$；</li>
<li>对于原图 $G$ 中的边$\lt u, v \gt$，对应在新网络中有边$\lt u2, v1 \gt$，容量为正无穷，即可得到对应的流网络图。<blockquote>
<p><font color="red">实际上：</font><br>　原图 $G$ 上节点 $u$，$v$ 和从 $u$ 到 $v$ 的边<code>&lt;u,v&gt;</code>在对应的流网络中为节点 $u1$，$u2$，$v1$ 和 $v2$ 以及边<code>&lt;u1,u2&gt;</code>（容量为1）；<code>&lt;u2,v1&gt;</code>（容量为正无穷）；<code>&lt;v1,v2&gt;</code>（容量为1），也是一条路径。</p>
</blockquote>
</li>
</ul>
</li>
<li>也是在上述对应的流网络上任意选取一个节点 $u$ 作为源点，枚举所有其他不相邻的节点求最大流，其中最小的那个最大流即为原图 $G$ 的点连通度。</li>
</ul>
</li>
<li>最小的最大流中，所有流量为1的边\lt u1, u2 \gt$对应的原图中的同一节点 $u$ 组成的点集即为最小的点割集（割顶集/割点集）<blockquote>
<p>设 $V’$ 是连通图 $G$ 的一个顶点子集，在 $G$ 中删去 $V’$ 和与 $V’$ 关联的边后图不连通，则称 $V’$ 是 $G$ 的<code>割顶集</code></p>
<ul>
<li>如果割边顶集 $V’$ 的任何真子集都不是割顶集，则称 $V’$ 为<code>极小割顶集</code></li>
<li>顶点个数（图 $G$ 的（点）连通度）最小的极小割顶集称为 <code>最小割顶集</code></li>
</ul>
<p>如果割顶集中只有一个顶点，则该顶点可以称为<code>割点</code>（或<code>关节点</code>）</p>
</blockquote>
</li>
</ul>
</li>
<li><code>关于无向图</code>：将图中的每条边 $(u, v)$ 拆成 $\lt u, v \gt$ 和 $\lt v, u \gt$ 两条边，即转成有向图处理。</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9467709">图的匹配问题与最大流问题（四）——计算图的边连通度和点连通度</a> </li>
<li><a href="http://www.cppblog.com/matono1/archive/2011/04/05/143449.html">图的连通度问题的求法</a></li>
<li><a href="https://www.zybuluo.com/DATASOURCE/note/168108">图的连通性问题</a></li>
<li><a href="https://github.com/zhaochenyou/Way-to-Algorithm/blob/master/5_GraphTheory/5_FlowNetwork/11_connectivity.cpp">Github: zhaochenyou/Way-to-Algorithm 连通度基础概念</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念？&quot;&gt;&lt;a href=&quot;#基本概念？&quot; class=&quot;headerlink&quot; title=&quot;基本概念？&quot;&gt;&lt;/a&gt;基本概念？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;点连通度（图的连通度）：对应一个图 $G$，对于所有点集 $U \subset V_G$，也就是 $V_G$ 的子集中，使得 $G-U$（在图 $G$ 中删去 $U$ 和与 $U$ 关联的边）要么是一个非连通图，要么就是一个平凡图，其中最小的集合 $U$ 的大小 $|U|$ 就是图 $G$ 的&lt;strong&gt;点连通度&lt;/strong&gt;（有时候也直接称为&lt;strong&gt;图的连通度&lt;/strong&gt;）。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0017] NP-完全问题：概述（两道证明习题）</title>
    <link href="http://durant35.github.io/2017/06/08/Algorithms_NP-Complete(I)/"/>
    <id>http://durant35.github.io/2017/06/08/Algorithms_NP-Complete(I)/</id>
    <published>2017-06-08T06:00:22.000Z</published>
    <updated>2017-07-06T08:49:26.226Z</updated>
    
    <content type="html"><![CDATA[<p>　　在计算机算法求解问题当中，经常用<code>时间复杂度</code>和<code>空间复杂度</code>来表示一个算法的运行效率。空间复杂度表示一个算法在计算过程当中要占用的内存空间大小；时间复杂度则表示这个算法运行得到想要的解所需的计算工作量，并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快，即探讨的是当输入值接近无穷时，算法所需工作量的变化快慢程度。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。<a id="more"></a><br>　　不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有$O(1)$的时间复杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是$O(N)$，比如找$N$个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于$O(N^2)$的复杂度；还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是$O(a^N)$的指数级复杂度，甚至$O(N!)$的阶乘级复杂度。时间复杂度排序：$O(1) \lt O(N) \lt O(logN) \lt O(N^2) \lt O(N^a) \lt O(b^N) \lt O(N!)$（$a \gt 2, b \gt 1$，$N$表示输入的数据个数）。<br>　　容易看出，前面的几类复杂度被分为两种级别，其中后者的复杂度无论如何都远远大于前者：一种是$O(1), O(logN), O(N^a)$等，我们把它叫做多项式级（$ax^n - bx^{n-1} + … + c$）的时间复杂度，因为它的规模$N$出现在底数的位置；另一种是$O(a^N)$和$O(N!)$型复杂度，它是非多项式级的，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法通常都需要是多项式级的时间复杂度，非多项式级的时间复杂度需要的时间太多，往往会超时，除非是数据规模非常小。<br>　　自然地，人们会想到一个问题：会不会所有的问题都可以找到复杂度为多项式级的算法呢？很遗憾，答案是否定的。有些问题甚至根本不可能找到一个正确的算法来，这称之为<strong>“不可解问题”(Undecidable Decision Problem)</strong>。下面引入 <code>P问题</code>、<code>NP问题</code> 等概念对一个问题求解的复杂度进行不同等级的评估。</p>
<h4 id="P-问题"><a href="#P-问题" class="headerlink" title="P 问题"></a>P 问题</h4><p>　如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于<code>P问题</code>，P(olynominal) 问题。</p>
<h4 id="NP-问题"><a href="#NP-问题" class="headerlink" title="NP 问题"></a>NP 问题</h4><p>　能在多项式时间内验证给出的一个解的问题属于<code>NP问题</code>，Nondeterministic Polynominal，非确定性多项式问题。</p>
<ul>
<li>NP 问题不是非 P 类问题，NP问题的另一个定义是，可以在多项式的时间里猜出一个解的问题。之所以要定义NP问题，是因为通常只有 NP 问题才可能找到多项式时间复杂度的算法，因为我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多项式级的算法。</li>
<li>NP 问题，实际上是在探讨 NP 问题与 P 问题的关系。<ul>
<li>很显然，<strong>所有的 P 问题都是 NP 问题</strong>，也就是说，能多项式地解决一个问题，必然能多项式时间内验证一个问题的解（既然正解都出来了，验证任意给定的解也只需要比较一下就可以了）。</li>
<li><strong>是否所有的 NP 问题都是 P 问题</strong>？我们可以用集合的观点来说明：如果把所有 P 类问题归为一个集合 P 中，把所有 NP 问题划进另一个集合 NP 中，那么，显然有P 属于 NP。现在，所有对 NP 问题的研究都集中在一个问题上，即究竟是否有 <code>P=NP</code>？在研究 NP 问题的过程中找出了一类非常特殊的 NP 问题叫做 <code>NP-完全问题</code>，也即所谓的 NPC 问题。正是 NPC 问题的存在，使人们相信 <code>P≠NP</code>。</li>
</ul>
</li>
</ul>
<h4 id="NPC-NP-Complete-问题"><a href="#NPC-NP-Complete-问题" class="headerlink" title="NPC(NP-Complete) 问题"></a>NPC(NP-Complete) 问题</h4><p>　<code>NPC问题</code>的定义非常简单，同时满足下面两个条件的问题就是 NPC 问题：① 首先，它得是一个 NP 问题；②然后，所有的 NP 问题都可以在多项式时间内归约到它。即如果所有 NP 问题都能在多项式时间内归约到一个 NP 问题，则称该 NP 问题为 <code>NPC问题</code>，NP Complete，NP 完全问题。</p>
<ul>
<li>什么是 <strong>归约</strong>？<ul>
<li>归约(Reducibility，有的资料上叫“约化”)。一个问题A可以归约到问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”问题B。<ul>
<li>举个例子，一元一次方程的求解，跟二元一次方程的求解</li>
<li>我们知道，只要能求解二元一次方程，那就可以用二元一次方程的解法来求解一元一次方程，只需要将一元一次方程加上y，并附加一个方程y=0就可以将一元一次方程变形为一个二元一次方程，然后用二元一次方程的解法来求解这个方程。</li>
<li>注意，这里二元一次方程的解法会比一元一次的复杂。所以我们说，只需要找到解二元一次方程的规则性解法，那就能用这个规则性解法来求解一元一次方程。</li>
</ul>
</li>
<li>“问题A可归约到问题B” 有一个重要的直观意义：B的时间复杂度≥A的时间复杂度，也就是说，问题A不比问题B难。<ul>
<li>这很容易理解。既然问题A能用问题B来解决，倘若B的时间复杂度比A的时间复杂度还低了，那A的算法就可以改进为B的算法，两者的时间复杂度还是相同。</li>
<li>正如解一元二次方程比解一元一次方程难，因为解决前者的方法可以用来解决后者。</li>
</ul>
</li>
<li>很显然，归约具有一项重要的性质：归约具有传递性。如果问题A可归约到问题B，问题B可归约到问题C，则问题A一定归约到问题C。<ul>
<li>不断归约下去，我们会发现一个很惊人的特性：就是一定会存在一个最大的问题，我们只需要解决了这个问题，那其下的所有问题也就解决啦！这个问题就是上面所说的 NPC 问题！！！</li>
</ul>
</li>
<li>对于同一类的所有的 NP 问题，若他们都可以在多项式时间内归约到 NPC 问题（更复杂的时间复杂度），当我们针对这个时间复杂度最高的超级 NP 问题要是能找到他的多项式时间算法的话，那就等于变向地证明了其下的所有属于同一类的 NP 问题都是存在多项式算法的，即 <code>NP=P</code>！！！！</li>
</ul>
</li>
<li>NPC 问题是 NP 问题的子集。</li>
<li>证明一个问题是 NPC 问题也很简单：先证明它至少是一个 NP 问题，再证明一个已知的 NPC 问题能在多项式时间内归约到它（由归约的传递性，则 NPC 问题定义的第二条条件也得以满足；至于第一个 NPC 问题是怎么来的？），这样就可以说它是 NPC 问题了。</li>
<li>既然所有的 NP 问题都能归约成 NPC 问题，那么只要任意一个 NPC 问题找到了一个多项式时间复杂度的算法，那么所有的 NP 问题都能用这个算法解决了，NP 也就等于 P 了。因此，给 NPC 找一个多项式时间复杂度算法太不可思议了。因此，上文才说，“正是 NPC 问题的存在，使人们相信 P≠NP”。</li>
<li>我们可以直观地理解：NPC 问题目前没有多项式的有效算法，只能用指数级甚至阶乘级复杂度进行搜索求解。</li>
</ul>
<h4 id="两道习题：如何证明一个问题是-NPC-NP-Complete-问题"><a href="#两道习题：如何证明一个问题是-NPC-NP-Complete-问题" class="headerlink" title="两道习题：如何证明一个问题是 NPC(NP-Complete) 问题"></a>两道习题：如何证明一个问题是 NPC(NP-Complete) 问题</h4><ul>
<li>证明一个问题是 NPC 问题<ul>
<li>先证明它至少是一个 NP 问题；</li>
<li>再证明一个已知的 NPC 问题能在多项式时间内归约到它。</li>
</ul>
</li>
</ul>
<h5 id="两道习题"><a href="#两道习题" class="headerlink" title="两道习题"></a>两道习题</h5><blockquote>
<ul>
<li>[8.3] <strong>STINGY SAT</strong> is the following problem: given a set of clauses (each a disjunction of literals) and an integer k, find a satisfying assignment in which at most k variables are true, if such an assignment exists. Prove that <strong>STINGY SAT</strong> is NP-complete.</li>
</ul>
</blockquote>
<ul>
<li><strong>STINGY SAT</strong> 是这样的：给定一组子句（每个子句都是其中变量的析取）和整数$k$，求一个最多有$k$个变量为 true 的满足赋值——如果该赋值存在。证明 <strong>STINGY SAT</strong> 是一个 NP-完全问题。<ul>
<li>首先，易知 <strong>STINGY SAT</strong> 的解是可在多项式时间内验证的，因此 <strong>STINGY SAT</strong> 是一个 NP 问题。</li>
<li>另外，很容易可以将 <strong>SAT</strong> 归约到 <strong>STINGY SAT</strong>：将 k 设为 <strong>SAT</strong> 问题中所有变量的总个数即可，于是证明：<strong>STINGY SAT</strong> 是一个 NP 完全问题。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>[8.8] In the <strong>EXACT 4SAT</strong> problem, the input is a set of clauses, each of which is a disjunction of exactly four literals, and such that each variable occurs at most once in each clause. The goal is to find a satisfying assignment, if one exists. Prove that <strong>EXACT 4SAT</strong> is NP-complete.</li>
</ul>
</blockquote>
<ul>
<li>在 <strong>EXACT 4SAT</strong> 问题中，输入为一组子句，每个字句都是恰好 4 个变量的析取，且每个变量最多在每个子句中出现一次；目标是求它的满足——如果该赋值存在。证明 <strong>EXACT 4SAT</strong> 是一个 NP-完全问题。<ul>
<li>首先很显然，<strong>EXACT 4SAT</strong> 是一个 NP 问题。</li>
<li>现在通过将 <strong>3SAT</strong> 归约到 <strong>EXACT 4SAT</strong> 来证明后者的 NP 完全性。<ul>
<li>对于任意一个 <strong>3SAT</strong> 实例（一组子句），如果其中某个子句中包含了同一个变量多次，那么可以缩减为一次；如果同时包含了某个变量本身及其取反，那么可以将这个变量去掉。</li>
<li>然后，再在每个子句中添加一些哑变量（即没用的辅助变量，赋值为 true），这样就可以将每个子句所包含的变量数目扩充到 4 个。至此，即已将该 <strong>3SAT</strong> 实例转化成了一个 <strong>EXACT 4SAT</strong> 实例，于是证明：<strong>EXACT 4SAT</strong> 是一个 NP-完全问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="NPH-NP-Hard-问题"><a href="#NPH-NP-Hard-问题" class="headerlink" title="NPH(NP-Hard) 问题"></a>NPH(NP-Hard) 问题</h4><p>　假如一个问题，不是一个 NP 问题，但所有的 NPC 问题都可以在多项式时间内归约到它的话，我们就叫它 <code>NPH问题</code>，NP Hard，NP 难问题。</p>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://www.matrix67.com/blog/archives/105">什么是P问题、NP问题和NPC问题</a></li>
<li><a href="http://blog.csdn.net/databatman/article/details/49304295">[总结]算法中的P问题、NP问题、NP完全问题和NP难问题</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　在计算机算法求解问题当中，经常用&lt;code&gt;时间复杂度&lt;/code&gt;和&lt;code&gt;空间复杂度&lt;/code&gt;来表示一个算法的运行效率。空间复杂度表示一个算法在计算过程当中要占用的内存空间大小；时间复杂度则表示这个算法运行得到想要的解所需的计算工作量，并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长得有多快，即探讨的是当输入值接近无穷时，算法所需工作量的变化快慢程度。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢了数万倍。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>DARPA[Boss]: Motion Planning in Urban Environments</title>
    <link href="http://durant35.github.io/2017/06/02/DARPA_Boss_MotionPlanninginUrbanEnvironments/"/>
    <id>http://durant35.github.io/2017/06/02/DARPA_Boss_MotionPlanninginUrbanEnvironments/</id>
    <published>2017-06-02T05:00:22.000Z</published>
    <updated>2017-06-03T14:37:33.593Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ul>
<li>model-predictIve trajectory generation algorithm（模型预测轨迹生成算法）</li>
<li>long range plans<ul>
<li>on-road planning</li>
<li>unstructured planning: parking lots/anomalous on-road scenarios（异常路况）<a id="more"></a>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;model-predictIve trajectory generation algorithm（模型预测轨迹生成算法）&lt;/li&gt;
&lt;li&gt;long range plans&lt;ul&gt;
&lt;li&gt;on-road planning&lt;/li&gt;
&lt;li&gt;unstructured planning: parking lots/anomalous on-road scenarios（异常路况）
    
    </summary>
    
      <category term="自动驾驶" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
      <category term="DARPA" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/DARPA/"/>
    
    
      <category term="DARPA" scheme="http://durant35.github.io/tags/DARPA/"/>
    
  </entry>
  
  <entry>
    <title>DARPA[Boss]: Boss and the Urban Challenge</title>
    <link href="http://durant35.github.io/2017/06/02/DARPA_Boss_BossandtheUrbanChallenge/"/>
    <id>http://durant35.github.io/2017/06/02/DARPA_Boss_BossandtheUrbanChallenge/</id>
    <published>2017-06-02T05:00:22.000Z</published>
    <updated>2017-06-04T02:37:58.380Z</updated>
    
    <content type="html"><![CDATA[<p>　Boss 自动驾驶软硬件概述。</p>
<h4 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h4><ul>
<li>软件概述<ul>
<li>Motion planning sub-system<br>==&gt; 2 planners: avoiding static and dynamic obstacles while achieving a desired goal（最终都是产生一条 trajectory）<ul>
<li>structured driving: road following</li>
<li>unstructured driving: maneuvering in parking lots（停车场等的机动控制）</li>
</ul>
</li>
<li>Perception sub-system<a id="more"></a>
<ul>
<li>static obstacle map</li>
<li>moving obstacles</li>
<li>location relative to the road</li>
</ul>
</li>
<li>Mission planner<ul>
<li>optimal path given knowledge of the road network</li>
</ul>
</li>
<li>Behavioral sub-system<ul>
<li>Lane Driving</li>
<li>Intersection Handling</li>
<li>Goal Selection：分配 execution tasks</li>
</ul>
</li>
<li>Software infrastructure（软件基础框架） and tools<br>==&gt; online data logging, offline data log playback and visualization.</li>
</ul>
</li>
<li>硬件概述<ul>
<li>With electric motors to<ul>
<li>转向</li>
<li>踩刹车</li>
<li>shift the transmission 换挡、变速器</li>
</ul>
</li>
<li>保留 normal human driving controls：steering wheel、brake、gas pedal</li>
<li>Two independent power busses<ul>
<li>remaining 12VDC battery and harnesses（电池和线束）</li>
<li>an upgraded high-output alternator：24VDC</li>
</ul>
</li>
<li>Sensors 感知传感器<center><img src="/img/DARPA/Boss_sensorsOverview.png" width="540px"/></center>

</li>
</ul>
</li>
</ul>
<h4 id="Motion-Planning"><a href="#Motion-Planning" class="headerlink" title="Motion Planning"></a>Motion Planning</h4>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　Boss 自动驾驶软硬件概述。&lt;/p&gt;
&lt;h4 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;软件概述&lt;ul&gt;
&lt;li&gt;Motion planning sub-system&lt;br&gt;==&amp;gt; 2 planners: avoiding static and dynamic obstacles while achieving a desired goal（最终都是产生一条 trajectory）&lt;ul&gt;
&lt;li&gt;structured driving: road following&lt;/li&gt;
&lt;li&gt;unstructured driving: maneuvering in parking lots（停车场等的机动控制）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Perception sub-system
    
    </summary>
    
      <category term="自动驾驶" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/"/>
    
      <category term="DARPA" scheme="http://durant35.github.io/categories/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/DARPA/"/>
    
    
      <category term="DARPA" scheme="http://durant35.github.io/tags/DARPA/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0016] 二分图匹配问题</title>
    <link href="http://durant35.github.io/2017/06/01/Algorithms_BiGraphMatching/"/>
    <id>http://durant35.github.io/2017/06/01/Algorithms_BiGraphMatching/</id>
    <published>2017-06-01T13:00:22.000Z</published>
    <updated>2017-07-06T08:49:00.162Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二分图匹配问题"><a href="#二分图匹配问题" class="headerlink" title="二分图匹配问题"></a>二分图匹配问题</h4><ul>
<li>二分图<br><center><img src="/img/Algorithms/0016_bipartiteGraph.png" width="340px" alt=""/></center><ul>
<li>顶点被分成两个不相交的集合（$U$ 和 $V$）并且同属一个集合内的点两两不相连（$E_{in U} = E_{in V} = \emptyset$），即要么没有圈，要么圈所包含的边数必定是偶数。</li>
<li><strong>二分图</strong> 的一个等价定义是：不含有 <strong>含奇数条边的环</strong> 的图。<a id="more"></a></li>
</ul>
</li>
<li><strong>匹配</strong> 是边的集合 $M$（$M \subseteq E$），其中任意的两条边不共点：$e_1, e_2 \in M, e_1 \cap e_2 = \varnothing $<ul>
<li>集合 $M$ 中的元素（边），称为 <strong>匹配边</strong></li>
<li>匹配边所连接的点被称为 <strong>匹配点</strong></li>
<li>同理可以定义 <strong>非匹配边</strong> 和 <strong>非匹配点</strong> 的概念</li>
</ul>
</li>
<li>最大匹配<ul>
<li>对于一个二分图可能有多种匹配，如果二分图里的某一个匹配包含的边的数量，在该二分图的所有匹配中最大，那么这个匹配称为 <strong>最大匹配</strong></li>
<li>如果一个图的某个匹配中，<font color="blue">所有的顶点都是匹配点</font>（可能会残留一些边不是匹配边），那么它就是一个 <strong>完美匹配</strong>。</li>
<li>显然，<strong>完美匹配</strong> 一定是 <strong>最大匹配</strong>（<strong>完美匹配</strong> 的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）；但并非每个图都存在 <strong>完美匹配</strong>，即  <strong>最大匹配</strong> 不一定是 <strong>完美匹配</strong>。</li>
</ul>
</li>
<li>增广路径（增广轨）<ul>
<li>在二分图的匹配中，如果一条路径的首尾是 <strong>非匹配点</strong>，路径中除此之外的（如果有）其他点均是 <strong>匹配点</strong>，那么这条路径就是一条 <strong>增广路径（agumenting path）/增广轨</strong>（顾名思义是指一条可以使匹配数变多的路径）。<ul>
<li>$A：$首尾是非匹配点，因此，增广路径的第一条和最后一条边，必然是 <strong>非匹配边</strong>。</li>
<li>$B：$增广路径的第二条（如果有）和倒数第二条（如果有），必然是 <strong>匹配边</strong> $\Longleftarrow N$ 个点（$0～N-1$），$v_1, v_2, …, v_{N-3}, v_{N-2}$ 均为匹配点，且 ($v_0 → v_1$) 和 ($v_{N-2} → v_{N-1}$) 为 <strong>非匹配边</strong>。</li>
<li>$C：$第三条（如果有）和倒数第三条（如果有）一定是 <strong>非匹配边</strong> $\Longleftarrow $($v_1 → v_2$)$\in M$，($v_1 → v_2$)$\cap$($v_2 → v_3$)$= v_2$，故 ($v_2 → v_3$) 只能是 <strong>非匹配边</strong></li>
</ul>
</li>
<li>$A, B, C \Longrightarrow$ 增广路径从非匹配边开始，匹配边和非匹配边依次交替，最后由非匹配边结束 $\Longrightarrow$ 增广路径中，非匹配边的数目会比匹配边大 1。</li>
<li>在二分图的匹配中，从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫 <strong>交替路径/交替轨</strong>。<ul>
<li><strong>增广路径/增广轨</strong> 也被称为 <strong>交替路径/交替轨</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="判断一个图是否为二分图？"><a href="#判断一个图是否为二分图？" class="headerlink" title="判断一个图是否为二分图？"></a>判断一个图是否为二分图？</h4><ul>
<li>假设我们有一个图，我们尝试用如下的方式去给每个节点着色，总共所有的节点只能着两种颜色中的一种（假设为红色或者蓝色）。对于一个节点来说，假设它着的是某一种颜色，和它相邻的节点只能着另一种颜色。给定一个图，如果这个图满足上述的特性的话，则这个图可以称之为<strong>二分图</strong>。<ul>
<li>判断一个图是否为二分图必然会遍历这个图</li>
<li>每次在判断的时候假定一个节点的颜色为某个值，那么再将它相邻的节点颜色都设置成不同的。因为只是两种颜色，可以直接用布尔值类型来处理。<ul>
<li>对于不属于二分图的情况，肯定是<font color="red">某个节点访问到一个它可以连接到的节点，而这个节点已经被访问过了，但是这个被访问过的节点和当前节点颜色是一样</font>。这样表明它和前面二分图的定义有冲突，所以，我们遍历整个图就是为了判断是否存在这种情况。</li>
</ul>
</li>
</ul>
</li>
<li>实际实现中需要考虑的细节。<ul>
<li>对于所有节点对应的颜色需要定义一个<code>boolean[] color</code>数组</li>
<li>最开始访问一个节点的时候，将其对应<code>color</code>位设置为<code>true</code>，每次访问一个关联的节点时，将关联节点设置成原来节点的相反值。也就是说，比如节点$v$它的颜色为<code>color[v]</code>，那么下一个它被关联的节点$w$的颜色则可以设置成<code>color[w] = !color[v]</code>，正好通过取反实现了颜色的变换。</li>
<li>这里实现的要点还是通过dfs方法<ul>
<li>每次碰到一个节点的时候就要判断一下是否已经访问过：①已经访问过的话，要判断颜色是否相同，相同则表明该图不是一个二分图；②没有访问过的话，则将新节点设置成当前节点的相反值。</li>
<li>然后就是要遍历所有节点，防止遗漏未连接的节点情况。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span>[] color;</div><div class="line">visited[] = <span class="literal">false</span>;</div><div class="line"> </div><div class="line"><span class="keyword">for</span> 所有节点 ?:</div><div class="line">  <span class="keyword">if</span>(!visited[?])</div><div class="line">    color[?] = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">if</span>(!dfs(?, visited, color))</div><div class="line">      <span class="comment">// 不是二分图</span></div><div class="line"><span class="comment">// 为二分图</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(startIdx, visited, color)</span> </span>&#123;</div><div class="line">  visited[startIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span> startIdx 邻接边 startIdx-&gt;?:</div><div class="line">    <span class="keyword">if</span>(!visited[?])&#123;</div><div class="line">      color[?] = !color[startIdx];</div><div class="line">      <span class="keyword">if</span>(!dfs(?, visited, color))</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(color[startIdx] == color[?]) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>可以看出，<font color="red">一个图是不是二分图并不严格要求其必须是一个连通图</font>。</li>
</ul>
</li>
</ul>
<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h4><ul>
<li>增广路径的性质<ul>
<li>有奇数条边</li>
<li>起点在二分图的左半边$U$，终点在右半边$V$</li>
<li>路径上的点一定是一个在左半边，一个在右半边，交替出现。（其实二分图的性质就决定了这一点，因为二分图同一边的点之间没有边相连）</li>
<li>整条路径上没有重复的点</li>
<li>起点和终点都是目前还没有配对的点，而其它所有点都是已经配好对的</li>
<li>路径上的所有第奇数条边都不在原匹配中，所有第偶数条边都出现在原匹配中</li>
<li>最后，也是最重要的一条，把增广路径上的所有第奇数条边加入到原匹配中去，并把增广路径中的所有第偶数条边从原匹配中删除（这个操作称为增广路径的 <strong>取反</strong> ），则新的匹配数就比原匹配数增加了1个</li>
</ul>
</li>
<li>算法思想<ul>
<li>初始时最大匹配为空。</li>
<li>从二分图中找出一条路径来，让路径的起点和终点都是还没有匹配过的点，并且路径经过的连线是一条没被匹配、一条已经匹配过、再下一条又没被匹配过这样交替的出现。</li>
<li>找到这样的路径后，显然路径里没被匹配过的连线比已经匹配了的连线多一条，于是修改匹配图，把路径里所有匹配过的连线去掉匹配关系，把没有匹配的连线变成匹配的，这样匹配数就比原来多1。</li>
<li>不断执行上述操作，直到找不到这样的路径为止。<ul>
<li>从反证法考虑，即假设存在这样的情况：当前匹配不是二分图的最大匹配，但已找不到一条新的增广路径。因为当前匹配不是二分图的最大匹配，那么在两个集合中，分别至少存在一个非匹配点。那么情况分为两种：<ul>
<li>这两个点之间存在一条边——那么我们找到了一条新的增广路径，产生矛盾；</li>
<li>这两个点之间不存在直接的边，即这两个点分别都只与匹配点相连——那么：（1）如果这两个点可以用已有的匹配点相连，那么我们找到了一条新的增广路径，产生矛盾；（2）如果这两个点无法用已有的匹配点相连，那么这两个点也就无法增加匹配中边的数量，也就是我们已经找到了二分图的最大匹配，产生矛盾。</li>
</ul>
</li>
<li>在所有可能的情况，上述假设都会产生矛盾。因此假设不成立，亦即贪心算法：不断地搜寻出增广路径，直到最终我们找不到新的增广路径为止，必然能求得最大匹配的解。</li>
</ul>
</li>
<li>如果二分图的左半边 $U$ 一共有 $|V_U|$ 个点，最多找 $|V_U|$ 条增广路径，如果图中有 $|E|$ 条边，每一条增广路径把所有边遍历一遍，所以时间复杂度为 $O(|V_U|·|E|)$。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>BigraphMatching.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>		<span class="comment">/* queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNMATCHING 	-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTPOINT	-1</span></div><div class="line">  </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  <span class="comment">// 0: in U/ 1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  <span class="comment">// 0: in U/1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data &gt;&gt; UorV; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].UorV = UorV;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">    <span class="comment">// Bigraph is a undirected graph</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeStart;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeEnd].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeEnd].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for Bigraph&lt;U, V&gt; is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].UorV == <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"U"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"V"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span> prevs[], <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != STARTPOINT) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx].data;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatching</span><span class="params">(Graph&amp; g, <span class="keyword">const</span> <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(matchings[i]!=<span class="number">-1</span> &amp;&amp; !visited[i]) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--&gt;"</span> &lt;&lt; g.VertexNodes[matchings[i]].data</div><div class="line">         &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">     	visited[i] = <span class="literal">true</span>;</div><div class="line">     	visited[matchings[i]] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Hungarian</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> U[g.vertexNum], V[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> uSize = <span class="number">0</span>, vSize = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertex=<span class="number">0</span>; vertex&lt;g.vertexNum; vertex++) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[vertex].UorV == <span class="number">0</span>) &#123;</div><div class="line">      U[uSize++] = g.VertexNodes[vertex].vertexIdx;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      V[vSize++] = g.VertexNodes[vertex].vertexIdx;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> matchingSize = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="comment">// -1 means no matching</span></div><div class="line">    matchings[i] = UNMATCHING;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// cout &lt;&lt; "U: #" &lt;&lt; uSize &lt;&lt; " V: #" &lt;&lt; vSize &lt;&lt; endl;</span></div><div class="line"> </div><div class="line">  <span class="keyword">int</span> prevs[g.vertexNum];</div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; bfsVertexQueue;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">"Hungarian Algorithm's Process: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexInU=<span class="number">0</span>; vertexInU&lt;uSize; vertexInU++) &#123;</div><div class="line">    <span class="keyword">int</span> vertexIdx = U[vertexInU];</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; g.VertexNodes[vertexIdx].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="comment">// find an agumenting path, starting with an unmatching vertex</span></div><div class="line">    <span class="keyword">if</span>(matchings[vertexIdx] == UNMATCHING) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"unmatched vertex"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">      <span class="keyword">while</span>(!bfsVertexQueue.empty()) &#123;</div><div class="line">        bfsVertexQueue.pop();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">bool</span> visited[g.vertexNum] = &#123;<span class="literal">false</span>&#125;;</div><div class="line"> </div><div class="line">      bfsVertexQueue.push(vertexIdx);</div><div class="line">      visited[vertexIdx] = <span class="literal">true</span>;</div><div class="line">      <span class="comment">// prevs for augumenting path's backtracking, -1 means starting point</span></div><div class="line">      prevs[vertexIdx] = STARTPOINT;</div><div class="line"> </div><div class="line">      <span class="keyword">bool</span> pathFound = <span class="literal">false</span>;</div><div class="line">      <span class="keyword">while</span>(!bfsVertexQueue.empty() &amp;&amp; !pathFound) &#123;</div><div class="line">        <span class="keyword">int</span> u = bfsVertexQueue.front();</div><div class="line">        <span class="comment">// cout &lt;&lt; "pop: " &lt;&lt; g.VertexNodes[u].data &lt;&lt; endl;</span></div><div class="line">        bfsVertexQueue.pop();</div><div class="line"> </div><div class="line">        adjVertexNode* head = g.VertexNodes[u].<span class="built_in">list</span>;</div><div class="line">        <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; !pathFound) &#123;</div><div class="line">          <span class="keyword">int</span> v = head-&gt;adjVertexIdx;</div><div class="line">          <span class="comment">// visited: avoid loop</span></div><div class="line">          <span class="keyword">if</span>(!visited[v]) &#123;</div><div class="line">            <span class="comment">// v is a matching vertex</span></div><div class="line">            <span class="keyword">if</span>(matchings[v] != UNMATCHING) &#123;</div><div class="line">              bfsVertexQueue.push(matchings[v]);</div><div class="line">              visited[v] = <span class="literal">true</span>;</div><div class="line">              visited[matchings[v]] = <span class="literal">true</span>;</div><div class="line">              prevs[v] = u;</div><div class="line">              prevs[matchings[v]] = v;</div><div class="line">              <span class="comment">// cout &lt;&lt; "push: " &lt;&lt; g.VertexNodes[matchings[v]].data &lt;&lt; endl;</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">// v is the other unmatching vertex, augumenting path found</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">// record previous vertex for backtracking</span></div><div class="line">              prevs[v] = u;</div><div class="line"> </div><div class="line">              pathFound = <span class="literal">true</span>;</div><div class="line">              <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t\tAugumenting path: "</span>;</div><div class="line">              PrintPath(g, prevs, v);</div><div class="line">              <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">              <span class="comment">// reverse the augumenting path, for one more matching</span></div><div class="line">              <span class="keyword">int</span> curIdx = v, prevIdx = u;</div><div class="line">              <span class="keyword">bool</span> isMatchedEdge = <span class="literal">false</span>;</div><div class="line">              <span class="keyword">while</span>(prevIdx != STARTPOINT) &#123;</div><div class="line">                <span class="keyword">if</span>(!isMatchedEdge) &#123;</div><div class="line">                  matchings[curIdx] = prevIdx;</div><div class="line">                  matchings[prevIdx] = curIdx;</div><div class="line">                &#125;</div><div class="line">                isMatchedEdge = !isMatchedEdge;</div><div class="line">                curIdx = prevIdx;</div><div class="line">                prevIdx = prevs[prevIdx];</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          </div><div class="line">          head = head-&gt;next;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// expand one more matching</span></div><div class="line">      <span class="keyword">if</span>(matchings[vertexIdx] != UNMATCHING) &#123;</div><div class="line">        matchingSize++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"matched vertex"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> matchingSize;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_GRAPH1</span></div><div class="line">    freopen(<span class="string">"Bigraph1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"Bigraph2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> matchings[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> matchingSize = Hungarian(g, matchings);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maximum Matching: #"</span> &lt;&lt; matchingSize &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMatching(g, matchings);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节如下<ul>
<li><code>int Hungarian(Graph&amp; g, int matchings[])</code> 函数根据传入的二分图 <code>g</code>，运行<strong>匈牙利算法</strong>确定该二分图的最大匹配数并返回，对应的匹配信息通过 <code>matchings</code> 数组返回。</li>
<li>从左边 $U$ 顶点集第 1 个顶点开始，挑选未匹配点进行搜索，寻找增广路径。<ul>
<li>上述实现中采用<strong>BFS</strong>进行搜索，也可以采用<strong>DFS</strong>进行搜索。<ul>
<li>如果经过一个未匹配点，说明搜索成功：根据增广路径更新匹配信息，最大匹配数 +1，停止搜索。</li>
<li>如果经过一个匹配点，</li>
</ul>
</li>
<li>如果未能找到增广路径，则跳过这个点进行下一次搜索：事实上，此时搜索后会形成一棵匈牙利树。我们可以永久性地把它从图中删去，而不影响结果。</li>
</ul>
</li>
<li>由于找到增广路径之后需要沿着路径更新匹配信息（取反操作），所以我们需要一个结构来记录路径上的点。DFS 通过函数递归调用隐式地使用一个栈，而 我们的 BFS 实现中使用 <code>prevs</code> 数组来记录增广路径上途径的点信息。<ul>
<li>沿着增广路径更新匹配信息（取反操作）是根据增广路径上的匹配边、非匹配边交替出现的性质。<center><img src="/img/Algorithms/0016_ExampleBigraphHungarian.png" width="420px" alt=""/></center></li>
</ul>
</li>
</ul>
</li>
<li><code>Graph[1]</code> 输入文件如下：</li>
<li>  <figure class="highlight cpp"><figcaption><span>Bigraph1.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="number">8</span> <span class="number">7</span></div><div class="line"><span class="number">1</span> <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">0</span></div><div class="line"><span class="number">3</span> <span class="number">0</span></div><div class="line"><span class="number">4</span> <span class="number">0</span></div><div class="line"><span class="number">5</span> <span class="number">1</span></div><div class="line"><span class="number">6</span> <span class="number">1</span></div><div class="line"><span class="number">7</span> <span class="number">1</span></div><div class="line"><span class="number">8</span> <span class="number">1</span></div><div class="line"><span class="number">0</span> <span class="number">4</span></div><div class="line"><span class="number">0</span> <span class="number">6</span></div><div class="line"><span class="number">1</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">5</span></div><div class="line"><span class="number">3</span> <span class="number">6</span></div><div class="line"><span class="number">3</span> <span class="number">7</span></div></pre></td></tr></table></figure>
<ul>
<li>构建运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_GRAPH1 BigraphMatching.cpp -o BigraphMatching</div><div class="line">$ ./BigraphMatching </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;7 5 </div><div class="line"> 2(U)-&gt;5 </div><div class="line"> 3(U)-&gt;6 5 </div><div class="line"> 4(U)-&gt;8 7 </div><div class="line"> 5(V)-&gt;3 2 1 </div><div class="line"> 6(V)-&gt;3 </div><div class="line"> 7(V)-&gt;4 1 </div><div class="line"> 8(V)-&gt;4 </div><div class="line"> </div><div class="line">Hungarian Algorithm&apos;s Process: </div><div class="line">  1: unmatched vertex</div><div class="line">    Augumenting path: 1-&gt;7</div><div class="line">  2: unmatched vertex</div><div class="line">    Augumenting path: 2-&gt;5</div><div class="line">  3: unmatched vertex</div><div class="line">    Augumenting path: 3-&gt;6</div><div class="line">  4: unmatched vertex</div><div class="line">    Augumenting path: 4-&gt;8</div><div class="line"> </div><div class="line">Maximum Matching: #4</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;5</div><div class="line">  + 3&lt;--&gt;6</div><div class="line">  + 4&lt;--&gt;8</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>Graph[2]</code> 输入文件如下：</li>
<li>  <figure class="highlight cpp"><figcaption><span>Bigraph2.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="number">12</span> <span class="number">16</span></div><div class="line"><span class="number">1</span> <span class="number">0</span></div><div class="line"><span class="number">2</span> <span class="number">0</span></div><div class="line"><span class="number">3</span> <span class="number">0</span></div><div class="line"><span class="number">4</span> <span class="number">0</span></div><div class="line"><span class="number">5</span> <span class="number">0</span></div><div class="line"><span class="number">6</span> <span class="number">0</span></div><div class="line"><span class="number">7</span> <span class="number">1</span></div><div class="line"><span class="number">8</span> <span class="number">1</span></div><div class="line"><span class="number">9</span> <span class="number">1</span></div><div class="line">a <span class="number">1</span></div><div class="line">b <span class="number">1</span></div><div class="line">c <span class="number">1</span></div><div class="line"><span class="number">0</span> <span class="number">6</span></div><div class="line"><span class="number">0</span> <span class="number">7</span></div><div class="line"><span class="number">0</span> <span class="number">9</span></div><div class="line"><span class="number">1</span> <span class="number">7</span></div><div class="line"><span class="number">1</span> <span class="number">11</span></div><div class="line"><span class="number">2</span> <span class="number">7</span></div><div class="line"><span class="number">2</span> <span class="number">8</span></div><div class="line"><span class="number">3</span> <span class="number">8</span></div><div class="line"><span class="number">3</span> <span class="number">10</span></div><div class="line"><span class="number">3</span> <span class="number">11</span></div><div class="line"><span class="number">4</span> <span class="number">8</span></div><div class="line"><span class="number">4</span> <span class="number">9</span></div><div class="line"><span class="number">4</span> <span class="number">10</span></div><div class="line"><span class="number">4</span> <span class="number">11</span></div><div class="line"><span class="number">5</span> <span class="number">7</span></div><div class="line"><span class="number">5</span> <span class="number">10</span></div></pre></td></tr></table></figure>
<ul>
<li>构建运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">$ g++ BigraphMatching.cpp -o BigraphMatching</div><div class="line">$ ./BigraphMatching </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;a 8 7 </div><div class="line"> 2(U)-&gt;c 8 </div><div class="line"> 3(U)-&gt;9 8 </div><div class="line"> 4(U)-&gt;c b 9 </div><div class="line"> 5(U)-&gt;c b a 9 </div><div class="line"> 6(U)-&gt;b 8 </div><div class="line"> 7(V)-&gt;1 </div><div class="line"> 8(V)-&gt;6 3 2 1 </div><div class="line"> 9(V)-&gt;5 4 3 </div><div class="line"> a(V)-&gt;5 1 </div><div class="line"> b(V)-&gt;6 5 4 </div><div class="line"> c(V)-&gt;5 4 2 </div><div class="line"> </div><div class="line">Hungarian Algorithm&apos;s Process: </div><div class="line">  1: unmatched vertex</div><div class="line">    Augumenting path: 1-&gt;a</div><div class="line">  2: unmatched vertex</div><div class="line">    Augumenting path: 2-&gt;c</div><div class="line">  3: unmatched vertex</div><div class="line">    Augumenting path: 3-&gt;9</div><div class="line">  4: unmatched vertex</div><div class="line">    Augumenting path: 4-&gt;b</div><div class="line">  5: unmatched vertex</div><div class="line">    Augumenting path: 5-&gt;c-&gt;2-&gt;8</div><div class="line">  6: unmatched vertex</div><div class="line">    Augumenting path: 6-&gt;b-&gt;4-&gt;c-&gt;5-&gt;a-&gt;1-&gt;7</div><div class="line"> </div><div class="line">Maximum Matching: #6</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;8</div><div class="line">  + 3&lt;--&gt;9</div><div class="line">  + 4&lt;--&gt;c</div><div class="line">  + 5&lt;--&gt;a</div><div class="line">  + 6&lt;--&gt;b</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>补充概念：匈牙利树<br><center><img src="/img/Algorithms/0016_HungarianTree.png" width="540px" alt=""/></center><ul>
<li>上文提到的 <strong>匈牙利树</strong> 一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。</li>
<li>上图（1），可以得到如图（2）的一棵 BFS 树：这棵树存在一个叶子节点为非匹配点（7 号），但是匈牙利树要求所有叶子节点均为匹配点，因此这不是一棵匈牙利树。相比之下，由图（3）得到的如图（4）的一棵 BFS 树，就是一棵匈牙利树。</li>
</ul>
</li>
</ul>
<h4 id="最大流方法计算最大匹配"><a href="#最大流方法计算最大匹配" class="headerlink" title="最大流方法计算最大匹配"></a>最大流方法计算最大匹配</h4><p>　如下图所示，对于一个二分图$G$，令已有的边的容量（Capacity）为无穷大，增加一个源点$S$和一个汇点$T$，令$S$和$T$分别连接二分图中的左半边$U$和右半边$V$，并设置其容量为1。这时得到流网络$G’$，计算得到的$G’$最大流就等于$G$的最大匹配。</p>
<center><img src="/img/Algorithms/0016_Bigraph2NetworkGraph.png" width="440px" alt=""/></center>

<ul>
<li>算法正确性简单证明<ul>
<li>首先假设，当前流网络有一个最大流，但它对应的不是最大匹配。那么，我们至少还可以向最大匹配中加入一条边$(u→v)$，显然我们还可以增加一条增广路径：<code>s-&gt;u-&gt;v-&gt;t</code>，那么就得到一个更大的流，和假设矛盾，所以假设不成立。</li>
<li>同理，假设当前有一个最大匹配，其对应的不是最大流，那么至少还存在一条增广路径<code>s-&gt;u-&gt;v-&gt;t</code>以确保更大的流，这时就可以增加边$(u→v)$到最大匹配中，同样和假设矛盾。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>BigraphMatchingbyMaxFlow.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>			<span class="comment">/* setw */</span> </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>			<span class="comment">/* queue */</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">  </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> UNMATCHING 	-1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STARTPOINT	-1</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  <span class="comment">// 0: in U/ 1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd;</div><div class="line">  <span class="comment">// 0: in U/1: in V</span></div><div class="line">  <span class="keyword">int</span> UorV;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data &gt;&gt; UorV; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].UorV = UorV;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd;</div><div class="line">    </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">    <span class="comment">// Bigraph is a undirected graph</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeStart;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeEnd].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeEnd].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for Bigraph&lt;U, V&gt; is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"("</span>;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].UorV == <span class="number">0</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"U"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"V"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">")-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span> prevs[], <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != STARTPOINT) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span>(toIdx == <span class="number">0</span>) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"S"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(toIdx == g.vertexNum+<span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"T"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx<span class="number">-1</span>].data;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMatching</span><span class="params">(Graph&amp; g, <span class="keyword">const</span> <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[g.vertexNum] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">if</span>(matchings[i]!=<span class="number">-1</span> &amp;&amp; !visited[i]) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--&gt;"</span> &lt;&lt; g.VertexNodes[matchings[i]].data</div><div class="line">         &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">     	visited[i] = <span class="literal">true</span>;</div><div class="line">     	visited[matchings[i]] = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>** graph, <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx, <span class="keyword">int</span>* prevs)</span> </span>&#123;</div><div class="line">  <span class="keyword">bool</span> visited[vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;vertexNum; vertexIdx++) &#123;</div><div class="line">    visited[vertexIdx] = <span class="literal">false</span>;</div><div class="line">    prevs[vertexIdx] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertexIdxQueue;</div><div class="line">  vertexIdxQueue.push(fromIdx);</div><div class="line">  visited[fromIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span> (!vertexIdxQueue.empty()) &#123;</div><div class="line">    <span class="keyword">int</span> u = vertexIdxQueue.front();</div><div class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " ";</span></div><div class="line">    <span class="keyword">if</span>(u == toIdx) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    vertexIdxQueue.pop();</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[v] &amp;&amp; graph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        vertexIdxQueue.push(v);</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">        prevs[v] = u;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> visited[toIdx];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxMatchingbyMaxFlow</span><span class="params">(Graph&amp; g, <span class="keyword">int</span> matchings[])</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    matchings[i] = UNMATCHING;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// Add source[0] and sink[g.vertexNum+1]</span></div><div class="line">  <span class="keyword">int</span> N = g.vertexNum+<span class="number">2</span>;</div><div class="line">  <span class="keyword">int</span> sourceIdx = <span class="number">0</span>, sinkIdx = g.vertexNum+<span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">int</span> maxFlow = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> flowGraph[N][N];</div><div class="line">  <span class="comment">// initialize the residual graph</span></div><div class="line">  <span class="keyword">int</span>** residualGraph = <span class="keyword">new</span> <span class="keyword">int</span>*[N];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;N; u++) &#123;</div><div class="line">    residualGraph[u] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;N; v++) &#123;</div><div class="line">      residualGraph[u][v] = <span class="number">0</span>;</div><div class="line">      flowGraph[u][v] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;g.vertexNum; vertexIdx++) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[vertexIdx].UorV == <span class="number">0</span>) &#123;</div><div class="line">      residualGraph[sourceIdx][vertexIdx+<span class="number">1</span>] = <span class="number">1</span>;</div><div class="line"> </div><div class="line">      adjVertexNode* head = g.VertexNodes[vertexIdx].<span class="built_in">list</span>;</div><div class="line">      <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">        residualGraph[vertexIdx+<span class="number">1</span>][head-&gt;adjVertexIdx+<span class="number">1</span>] = INT_MAX;</div><div class="line">        head = head-&gt;next;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      residualGraph[vertexIdx+<span class="number">1</span>][sinkIdx] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// prevs array for storing the augmenting path</span></div><div class="line">  <span class="keyword">int</span> prevs[N];</div><div class="line">  <span class="keyword">int</span> iter = <span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Algorithm Process:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// Augment the flow while there is a path from source to sink</span></div><div class="line">  <span class="keyword">while</span>(BFS(residualGraph, N, sourceIdx, sinkIdx, prevs)) &#123;</div><div class="line">    <span class="comment">// find the maximum flow(minimum residual capacity) through the path found</span></div><div class="line">    <span class="keyword">int</span> pathFlow = INT_MAX;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sinkIdx; v!=sourceIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      <span class="keyword">if</span>(residualGraph[u][v] &lt; pathFlow) &#123;</div><div class="line">        pathFlow = residualGraph[u][v];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update residual capacities of the edges &amp; reverse edges along the augmenting path</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sinkIdx; v!=sourceIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      residualGraph[u][v] -= pathFlow;</div><div class="line">      residualGraph[v][u] += pathFlow;</div><div class="line">      <span class="comment">// record flows</span></div><div class="line">      flowGraph[u][v] += pathFlow;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update matching from augumenting path</span></div><div class="line">    <span class="keyword">int</span> curIdx = prevs[sinkIdx], prevIdx = prevs[curIdx];</div><div class="line">    <span class="keyword">while</span>(prevIdx != STARTPOINT) &#123;</div><div class="line">      <span class="comment">// -1 with source and sink</span></div><div class="line">      matchings[curIdx<span class="number">-1</span>] = prevIdx<span class="number">-1</span>;</div><div class="line">      matchings[prevIdx<span class="number">-1</span>] = curIdx<span class="number">-1</span>;</div><div class="line"></div><div class="line">      curIdx = prevs[prevIdx];</div><div class="line">      prevIdx = prevs[curIdx];</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    maxFlow += pathFlow;</div><div class="line">    <span class="comment">// print current iteration's info</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t#"</span> &lt;&lt; iter++ &lt;&lt; <span class="string">" flow: "</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; pathFlow &lt;&lt; <span class="string">" Augmenting-path: "</span>;</div><div class="line">    PrintPath(g, prevs, sinkIdx);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// memory release</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">    <span class="keyword">delete</span>[] residualGraph[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>[] residualGraph;</div><div class="line"> </div><div class="line">  <span class="comment">// show the flows</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">bool</span> noflow;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    noflow = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> &lt;&lt; g.VertexNodes[u].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(flowGraph[u+<span class="number">1</span>][v+<span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; g.VertexNodes[v].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; flowGraph[u+<span class="number">1</span>][v+<span class="number">1</span>] &lt;&lt; <span class="string">")\t"</span>;</div><div class="line">        noflow = <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(noflow) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> maxFlow;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_GRAPH1</span></div><div class="line">    freopen(<span class="string">"Bigraph1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"Bigraph2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> matchings[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> matchingSize = MaxMatchingbyMaxFlow(g, matchings);</div><div class="line">  </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Maximum Matching: #"</span> &lt;&lt; matchingSize &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMatching(g, matchings);</div><div class="line">  </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节如下：<ul>
<li><code>int MaxMatchingbyMaxFlow(Graph&amp; g, int matchings[])</code> 实现了和匈牙利算法中一样的函数接口，思路很简单，<code>residualGraph</code> 初始化为构造的流网络$G’$，然后调用最大流算法，得到的<strong>最大流</strong>即为返回的<strong>最大匹配数</strong>；此外，利用最大流算法每次迭代搜索到的增广路径更新匹配信息<code>matchings</code>。</li>
<li>因为二分图上任何匹配数目至多为$|V’| = min(|V_{\in U}|, |V_{\in V}|)$，所以流网络$G’$中最大流的值为$O(|V’|)$，因此，可以在$O(|V’|·|E’|) = O(|V|·|E|)$的时间内找出二分图的最大匹配。</li>
</ul>
</li>
<li>利用上述最大流方法得到的匹配信息和匈牙利算法有些许区别，但可以看出，都能正确得到最大匹配，同时也是完美匹配。<center><img src="/img/Algorithms/0016_ExampleBigraphMaxflow.png" width="420px" alt=""/></center>

</li>
</ul>
<figure class="highlight plain"><figcaption><span>Graph[1]</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_GRAPH1 BigraphMatchingbyMaxFlow.cpp -o BigraphMatchingbyMaxFlow</div><div class="line">$ ./BigraphMatchingbyMaxFlow </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;7 5 </div><div class="line"> 2(U)-&gt;5 </div><div class="line"> 3(U)-&gt;6 5 </div><div class="line"> 4(U)-&gt;8 7 </div><div class="line"> 5(V)-&gt;3 2 1 </div><div class="line"> 6(V)-&gt;3 </div><div class="line"> 7(V)-&gt;4 1 </div><div class="line"> 8(V)-&gt;4 </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   1 Augmenting-path: S-&gt;1-&gt;5-&gt;T</div><div class="line">  #2 flow:   1 Augmenting-path: S-&gt;3-&gt;6-&gt;T</div><div class="line">  #3 flow:   1 Augmenting-path: S-&gt;4-&gt;7-&gt;T</div><div class="line">  #4 flow:   1 Augmenting-path: S-&gt;2-&gt;5-&gt;1-&gt;7-&gt;4-&gt;8-&gt;T</div><div class="line"> Maximum Flow Graph:</div><div class="line">   1: -&gt;5(1)	-&gt;7(1)	</div><div class="line">   2: -&gt;5(1)	</div><div class="line">   3: -&gt;6(1)	</div><div class="line">   4: -&gt;7(1)	-&gt;8(1)	</div><div class="line">   5: -&gt;1(1)	</div><div class="line">   6: NULL</div><div class="line">   7: -&gt;4(1)	</div><div class="line">   8: NULL</div><div class="line"> </div><div class="line">Maximum Matching: #4</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;5</div><div class="line">  + 3&lt;--&gt;6</div><div class="line">  + 4&lt;--&gt;8</div></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>Graph[2]</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">$ g++ BigraphMatchingbyMaxFlow.cpp -o BigraphMatchingbyMaxFlow</div><div class="line">$ ./BigraphMatchingbyMaxFlow </div><div class="line">The adjacent list for Bigraph&lt;U, V&gt; is:</div><div class="line"> 1(U)-&gt;a 8 7 </div><div class="line"> 2(U)-&gt;c 8 </div><div class="line"> 3(U)-&gt;9 8 </div><div class="line"> 4(U)-&gt;c b 9 </div><div class="line"> 5(U)-&gt;c b a 9 </div><div class="line"> 6(U)-&gt;b 8 </div><div class="line"> 7(V)-&gt;1 </div><div class="line"> 8(V)-&gt;6 3 2 1 </div><div class="line"> 9(V)-&gt;5 4 3 </div><div class="line"> a(V)-&gt;5 1 </div><div class="line"> b(V)-&gt;6 5 4 </div><div class="line"> c(V)-&gt;5 4 2 </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   1 Augmenting-path: S-&gt;1-&gt;7-&gt;T</div><div class="line">  #2 flow:   1 Augmenting-path: S-&gt;2-&gt;8-&gt;T</div><div class="line">  #3 flow:   1 Augmenting-path: S-&gt;3-&gt;9-&gt;T</div><div class="line">  #4 flow:   1 Augmenting-path: S-&gt;4-&gt;b-&gt;T</div><div class="line">  #5 flow:   1 Augmenting-path: S-&gt;5-&gt;a-&gt;T</div><div class="line">  #6 flow:   1 Augmenting-path: S-&gt;6-&gt;8-&gt;2-&gt;c-&gt;T</div><div class="line"> Maximum Flow Graph:</div><div class="line">   1: -&gt;7(1)	</div><div class="line">   2: -&gt;8(1)	-&gt;c(1)	</div><div class="line">   3: -&gt;9(1)	</div><div class="line">   4: -&gt;b(1)	</div><div class="line">   5: -&gt;a(1)	</div><div class="line">   6: -&gt;8(1)	</div><div class="line">   7: NULL</div><div class="line">   8: -&gt;2(1)	</div><div class="line">   9: NULL</div><div class="line">   a: NULL</div><div class="line">   b: NULL</div><div class="line">   c: NULL</div><div class="line">  </div><div class="line">Maximum Matching: #6</div><div class="line">  + 1&lt;--&gt;7</div><div class="line">  + 2&lt;--&gt;c</div><div class="line">  + 3&lt;--&gt;9</div><div class="line">  + 4&lt;--&gt;b</div><div class="line">  + 5&lt;--&gt;a</div><div class="line">  + 6&lt;--&gt;8</div></pre></td></tr></table></figure>
<h4 id="最大匹配与最大边独立集"><a href="#最大匹配与最大边独立集" class="headerlink" title="最大匹配与最大边独立集"></a>最大匹配与最大边独立集</h4><ul>
<li>边独立集即一个边集，满足边集中的任意两边不邻接。</li>
<li>极大边独立集(maximal edge independent set)：本身为边独立集，再加入任何边都不是。</li>
<li>最大边独立集(maximum edge independent set)：边最多的边独立集。</li>
<li>边独立数(edge independent number)：最大边独立集的边数。</li>
<li>边独立集又称匹配(matching)，相应的有极大匹配(maximal matching)，最大匹配(maximum matching)，匹配数(matching number)。</li>
</ul>
<h4 id="最大匹配与最小路径覆盖"><a href="#最大匹配与最小路径覆盖" class="headerlink" title="最大匹配与最小路径覆盖"></a>最大匹配与最小路径覆盖</h4><ul>
<li>给定有向图$G=(V, E)$，设$P$是$G$的一个简单路（顶点不相交）的集合。如果$V$中每个顶点恰好在$P$的一条路上，则称$P$是$G$的一个<strong>路径覆盖</strong>。$P$中路径可以从$V$的任何一个顶点开始，长度也是任意的，特别地，可以为0（单个点）。$G$的<strong>最小路径覆盖</strong>是$G$的所含路径条数$|P|$最少的路径覆盖。</li>
<li><strong>最小路径覆盖数＝$G$的点数$|V|$ - 最小路径覆盖$P$中的边的数目</strong>（$P$由边和点组成，且不出现重复点）$\Longrightarrow$ 最小路径覆盖$P$中的边数尽量多，但是又不能让两条边在同一个顶点相交。<ul>
<li>拆点：将每一个顶点$i$拆成两个顶点$U_i$和$V_i$。</li>
<li>根据原图中边的信息，从左半边$U$往右半边$V$引边，所有边的方向都是由$U$到$V$，即如果有边$(u→v)$，则在二分图$G’$中引入边$(U_u→V_v)$。</li>
<li>因此，所转化出的二分图$G’$的最大匹配数则是原图$G$中最小路径覆盖上的边数。因此<strong>最小路径覆盖数＝原图$G$的顶点数 - 二分图$G’$的最大匹配数</strong>便可以得解。</li>
</ul>
</li>
<li>简单证明：<strong>最小路径覆盖数＝$G$的点数$|V|$-$G’$的最大匹配数</strong><ul>
<li>首先，若最大匹配数为0，则二分图$G’$中无边，也就是说图$G$中不存在边，那么显然：最小路径覆盖数=$|V|$ - 最大匹配数=$|V|$ - 0=$|V|$。</li>
<li>若此时增加一条匹配边$(U_u→V_v)$，则在图$G$中，u、v在同一条路径上，最小路径覆盖数减少一个。继续增加匹配边，每增加一条，最小路径覆盖数减少一个，则公式：最小路径覆盖数=|V|-$G’$最大匹配数得证。</li>
</ul>
</li>
<li>提取最小路径覆盖？<ul>
<li>二分图$G’$的最大匹配中的匹配边对应的原图$G$中的边，加上未在边中的顶点，即为最小路径覆盖。 </li>
</ul>
</li>
</ul>
<h4 id="最大匹配与最小点覆盖"><a href="#最大匹配与最小点覆盖" class="headerlink" title="最大匹配与最小点覆盖"></a>最大匹配与最小点覆盖</h4><ul>
<li>顶点覆盖问题：输入一个图$G$和预算$b$，求$b$个能够覆盖到每条边的顶点。</li>
<li>最小覆盖要求用最少的点（假如是二分图，$U$集合或$V$集合的都行），让每条边都至少和其中一个点关联，即假如选了一个点就相当于覆盖了以它为端点的所有边，如何需要选择最少的点来覆盖途图中的所有的边？</li>
<li><strong>König定理</strong>：一个二分图中的最大匹配数等于这个图中的最小点覆盖数。<br><center><img src="/img/Algorithms/0016_Bigraph3.png" width="480px" alt=""/></center><ul>
<li>如上图，我们已经通过上述的匈牙利算法求出了最大匹配数：$M=3$，最大匹配：$(A→G)、(B→H)、(D→I)$。</li>
<li>匈牙利算法需要我们从左半边$U$的某个没有匹配的点，走出一条使得“一条没被匹配、一条已经匹配过，再下一条又没匹配这样交替地出现”的路（交错轨，增广轨）。但是，现在我们已经找到了最大匹配，已经不存在这样的路了。换句话说，我们能寻找到很多可能的增广路，但最后都以找不到“终点是还没有匹配过的点”而失败（如上图$[E→B→H→D→I]$和$[F→B→H→D→I]$）。我们给所有这样的点打上记号（用<font color="red">“√”</font>表示）：从右半边$V$（从左半边$U$出发的增广路径已经在匈牙利算法中搜索过，重复显然没有意义）的所有没有匹配过的点出发，按照增广轨“交替出现”的要求可以走到的所有点（最后走出的路径是很多条不完整的增广路），我们将这些点一一打上标记。</li>
<li>那么这些点（红色矩形圈出来的点）组成了最小点覆盖点集：<strong>右边所有没有打上记号的点，加上左边已经有记号的点</strong>。</li>
</ul>
</li>
<li><strong>König定理</strong>简单证明<ul>
<li>首先，为什么这样得到的点集，点的个数恰好有$M$个呢？<ul>
<li>答案很简单，因为这样得到的点集中的每个点都是某条匹配边的其中一个端点。<ul>
<li><strong>右边所有没有打上<font color="red">“√”</font>的点和左边已经有<font color="red">“√”</font>的点</strong>一定都是匹配边的端点。<ul>
<li>如果右半边的哪个点是没有匹配过的，那么它早就当成起点被标记了。</li>
<li>如果左半边的哪个点是没有匹配过的，那就走不到它那里去，否则就找到了一条完整的增广路径，与已经求出最大匹配矛盾。</li>
</ul>
</li>
<li>一条匹配边不可能左端点是标记了的，同时右端点是没标记的，不然的话右边的点就可以经过这条匹配边到达了（右半边到左半边通过非匹配边/左半边到右半边通过匹配边）。</li>
</ul>
</li>
<li>因此，最后我们圈起来的点数与匹配边数。</li>
</ul>
</li>
<li>其次，为什么这样得到的点集可以覆盖所有的边呢？<ul>
<li>答案同样简单。不可能存在某一条边，它的左端点是没有标记的，而右端点是有标记的。<ul>
<li>如果这条边不属于匹配边，那么左端点就可以通过这条边到达（右半边到左半边通过非匹配边/左半边到右半边通过匹配边），从而得到标记。</li>
<li>如果这条边属于我们的匹配边，那么右端点不可能是一条路径的起点，于是它的标记只能是从这条边的左端点过来的（匹配边的右端点不可能作为起点被标记），左端点就应该有标记。</li>
</ul>
</li>
</ul>
</li>
<li>最后，为什么这样得到的点集是最小的点覆盖集呢？<ul>
<li>这当然是最小的，不可能有比$M$还小的点覆盖集了，因为要覆盖这$M$条匹配边至少就需要$M$个点（匹配边互不相交）。</li>
</ul>
</li>
</ul>
</li>
<li>提取最小点覆盖？<ul>
<li>通过上述的方法对二分图$G$中的顶点进行标记，<strong>$V$中所有没有被打上记号的点，加上$U$中已经有记号的点</strong>，即为最小点覆盖。</li>
</ul>
</li>
</ul>
<h4 id="最大匹配与最大独立数"><a href="#最大匹配与最大独立数" class="headerlink" title="最大匹配与最大独立数"></a>最大匹配与最大独立数</h4><ul>
<li>独立集问题：给定一个图和整数$g$，目标是求图中的$g$个相互独立的顶点，即在任意两个这样的顶点间都不存在相连的边（或者说导出的子图是零图（没有边）的点集）。</li>
<li>简单证明：<strong>二分图最大独立集=顶点数-二分图最大匹配</strong><br><center><img src="/img/Algorithms/0016_Bigraph3MaxIndependentSet.png" width="480px" alt=""/></center><ul>
<li>上图，我们用红圈圈住的三个点（$B$、$D$、$G$）覆盖了所有边，这是我们证明的前提条件：已经达到最小覆盖，即条件①已经覆盖所有边；条件②所用的点数最小。</li>
<li>首先我们来证明其余点（$A$、$C$、$E$、$F$、$H$、$I$）组成的是一个独立集。<ul>
<li>如果有两个蓝圈点间有边相连，那么这条边则没有被覆盖，则与条件①矛盾，因此是独立集。</li>
</ul>
</li>
<li>再来证明这个独立集是最大的。<ul>
<li>如果我们要再增加这个独立集中的点，则需要把某个红圈点变成蓝圈点。而由<strong>最小覆盖数=最大匹配数</strong>的证明我们知道，每一个红圈点是最大匹配中的一个匹配点，也就是说每个红圈点至少连接了一条边。因此当我们将某个红圈点变成蓝圈点时，我们需要牺牲的蓝圈点的个数是≥1的。也就是说，我们最多只能找到顶点数量相等的其他独立集，而无法找到数量更大的。因此蓝圈点集必定为最大独立集。</li>
<li>蓝圈点数 = 总点数 - 红圈点数，即最大独立集=顶点数 - 最小覆盖集。</li>
</ul>
</li>
<li>上面已经证明的<strong>König定理：最小点覆盖数=最大匹配数</strong>，故有<strong>二分图最大独立数=顶点数-二分图最大匹配数</strong>。</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://liam0205.me/2016/04/03/Hungarian-algorithm-in-the-maximum-matching-problem-of-bigraph/">二分图最大匹配问题与匈牙利算法的核心思想</a></li>
<li><a href="http://blog.csdn.net/hackbuteer1/article/details/7398008">二分图的最大匹配</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9672181">图的匹配问题与最大流问题(五)——计算二分图的最大匹配</a></li>
<li><a href="https://www.renfei.org/blog/bipartite-matching.html">二分图的最大匹配、完美匹配和匈牙利算法</a></li>
<li><a href="http://www.cnblogs.com/pony1993/archive/2012/07/25/2607738.html">二分图的最大匹配—匈牙利算法</a></li>
<li><a href="http://www.matrix67.com/blog/archives/116">二分图最大匹配的König定理及其证明</a></li>
<li><a href="http://dsqiu.iteye.com/blog/1689505">二分图大讲堂——彻底搞定最大匹配数（最小覆盖数）、最大独立数、最小路径覆盖、带权最优匹配</a></li>
<li><a href="http://m.blog.csdn.net/article/details?id=50011363">最大独立集=总数-最小覆盖集证明</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二分图匹配问题&quot;&gt;&lt;a href=&quot;#二分图匹配问题&quot; class=&quot;headerlink&quot; title=&quot;二分图匹配问题&quot;&gt;&lt;/a&gt;二分图匹配问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;二分图&lt;br&gt;&lt;center&gt;&lt;img src=&quot;/img/Algorithms/0016_bipartiteGraph.png&quot; width=&quot;340px&quot; alt=&quot;&quot;/&gt;&lt;/center&gt;&lt;ul&gt;
&lt;li&gt;顶点被分成两个不相交的集合（$U$ 和 $V$）并且同属一个集合内的点两两不相连（$E_{in U} = E_{in V} = \emptyset$），即要么没有圈，要么圈所包含的边数必定是偶数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二分图&lt;/strong&gt; 的一个等价定义是：不含有 &lt;strong&gt;含奇数条边的环&lt;/strong&gt; 的图。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0015] Union Find Set（并查集）</title>
    <link href="http://durant35.github.io/2017/06/01/Algorithms_UnionFindSet/"/>
    <id>http://durant35.github.io/2017/06/01/Algorithms_UnionFindSet/</id>
    <published>2017-06-01T06:00:22.000Z</published>
    <updated>2017-07-06T08:46:59.564Z</updated>
    
    <content type="html"><![CDATA[<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><ul>
<li>并查集：并查集处理的是集合之间的关系，即 union，find。在这种数据类型中，N个不同元素被分成若干个组，每组是一个集合，这种集合叫做分离集合。并查集支持查找一个元素所属的集合和两个元素分别所属的集合的合并。注意：并查集只能进行合并操作，不能进行分割操作。</li>
<li>并查集支持以下操作：<ul>
<li><code>makeset(x)</code>：创建一个仅包含 x 的独立集合（分离集）；最初每个节点单独构成了一个分离集 ==&gt; 一组分离集</li>
<li><code>find(x)</code>：不断重复地检验节点对，判断其是否属于同一个集合？</li>
<li><code>union(x, y)</code>：每当增加了一条边，将与之相关的两个集合合并。<a id="more"></a></li>
</ul>
</li>
<li>并查集的实现原理<ul>
<li>并查集是使用树结构实现的<ul>
<li>初始化：准备 N 个节点来表示 N 个元素，最开始没有边。</li>
<li>为避免树的退化，对于每棵树，记录其高度 rank。</li>
<li>查询：查询两个节点是否在同一个集合，只需要查询他们是否具有相同的根。<center><img src="/img/Algorithms/0007_UnionFind_find.png" width="340px"/></center></li>
<li>合并：从一个分离集的根向另一个分离集的根连边，这样两棵树就变为了一棵树，也就把两个集合合并为一个了；除非将要合并的树等高，否则将不会出现合并后总高度增加的情形；如果合并时两棵树高度不同，那么从 rank 小的向 rank 大的连边。<center><img src="/img/Algorithms/0007_UnionFind_union.png" width="580px"/></center></li>
<li>路径压缩：每次 find 操作中，当循着一系列的父指针最终找到树的根后，改变所有这些父指针的目标，使其直接指向树根。<br><center><img src="/img/Algorithms/0007_UnionFind_find2.png" width="420px"/></center><ul>
<li>通过路径压缩，所有节点的等级都不会发生改变；节点的 rank 不再能解释为其下方子树的高度</li>
<li>union 操作只关注树的顶层，路径压缩不会对 union 操作产生影响，它将保持树的顶层不变</li>
<li>find 操作（不论是否采用路径压缩）仅仅触及树的内部</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>并查集实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="Kruskal-算法"><a href="#Kruskal-算法" class="headerlink" title="Kruskal 算法"></a>Kruskal 算法</h4><ul>
<li>Kruskal 最小生成树算法<br><center><img src="/img/Algorithms/0007_KruskalPseudo.png" width="720px"/></center><ul>
<li>起始于一个空的图。</li>
<li>通过逐条增加边来构造最小生成树：假如在构建最小生成树的过程中，我们已经选择了某些边并在向着正确的方向前进，下一步选择那条边呢？<ul>
<li>不断重复地选择未被选中的边中权重最轻的且不会形成环的一条。<ul>
<li>为保证连接等价类边的权值最短，算法首先对图中所有边按照权值进行排序。按权值由小到大依次选择边</li>
<li>不会形成环：每次选择一条边加入到现有的部分解中 ===&gt; 需要检验每一条侯选边(u-&gt;v) 的端点是否属于不同的连通分量，一旦选定了某条边，则将这条边添加到 MST 并将两个相关的连通分量将被合并。</li>
</ul>
</li>
</ul>
</li>
<li>Kruskal 最小生成树算法关键数据结构：并查集/分离集 (union-find/disjoint sets)<ul>
<li>Kruskal 算法开始有 n 个分别包含一个节点的集合（即 n 个分离集）；随着算法的进展，分离集的个数逐渐减少，直到算法的最后一步，分离集的个数变为 1，此时产生最小生成树。</li>
</ul>
</li>
</ul>
</li>
<li>基于并查集的 Kruskal 算法实现：</li>
</ul>
<figure class="highlight cpp"><figcaption><span>Kruskal 最小生成树</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>		<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>		<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span>		<span class="comment">/* assert */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span>			<span class="comment">/* priority_queue */</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">  </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line">  </div><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> PI[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> rank[MAX_VERTEX_NUM];</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">    	<span class="keyword">this</span>-&gt;size = size;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;size; vertexIdx++) &#123;</div><div class="line">    		PI[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    		rank[vertexIdx] = <span class="number">-1</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	PI[x] = x;</div><div class="line">    	rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;find&gt;:" &lt;&lt; endl; </span></div><div class="line">        <span class="comment">// cout &lt;&lt; "\tPI[" &lt;&lt; x &lt;&lt; "]: " &lt;&lt; PI[x] &lt;&lt; endl;</span></div><div class="line">        <span class="comment">/*</div><div class="line">         * find(PI[x]): backtracking, finding the root node</div><div class="line">         * PI[x]=&lt;backtracking result&gt;: </div><div class="line">         *	directly connect the leaf node to the root node to achieve path compression</div><div class="line">         */</span></div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">        	PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">    	<span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    	assert(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; size);</div><div class="line">    	assert(y &gt;= <span class="number">0</span> &amp;&amp; y &lt; size);</div><div class="line">        <span class="comment">// cout &lt;&lt; "&lt;unite&gt;: " &lt;&lt; endl;</span></div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="comment">// cout &lt;&lt; "\t" &lt;&lt; x &lt;&lt; "["  &lt;&lt; rx &lt;&lt; "]" &lt;&lt; y &lt;&lt; "[" &lt;&lt; ry &lt;&lt; "]" &lt;&lt; endl;</span></div><div class="line">    	assert(rx &gt;= <span class="number">0</span> &amp;&amp; rx &lt; size);</div><div class="line">    	assert(ry &gt;= <span class="number">0</span> &amp;&amp; ry &lt; size);</div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">        	<span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">        	PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">            	rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printset</span><span class="params">()</span> </span>&#123;</div><div class="line">    	<span class="built_in">cout</span> &lt;&lt; <span class="string">"&lt;Union&amp;Find set&gt;: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">    		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\tPI["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; PI[i]</div><div class="line">    			 &lt;&lt; <span class="string">"   "</span></div><div class="line">    			 &lt;&lt; <span class="string">"rank["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; rank[i] &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    	&#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">   </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">  <span class="comment">// cost for VertexNode to reach current MST</span></div><div class="line">  <span class="keyword">int</span> cost;</div><div class="line">  <span class="comment">// recording the pre-visit VertexNode in the path --&gt; restore a MST</span></div><div class="line">  VertexNode* prev;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="keyword">struct</span> Edge &#123;</div><div class="line">  <span class="keyword">int</span> fromIdx, toIdx;</div><div class="line">  <span class="keyword">int</span> weight;</div><div class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Edge&amp; right) <span class="keyword">const</span> &#123;</div><div class="line">    <span class="keyword">return</span> weight &gt; right.weight;</div><div class="line">  &#125;;</div><div class="line">&#125;;</div><div class="line">   </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, weight;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">    g.VertexNodes[i].prev = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; weight;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;weight = weight;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;weight &lt;&lt; <span class="string">") "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="function">UnionFindSets <span class="title">sets</span><span class="params">(g.vertexNum)</span></span>;</div><div class="line">  <span class="comment">// use priority_queue for sorting the edges E by weight</span></div><div class="line">  priority_queue&lt;Edge&gt; EdgeQueue;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    sets.makeset(g.VertexNodes[i].vertexIdx);</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      Edge e;</div><div class="line">      e.fromIdx = g.VertexNodes[i].vertexIdx;</div><div class="line">      e.toIdx = head-&gt;adjVertexIdx;</div><div class="line">      e.weight = head-&gt;weight;</div><div class="line">      EdgeQueue.push(e);</div><div class="line"></div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nMST constructing: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">while</span>(!EdgeQueue.empty()) &#123;</div><div class="line">    Edge e = EdgeQueue.top();</div><div class="line">    EdgeQueue.pop();</div><div class="line">    <span class="comment">// cout &lt;&lt; "\npop: " &lt;&lt; e.fromIdx &lt;&lt; "-&gt;" &lt;&lt; e.toIdx &lt;&lt; "(" &lt;&lt; e.weight &lt;&lt; ")" &lt;&lt; endl;</span></div><div class="line">    <span class="keyword">if</span>(sets.find(e.fromIdx) != sets.find(e.toIdx)) &#123;</div><div class="line">      <span class="comment">/*</div><div class="line">       * 2 edges with same vertex in an undirect graph</div><div class="line">       *	but every VertexNode can only have on prev.</div><div class="line">       */</span></div><div class="line">      <span class="keyword">if</span>(g.VertexNodes[e.toIdx].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line">      g.VertexNodes[e.toIdx].prev = &amp;g.VertexNodes[e.fromIdx];</div><div class="line">      g.VertexNodes[e.toIdx].cost = e.weight;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[e.fromIdx].data &lt;&lt; <span class="string">"--&gt;"</span> &lt;&lt; g.VertexNodes[e.toIdx].data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; e.weight &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">      sets.unite(e.fromIdx, e.toIdx);</div><div class="line">      <span class="comment">// sets.printset();</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">   </div><div class="line"><span class="comment">// backtracking for the path</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMST</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> cost = <span class="number">0</span>;</div><div class="line">  <span class="comment">// MST always starts from 0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=g.vertexNum<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">    <span class="keyword">if</span>(g.VertexNodes[i].prev != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t+ "</span></div><div class="line">         &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"&lt;--"</span> &lt;&lt; g.VertexNodes[i].prev-&gt;data</div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; g.VertexNodes[i].cost &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">       cost += g.VertexNodes[i].cost;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"   cost: "</span> &lt;&lt; cost &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  freopen(<span class="string">"Prim.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line">  </div><div class="line">  Kruskal(g);</div><div class="line">   </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Minimum Spanning Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  PrintMST(g);</div><div class="line">   </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>构建并运行，结果如下：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">$ g++ Kruskal.cpp -o Kruskal</div><div class="line">$ ./Kruskal </div><div class="line">The adjacent list <span class="keyword">for</span> graph is:</div><div class="line"> 0-&gt;7(8) 1(4) </div><div class="line"> 1-&gt;2(8) 0(4) </div><div class="line"> 2-&gt;8(2) 5(4) 3(7) 1(8) </div><div class="line"> 3-&gt;5(14) 4(9) 2(7) </div><div class="line"> 4-&gt;5(10) 3(9) </div><div class="line"> 5-&gt;6(2) 4(10) 3(14) 2(4) </div><div class="line"> 6-&gt;8(6) 7(1) 5(2) </div><div class="line"> 7-&gt;8(7) 6(1) 0(8) </div><div class="line"> 8-&gt;7(7) 6(6) 2(2) </div><div class="line"> </div><div class="line">MST constructing: </div><div class="line">  + 6--&gt;7(1)</div><div class="line">  + 5--&gt;6(2)</div><div class="line">  + 8--&gt;2(2)</div><div class="line">  + 2--&gt;5(4)</div><div class="line">  + 1--&gt;0(4)</div><div class="line">  + 2--&gt;3(7)</div><div class="line">  + 2--&gt;1(8)</div><div class="line">  + 3--&gt;4(9)</div><div class="line"> </div><div class="line">Minimum Spanning Tree: </div><div class="line">  + 7&lt;--6(1)</div><div class="line">  + 6&lt;--5(2)</div><div class="line">  + 5&lt;--2(4)</div><div class="line">  + 4&lt;--3(9)</div><div class="line">  + 3&lt;--2(7)</div><div class="line">  + 2&lt;--8(2)</div><div class="line">  + 1&lt;--2(8)</div><div class="line">  + 0&lt;--1(4)</div><div class="line">   cost: 37</div></pre></td></tr></table></figure>
<ul>
<li>整棵最小生成树的构建过程如下：<center><img src="/img/Algorithms/0007_MSTKruskal.png" width="640px"/></center>

</li>
</ul>
<h4 id="Number-of-Islands"><a href="#Number-of-Islands" class="headerlink" title="Number of Islands"></a><a href="https://leetcode.com/problems/number-of-islands/#/description">Number of Islands</a></h4><p>　下面使用并查集解决 <strong>岛屿数量</strong> 问题，该问题描述如下：</p>
<blockquote>
<p>　Given a 2d grid map of <strong>‘1’</strong>s (land) and <strong>‘0’</strong>s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. <strong>You may assume all four edges of the grid are all surrounded by water</strong>.</p>
<ul>
<li><code>Example 1</code>:<br>　11110<br>　11010<br>　11000<br>　00000<br>Answer: 1</li>
<li><code>Example 2</code>:<br>　11000<br>　11000<br>　00100<br>　00011<br>Answer: 3</li>
</ul>
</blockquote>
<ul>
<li>问题分析<ul>
<li>问题实际就是寻找 0-1 2d 网格中由 1 表示的 land 的连通区域块的数目，所以首先是如何确定一个连通区域块，确定之后即可统计整个网格中的块数目即可。</li>
<li>可以通过 DFS 确定寻找连通区域块：由上至下/从左及右从一块 land 开始，向右/向下进行 DFS 遍历，当遍历结束时，即到达本岛屿的每一块 land，可以寻找下一块岛屿；为了避免重复遍历，需要将每一块 land 打上标签，标注已属于某个岛屿。</li>
<li>一个岛屿即为一个集合，通过遍历每块 land，通过集合的并操作将 land 依次并入各岛屿集合，最终统计岛屿集合的数目即可。</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><figcaption><span>Number of Islands</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> UnionFindSets &#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PI;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rank;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    UnionFindSets(<span class="keyword">int</span> size) &#123;</div><div class="line">        PI.resize(size);</div><div class="line">        rank.resize(size);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            PI[i] = <span class="number">-1</span>;</div><div class="line">            rank[i] = <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">makeset</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        PI[x] = x;</div><div class="line">        rank[x] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(PI[x] &lt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(x != PI[x]) &#123;</div><div class="line">            PI[x] = find(PI[x]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> PI[x];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> rx = find(x);</div><div class="line">        <span class="keyword">int</span> ry = find(y);</div><div class="line">        <span class="keyword">if</span>(rx==<span class="number">-1</span> || ry==<span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(rx == ry) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(rank[rx] &gt; rank[ry]) &#123;</div><div class="line">            PI[ry] = rx;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            PI[rx] = ry;</div><div class="line">            <span class="keyword">if</span>(rank[rx] == rank[ry]) &#123;</div><div class="line">                rank[ry] += <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(grid.empty()) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> rowSize = grid.size();</div><div class="line">        <span class="keyword">int</span> colSize = grid[<span class="number">0</span>].size();</div><div class="line">        <span class="function">UnionFindSets <span class="title">sets</span><span class="params">(rowSize*colSize)</span></span>;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;rowSize; row++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;colSize; col++) &#123;</div><div class="line">                <span class="keyword">int</span> gridSetIdx = row*colSize + col;</div><div class="line">                <span class="comment">// water grid not need to make set, still -1</span></div><div class="line">                <span class="keyword">if</span>(grid[row][col] == <span class="string">'0'</span>) &#123;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    sets.makeset(gridSetIdx);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// upper grid is land, need to unite for enlarging land</span></div><div class="line">                <span class="keyword">if</span>(row&gt;<span class="number">0</span> &amp;&amp; grid[row<span class="number">-1</span>][col]==<span class="string">'1'</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> upperSetIdx = (row<span class="number">-1</span>)*colSize + col;</div><div class="line">                    sets.unite(gridSetIdx, upperSetIdx);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// left grid is land, need to unite for enlarging land</span></div><div class="line">                <span class="keyword">if</span>(col&gt;<span class="number">0</span> &amp;&amp; grid[row][col<span class="number">-1</span>]==<span class="string">'1'</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> leftSetIdx = row*colSize + (col<span class="number">-1</span>);</div><div class="line">                    sets.unite(gridSetIdx, leftSetIdx);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// count the number of united sets</span></div><div class="line">        <span class="keyword">int</span> unitedSetNum = <span class="number">0</span>;</div><div class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; counted;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> setIdx=<span class="number">0</span>; setIdx&lt;rowSize*colSize; setIdx++) &#123;</div><div class="line">            <span class="keyword">int</span> unitedSetIdx = sets.find(setIdx);</div><div class="line">            <span class="keyword">if</span>(unitedSetIdx == <span class="number">-1</span>) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(!counted[unitedSetIdx]) &#123;</div><div class="line">                unitedSetNum++;</div><div class="line">                counted[unitedSetIdx] = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> unitedSetNum;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节<ul>
<li><strong>“0”</strong> 网格（water）不作为并查集合元素，每一个 <strong>“1”</strong> 网格（land）一开始为一个集合。</li>
<li>如果一个网格为 <strong>“1”</strong> ，那这个网格和它左方/上方为 <strong>“1”</strong> 的网格属于一个连通块，并到一个集合。</li>
<li>最后，遍历并查集合中的每个元素（忽略了 water 未初始化集合），对其中存在的集合进行计数。</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;并查集：并查集处理的是集合之间的关系，即 union，find。在这种数据类型中，N个不同元素被分成若干个组，每组是一个集合，这种集合叫做分离集合。并查集支持查找一个元素所属的集合和两个元素分别所属的集合的合并。注意：并查集只能进行合并操作，不能进行分割操作。&lt;/li&gt;
&lt;li&gt;并查集支持以下操作：&lt;ul&gt;
&lt;li&gt;&lt;code&gt;makeset(x)&lt;/code&gt;：创建一个仅包含 x 的独立集合（分离集）；最初每个节点单独构成了一个分离集 ==&amp;gt; 一组分离集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find(x)&lt;/code&gt;：不断重复地检验节点对，判断其是否属于同一个集合？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union(x, y)&lt;/code&gt;：每当增加了一条边，将与之相关的两个集合合并。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0014] Dynamic Programming(V) 一道习题</title>
    <link href="http://durant35.github.io/2017/05/26/Algorithms_Dynamic%20Programming(V)/"/>
    <id>http://durant35.github.io/2017/05/26/Algorithms_Dynamic Programming(V)/</id>
    <published>2017-05-26T06:00:22.000Z</published>
    <updated>2017-07-06T08:46:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<ul>
<li>Consider the following game. A “dealer” produces a sequence $s_1, …, s_n$ of “cards”, face up, where each card $s_i$ has a value $v_i$. Then two players take turns picking a card from the sequence, but can only pick the first or the last card of the (remaining) sequence. The goal is to collect cards of largest total value. (For example, you can think of the cards as bills of different denominations.) Assume n is even.</li>
</ul>
<a id="more"></a>
<p>　(a) Show a sequence of cards such that it is not optimal for the first player to start by picking up the available card of larger value. That is, the natural greedy strategy is suboptimal.<br>　(b) Give an $O(n^2)$ algorithm to compute an optimal strategy for the first player. Given the initial sequence, your algorithm should precompute in $O(n^2)$ time some information, and then the first player should be able to make each move optimally in $O(1)$ time by looking up the precomputed information.</p>
</blockquote>
<ul>
<li>考虑如下博弈：发牌手准备了一摞扑克牌 $s_1, …, s_n$。从牌面上看，牌 $s_i$ 的价值为 $v_i$。现在两个玩家轮流拿牌，每人每次只能拿最前或最后的一张。玩家的目标是使所拿到的牌总价值最高（不妨想象这些牌都是有面值的筹码）。假设 $n$ 为偶数。<ul>
<li>请给出一个序列，使得先开始的玩家如果采取贪心策略（即每次取走能拿的牌中面值较大的一张），最终的牌总价值并不比另一个玩家大。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Solution：&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">3</span>&#125;</div><div class="line">先手：<span class="number">3</span></div><div class="line">后手：<span class="number">10</span>（先手由于贪心损失最大牌值的一张牌）</div><div class="line">先手：<span class="number">2</span></div><div class="line">后手：<span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li>给出一个 $O(n^2)$ 的算法，用于计算先开始玩家的最优策略。给定初始序列，该算法首先利用 $O(n^2)$ 的时间进行预先计算，然后在每次选择时，玩家只需通过查找预先计算的结果即可在 $O(1)$ 内做出最有选择。<br><font color="red">Solution：</font><br>　　$r(i, j)$ 表示在子串 $s[i, j]$ 中进行游戏时所获得的最大分数值（假设对手也总是采取最优的策略），设 $r_i$ 是在子串 $s[i, j]$ 中进行游戏时，先手第一步选择最前一张牌所能得到的分数； $r_j$ 是先手第一步选择最后一张牌所能得到的分数，则有：<br>　　$\begin{cases}<br>r_i = v_i + min(r(i+2, j), r(i+1, j-1))\cr<br>r_j = v_j + min(r(i+1, j-1), r(i, j-2))<br>\end{cases}$，当先手第一步选择最前一张牌后，在第二步的选择中，$r(i+2, j)$ 对应后手第一步选择剩下的最前一张牌，$r(i+1, j-1)$则是后手第一步选择剩下的牌中的最后一张；类似地，当先手第一步选择最后一张牌后，在第二步的选择中，$r(i+1, j-1)$ 对应后手第一步选择剩下的最前一张牌，$r(i, j-2)$则是后手第一步选择了最后一张牌。<br>　　子串的长度 <code>len</code> 从2, 4, …, 初始序列长度 <code>LEN</code>，然后遍历（$i =  0,1,…,LEN-len-1: s[i, i+len]$）所有可能的子串进行如上的预处理。<br>　　为了在 $O(1)$ 内做出最有选择，还需要记录对于每个子串，先手玩家第一步的选择 $c(i, j)：$<br>　　$\begin{cases}<br>if(r_i \gt r_j): c(i, j)=pickfront \cr<br>else: \qquad c(i, j)=pickback<br>\end{cases}$</li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Consider the following game. A “dealer” produces a sequence $s_1, …, s_n$ of “cards”, face up, where each card $s_i$ has a value $v_i$. Then two players take turns picking a card from the sequence, but can only pick the first or the last card of the (remaining) sequence. The goal is to collect cards of largest total value. (For example, you can think of the cards as bills of different denominations.) Assume n is even.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0013] 网络流：最大流（Max Flow）问题</title>
    <link href="http://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/"/>
    <id>http://durant35.github.io/2017/05/19/Algorithms_MaximizingFlow/</id>
    <published>2017-05-19T02:54:22.000Z</published>
    <updated>2017-07-06T08:46:19.368Z</updated>
    
    <content type="html"><![CDATA[<h4 id="网络流：最大流问题"><a href="#网络流：最大流问题" class="headerlink" title="网络流：最大流问题"></a>网络流：最大流问题</h4><ul>
<li>所谓网络：<ul>
<li>一个有向图 $G=(V, E)$</li>
<li>G中有两个特殊节点 $s, t \in V$，分别称为 G 中的源点(source) 和汇点(sink)。</li>
<li>G中每条边都有容量 $c_e \lt 0$。</li>
</ul>
</li>
<li>所谓流是指一种特定的输送方式，其中对每条边赋予一个变量 $f_e$，使其满足如下三个基本性质：<a id="more"></a>
<ul>
<li>容量限制(Capacity Constraints)：不超过边的容量，即对所有 $e \in E, 0 \leq f_e \leq c_e$</li>
<li>流量守恒(Flow Conservation)：对于 s 和 t  之外的任意节点 u，输入 u 的流量等于输出 u 的流量（流量是守恒的）：$\sum_{(w, u) \in E} f_{wu} = \sum_{(u, z) \in E} f_{uz} $</li>
<li>斜对称性(Skew Symmetry)：$ f_{uv} = -f_{vu}$</li>
</ul>
</li>
<li>网络流问题（NetWork Flow Problem）<ul>
<li>给定指定的一个有向图，其中有两个特殊的点：源 S 和汇 T，每条边有指定的容量(Capacity)，求满足条件的从 S 到 T 的最大流(MaxFlow)。</li>
</ul>
</li>
<li>最大流<ul>
<li>流的规模为由 s 流向 t 的总流量，由上面的流量的守恒律，其等于离开 s 的流量。</li>
<li>目标函数（最大化）：$ 规模(f) =  \sum_{(s, u) \in E} f_{su} = \sum_{(z, t) \in E} f_{zt} $</li>
</ul>
</li>
<li>其他相关定义<ul>
<li>容量网络(capacity network)&amp;流量网络(flow network)&amp;残留网络(residual network)<ul>
<li>网络就是有源、汇的有向图，关于什么的网络就是指边权的含义是什么。<center><img src="/img/Algorithms/0013_networkGraphSketch.png" width="540px"/></center></li>
<li>容量网络就是关于容量的网络。在求解问题的过程中，容量网络基本是不改变的。</li>
<li>流量网络就是关于流量的网络。在求解问题的过程中，流量网络通常在不断改变，但是总是满足上述三个性质；调整到最后就是最大流网络，同时也可以得到最大流值。</li>
<li>残量网络往往概括了容量网络和流量网络，是最为常用的，残量网络=容量网络-流量网络。</li>
</ul>
</li>
<li>增广路径(Augmenting path)：增广路径顾名思义就是能够增加流量的路径。增广路径 p 是残量网络中一条从源点 s 到汇点 t 的简单路径，在一条增广路径 p 上能够为每条边增加的流量的最大值为路径 p 的 <strong>残存容量(remaining capacity)</strong>：$c_f(p) = min \verb|{| c_f(u,v):(u,v) \in p \verb|}|$</li>
<li>割&amp;割集<ul>
<li>一个无向连通网络，去掉一个边集可以使其变成两个连通分量，则这个边集就是割集<ul>
<li>无向图的割集(Cut Set)：$C[A,B]$ 是将图 G 分为 A 和 B 两个点集（连通分量）的连接 A 和 B 之间的边的全集。</li>
</ul>
</li>
<li>带权图的割(Cut) 就是割集中边或者有向边的权和。<ul>
<li>最小割集当然就是权和最小的割集。</li>
</ul>
</li>
<li>在有向图网络 $G(V, E)$ 中, 割(S, T) 将 V 划分为 S 和 T=V-S，使得 s 属于 S 集合，t 属于 T 集合，割(S, T) 的容量是指从集合 S 到集合 T 所有边的容量之和。<center><img src="/img/Algorithms/0013_cutSketch.png" width="540px"/></center>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="最大流问题与线性规划"><a href="#最大流问题与线性规划" class="headerlink" title="最大流问题与线性规划"></a>最大流问题与线性规划</h4><p>　最大流问题可以转换为线性规划问题，而线性规划问题最著名的解法自然就是 <strong>单纯形法</strong>。这种算法非常奇特，其复杂度为在最坏情况下是指数级的，但其在实践中绝大多数的情况下表现出的效率非常令人满意。</p>
<ul>
<li>设$c_{uv}$ 代表边 u 到 v 最大允许的流量（capacity），$f_{uv}$ 代表 u 到 v 当前流量。</li>
<li>最大流可以表示为：<br>$$<br>  \Large{max}<br>  \normalsize{ \sum_{u:(s, u) \in E} f_{su} \quad }<br>  \Large{s.t.} \normalsize{<br>   \begin{cases} 0 \leq f_{uv} \leq c_{uv}, \forall (u, v) \in E \cr<br>   \sum_{w:(w, u) \in E} f_{wu} - \sum_{v:(u, v) \in E} f_{uv} = 0, \forall u \in V \backslash \verb|{| s, t \verb|}| \end{cases}<br>  }<br>$$</li>
<li>事实上，使用 <strong>单纯形法</strong> 解决网络最大流问题非常直观：<ol>
<li>从零流量开始</li>
<li>重复下述过程：<ul>
<li>选择一条从源点 s 到汇点 t 的合适路径</li>
<li>将该路径的流量增加到无法增加为止</li>
</ul>
</li>
</ol>
</li>
<li>每次迭代单纯形法寻找到 s→t 的一条路径，路径中的边有两种类型（如下图(b)中右图所示，可以同时存在这两种类型的边）：<br>  　　① 边在最初的网络中，且未达到最大流量，如下图(b)右图中的边 <strong>a→d</strong>；<br>  　　② 边的反向边在最初的网络中，如下图(c)右图中的边 <strong>d→a</strong>。<br><center><img src="/img/Algorithms/0013_residualGraphSketch.png" width="540px"/></center><ul>
<li>如果当前的流为 $f$，则对于第①种情况，边 $(u, v)$ 最多还能接受 $c_{uv} - f_{u, v}$ 的多余流量；而在第②种情况，最多增加的流量为 $f_{vu}$（取消 $(v, u)上的全部或部分流量$ ）。</li>
<li>这类增加流量的机会可以由 <strong>残量网络</strong> $G^f=(V, E^f)$ 来判定，该网络包含了所有的以上两种边，并标出了每条边的剩余流量：<br>$$<br>c^f =<br> \begin{cases} c_{uv} - f_{uv}, \quad 若(u, v) \in E 且 f_{uv} \lt c_{uv} \cr<br>f_{vu}, \qquad \quad 若(v, u) \in E 且 f_{uv} \gt 0 \end{cases}<br>$$</li>
</ul>
</li>
</ul>
<h4 id="最大流基本方法（Ford-Fulkerson）"><a href="#最大流基本方法（Ford-Fulkerson）" class="headerlink" title="最大流基本方法（Ford-Fulkerson）"></a>最大流基本方法（Ford-Fulkerson）</h4><ul>
<li>通过模拟单纯形法，我们得到了一个解决最大流问题的直接算法（Ford-Fulkerson）。该算法采取迭代的方式进行，每次先构造一个 $G^f$，然后在 $G^f$ 中寻找 s 到 t 的一条可行的增广（能够继续提高流量的）路径，找不到任何这样的路径时算法停止。</li>
<li>Ford-Fulkerson 方法<ul>
<li>Ford-Fulkerson 方法，即增广路方法，是一种迭代的方法，之所以称之为方法，而不是算法，因为FF(Ford-Fulkerson) 包含不同运行时间的几种实现。</li>
<li>Ford-Fulkerson 方法伪代码如下，解决了以下三个子问题：①<strong>while</strong>：要增广多少次？②<strong>augmenting path</strong>：如何找到一条增广路径？③<strong>update</strong>：如何增广？<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FORD-FULKERSON-METHOD(G, s, t): </div><div class="line">   initialize flow f to <span class="number">0</span></div><div class="line">   <span class="keyword">while</span> there exists an augmenting path p, path-flow as its remaining capacity</div><div class="line">     <span class="keyword">do</span> augment flow path-flow along p to flow f</div><div class="line">     update residual graph</div><div class="line">   <span class="keyword">return</span> flow f</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>最大流算法 Ford-Fulkerson 方法最优性验证<ul>
<li>最大流最小割定理：设 $f$ 为流网络 $G = (V, E)$ 中的一个流，该流网络的源点为 s，汇点为t，则下面的条件是等价的：<ul>
<li>$f$ 是 $G$ 的一个最大流</li>
<li>残量网络 $G^f$ 不包含任何增广路径</li>
<li>$|f| = |C(S, T)|$，即最大流流量等于割 $C$ 的容量，割 $C=(S, T)$ 是流网络 $G$ 的最小割</li>
</ul>
</li>
<li>找到最大流 $f$ $\Longrightarrow$ 残量网络 $G^f$ 中已经无法找到任何由 s 到 t 的路径 $\Longrightarrow$ $(L, R)$ 为图 $G$ 的一个分割 $\begin{cases} L为 G^f 中 s 可达的所有节点集合 \cr R=V-L 为剩余的节点 \end{cases}$</li>
<li>对于任意流 $f$ 和任意 $(s, t)$ 分割 $(L, R)$，$流量(f) \leq 容量(L, R)$，由最大流最小割定理，最大流算法产生最小割，最小割对应于流的上限，这就是所求得流的最优性的保证。</li>
</ul>
</li>
<li>最大流算法的运行效率<ul>
<li>FORD-FULKERSON-METHOD 每个单次循环都是效率很高的，无论通过使用 <a href="http://durant35.github.io/2017/03/15/Algorithms_DFS/">DFS</a> 还是 <a href="http://durant35.github.io/2017/03/22/Algorithms_BFS/">BFS</a>，每次循环都只需要 $O(|E|)$ 的时间，但问题是，我们一共需要循环多少次呢？可以看出，循环次数的上线是所有边流量的最大值 C（每次循环只能增加 1 个流量），算法最坏情况为 $O(C|E|)$，然而 C 可能是一个很大的值！</li>
<li>采用广度优先搜索将使得找到的增广路径包含最少的边，则不管边的容量如何，C 如何，最终的迭代次数将不超过 $O(|V|·|E|)$（所有可能的路径总和）。因此，通过仔细地选择增广路径，可以将循环次数限制在 $O(|V|·|E|)$ 之内，在这种情况下，整个算法的时间复杂度为 $O(|V|·|E|^2)$。在 FORD-FULKERSON-METHOD 中通过 BFS 搜索增广路径，这就是<strong>Edmonds-Karp</strong> 算法（最短路径增广算法），其算法实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// MaxFlow.cpp</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span>			<span class="comment">/* setw */</span>  </span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span>			<span class="comment">/* stdin */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits.h&gt;</span>			<span class="comment">/* INT_MAX */</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_VERTEX_NUM    26</span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> adjVertexNode &#123;</div><div class="line">  <span class="keyword">int</span> adjVertexIdx;</div><div class="line">  <span class="keyword">int</span> capacity;</div><div class="line">  adjVertexNode* next;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// Alignment-requirement: the first char is expanded to 4(8) bytes in 32-bit(64-bit) machine</span></div><div class="line"><span class="comment">// sizeof(VertexNode) == 16(32)</span></div><div class="line"><span class="keyword">struct</span> VertexNode &#123;</div><div class="line">  <span class="keyword">char</span> data;</div><div class="line">  <span class="keyword">int</span> vertexIdx;</div><div class="line">  adjVertexNode* <span class="built_in">list</span>;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Graph &#123;</div><div class="line">  VertexNode VertexNodes[MAX_VERTEX_NUM];</div><div class="line">  <span class="keyword">int</span> vertexNum;</div><div class="line">  <span class="keyword">int</span> edgeNum;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateGraph</span> <span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i, j, edgeStart, edgeEnd, capacity;</div><div class="line">  adjVertexNode* adjNode;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex and edge num (vertex-num edge-num):" &lt;&lt;endl;</span></div><div class="line">  <span class="built_in">cin</span> &gt;&gt; g.vertexNum &gt;&gt; g.edgeNum;</div><div class="line">  <span class="comment">//cout &lt;&lt; "Please input vertex information (v1)/n note: every vertex info end with Enter" &lt;&lt;endl;</span></div><div class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; g.VertexNodes[i].data; <span class="comment">// vertex data info.</span></div><div class="line">    g.VertexNodes[i].vertexIdx = i;</div><div class="line">    g.VertexNodes[i].<span class="built_in">list</span> = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//cout &lt;&lt; "input edge information(start end):" &lt;&lt; endl;</span></div><div class="line">  <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;g.edgeNum; j++)	&#123;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; edgeStart &gt;&gt; edgeEnd &gt;&gt; capacity;</div><div class="line"> </div><div class="line">    <span class="comment">// insert new adjacent VertexNode at the begining of the adjacent list</span></div><div class="line">    adjNode = <span class="keyword">new</span> adjVertexNode;</div><div class="line">    adjNode-&gt;adjVertexIdx = edgeEnd;</div><div class="line">    adjNode-&gt;capacity = capacity;</div><div class="line">    adjNode-&gt;next = g.VertexNodes[edgeStart].<span class="built_in">list</span>;</div><div class="line">    g.VertexNodes[edgeStart].<span class="built_in">list</span> = adjNode;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAdjList</span><span class="params">(<span class="keyword">const</span> Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"The adjacent list for graph is:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; g.vertexNum; i++) &#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; g.VertexNodes[i].data &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">    adjVertexNode* head = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[head-&gt;adjVertexIdx].data </div><div class="line">         &lt;&lt; <span class="string">"("</span> &lt;&lt; head-&gt;capacity &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="string">" "</span>;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPath</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">int</span>* prevs, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">  <span class="comment">// no previous node ==&gt; reach starting node </span></div><div class="line">  <span class="keyword">if</span> (prevs[toIdx] != <span class="number">-1</span>) &#123;</div><div class="line">    PrintPath(g, prevs, prevs[toIdx]);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; g.VertexNodes[toIdx].data;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteGraph</span><span class="params">(Graph&amp; g)</span> </span>&#123;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    adjVertexNode* tmp = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span>(g.VertexNodes[i].<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</div><div class="line">      tmp = g.VertexNodes[i].<span class="built_in">list</span>;</div><div class="line">      g.VertexNodes[i].<span class="built_in">list</span> = g.VertexNodes[i].<span class="built_in">list</span>-&gt;next;</div><div class="line">      <span class="keyword">delete</span> tmp;</div><div class="line">      tmp = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span>** graph, <span class="keyword">int</span> vertexNum, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx, <span class="keyword">int</span>* prevs)</span> </span>&#123;</div><div class="line">  <span class="comment">// cout &lt;&lt; "BFS" &lt;&lt; endl;</span></div><div class="line">  <span class="comment">// for(int u=0; u&lt;vertexNum; u++) &#123;</span></div><div class="line">  <span class="comment">// 	for(int v=0; v&lt;vertexNum; v++) &#123;</span></div><div class="line">  <span class="comment">// 		if(graph[u][v] &gt; 0) &#123;</span></div><div class="line">  <span class="comment">// 			cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; v &lt;&lt; "(" &lt;&lt; graph[u][v] &lt;&lt; ") ";</span></div><div class="line">  <span class="comment">// 		&#125;</span></div><div class="line">  <span class="comment">// 	&#125;</span></div><div class="line">  <span class="comment">// 	cout &lt;&lt; endl;</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="keyword">bool</span> visited[vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;vertexNum; vertexIdx++) &#123;</div><div class="line">    visited[vertexIdx] = <span class="literal">false</span>;</div><div class="line">    prevs[vertexIdx] = <span class="number">-1</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; vertexIdxQueue;</div><div class="line">  vertexIdxQueue.push(fromIdx);</div><div class="line">  visited[fromIdx] = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">while</span> (!vertexIdxQueue.empty()) &#123;</div><div class="line">    <span class="keyword">int</span> u = vertexIdxQueue.front();</div><div class="line">    <span class="comment">// cout &lt;&lt; u &lt;&lt; " ";</span></div><div class="line">    <span class="keyword">if</span>(u == toIdx) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    vertexIdxQueue.pop();</div><div class="line"> </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(!visited[v] &amp;&amp; graph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        vertexIdxQueue.push(v);</div><div class="line">        visited[v] = <span class="literal">true</span>;</div><div class="line">        prevs[v] = u;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> visited[toIdx];</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">FordFulkerson</span><span class="params">(<span class="keyword">const</span> Graph&amp; g, <span class="keyword">const</span> VertexNode&amp; source, <span class="keyword">const</span> VertexNode&amp; sink)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> maxFlow = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> flowGraph[g.vertexNum][g.vertexNum];</div><div class="line">  <span class="comment">// initialize the residual graph</span></div><div class="line">  <span class="keyword">int</span>** residualGraph = <span class="keyword">new</span> <span class="keyword">int</span>*[g.vertexNum];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    residualGraph[u] = <span class="keyword">new</span> <span class="keyword">int</span>[g.vertexNum];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      residualGraph[u][v] = <span class="number">0</span>;</div><div class="line">      flowGraph[u][v] = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> vertexIdx=<span class="number">0</span>; vertexIdx&lt;g.vertexNum; vertexIdx++) &#123;</div><div class="line">    adjVertexNode* head = g.VertexNodes[vertexIdx].<span class="built_in">list</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// cout &lt;&lt; vertexIdx &lt;&lt; "--&gt;" &lt;&lt; head-&gt;adjVertexIdx &lt;&lt; endl;</span></div><div class="line">      residualGraph[vertexIdx][head-&gt;adjVertexIdx] = head-&gt;capacity;</div><div class="line">      head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// prevs array for storing the augmenting path</span></div><div class="line">  <span class="keyword">int</span> prevs[g.vertexNum];</div><div class="line">  <span class="keyword">int</span> iter = <span class="number">1</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Algorithm Process:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="comment">// Augment the flow while there is a path from source to sink</span></div><div class="line">  <span class="keyword">while</span>(BFS(residualGraph, g.vertexNum, source.vertexIdx, sink.vertexIdx, prevs)) &#123;</div><div class="line">    <span class="comment">// find the maximum flow(minimum residual capacity) through the path found</span></div><div class="line">    <span class="keyword">int</span> pathFlow = INT_MAX;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sink.vertexIdx; v!=source.vertexIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      <span class="keyword">if</span>(residualGraph[u][v] &lt; pathFlow) &#123;</div><div class="line">        pathFlow = residualGraph[u][v];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// update residual capacities of the edges &amp; reverse edges along the augmenting path</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=sink.vertexIdx; v!=source.vertexIdx; v=prevs[v]) &#123;</div><div class="line">      <span class="keyword">int</span> u = prevs[v];</div><div class="line">      residualGraph[u][v] -= pathFlow;</div><div class="line">      residualGraph[v][u] += pathFlow;</div><div class="line">      <span class="comment">// record flows</span></div><div class="line">      flowGraph[u][v] += pathFlow;</div><div class="line">    &#125;</div><div class="line">    maxFlow += pathFlow;</div><div class="line">    <span class="comment">// print current iteration's info</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\t#"</span> &lt;&lt; iter++ &lt;&lt; <span class="string">" flow: "</span> &lt;&lt; setw(<span class="number">3</span>) &lt;&lt; pathFlow &lt;&lt; <span class="string">" Augmenting-path: "</span>;</div><div class="line">    PrintPath(g, prevs, sink.vertexIdx);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">// memory release</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;g.vertexNum; i++) &#123;</div><div class="line">    <span class="keyword">delete</span>[] residualGraph[i];</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">delete</span>[] residualGraph;</div><div class="line"> </div><div class="line">  <span class="comment">// show the flows</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow Graph:"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">bool</span> noflow;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>; u&lt;g.vertexNum; u++) &#123;</div><div class="line">    noflow = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   "</span> &lt;&lt; g.VertexNodes[u].data &lt;&lt; <span class="string">": "</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;g.vertexNum; v++) &#123;</div><div class="line">      <span class="keyword">if</span>(flowGraph[u][v] &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-&gt;"</span> &lt;&lt; g.VertexNodes[v].data</div><div class="line">           &lt;&lt; <span class="string">"("</span> &lt;&lt; flowGraph[u][v] &lt;&lt; <span class="string">")\t"</span>;</div><div class="line">        noflow = <span class="literal">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(noflow) &#123;</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"NULL"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> maxFlow;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_FLOW1</span></div><div class="line">    freopen(<span class="string">"flow1.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    freopen(<span class="string">"flow2.txt"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"> </div><div class="line">  Graph g;</div><div class="line">  CreateGraph(g);</div><div class="line">  PrintAdjList(g);</div><div class="line"> </div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  </div><div class="line">  <span class="meta">#<span class="meta-keyword">ifdef</span> USE_FLOW1</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow: "</span> &lt;&lt; FordFulkerson(g, g.VertexNodes[<span class="number">0</span>], g.VertexNodes[<span class="number">6</span>]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" Maximum Flow: "</span> &lt;&lt; FordFulkerson(g, g.VertexNodes[<span class="number">0</span>], g.VertexNodes[<span class="number">5</span>]) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">  </div><div class="line">  DeleteGraph(g);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="red">算法实现细节分析如下：</font><ul>
<li><code>bool BFS(int** graph, int vertexNum, int fromIdx, int toIdx, int* prevs)</code> 函数通过广度优先搜索算法寻找边数目最少的增广路径，返回值表示能否寻找到这样的一条路径；假如存在这样的一条增广路径，<code>prevs</code> 数组则记录这样的一条增广路径：<strong>toIdx → prevs[toIdx] → prevs[prevs[toIdx]] → … → fromIdx</strong>。</li>
<li><code>residualGraph[u][v]</code> 通过邻接矩阵的方式维护一个残量网络，<code>flowGraph</code>则维护了流量网络的情况。</li>
<li><code>pathFlow</code> 则用于获取每次迭代寻找到的该增广路径的残存容量，用于更新残量网络和流量网络。<code>maxFlow</code> 则保留了最终的最大流量值。</li>
</ul>
</li>
<li>算法运行实例（一）<br>  <center><img src="/img/Algorithms/0013_demoFlow1.png" width="540px"/></center><ul>
<li>上图网络流对应的输入文件 <strong>flow1.txt</strong> 如下：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">7</span> <span class="number">11</span></div><div class="line">s a b c d e t</div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">3</span></div><div class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">4</span></div><div class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">10</span></div><div class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></div><div class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">5</span></div><div class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1</span></div><div class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">2</span></div><div class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">5</span></div></pre></td></tr></table></figure>
<ul>
<li>编译构建，运行结果如下，过程可视化如上图。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$ g++ -DUSE_FLOW1 MaxFlow.cpp -o MaxFlow</div><div class="line">$ ./MaxFlow </div><div class="line">The adjacent list for graph is:</div><div class="line"> s-&gt;c(4) b(3) a(3) </div><div class="line"> a-&gt;d(2) </div><div class="line"> b-&gt;d(1) a(10) </div><div class="line"> c-&gt;e(5) </div><div class="line"> d-&gt;t(2) e(1) c(1) </div><div class="line"> e-&gt;t(5) </div><div class="line"> t-&gt;NULL</div><div class="line"> </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:   2 Augmenting-path: s-&gt;a-&gt;d-&gt;t</div><div class="line">  #2 flow:   4 Augmenting-path: s-&gt;c-&gt;e-&gt;t</div><div class="line">  #3 flow:   1 Augmenting-path: s-&gt;b-&gt;d-&gt;e-&gt;t</div><div class="line"> Maximum Flow Graph:</div><div class="line">   s: -&gt;a(2)	-&gt;b(1)	-&gt;c(4)	</div><div class="line">   a: -&gt;d(2)	</div><div class="line">   b: -&gt;d(1)	</div><div class="line">   c: -&gt;e(4)	</div><div class="line">   d: -&gt;e(1)	-&gt;t(2)	</div><div class="line">   e: -&gt;t(5)	</div><div class="line">   t: NULL</div><div class="line"> Maximum Flow: 7</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>算法运行实例（二）<br>  <center><img src="/img/Algorithms/0013_demoFlow2.png" width="420px"/></center><ul>
<li>上图网络流对应的输入文件 <strong>flow2.txt</strong> 如下：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="number">6</span> <span class="number">10</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></div><div class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">16</span></div><div class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">13</span></div><div class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">10</span></div><div class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">12</span></div><div class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">4</span></div><div class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">14</span></div><div class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">9</span></div><div class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">20</span></div><div class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">7</span></div><div class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></div></pre></td></tr></table></figure>
<ul>
<li>编译构建，运行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">$ g++ MaxFlow.cpp -o MaxFlow</div><div class="line">$ ./MaxFlow </div><div class="line">The adjacent list for graph is:</div><div class="line"> 0-&gt;2(13) 1(16) </div><div class="line"> 1-&gt;3(12) 2(10) </div><div class="line"> 2-&gt;4(14) 1(4) </div><div class="line"> 3-&gt;5(20) 2(9) </div><div class="line"> 4-&gt;5(4) 3(7) </div><div class="line"> 5-&gt;NULL</div><div class="line"> </div><div class="line"> Maximum Flow Algorithm Process:</div><div class="line">  #1 flow:  12 Augmenting-path: 0-&gt;1-&gt;3-&gt;5</div><div class="line">  #2 flow:   4 Augmenting-path: 0-&gt;2-&gt;4-&gt;5</div><div class="line">  #3 flow:   7 Augmenting-path: 0-&gt;2-&gt;4-&gt;3-&gt;5</div><div class="line"> Maximum Flow Graph:</div><div class="line">   0: -&gt;1(12)	-&gt;2(11)	</div><div class="line">   1: -&gt;3(12)	</div><div class="line">   2: -&gt;4(11)	</div><div class="line">   3: -&gt;5(19)	</div><div class="line">   4: -&gt;3(7)	-&gt;5(4)	</div><div class="line">   5: NULL</div><div class="line"> Maximum Flow: 23</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li>基本概念：<ul>
<li><a href="http://blog.csdn.net/xzz_hust/article/details/22041173">网络流：最大流，最小割 基本概念及算法</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9275177">图的匹配问题与最大流问题(一)</a><ul>
<li>最大流问题跟线性规划又是如何产生联系的呢？</li>
</ul>
</li>
</ul>
</li>
<li>算法涉及概念补充：<a href="http://www.jianshu.com/p/1451e70909c8">最大流, 最小割问题及算法实现</a></li>
<li>算法实现细节：<ul>
<li><a href="http://www.cnblogs.com/gaochundong/p/ford_fulkerson_maximum_flow_algorithm.html">Ford-Fulkerson 最大流算法</a></li>
<li><a href="http://blog.csdn.net/smartxxyx/article/details/9293805">图的匹配问题与最大流问题（三）——最大流问题Ford-Fulkerson方法Java实现</a></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;网络流：最大流问题&quot;&gt;&lt;a href=&quot;#网络流：最大流问题&quot; class=&quot;headerlink&quot; title=&quot;网络流：最大流问题&quot;&gt;&lt;/a&gt;网络流：最大流问题&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;所谓网络：&lt;ul&gt;
&lt;li&gt;一个有向图 $G=(V, E)$&lt;/li&gt;
&lt;li&gt;G中有两个特殊节点 $s, t \in V$，分别称为 G 中的源点(source) 和汇点(sink)。&lt;/li&gt;
&lt;li&gt;G中每条边都有容量 $c_e \lt 0$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;所谓流是指一种特定的输送方式，其中对每条边赋予一个变量 $f_e$，使其满足如下三个基本性质：
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>CPU 扫盲（核心数/线程数）</title>
    <link href="http://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/"/>
    <id>http://durant35.github.io/2017/05/16/hsw_CPUWipeoutIlliteracy/</id>
    <published>2017-05-16T07:33:00.000Z</published>
    <updated>2017-07-06T08:37:37.170Z</updated>
    
    <content type="html"><![CDATA[<p>　　处理器（CPU）决定了电脑的性能等级，是一个需要考虑的核心因素。CPU 从早期的单核，发展到现在的双核，多核。除了<strong>核心数</strong>之外，还有<strong>线程数</strong>之说，下面会对这两个概念进行扫盲。
　　</p>
<h4 id="CPU-个数"><a href="#CPU-个数" class="headerlink" title="CPU 个数"></a>CPU 个数</h4><p>　CPU 的个数是指物理上，也就是硬件上存在着几颗物理 CPU，指的是真实存在的处理器的个数，1个代表1颗、2个代表2颗 CPU 处理器。<br><a id="more"></a></p>
<h4 id="CPU-核心数"><a href="#CPU-核心数" class="headerlink" title="CPU 核心数"></a>CPU 核心数</h4><p>　一个核心就是一个物理线程，<strong>单核</strong>、<strong>双核</strong>、<strong>多核</strong>，指的就是物理核心的数目。
　　</p>
<h4 id="CPU-线程数"><a href="#CPU-线程数" class="headerlink" title="CPU 线程数"></a>CPU 线程数</h4><p>　CPU 的线程数概念仅仅只针对 Intel 的 CPU 才有用，因为它是通过 Intel 超线程技术来实现的，最早应用在 Pentium4 上。如果没有超线程技术，一个 CPU 核心对应一个线程（因此对于一个CPU，线程数总是大于或等于核心数的）。所以，对于 AMD 的 CPU 来说，只有核心数的概念，没有线程数的概念。<br>　CPU 之所以要增加线程数，是源于多任务处理的需要：线程数越多，越有利于同时运行多个程序，因为线程数等同于在某个瞬间 CPU 能同时并行处理的任务数。<br>　因此，线程数是一种逻辑的概念，简单地说，就是模拟出的 CPU 核心数。一个核心最少对应一个线程，但英特尔有个超线程技术可以把一个物理线程模拟出两个线程来用，充分发挥 CPU 性能，即一个核心可以有两个到多个线程。</p>
<h4 id="Linux-中获取处理器信息"><a href="#Linux-中获取处理器信息" class="headerlink" title="Linux 中获取处理器信息"></a>Linux 中获取处理器信息</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看 cpu 型号</span></div><div class="line">sudo dmidecode <span class="_">-s</span> processor-version</div><div class="line"><span class="comment"># 查看 cpu 个数</span></div><div class="line">grep <span class="string">'physical id'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div><div class="line"><span class="comment"># 查看核心数</span></div><div class="line">grep <span class="string">'core id'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div><div class="line"><span class="comment"># 查看线程数</span></div><div class="line">grep <span class="string">'processor'</span> /proc/cpuinfo | sort -u | wc <span class="_">-l</span></div></pre></td></tr></table></figure>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　处理器（CPU）决定了电脑的性能等级，是一个需要考虑的核心因素。CPU 从早期的单核，发展到现在的双核，多核。除了&lt;strong&gt;核心数&lt;/strong&gt;之外，还有&lt;strong&gt;线程数&lt;/strong&gt;之说，下面会对这两个概念进行扫盲。
　　&lt;/p&gt;
&lt;h4 id=&quot;CPU-个数&quot;&gt;&lt;a href=&quot;#CPU-个数&quot; class=&quot;headerlink&quot; title=&quot;CPU 个数&quot;&gt;&lt;/a&gt;CPU 个数&lt;/h4&gt;&lt;p&gt;　CPU 的个数是指物理上，也就是硬件上存在着几颗物理 CPU，指的是真实存在的处理器的个数，1个代表1颗、2个代表2颗 CPU 处理器。&lt;br&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="Architecture" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/Architecture/"/>
    
    
  </entry>
  
  <entry>
    <title>一张图带你看 Ubuntu(Linux) 系统启动过程</title>
    <link href="http://durant35.github.io/2017/05/13/hsw_UbuntuSystemBootSequence/"/>
    <id>http://durant35.github.io/2017/05/13/hsw_UbuntuSystemBootSequence/</id>
    <published>2017-05-13T14:04:00.000Z</published>
    <updated>2017-07-06T08:37:12.809Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="/img/hsw/BootProcess4Ubuntu.png" width="1600px"/></center><br><a id="more"></a></p>
<h3 id="计算机系统的启动过程"><a href="#计算机系统的启动过程" class="headerlink" title="计算机系统的启动过程"></a>计算机系统的启动过程</h3><blockquote>
<p><a href="https://blog.auroraka.com/2017/02/02/%e5%a4%9a%e7%b3%bb%e7%bb%9f%e6%8a%98%e8%85%be%e8%ae%b0/">Auroraka’s Blog：多系统折腾记——总结</a></p>
</blockquote>
<ol>
<li>计算机通电</li>
<li>CPU读取内置ROM芯片中的数据，BIOS或UEFI进行系统自检，并按照预先设置的优先级依次尝试寻找各储存器，并将控制权交给该储存设备(硬盘)</li>
<li>如果是BIOS启动，系统确定储存器分区表的分区以及操作系统所在的分区，并将控制权转交给操作系统。如果是EFI启动，系统首先确定分区表的分区，接着寻找文件系统格式为FAT32的分区，并按照其中的内容启动EFI系统，接着按照情况启动操作系统的boot loader，将控制权转交给操作系统</li>
<li>操作系统启动</li>
</ol>
<p>　　</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/hsw/BootProcess4Ubuntu.png&quot; width=&quot;1600px&quot;/&gt;&lt;/center&gt;&lt;br&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="Architecture" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/Architecture/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0012] Dynamic Programming(IV)（Longest Palindromic Subsequence）</title>
    <link href="http://durant35.github.io/2017/05/12/Algorithms_LongestPalindromicSubsequence/"/>
    <id>http://durant35.github.io/2017/05/12/Algorithms_LongestPalindromicSubsequence/</id>
    <published>2017-05-12T06:00:22.000Z</published>
    <updated>2017-07-06T08:46:00.780Z</updated>
    
    <content type="html"><![CDATA[<p>　所谓 <strong>回文（palindrome）</strong>，指的是正读和反读都是一样的。而 <strong>字符子串</strong> 和 <strong>字符子序列</strong> 的区别，在前面 <a href="http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/">算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）</a> 中也有提到过，字符字串指的是字符串中连续的n个字符，而字符子序列指的是字符串中不一定连续但先后顺序与原字符串一致的n个字符。<br><a id="more"></a></p>
<h4 id="最长回文字符串"><a href="#最长回文字符串" class="headerlink" title="最长回文字符串"></a>最长回文字符串</h4><ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-substring/#/description">5. Longest Palindromic Substring</a> 题目描述如下：<blockquote>
<p>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.<br>> Example:<br>　Input: “babad”<br>　Output: “bab”<br>Note: “aba” is also a valid answer.<br>> Example:<br>　Input: “cbbd”<br>　Output: “bb”</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> n = s.size();</div><div class="line">        <span class="comment">/*</div><div class="line">         * isPalindrome[i][j]: str[i...j] is a palindrome substring</div><div class="line">         * n ≤ 1000</div><div class="line">         */</span></div><div class="line">        <span class="keyword">bool</span> isPalindrome[n][n] = &#123;<span class="literal">false</span>&#125;;</div><div class="line">        <span class="comment">// &lt;1&gt; palindrome substring with length 2, a single char is a palindrome substring</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> strIdx=<span class="number">0</span>; strIdx&lt;n; strIdx++) &#123;</div><div class="line">            isPalindrome[strIdx][strIdx] = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// longest palindrome substring s[longestStartIdx,longestStartIdx+longestLen-1] with length:longestLen</span></div><div class="line">        <span class="keyword">int</span> longestStartIdx=<span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> longestLen = <span class="number">1</span>;</div><div class="line">        </div><div class="line">        <span class="comment">// &lt;2&gt; palindrome substring with length 2</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> strIdx=<span class="number">0</span>; strIdx&lt;n<span class="number">-1</span>; strIdx++) &#123;</div><div class="line">            <span class="keyword">if</span>(s[strIdx+<span class="number">1</span>] == s[strIdx]) &#123;</div><div class="line">                isPalindrome[strIdx][strIdx+<span class="number">1</span>] = <span class="literal">true</span>;</div><div class="line">                longestLen = <span class="number">2</span>;</div><div class="line">                longestStartIdx = strIdx;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// &lt;3&gt; palindrome substring with length:len</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">3</span>; len&lt;=n; len++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> strIdx=<span class="number">0</span>; strIdx&lt;=n-len; strIdx++) &#123;</div><div class="line">                <span class="keyword">int</span> endIdx = strIdx+len<span class="number">-1</span>;</div><div class="line">                <span class="keyword">if</span>(s[endIdx] == s[strIdx] &amp;&amp; isPalindrome[strIdx+<span class="number">1</span>][endIdx<span class="number">-1</span>]) &#123;</div><div class="line">                    isPalindrome[strIdx][endIdx] = <span class="literal">true</span>;</div><div class="line">                    <span class="keyword">if</span>(len &gt; longestLen) &#123;</div><div class="line">                        longestLen = len;</div><div class="line">                        longestStartIdx = strIdx;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> s.substr(longestStartIdx, longestLen);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>代码实现细节<ul>
<li><code>isPalindrome[i][j]</code>：字符子串 $s[i][j]$ 是否是回文子串？</li>
<li>动态规划过程：依次遍历长度为 $1, 2, …, len, …, n(本题: \leq 1000)$ 的所有子串，判断子串 $s[strIdx, strIdx+len-1], strIdx \in [0, n-len]$ 是否为回文子串<ul>
<li>动态规划初始化①：长度为 1 的子串均为回文子串，即 $\qquad isPalindrome[i][i]=true, i \in [0, n)$</li>
<li>动态规划初始化②：长度为 2 的子串，相邻两个字符相同的子串也为回文子串，即 $\begin{cases} if(s[i] == s[i+1]): \cr \quad isPalindrome[i][i+1]=true \cr else: \cr \quad isPalindrome[i][i+1]=false \end{cases} i \in [0, n-1)$</li>
<li>动态规划填表过程 $isPalindrome[i][j]$：$\begin{cases} for 　 len=3, …, n: \cr \quad for 　 i=0, 1, …, n-len: \cr \qquad j=i+len-1 \cr \qquad if(s[i] == s[j] \&amp;\&amp; isPalindrome[i+1][j-1]): \cr \qquad \quad isPalindrome[i][j]=true \cr \qquad else: \cr \qquad \quad isPalindrome[i][j]=false \end{cases}$</li>
</ul>
</li>
<li>在动态规划过程，通过变量 <code>longestLen</code>记录在动态规划过程中发现的最长回文子串长度及该子串在原始子串中的起始下标 <code>longestStartIdx</code>。</li>
</ul>
</li>
<li><font color="blue">提取最长回文子串</font><ul>
<li>最终得到最长回文子串：$\qquad s[longestStartIdx…longestStartIdx+longestLen-1] $</li>
</ul>
</li>
</ul>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><p>　对于任意字符子串，如果头尾字符相同：①由于子字符串必须是连续的，只有在该字符子串除去头尾字符后剩下的部分是回文的，该子字符串才是回文子串；②子序列，因为可以不连续，要求更宽松了，这种情况下，该子字符串存在一个长度至少为2的回文子序列，至于最长子序列，还要加上去掉首尾字符的字符串的最长子序列；<br>　如果首尾字符不同：①该子字符串一定不是回文子串；②对于最长回文子序列，为了尽可能增加长度（也许第二个字符正好与末尾字符相同/也许倒数第二个字符正好与首字符相同），最长回文子序列在去掉头的子字符串的最长回文子序列和去掉尾的子字符串的最长回文子序列中产生，为长度较大者。</p>
<ul>
<li><a href="https://leetcode.com/problems/longest-palindromic-subsequence/#/description">[516. Longest Palindromic Subsequence]</a> 解题思路<br>　基于上述思路，很容易想到如下的递归实现，不过由于递归中出现的多余计算、频繁的函数调用，在 leetcode 上提交会有：<strong>Time Limit Exceeded</strong> 超时错误。</li>
<li>  <figure class="highlight cpp"><figcaption><span>递归实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">lps</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> fromIdx, <span class="keyword">int</span> toIdx)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(fromIdx==toIdx) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(str[fromIdx] == str[toIdx]) &#123;</div><div class="line">        <span class="keyword">if</span>(toIdx-fromIdx==<span class="number">1</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> lps(str, fromIdx+<span class="number">1</span>, toIdx<span class="number">-1</span>) + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> max(lps(str, fromIdx+<span class="number">1</span>, toIdx), lps(str, fromIdx, toIdx<span class="number">-1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    <span class="keyword">return</span> lps(s, <span class="number">0</span>, n<span class="number">-1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　基于上述思路的动态规划实现，定义的子问题与最长回文子串有明显出入。<br>　①<strong>子问题</strong>：设字符串为 s，长度为 n，$dp[fromIdx][toIdx]$：子字符串 $s(fromIdx…toIdx)$ 中的最长回文子序列长度。<br>　②与最长回文子串类似，依次遍历长度为 $1, 2, …, len, …, n(本题: \leq 1000)$ 的所有子串，计算 $s(fromIdx…fromIdx+len-1)$ 中的最长回文子序列长度 $dp[fromIdx][fromIdx+len-1]$<br>　　<strong>状态初始条件</strong>（1）：长度为 1 的子串均为回文子序列，即 $\qquad \qquad dp[i][i]=1, i \in [0, n)$<br>　　<strong>状态初始条件</strong>（2）：长度为 2 的子串，相邻两个字符相同的子串也为回文子序列，即 $\begin{cases} if(s[i] == s[i+1]): \cr \quad dp[i][i+1]=2 \cr else: \cr \quad dp[i][i+1]=0 \end{cases} i \in [0, n-1)$<br>　　<font color="red">注：代码实现中将<strong>状态初始条件（2）</strong>这一过程附带在下一步<strong>填表过程</strong>中。</font><br>　　<strong>状态转移方程</strong>（填表过程）：$\qquad \qquad \begin{cases} for 　 len=3, …, n: \cr \quad for 　 i=0, 1, …, n-len: \cr \qquad j=i+len-1 \cr \qquad if(s[i] == s[j]): \cr \qquad \quad dp[i][j]=dp[i+1][j-1]+2 \cr \qquad else: \cr \qquad \quad dp[i][j]=max(dp[i+1][j], dp[i][j-1]) \end{cases}$</p>
<ul>
<li>  <figure class="highlight cpp"><figcaption><span>动态规划实现</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</div><div class="line">    <span class="comment">// dp[fromIdx][toIdx]: s(fromIdx,toIdx) is palindrome of length dp[fromIdx][toIdx]</span></div><div class="line">    <span class="keyword">int</span> dp[n][n];</div><div class="line">    </div><div class="line">    <span class="comment">// strings of length 1 are palindrome of length 1</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;n; idx++) &#123;</div><div class="line">        dp[idx][idx] = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++) &#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> fromIdx=<span class="number">0</span>; fromIdx&lt;=n-len; fromIdx++) &#123;</div><div class="line">            <span class="keyword">int</span> toIdx = fromIdx + len - <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(s[fromIdx] == s[toIdx]) &#123;</div><div class="line">                <span class="keyword">if</span>(len==<span class="number">2</span>) &#123;</div><div class="line">                    dp[fromIdx][toIdx] = <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// s(fromIdx+1,toIdx-1) have smaller length:len-2</span></div><div class="line">                    dp[fromIdx][toIdx]= dp[fromIdx+<span class="number">1</span>][toIdx<span class="number">-1</span>] + <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// s(fromIdx+1,toIdx) &amp; s(fromIdx,toIdx-1) have smaller length:len-1 </span></div><div class="line">                dp[fromIdx][toIdx] = max(dp[fromIdx+<span class="number">1</span>][toIdx], dp[fromIdx][toIdx<span class="number">-1</span>]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><font color="blue">提取最长回文子序列</font><ul>
<li>利用动态规划过程的中间结果 <code>dp[i][j]</code>，使用与 <strong>提取最长公共子序列</strong> 一样的方法，能够提取出最长回文子序列。</li>
<li>在序列 s 中分别从头下标 <code>fromIdx: 0</code> 和尾下标 <code>toIdx: n-1</code> 向中间挪动，找出  <code>dp[i][j]</code> 个字符，即为提取的最长回文子序列。</li>
<li>如何在序列中向中间挪动呢？<ul>
<li><code>s[fromIdx]==s[toIdx]</code>，当前字符在最长回文子序列中，头尾下标同时向中间挪：<code>fromIdx++</code> &amp; <code>toIdx--</code>。</li>
<li><code>s[fromIdx]!=s[toIdx]</code>，当前字符不相同<ul>
<li><code>dp[fromIdx][toIdx-1]</code> 大，说明 <code>s[fromIdx]</code> 可能是最长回文子序列的下一个字符，需要挪动尾下标：<code>toIdx--</code>；</li>
<li>反之<code>dp[fromIdx+1][toIdx]</code> 大，则需要挪动头下标：<code>fromIdx++</code>。</li>
</ul>
</li>
</ul>
</li>
<li>挪动的边界条件：<code>while(fromIdx≤toIdx)</code><ul>
<li>出现 <code>fromIdx==toIdx</code> 后退出循环：最长回文子序列长度为奇数（如：”bab”），选择夹在原序列中最后一个相同字符间的任一字符作为唯一一个不成对字符。</li>
<li>直接因为 <code>fromIdx&lt;toIdx)</code> 退出循环：最长回文子序列长度为偶数（如：”bb”），原序列中最后一个相同字符间不存在其它字符。</li>
</ul>
</li>
<li>具体的代码实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> LPS;</div><div class="line">fromIdx = <span class="number">0</span>;</div><div class="line">toIdx = n<span class="number">-1</span>;</div><div class="line"><span class="keyword">while</span>(fromIdx&lt;=toIdx) &#123;</div><div class="line">    <span class="keyword">if</span>(s[fromIdx] == s[toIdx]) &#123;</div><div class="line">        LPS += s[fromIdx];</div><div class="line">        fromIdx++;</div><div class="line">        toIdx--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(dp[fromIdx][toIdx<span class="number">-1</span>] &lt; dp[fromIdx+<span class="number">1</span>][toIdx]) &#123;</div><div class="line">            fromIdx++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            toIdx--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　所谓 &lt;strong&gt;回文（palindrome）&lt;/strong&gt;，指的是正读和反读都是一样的。而 &lt;strong&gt;字符子串&lt;/strong&gt; 和 &lt;strong&gt;字符子序列&lt;/strong&gt; 的区别，在前面 &lt;a href=&quot;http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/&quot;&gt;算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）&lt;/a&gt; 中也有提到过，字符字串指的是字符串中连续的n个字符，而字符子序列指的是字符串中不一定连续但先后顺序与原字符串一致的n个字符。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0011] Dynamic Programming(III)（Longest Common Subsequence）</title>
    <link href="http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/"/>
    <id>http://durant35.github.io/2017/05/03/Algorithms_LongestCommonSubsequence/</id>
    <published>2017-05-03T06:00:22.000Z</published>
    <updated>2017-07-06T08:45:26.627Z</updated>
    
    <content type="html"><![CDATA[<p>　　子序列和子字符串的不同之处在于，子序列不需要是原序列上连续的字符。对于 <a href="http://www.lintcode.com/en/problem/longest-common-substring/">Longest Common Substring</a> 以及 <a href="http://www.lintcode.com/en/problem/longest-common-subsequence/"> Longest Common Subsequence</a> 这类题目，大多数需要用到 DP 的思想，其中，状态转移是关键。<br><a id="more"></a></p>
<h4 id="最长公共子字符串"><a href="#最长公共子字符串" class="headerlink" title="最长公共子字符串"></a>最长公共子字符串</h4><blockquote>
<p>Given two strings, find the longest common substring.<br>Return the length of it.</p>
<ul>
<li><strong>Example</strong><br>　Given A = “ABCD”, B = “CBCE”, return 2.</li>
</ul>
</blockquote>
<ul>
<li>$L(idxA, idxB)$：以 $A[idxA]$ 和 $B[idxB]$ 结尾的相同子字符串的最长长度。最长公共子字符串必然存在所有情况中以 A 序列中某个字符结尾，以 B 序列中某个字符结尾的一种情况，所以<strong>取所有可能情况中的最大值</strong>即为 Longest Common Substring 的长度。<ul>
<li>因为要求子串连续，所以对于 $A_{idxA}$ 与 $B_{idxB}$ 来讲，它们要么与之前的公共子串构成新的公共子串；要么就是不构成公共子串。<br>$$ L(idxA, idxB) =  \begin{cases}<br>  if（idxA==0||idxB==0）: \begin{cases} 1, A[idxA]==B[idxB] \cr 0, others \end{cases} \cr<br>  else-if（A[idxA]==B[idxB]）: L(idxA-1, idxB-1) + 1 \cr<br>  else: 0<br>  \end{cases}<br>$$</li>
<li>上述过程的示例图如下，可以看出只有对角线方向上的长度延伸，长度不能保留。<br><center><img src="/img/Algorithms/0011_LCStringProcessDemo.jpg" width="480px"/></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>: </div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two string.</div><div class="line">     * @return: the length of the longest common substring.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubstring</span><span class="params">(<span class="built_in">string</span> &amp;A, <span class="built_in">string</span> &amp;B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the largest length of LCS ending with A[idxA] and B[idxB] </span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>; </div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                L[idxA][idxB] = A[idxA]==B[idxB]? L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>]+<span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> maxLenIdx = <span class="number">-1</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">0</span>; idxA&lt;lenA; idxA++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">0</span>; idxB&lt;lenB; idxB++)&#123;</div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                    maxLenIdx = idxA;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> maxLen;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="blue">提取最长公共子串</font><ul>
<li>使用变量 <code>maxLenIdx</code> 记录最长公共子串（长度 <code>maxLen</code> ）对应的结尾字符下标（序列 A/B 都可以），回退获取 <code>maxLen</code> 个字符即可。</li>
</ul>
</li>
</ul>
<h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><blockquote>
<p>Given two strings, find the longest common subsequence (<em>LCS</em>).<br>Your code should return the length of <em>LCS</em>.</p>
<ul>
<li><strong>Example</strong><br>　For “ABCD” and “EDCA”, the LCS is “A” (or “D”, “C”), return 1.<br>　For “ABCD” and “EACB”, the LCS is “AC”, return 2.</li>
</ul>
</blockquote>
<ul>
<li>$L(idxA, idxB)$：以 $A_{idxA}$ 结尾的子串（$A[0, 1, …, idxA], 0 \leq idxA \lt len_A$） 和 $B_{idxB}$ 结尾的子串（$B[0, 1, …, idxB], 0 \leq idxB \lt len_B$）最长公共子序列的长度。自然地，$L(len_A-1, len_B-1)$ 即为所求的最长公共子序列长度。</li>
<li>与子串不同，子序列可以是不连续的。<ul>
<li>$L(idxA, idxB)$ 与 $L(idxA-1, idxB-1)$ 两者其实只差 $A_{idxA}$ 和 $B_{idxB}$ 这一对字符。</li>
<li>如果 $A_{idxA}$ 和 $B_{idxB}$ 相同，那么就只要在以 $A_{idxA}$ 和以 $B_{idxB}$ 结尾的两个子串的最长公共子序列之后添上这个相同字符即可，这样就可以让长度增加一位。</li>
<li>如果 $A_{idxA}$ 和 $B_{idxB}$ 不同，两个子串在末尾添加一个字符后最长公共子序列并不能得到延伸。考虑到 $A_{idxA}$ 可能与 $B_{idxB-1}$ 相同或者 $B_{idxB}$ 会与 $A_{idxA-1}$ 相同，没能延伸的最长公共子序列只能在 $L(idxA, idxB-1)$ 和 $L(idxA-1, idxB)$ 存在，取更长的那个。</li>
<li>结合边界限制，最终得到的状态转移方程如下：<br>$$ L(idxA, idxB) =  \begin{cases}<br>  if（idxA==0）: \begin{cases} 1, B[idxB]==A[0] \cr L(0, idxB-1), others \end{cases} \cr<br>  else·if（idxB==0）: \begin{cases} 1, A[idxA]==B[0] \cr L(idxA-1, 0), others \end{cases} \cr<br>  else·if（A[idxA]==B[idxB]）: L(idxA-1, idxB-1) + 1 \cr<br>  else: max(L(idxA, idxB-1), L(idxA-1, idxB))<br>  \end{cases}<br>$$</li>
<li>上述过程的示例图如下，可以看出同样只有对角线方向上的长度延伸，不过长度可以在 <strong>上→下</strong> 和 <strong>左→右</strong> 方向上得到保留。<br><center><img src="/img/Algorithms/0011_LCSequenceProcessDemo.png" width="450px"/></center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a&gt;b?a:b)</span></div><div class="line"><span class="keyword">class</span> Solution &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</div><div class="line">     * @param A, B: Two strings.</div><div class="line">     * @return: The length of longest common subsequence of A and B.</div><div class="line">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> lenA = A.length();</div><div class="line">        <span class="keyword">int</span> lenB = B.length();</div><div class="line">        <span class="keyword">if</span>(lenA==<span class="number">0</span> || lenB==<span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// L[idxA][idxB]: the length of the LCS ending with A[idxA] and B[idxB]</span></div><div class="line">        <span class="keyword">int</span> L[lenA][lenB];</div><div class="line">        <span class="comment">// for recording LCS's tail element index</span></div><div class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>, maxLenIdxA = <span class="number">0</span>, maxLenIdxB = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        L[<span class="number">0</span>][<span class="number">0</span>] = A[<span class="number">0</span>]==B[<span class="number">0</span>]? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">            L[<span class="number">0</span>][idxB] = B[idxB]==A[<span class="number">0</span>]? <span class="number">1</span> : L[<span class="number">0</span>][idxB<span class="number">-1</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// for recording LCS's tail element index</span></div><div class="line">            <span class="keyword">if</span>(L[<span class="number">0</span>][idxB] &gt; maxLen) &#123;</div><div class="line">                maxLen = L[<span class="number">0</span>][idxB];</div><div class="line">                maxLenIdxB = idxB;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            L[idxA][<span class="number">0</span>] = A[idxA]==B[<span class="number">0</span>]? <span class="number">1</span> : L[idxA<span class="number">-1</span>][<span class="number">0</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// for recording LCS's tail element index</span></div><div class="line">            <span class="keyword">if</span>(L[idxA][<span class="number">0</span>] &gt; maxLen) &#123;</div><div class="line">                maxLen = L[idxA][<span class="number">0</span>];</div><div class="line">                maxLenIdxA = idxA;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idxA=<span class="number">1</span>; idxA&lt;lenA; idxA++) &#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> idxB=<span class="number">1</span>; idxB&lt;lenB; idxB++) &#123;</div><div class="line">                <span class="keyword">if</span>(A[idxA] == B[idxB]) &#123;</div><div class="line">                    L[idxA][idxB] = L[idxA<span class="number">-1</span>][idxB<span class="number">-1</span>] + <span class="number">1</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    L[idxA][idxB] = max(L[idxA][idxB<span class="number">-1</span>], L[idxA<span class="number">-1</span>][idxB]);</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// for recording LCS's tail element index</span></div><div class="line">                <span class="keyword">if</span>(L[idxA][idxB] &gt; maxLen) &#123;</div><div class="line">                    maxLen = L[idxA][idxB];</div><div class="line">                    maxLenIdxA = idxA;</div><div class="line">                    maxLenIdxB = idxB;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> L[lenA<span class="number">-1</span>][lenB<span class="number">-1</span>];</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><font color="blue">提取最长公共子序列</font><ul>
<li>使用变量 <code>maxLen</code> 记录最长公共子序列的长度，并通过变量 <code>maxLenIdxA</code> 和 <code>maxLenIdxB</code> 记录该最长长度序列末尾字符对应的序列 A 和序列 B 中的字符下标。</li>
<li>在序列 A 和 B 中分别从下标 <code>maxLenIdxA</code> 和 <code>maxLenIdxB</code> 向左挪动，找出  <code>maxLen</code> 个相同字符，即为提取的最长公共子序列。</li>
<li>如何在序列 A 和 B 中向左挪动呢？<ul>
<li><code>A[maxLenIdxA]==B[maxLenIdxB]</code>，当前字符相同，同时左挪（因为公共子序列的特点，此时二者肯定均为到达边界）：<code>maxLenIdxA--</code> &amp; <code>maxLenIdxB--</code>。</li>
<li><code>A[maxLenIdxA]!=B[maxLenIdxB]</code>，当前字符不相同<ul>
<li>有挪动到边界（0）的，只能挪动另一个还没到边界的；假如同时挪动到边界，由于  <code>maxLen</code> 的准确性，说明已经提取出最长公共子序列。</li>
<li><code>L[idxA][idxB-1]</code> 大，说明 <code>A[maxLenIdxA]</code> 可能与序列 B 中下一个字符相同，需要挪动序列 B：<code>maxLenIdxB--</code>；反之，则需要挪动序列 A：<code>maxLenIdxA--</code>。</li>
</ul>
</li>
</ul>
</li>
<li>具体的代码实现如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> LCS;</div><div class="line"><span class="keyword">while</span>(maxLenIdxA&gt;=<span class="number">0</span> &amp;&amp; maxLenIdxB&gt;=<span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span>(A[maxLenIdxA] == B[maxLenIdxB]) &#123;</div><div class="line">        LCS += A[maxLenIdxA];</div><div class="line">        maxLenIdxA--;</div><div class="line">        maxLenIdxB--;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span>(maxLenIdxA == <span class="number">0</span>) &#123;</div><div class="line">            maxLenIdxB--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(maxLenIdxB == <span class="number">0</span>) &#123;</div><div class="line">            maxLenIdxA--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(L[maxLenIdxA][maxLenIdxB<span class="number">-1</span>] &lt; L[maxLenIdxA<span class="number">-1</span>][maxLenIdxB]) &#123;</div><div class="line">                maxLenIdxB--;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                maxLenIdxA--;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　子序列和子字符串的不同之处在于，子序列不需要是原序列上连续的字符。对于 &lt;a href=&quot;http://www.lintcode.com/en/problem/longest-common-substring/&quot;&gt;Longest Common Substring&lt;/a&gt; 以及 &lt;a href=&quot;http://www.lintcode.com/en/problem/longest-common-subsequence/&quot;&gt; Longest Common Subsequence&lt;/a&gt; 这类题目，大多数需要用到 DP 的思想，其中，状态转移是关键。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="leetcode" scheme="http://durant35.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
