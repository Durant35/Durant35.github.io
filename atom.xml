<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tarantula-7&#39;s Blog</title>
  <subtitle>　　你永远流淌在我的记忆里？River flows in you</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://durant35.github.io/"/>
  <updated>2017-10-29T14:44:41.615Z</updated>
  <id>http://durant35.github.io/</id>
  
  <author>
    <name>Gary</name>
    <email>chenshj35@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟内存[02] Linux 中的各种栈：进程栈 线程栈 内核栈 中断栈</title>
    <link href="http://durant35.github.io/2017/10/29/VM_Stack/"/>
    <id>http://durant35.github.io/2017/10/29/VM_Stack/</id>
    <published>2017-10-29T14:01:00.000Z</published>
    <updated>2017-10-29T14:44:41.615Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="/img/kernel/mm/va_spacex86.png" width="810px" alt=""/><br/>图: 32 位系统下进程地址空间默认布局(左)和进程地址空间经典布局(右)</center><a id="more"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> mm_struct &#123;</div><div class="line">    <span class="keyword">struct</span> vm_area_struct *mmap;           <span class="comment">/* 内存区域链表 */</span></div><div class="line">    <span class="keyword">struct</span> rb_root mm_rb;                  <span class="comment">/* VMA 形成的红黑树 */</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">struct</span> list_head mmlist;               <span class="comment">/* 所有 mm_struct 形成的链表 */</span></div><div class="line">    ...</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> total_vm;                <span class="comment">/* 全部页面数目 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> locked_vm;               <span class="comment">/* 上锁的页面数据 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> pinned_vm;               <span class="comment">/* Refcount permanently increased */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> shared_vm;               <span class="comment">/* 共享页面数目 Shared pages (files) */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> exec_vm;                 <span class="comment">/* 可执行页面数目 VM_EXEC &amp; ~VM_WRITE */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_vm;                <span class="comment">/* 栈区页面数目 VM_GROWSUP/DOWN */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> def_flags;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_code, end_code, start_data, end_data;    <span class="comment">/* 代码段、数据段 起始地址和结束地址 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> start_brk, brk, start_stack;                   <span class="comment">/* 栈区 的起始地址，堆区 起始地址和结束地址 */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> arg_start, arg_end, env_start, env_end;        <span class="comment">/* 命令行参数 和 环境变量的 起始地址和结束地址 */</span></div><div class="line">    ...</div><div class="line">    <span class="comment">/* Architecture-specific MM context */</span></div><div class="line">    <span class="keyword">mm_context_t</span> context;                  <span class="comment">/* 体系结构特殊数据 */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Must use atomic bitops to access the bits */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;                   <span class="comment">/* 状态标志位 */</span></div><div class="line">    ...</div><div class="line">    <span class="comment">/* Coredumping and NUMA and HugePage 相关结构体 */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="进程栈"><a href="#进程栈" class="headerlink" title="进程栈"></a>进程栈</h3><p>进程虚拟地址空间中的栈区，正指的是我们所说的进程栈。进程栈的初始化大小是由编译器和链接器计算出来的，但是栈的实时大小并不是固定的，Linux 内核会根据入栈情况对栈区进行动态增长（其实也就是添加新的页表）。但是并不是说栈区可以无限增长，它也有最大限制 RLIMIT_STACK (一般为 8M)，我们可以通过 ulimit 来查看或更改 RLIMIT_STACK 的值</p>
<ul>
<li>进程栈的动态增长实现<ul>
<li>进程在运行的过程中，通过不断向栈区压入数据，当超出栈区容量时，就会耗尽栈所对应的内存区域，这将触发一个<strong>缺页异常 (page fault)</strong>。通过异常陷入内核态后，异常会被内核的 <code>expand_stack()</code> 函数处理，进而调用 <code>acct_stack_growth()</code> 来检查是否还有合适的地方用于栈的增长。</li>
<li>如果栈的大小低于 <strong>RLIMIT_STACK</strong>（通常为 8MB），那么一般情况下栈会被加长，程序继续执行，感觉不到发生了什么事情，这是一种将栈扩展到所需大小的常规机制。然而，如果达到了最大栈空间的大小，就会发生<strong>栈溢出（stack overflow）</strong>，进程将会收到内核发出的<strong>段错误（segmentation fault）</strong> 信号。</li>
<li><font color="blue">动态栈增长是唯一一种访问未映射内存区域而被允许的情形</font>，其他任何对未映射内存区域的访问都会触发页错误，从而导致段错误。一些被映射的区域是只读的，因此企图写这些区域也会导致段错误。</li>
</ul>
</li>
</ul>
<h3 id="线程栈"><a href="#线程栈" class="headerlink" title="线程栈"></a>线程栈</h3><ul>
<li>从 Linux 内核的角度来说，其实它并没有线程的概念，Linux 把所有线程都当做进程来实现，它将线程和进程不加区分的统一到了 <code>task_struct</code> 中。线程仅仅被视为一个与其他进程共享某些资源的进程，而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。线程创建的时候，加上了 <code>CLONE_VM</code> 标记，这样<strong>线程的内存描述符将直接指向父进程的内存描述符</strong>。</li>
<li>虽然线程的地址空间和进程一样，但是对待其地址空间的 stack 还是有些区别的。<ul>
<li>对于 Linux 进程或者说主线程，其 stack 是在 fork 的时候生成的，实际上就是复制了父亲的 stack 空间地址，然后写时拷贝 (cow) 以及动态增长；对于主线程生成的子线程而言，其 stack 将不再是这样的了，而是事先固定下来的，使用 <code>mmap()</code>系统调用，它不带有 <code>VM_STACK_FLAGS</code> 标记。<blockquote>
<p>由于线程的 <code>mm-&gt;start_stack</code>栈地址和所属进程相同，所以线程栈的起始地址并没有存放在 <code>task_struct</code> 中，应该是使用 <code>pthread_attr_t</code> 中的 <code>stackaddr</code> 来初始化 <code>task_struct-&gt;thread-&gt;sp</code>（sp 指向 <code>struct pt_regs</code> 对象，该结构体用于保存用户进程或者线程的寄存器现场）</p>
</blockquote>
</li>
<li>重要的是，<font color="blue">线程栈不能动态增长，一旦用尽就没了</font>，这是和生成进程的 fork 不同的地方。</li>
</ul>
</li>
<li>线程栈是从进程的地址空间中 <strong>mmap</strong> 出来的一块内存区域，原则上是线程私有的；但是同一个进程的所有线程在生成的时候会浅拷贝线程生成者 <code>task_struct</code> 的很多字段，其中包括所有的vma，因此如果愿意，其它线程也还是可以访问到的，于是一定要注意。</li>
<li>为什么需要单独的线程栈？不能共享同一个进程栈吗？<ul>
<li>Linux 调度程序中并没有区分线程和进程（线程是调度的基本单位），当调度程序需要唤醒“进程”的时候，必然需要恢复进程的上下文环境，也就是<strong>进程栈</strong>；线程和父进程完全共享一份地址空间，如果栈也用同一个那就会遇到以下问题：<ul>
<li>假如进程的栈指针初始值为 <code>0x7ffc80000000</code>；父进程 A 先执行，调用了一些函数后栈指针 esp 为 <code>0x7ffc8000FF00</code>，此时父进程主动休眠了；</li>
<li>接着调度器唤醒子线程 A1： 此时 A1 的栈指针 esp 如果为初始值 <code>0x7ffc80000000</code>，则线程 A1 一但出现函数调用，必然会破坏父进程 A 已入栈的数据。</li>
</ul>
</li>
<li>如果此时线程 A1 的栈指针和父进程最后更新的值一致，esp 为 <code>0x7ffc8000FF00</code>，那线程 A1 进行一些函数调用后，栈指针 esp 增加到 <code>0x7ffc8000FFFF</code>，然后线程 A1 休眠；调度器再次换成父进程 A 执行，那这个时候父进程的栈指针是应该为 <code>0x7ffc8000FF00</code> 还是 <code>0x7ffc8000FFFF</code> 呢？无论栈指针被设置到哪个值，都会有问题不是吗？</li>
</ul>
</li>
</ul>
<h3 id="进程内核栈"><a href="#进程内核栈" class="headerlink" title="进程内核栈"></a>进程内核栈</h3><ul>
<li>在每一个进程的生命周期中，必然会通过到系统调用陷入内核。在执行系统调用陷入内核之后，这些内核代码所使用的栈并不是原先进程用户空间中的栈，而是一个单独内核空间的栈，这个称作<strong>进程内核栈</strong>。<ul>
<li>进程内核栈在进程创建的时候，通过 <strong>slab 分配器</strong> 从 <code>thread_info_cache</code> 缓存池中分配出来，其大小为 <code>THREAD_SIZE</code>，一般来说是一个页大小 4K；</li>
</ul>
</li>
<li>内核经常要访问 <code>task_struct</code>，<font color="blue">高效获取当前进程的描述符</font>是一件非常重要的事情。</li>
<li>  <figure class="highlight cpp"><figcaption><span>current 宏的实现方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> current_stack_pointer <span class="title">asm</span> <span class="params">(<span class="string">"sp"</span>)</span></span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> thread_info *<span class="title">current_thread_info</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line"></span>&#123;</div><div class="line">        <span class="keyword">return</span> (<span class="keyword">struct</span> thread_info *)                        </div><div class="line">                (current_stack_pointer &amp; ~(THREAD_SIZE - <span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> get_current() (current_thread_info()-&gt;task)</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> current get_current()</span></div></pre></td></tr></table></figure>
<ul>
<li>内核可以先获取到栈顶指针 esp，然后通过 esp 来获取 <code>thread_info</code></li>
<li>成功获取到 <code>thread_info</code> 后，直接取出它的 task 成员就成功得到了<code>task_struct</code>。</li>
</ul>
</li>
<li>为什么需要单独的进程内核栈？<blockquote>
<p>所有进程运行的时候，都可能通过系统调用陷入内核态继续执行：假设第一个进程 A 陷入内核态执行的时候，需要等待读取网卡的数据，主动调用 <code>schedule()</code> 让出 CPU；此时调度器唤醒了另一个进程 B，碰巧进程 B 也需要系统调用进入内核态；那问题就来了，如果内核栈只有一个，那进程 B 进入内核态的时候产生的压栈操作，必然会破坏掉进程 A 已有的内核栈数据，一但进程 A 的内核栈数据被破坏，很可能导致进程 A 的内核态无法正确返回到对应的用户态了。</p>
</blockquote>
</li>
<li>进程和线程是否共享一个进程内核栈？<blockquote>
<p>线程和进程创建的时候都调用 <code>dup_task_struct</code> 来创建 task 相关结构体，而内核栈也是在此函数中 <code>alloc_thread_info_node</code>出来的，因此虽然线程和进程共享一个地址空间 <code>mm_struct</code>，但是并不共享一个内核栈（线程是 CPU 调度的基本单位）。</p>
</blockquote>
</li>
</ul>
<h3 id="中断栈"><a href="#中断栈" class="headerlink" title="中断栈"></a>中断栈</h3><ul>
<li>进程陷入内核态的时候，需要内核栈来支持内核函数调用；中断也是如此，当系统收到中断事件后，进行中断处理的时候，也需要中断栈来支持函数调用。由于系统中断的时候，系统当然是处于内核态的，所以中断栈是可以和内核栈共享的（但是具体是否共享，这和具体处理架构密切相关）。<ul>
<li>x86 上中断栈就是独立于内核栈的：独立的中断栈所在内存空间的分配发生在 <code>arch/x86/kernel/irq_32.c</code> 的<code>irq_ctx_init()</code> 函数中（如果是多处理器系统，那么每个处理器都会有一个独立的中断栈）<ul>
<li>函数使用 <code>__alloc_pages</code> 在低端内存区分配 2个物理页面，也就是 8KB 大小的空间。</li>
<li>这个函数还会为 softirq 分配一个同样大小的独立堆栈，如此说来，softirq 将不会在 hardirq 的中断栈上执行，而是在自己的上下文中执行。</li>
</ul>
</li>
<li>ARM 上中断栈和内核栈则是共享的；中断栈和内核栈共享有一个负面因素，如果中断发生嵌套，可能会造成栈溢出，从而可能会破坏到内核栈的一些重要数据，所以栈空间有时候难免会捉襟见肘。</li>
</ul>
</li>
<li>为什么需要单独中断栈？<blockquote>
<p>这个问题其实不对，ARM 架构就没有独立的中断栈。</p>
</blockquote>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="http://blog.csdn.net/freeelinux/article/details/53782986">《Linux虚拟地址空间布局以及进程栈和线程栈总结》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/kernel/mm/va_spacex86.png&quot; width=&quot;810px&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图: 32 位系统下进程地址空间默认布局(左)和进程地址空间经典布局(右)&lt;/center&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="Kernel" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/Kernel/"/>
    
    
      <category term="Linux" scheme="http://durant35.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存[01] 用户内存空间的各个段分布</title>
    <link href="http://durant35.github.io/2017/10/29/VM_UserSpaceSegments/"/>
    <id>http://durant35.github.io/2017/10/29/VM_UserSpaceSegments/</id>
    <published>2017-10-29T02:28:00.000Z</published>
    <updated>2017-10-29T13:21:39.571Z</updated>
    
    <content type="html"><![CDATA[<p><center><img src="/img/kernel/mm/va_spacex86.png" width="810px" alt=""/><br/>图: 32 位系统下进程地址空间默认布局(左)和进程地址空间经典布局(右)</center><a id="more"></a></p>
<ul>
<li>这些段只是简单的内存地址范围，与 Intel 处理器的段没有关系。</li>
<li>内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，并且在所有进程中都映射到同样的物理内存，只是不允许应用程序读写该区域的内容或直接调用内核代码定义的函数，因此内核代码和数据总是可寻址，随时准备处理中断和系统调用；与此相反，用户地址空间的映射随进程切换的发生而不断变化。</li>
<li><strong>Random stack offset</strong>、<strong>Random mmap offset</strong> 和 <strong>Random brk offset</strong> 随机值意在防止恶意程序。Linux 通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱布局，以免恶意程序通过计算访问栈、库函数等地址。</li>
<li>用户进程部分分段存储内容如下表所示(按地址递减顺序)：<br>  <center><img src="/img/kernel/mm/Userspace_segment.png" width="640px" alt=""/></center><ul>
<li>BSS 段、数据段和代码段是可执行程序编译时的分段，运行时还需要栈和堆。</li>
<li>在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和 BSS 段的加载，并在内存中为这些段分配空间。栈也由操作系统分配和管理；堆由程序员自己管理，即显式地申请和释放空间。<ul>
<li>首先<code>execve(2)</code>负责为进程代码段和数据段建立映射，真正将代码段和数据段的内容读入内存是由系统的缺页异常处理程序按需完成的。</li>
<li>另外，<code>execve(2)</code>还会将BSS段清零。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><hr/></p>
<h3 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h3><ul>
<li>栈又称堆栈，由<strong>编译器自动分配释放</strong>，行为类似数据结构中的栈（先进后出）。堆栈主要有三个用途：<ul>
<li>为函数内部声明的<strong>非静态局部变量</strong>（C语言中称“自动变量”）提供存储空间。</li>
<li>记录函数调用过程相关的维护性信息，称为<strong>栈帧(Stack Frame)</strong>或<strong>过程活动记录(Procedure Activation Record)</strong>。<ul>
<li>它包括函数返回地址，不适合装入寄存器的函数参数及一些寄存器值的保存。</li>
<li>除递归调用外，堆栈并非必需，因为编译时可获知局部变量，参数和返回地址所需空间，并将其分配于 BSS 段。</li>
</ul>
</li>
<li>临时存储区，用于暂存<strong>长算术表达式部分计算结果</strong>或<code>alloca()</code>函数分配的栈内内存。</li>
</ul>
</li>
<li>进程中的每个线程都有属于自己的栈。向栈中不断压入数据时，若超出其容量就会耗尽栈对应的内存区域，从而触发一个页错误。此时若栈的大小低于堆栈最大值<code>RLIMIT_STACK</code>(通常是 8M)，则栈会动态增长，程序继续运行。映射的栈区扩展到所需大小后，不再扩展。</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gary@xxx:~$ <span class="built_in">ulimit</span> <span class="_">-s</span></div><div class="line">8192</div></pre></td></tr></table></figure>
<ul>
<li>上述命令可查看和设置堆栈最大值，当程序使用的堆栈超过该值时，发生栈溢出(Stack Overflow)，程序收到一个段错误(Segmentation Fault)。</li>
<li>注意，调高堆栈容量可能会增加内存开销和启动时间。</li>
</ul>
</li>
<li>持续地重用栈空间有助于使活跃的栈内存保持在 CPU 缓存中，从而加速访问。</li>
<li>堆栈既可向下增长（向内存低地址）也可向上增长，这依赖于具体的实现；Linux 中堆栈是向下增长的。</li>
</ul>
<p><hr/></p>
<h3 id="内存映射段-mmap"><a href="#内存映射段-mmap" class="headerlink" title="内存映射段(mmap)"></a>内存映射段(mmap)</h3><ul>
<li>内核将硬盘文件的内容直接映射到内存，任何应用程序都可通过 Linux 的<code>mmap()</code>系统调用（或 Windows 的<code>CreateFileMapping()</code>/<code>MapViewOfFile()</code>）请求这种映射。<ul>
<li>内存映射是一种方便高效的<strong>文件 I/O 方式</strong>， 因而被用于装载动态共享库。<blockquote>
<p>　在 Linux 2.4 版本中（进程地址空间经典布局），若可执行文件依赖共享库，则系统会为这些动态库在从<code>0x40000000</code>开始的地址分配相应空间，并在程序装载时将其载入到该空间。<br>　在 Linux 2.6 内核中（进程地址空间默认布局），共享库的起始地址被往上移动至更靠近栈区的位置，即位于<code>0xBF??????</code>附近。</p>
</blockquote>
</li>
<li>用户也可创建匿名内存映射，该映射没有对应的文件，可用于存放程序数据。<blockquote>
<p>　在 Linux 中，若通过<code>malloc()</code>请求一大块内存，C运行库将创建一个匿名内存映射，而不使用堆内存。“大块”意味着比阈值<code>MMAP_THRESHOLD</code>还大，缺省为 <strong>128KB</strong>，可通过<code>mallopt()</code>调整。</p>
</blockquote>
</li>
</ul>
</li>
<li>mmap 映射区向下扩展，堆向上扩展，两者相对扩展，直到耗尽虚拟地址空间中的剩余区域。</li>
</ul>
<blockquote>
<p>【扩展】<strong>应用程序可申请的最大堆空间是多少？</strong></p>
<ul>
<li>从进程地址空间的布局可以看到，在有共享库的情况下，Linux kernel 2.6 版本之前的经典布局下留给堆的可用空间还有两处：一处是从 .bss 段到 <code>0x40000000</code>，约不到 1GB 的空间；另一处是从共享库到栈之间的空间，约不到 2GB。这两块空间大小取决于栈、共享库的大小和数量。</li>
<li>在新的布局里，共享库的装载地址已经被挪到靠近栈的位置，因此，此时的堆范围就不会被共享库分割成 2 个“碎片”，故 kernel 2.6 及以上的 32 位 Linux 系统中，<code>malloc()</code>申请的最大内存理论值在 2.9GB 左右。</li>
</ul>
</blockquote>
<p><hr/></p>
<h3 id="堆-heap"><a href="#堆-heap" class="headerlink" title="堆(heap)"></a>堆(heap)</h3><ul>
<li>堆用于存放进程运行时动态分配的内存段，可动态扩张或缩减。<ul>
<li>堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。当进程调用<code>malloc()</code>(C)/<code>new()</code>(C++)等函数分配内存时，新分配的内存动态添加到堆上(扩张)；当调用<code>free()</code>(C)/<code>delete()</code>(C++)等函数释放内存时，被释放的内存从堆中剔除(缩减) 。</li>
<li>分配的堆内存是经过字节对齐的空间，以适合原子操作。</li>
</ul>
</li>
<li><strong>堆管理器</strong>通过链表管理每个申请的内存，由于堆申请和释放是无序的，最终会产生内存碎片。<ul>
<li>堆的末端由<strong>break 指针</strong>标识，当堆管理器需要更多内存时，可通过系统调用<code>brk()</code>和<code>sbrk()</code>来移动<strong>break 指针</strong>以扩张堆，一般由系统自动调用。</li>
<li>堆内存一般由应用程序分配释放，回收的内存可供重新使用。若程序员不释放，程序结束时操作系统可能会自动回收。</li>
</ul>
</li>
<li>使用堆时经常出现两种问题<ul>
<li>“内存破坏”：释放或改写仍在使用的内存；</li>
<li>“内存泄漏”：未释放不再使用的内存。当释放次数少于申请次数时，可能已造成内存泄漏。<blockquote>
<p>泄漏的内存往往比忘记释放的数据结构更大，因为所分配的内存通常会圆整为下个大于申请数量的2的幂次（如申请$212B$，会圆整为$2^8=256B$）。</p>
</blockquote>
</li>
</ul>
</li>
<li>注意，堆不同于数据结构中的“堆”，其行为类似链表。<blockquote>
<p>【扩展】<strong>栈和堆的区别</strong><br>① <font color="blue">管理方式</font>：栈由编译器自动管理；堆由程序员控制，使用方便，但易产生“内存泄露”。<br>② <font color="blue">生长方向</font>：栈向低地址扩展（即“向下生长”），是连续的内存区域；堆向高地址扩展（即“向上生长”），可以是不连续的内存区域（这是由于系统用链表来存储空闲内存地址，自然不连续，而链表从低地址向高地址遍历）。<br>③ <font color="blue">空间大小</font>：栈顶地址和栈的最大容量由系统预先规定（通常默认 8M）；堆的大小则受限于计算机系统中有效的虚拟内存，32 位 Linux 系统中堆内存可达 2.9G空间。<br>④ <font color="blue">存储内容</font>：栈在函数调用时，首先压入<strong>主调函数中下条指令</strong>（函数调用语句的下条可执行语句）的地址，然后是<strong>函数实参</strong>，然后是<strong>被调函数的局部变量</strong>。本次调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的指令地址，程序由该点继续运行下条可执行语句；堆通常在头部用一个字节存放其大小，堆用于存储生存期与函数调用无关的数据，具体内容由程序员安排。<br>⑤ <font color="blue">分配方式</font>：栈可静态分配或动态分配。<strong>静态分配由编译器完成</strong>，如局部变量的分配。<strong>动态分配</strong>由<code>alloca()</code>函数在栈上申请空间，用完后自动释放。堆只能动态分配且手工释放。<br>⑥ <font color="blue">分配效率</font>：栈由计算机底层提供支持（分配专门的寄存器存放栈地址，压栈出栈由专门的指令执行），因此效率较高；堆由函数库提供，机制复杂，效率比栈低得多。<br>⑦ <font color="blue">分配后系统响应</font><br>　<strong>+</strong> 只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则报告异常提示<strong>栈溢出</strong>；<br>　<strong>+</strong> 操作系统为堆维护一个<strong>记录空闲内存地址的链表</strong>：当系统收到程序的内存分配申请时，会遍历该链表寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点空间分配给程序；若<strong>无足够大小的空间</strong>（可能由于内存碎片太多），有可能调用系统功能去增加程序数据段的内存空间，以便有机会分到足够大小的内存，然后进行返回；大多数系统会在该内存空间<strong>首地址处记录本次分配的内存大小</strong>，供后续的释放函数（如<code>free()</code>/<code>delete()</code>）正确释放本内存空间；此外，由于找到的堆结点大小不一定正好等于申请的大小，系统会自动将<strong>多余的部分</strong>重新放入空闲链表中。<br>⑧ <font color="blue">碎片问题</font><br>　<strong>+</strong> 栈不会存在碎片问题，因为栈是先进后出的队列，内存块弹出栈之前，在其上面的后进的栈内容已弹出<br>　<strong>+</strong> 频繁申请释放操作会造成堆内存空间的不连续，从而造成大量碎片，使程序效率降低。</p>
<p>　可见，<font color="green">堆容易造成内存碎片；由于没有专门的系统支持，效率很低；可能引发用户态和内核态切换，内存申请的代价更为昂贵</font>。所以<font color="green">栈在程序中应用最广泛，<strong>函数调用</strong>也利用栈来完成，调用过程中的参数、返回地址、栈基指针和局部变量等都采用栈的方式存放</font>。所以，建议<strong>尽量使用栈，仅在分配大量或大块内存空间时使用堆</strong>。<br>　<font color="red">使用栈和堆时应避免越界发生，否则可能程序崩溃或破坏程序堆、栈结构，产生意想不到的后果</font>。</p>
</blockquote>
</li>
</ul>
<p><hr/></p>
<h3 id="BSS-段"><a href="#BSS-段" class="headerlink" title="BSS 段"></a>BSS 段</h3><blockquote>
<p>【扩展】<strong>BSS历史</strong><br>　BSS(Block Started by Symbol，以符号开始的块) 一词最初是 UA-SAP 汇编器(United Aircraft Symbolic Assembly Program) 中的伪指令，用于为符号预留一块内存空间，该汇编器由美国联合航空公司于20世纪50年代中期为IBM 704大型机所开发；后来该词被作为关键字引入到了IBM 709和7090/94机型上的标准汇编器 FAP(Fortran Assembly Program)，用于定义符号并且为该符号预留指定字数的未初始化空间块。<br>　在采用段式内存管理的架构中(如 Intel 80x86 系统)，<font color="green">BSS 段通常指用来存放程序中未初始化全局变量的一块内存区域，该段变量只有名称和大小却没有值；程序开始时由系统初始化清零</font>。</p>
</blockquote>
<ul>
<li>BSS(Block Started by Symbol) 段中通常存放程序中以下符号：<ul>
<li>未初始化的全局变量和静态局部变量</li>
<li>初始值为 0 的全局变量和静态局部变量（依赖于编译器实现）</li>
<li>未定义且初值不为 0 的符号（该初值即 common block 的大小）</li>
</ul>
</li>
<li>BSS 段用来存放程序中未初始化的静态分配变量（全局变量），该段内容<strong>只记录数据所需空间大小，并不分配真实空间</strong>（仅维护开始和结束地址，以便内存能在运行时被有效地清零）；BSS 段在目标文件中也不占据空间，这样可减少目标文件体积，<font color="green">BSS 段在应用程序的二进制映象文件中并不存在</font>；但程序运行时需为变量分配内存空间，故目标文件必须记录所有未初始化的静态分配变量大小总和（通过<code>start_bss</code>和<code>end_bss</code>地址写入机器代码）。</li>
<li>当<strong>加载器(loader)</strong> 加载程序时，BSS 会被操作系统清零，所以未赋初值或初值为 0 的<strong>全局变量</strong>都在 BSS 中。<ul>
<li>C语言中，未显式初始化的静态分配变量被初始化为 0（算术类型）或空指针（指针类型）。</li>
<li>在嵌入式软件中，进入<code>main()</code>函数之前，BSS 段被<strong>C运行时系统</strong>映射到初始化为全零的内存（效率较高）。</li>
</ul>
</li>
<li><font color="green">定义全局变量需要注意的细节</font><ul>
<li>尽管均放置于 BSS 段，但<strong>初值为 0 的全局变量</strong>是强符号，而<strong>未初始化的全局变量</strong>是弱符号。若其他地方已定义同名的强符号（初值可能非 0），则弱符号与之链接时不会引起重定义错误，但运行时的初值可能并非期望值（会被强符号覆盖）。</li>
<li>因此，<font color="red">定义全局变量时，若只有本文件使用，则尽量使用 <strong>static</strong> 关键字修饰；否则需要为全局变量定义赋初值（哪怕 0 值），保证该变量为强符号，以便链接时发现变量名冲突，而不是被未知值覆盖</font>。</li>
</ul>
</li>
</ul>
<p><hr/></p>
<h3 id="数据段-data"><a href="#数据段-data" class="headerlink" title="数据段(data)"></a>数据段(data)</h3><ul>
<li>数据段通常用于存放程序中<strong>已初始化且初值不为 0 的全局变量和静态局部变量</strong>。数据段属于静态内存分配(静态存储区)，可读可写。</li>
<li>数据段保存在目标文件中（在嵌入式系统里一般固化在镜像文件中），其内容由程序初始化（例如，对于全局变量int gVar = 10，必须在目标文件数据段中保存10 这个数据，然后在程序加载时复制到相应的内存）。</li>
<li>运行时“数据段”和“BSS 段”的整个区段通常称为<strong>数据区</strong>；某些资料中“数据段”指代“数据段 + BSS段 + 堆”。</li>
<li><strong>数据段与 BSS 段的区别</strong><ul>
<li><font color="green">BSS 段</font>不占用物理文件尺寸，但占用内存空间；<font color="green">数据段</font>占用物理文件，也占用内存空间。<blockquote>
<p> 大型数组：<font color="blue">int ar0[10000] = {1, 2, 3, …}</font> 和 <font color="blue">int ar1[10000]</font><br>　<strong>+</strong> <font color="blue">ar1</font> 放在 BSS 段，只记录共有 10000*4 个字节需要初始化为 0；<br>　<strong>+</strong> <font color="blue">ar0</font> 记录每个数据1、2、3…，此时 BSS 为目标文件所节省的磁盘空间相当可观。</p>
</blockquote>
</li>
<li>当<font color="green">程序读取数据段的数据</font>时，系统会触发<strong>缺页异常</strong>，从而分配相应的物理内存；当<font color="green">程序读取 BSS 段的数据</font>时，内核会将其转到一个全零页面，不会发生缺页异常，也不会为其分配相应的物理内存。</li>
</ul>
</li>
</ul>
<p><hr/></p>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(text)"></a>代码段(text)</h3><ul>
<li>代码段也称“正文段”或“文本段”，通常用于存放程序执行代码（即 CPU 执行的机器指令）。<ul>
<li>一般C语言执行语句都编译成<strong>机器代码</strong>保存在代码段；</li>
<li>通常代码段是<strong>可共享</strong>的，因此频繁执行的程序只需要在内存中拥有一份拷贝即可；</li>
<li>代码段通常属于<strong>只读</strong>，以防止其他程序意外地修改其指令，对该段的写操作将导致段错误（某些架构也允许代码段为可写，即允许修改程序）。</li>
</ul>
</li>
<li>代码段指令根据程序设计流程依次执行，对于<strong>顺序指令</strong>，只会执行一次（每个进程）；若有反复，则需使用<strong>跳转指令</strong>；若进行<strong>递归</strong>，则需要借助栈来实现。</li>
<li>代码段指令中包括<strong>操作码</strong>和<strong>操作对象</strong>（或<strong>对象地址引用</strong>）<ul>
<li>若操作对象是<strong>立即数</strong>（具体数值），将直接包含在代码中；</li>
<li>若是<strong>局部数据</strong>，将在栈区分配空间，然后引用该数据地址；</li>
<li>若位于 <strong>BSS 段和数据段</strong>，同样引用该数据地址。</li>
</ul>
</li>
<li>代码段最容易受优化措施影响。</li>
</ul>
<p><hr/></p>
<h3 id="保留区"><a href="#保留区" class="headerlink" title="保留区"></a>保留区</h3><ul>
<li>保留区位于虚拟地址空间的最低部分，<strong>未赋予物理地址</strong>，任何对它的引用都是非法的，<font color="green">用于捕捉使用<strong>空指针</strong>和小整型值指针引用内存的异常情况</font>。</li>
<li>保留区并不是一个单一的内存区域，而是<strong>对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称</strong>。大多数操作系统中，极小的地址通常都是不允许访问的，如<code>NULL</code>。<ul>
<li>C语言将无效指针赋值为 0 也是出于这种考虑，因为 <strong>0 地址</strong>上正常情况下不会存放有效的可访问数据。</li>
<li>在32 位 x86 架构的 Linux 系统中，用户进程可执行程序一般从虚拟地址空间<code>0x08048000</code>开始加载（该加载地址由ELF文件头决定，可通过自定义链接器脚本覆盖链接器默认配置，进而修改加载地址）；<code>0x08048000</code>以下的地址空间通常由 C 动态链接库、<strong>动态加载器 ld.so</strong>和内核VDSO（内核提供的虚拟共享库）等占用。</li>
<li>通过使用<code>mmap()</code>系统调用，可访问<code>0x08048000</code>以下的地址空间。</li>
</ul>
</li>
</ul>
<p><hr/></p>
<h3 id="分段的好处"><a href="#分段的好处" class="headerlink" title="分段的好处"></a>分段的好处</h3><ul>
<li>进程运行过程中，代码指令根据流程依次执行，只需访问一次（当然跳转和递归可能使代码执行多次）；而数据（数据段和 BSS 段）通常需要访问多次，因此<strong>单独开辟空间以方便访问和节约空间</strong>：<ul>
<li>现代 CPU 具有极为强大的<strong>缓存(Cache) 体系</strong>，程序必须尽量提高缓存命中率：<strong>指令区</strong>（text 段）和<strong>数据区</strong>（data 段和 BSS 段）的分离有利于提高程序的局部性；现代 CPU 一般<strong>数据缓存</strong>和<strong>指令缓存</strong>分离，故程序的指令和数据分开存放有利于提高 CPU 缓存命中率。</li>
<li>当系统中<strong>运行多个该程序的副本时，其指令相同，故内存中只须保存一份该程序的指令部分</strong>：若系统中运行数百进程，通过共享指令将节省大量空间（尤其对于有动态链接的系统）；其他只读数据如程序里的图标、图片、文本等资源也可共享；而每个副本进程的其它数据区域不同，它们是进程私有的。</li>
<li><strong>临时数据</strong>及需要再次使用的代码在运行时放入栈区中，生命周期短；<strong>全局数据和静态数据</strong>可能在整个程序执行过程中都需要访问，因此单独存储管理；<strong>堆区</strong>由用户自由分配，以便管理。</li>
</ul>
</li>
<li>当程序被装载后，数据和指令分别映射到两个虚存区域：<strong>数据区</strong>对于进程而言可读写，而<strong>指令区</strong>对于进程只读，两区的权限可分别设置为可读写和只读，以<strong>防止程序指令被有意或无意地改写</strong>。</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="http://www.cnblogs.com/clover-toeic/p/3754433.html">《Linux虚拟地址空间布局》</a><br><a href="http://blog.csdn.net/freeelinux/article/details/53782986">《Linux虚拟地址空间布局以及进程栈和线程栈总结》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;center&gt;&lt;img src=&quot;/img/kernel/mm/va_spacex86.png&quot; width=&quot;810px&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图: 32 位系统下进程地址空间默认布局(左)和进程地址空间经典布局(右)&lt;/center&gt;
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="Kernel" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/Kernel/"/>
    
    
      <category term="Linux" scheme="http://durant35.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式系统导论[03] Model of Computation</title>
    <link href="http://durant35.github.io/2017/10/24/TACouses_ES2017_MoCs/"/>
    <id>http://durant35.github.io/2017/10/24/TACouses_ES2017_MoCs/</id>
    <published>2017-10-24T04:50:14.000Z</published>
    <updated>2017-10-29T03:24:11.797Z</updated>
    
    <content type="html"><![CDATA[<p>　承接前期<a href="http://durant35.github.io/2016/10/01/TACouses_Embedded_System_2016/">DOL Functional Simulation 和 MPARM Simulation</a>的实验内容，结合在<strong>SystemC 系统设计</strong>中提到的<a href="http://durant35.github.io/2017/09/26/TACouses_ES2017_SystemC/">Y-chart</a>，本文将讨论在 Behavior 层面的系统建模：<strong>MoCs (Model of Computation)</strong>，希望对 DOL 的建模原理有一定认识：</p>
<blockquote>
<p>　To model streaming applications, the <strong>dataflow process network</strong> model of computation [Lee and Parks 1995], a subclass of <strong>Kahn process networks</strong> [Kahn 1974], has been adopted in the DOL design flow. </p>
</blockquote>
<p>　什么是<strong>dataflow process network</strong>？<strong>Kahn process networks</strong>又是什么？接下来我们将一一论述。<a id="more"></a>
　</p>
<h3 id="Model-of-System（系统建模）"><a href="#Model-of-System（系统建模）" class="headerlink" title="Model of System（系统建模）"></a>Model of System（系统建模）</h3><ul>
<li>传统模型不能满足后续的 Requirements<ul>
<li>Von Neumann Model</li>
<li>Thread-based Concurrency Models</li>
</ul>
</li>
<li>Requirements for Model for Embedded Systems<ul>
<li><strong>Modularity</strong>: Systems specified as a composition of objects</li>
<li><strong>Represent hierarchy</strong>: Humans not capable to understand systems containing more than a few objects<ul>
<li>Behavioral hierarchy: like statements-&gt;procedures-&gt;programs</li>
<li>Structural hierarchy: like transistors-&gt;gates-&gt;processors-&gt;printed circuit</li>
</ul>
</li>
<li><strong>Concurrency</strong>, <strong>synchronization</strong> and <strong>communication</strong></li>
<li>Represent <strong>timing</strong> behavior/requirements<ul>
<li>Timing is essential for embedded systems!</li>
<li>Four types of timing specs required [Burns, 1990]<center><img src="/img/TA-Cources/ES2017/4typesTiming.png" width="640px" alt=""/></center></li>
</ul>
</li>
<li>Represent <strong>state-oriented behavior</strong>: Required for reactive systems</li>
<li>Represent <strong>dataflow-oriented behavior</strong>: Components send streams of data to each other</li>
</ul>
</li>
<li>Model of Computation（满足 Requirements 的一些系统建模方法）<ul>
<li>StateCharts</li>
<li>Data-Flow Models<ul>
<li>Kahn Process Network</li>
<li>Synchronous Dataflow</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="State-Charts"><a href="#State-Charts" class="headerlink" title="State Charts"></a>State Charts</h3><ul>
<li>FSM <strong>→</strong> State Charts<br>  <center><img src="/img/TA-Cources/ES2017/StateCharts_FSM2StateCharts.png" width="640px" alt=""/></center><ul>
<li>Introducing Hierarchy</li>
<li>Types of States<ul>
<li>Current states of FSMs are also called <strong>active states</strong></li>
<li>States which are not composed of other states are called <strong>basic states</strong></li>
<li>States containing other states are called <strong>super-states</strong></li>
<li>For each basic state <em>s</em>, the super-states containing <em>s</em> are called <strong>ancestor states</strong></li>
<li>Super-states <code>S</code> are called <strong>OR-super-states</strong>, if exactly one of the sub-states of <code>S</code> is active whenever <code>S</code> is active.</li>
</ul>
</li>
<li>Default State Mechanism</li>
</ul>
</li>
<li>Concurrency<ul>
<li><strong>AND-super-states</strong>: FSM is in all (immediate) sub-states of a super-state<center><img src="/img/TA-Cources/ES2017/StateCharts_Concurrency.png" width="640px" alt=""/></center></li>
</ul>
</li>
<li>Tree Representation of State Sets<br>  <center><img src="/img/TA-Cources/ES2017/StateCharts_TreeRepresentation.png" width="540px" alt=""/></center><ul>
<li>Computation of State Sets（状态空间）：State Charts $\Longrightarrow$ FSM<ul>
<li><strong>basic states</strong>: state set = state</li>
<li><strong>OR-super-states</strong>: state set = union of children</li>
<li><strong>AND-super-states</strong>: state set = Cartesian product of children<blockquote>
<p>两个集合 $X$ 和 $Y$ 的<strong>笛卡尔积（Cartesian product）</strong>，是所有可能的有序对组成的集合：<br>$$X × Y = \verb|{| (x, y) \space | \space x \in X \wedge y \in Y \verb|}|$$</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>Representation of Computations<br>  <center><img src="/img/TA-Cources/ES2017/StateCharts_EdgeLabel.png" width="480px" alt=""/></center><ul>
<li><strong>Events</strong><ul>
<li>有效性：only until the next evaluation of the model</li>
<li>Can be either internally or externally generated</li>
<li>“event” can be composed of several events:  <strong>e1 and e2</strong>; <strong>e1 or e2</strong>; <strong>not e</strong></li>
</ul>
</li>
<li><strong>Conditions</strong>: refer to values of variables/states that keep their value until they are reassigned</li>
<li><strong>Actions</strong><ul>
<li>Can either be assignments for variables or creation of events</li>
<li>“action” can also be composed: <strong>(a1; a2)</strong>, actions <em>a1</em> and <em>a2</em> are executed in parallel.</li>
</ul>
</li>
<li>All events, states and actions are globally visible</li>
</ul>
</li>
</ul>
<h3 id="Data-Flow-Models"><a href="#Data-Flow-Models" class="headerlink" title="Data-Flow Models"></a>Data-Flow Models</h3><ul>
<li>All processes run “simultaneously”</li>
<li>Processes can be described with imperative code (Host Language, e.g. <em>C/C++/Java/…</em>)</li>
<li><strong>Processes can only communicate through buffers</strong>, network description with Coordination Language, e.g. <em>XML</em><center><img src="/img/TA-Cources/ES2017/DataFlow_Model.png" width="340px" alt=""/></center></li>
<li>Sequence of read tokens is identical to the sequence of written tokens</li>
<li>Appropriate for applications that deal with <strong>streams of data</strong><ul>
<li>Fundamentally concurrent: maps easily to parallel hardware</li>
<li>Perfect fit for block-diagram specifications (control systems, signal processing)<center><img src="/img/TA-Cources/ES2017/DataFlow_MPEG2.png" width="540px" alt=""/><br/>Example: MPEG-2 Video Decoder</center></li>
<li>Matches well current and future trend towards multimedia applications</li>
</ul>
</li>
<li>下面详细介绍两种 Data-Flow Models：<strong>KPN</strong> 以及它的一种变种 <strong>SDF</strong>。</li>
</ul>
<h4 id="Kahn-Process-Network-KPN"><a href="#Kahn-Process-Network-KPN" class="headerlink" title="Kahn Process Network (KPN)"></a>Kahn Process Network (KPN)</h4><ul>
<li>Proposed by Kahn in 1974 as a general-purpose scheme for <strong>parallel programming</strong><ul>
<li>FIFO buffers（管道无穷大）: infinite size</li>
<li>Blocking-read（阻塞读）: destructive and blocking (reading an empty channel blocks until data is available)</li>
<li>Non-blocking-write（非阻塞写）</li>
<li>Unique attribute: determinate（确定性）</li>
</ul>
</li>
<li>KPN 的 Determinacy（确定性）问题<ul>
<li>Random vs Determinate: A system is <strong>random</strong> if the information known about the system and its inputs is not sufficient to determine its outputs</li>
<li>Define the <strong>history of a channel</strong> to be the sequence of tokens that have been both written and read. A process network is said to be determinate if <strong>the histories of all channels (output channels) depend only on the histories of the input channels</strong>.</li>
<li>Importance<ul>
<li><strong>Functional behavior</strong>（MoCs 是行为级层面的系统建模） is <strong>independent of timing</strong> (scheduling, communication time, execution time of processes)</li>
<li>Separation of functional properties and timing</li>
</ul>
</li>
<li>Proof of Determinism<ul>
<li>monotonic（单调性）$\Longrightarrow$ determinate（确定性的严格证明）<ul>
<li>网络中的每个进程都是单调的，则整个网络也是单调的：A network of monotonic processes itself defines a monotonic process.</li>
<li>一个单调的网络自然满足确定性：A monotonic process is clearly determinate<br><center><img src="/img/TA-Cources/ES2017/DataFlow_Monotonic.png" width="640px" alt=""/></center><blockquote>
<p>如何证明进程的单调性？<br>　① Formal definition</p>
<ul>
<li>input/output sequence (stream): $X = [x_1, x_2, x_3, …]$ （单个 channel）</li>
<li>p-tuple of sequences: $\mathbf{X} = [X^1, X^2, X^3, …] \in S$（多个 channel）</li>
<li><strong>prefix ordering</strong>: $[x_1] \subseteq [x_1, x_2] \subseteq [x_1, x_2, x_3]$</li>
<li><strong>process</strong>: $F = S_{in} \to S_{out}$，输入 $\mathbf{X} \in S_{in}$， 输出 $F(\mathbf{X}) \in S_{out}$</li>
</ul>
<p>　② $\mathbf{X} \subseteq \mathbf{X’}  \Rightarrow F(\mathbf{X}) \subseteq F(\mathbf{X’})$ $\Longrightarrow$ monotonic process</p>
<ul>
<li><strong>ordered set of sequences</strong> $\mathbf{X} \subseteq \mathbf{X’}$</li>
<li>输入 sequences 互为 <strong>ordered set</strong>，输出 sequences 也互为 <strong>ordered set</strong>，那么进程是单调的<br>　③ 如何证明：sequences 互为 <strong>ordered set</strong></li>
<li>证明：$ \forall X^i \subseteq X’^i \Rightarrow \mathbf{X} \subseteq \mathbf{X’}$</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>反证法简单证明 $\Longrightarrow$ non-monotonic behavior（output 不仅取决于 input，还跟时间相关）$\Longrightarrow$ non-determinate</li>
</ul>
</li>
</ul>
</li>
<li>实例 (A Kahn Process Network): prints an alternating sequence of 0’s and 1’s<br><center><img src="/img/TA-Cources/ES2017/DataFlow_KPN.png" width="640px" alt=""/></center><ul>
<li>Process <code>h</code> sends initial value, then passes through values</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">process <span class="title">h</span><span class="params">(in <span class="keyword">int</span> u, out <span class="keyword">int</span> v, <span class="keyword">int</span> init)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i = init;</div><div class="line">  send(i, v);</div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    i = wait(u);</div><div class="line">    send(i, v);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Process <code>f</code>alternately reads from u and v, prints the data value, and writes it to w</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">process <span class="title">f</span><span class="params">(in <span class="keyword">int</span> u, in <span class="keyword">int</span> v, out <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">bool</span> b = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    i = b ? wait(u) : wait(v);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%i\n"</span>, i);</div><div class="line">    send(i, w);</div><div class="line">    b = !b;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Process <code>g</code> reads from u and alternately copies it to v and w</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function">process <span class="title">g</span><span class="params">(in <span class="keyword">int</span> u, out <span class="keyword">int</span> v, out <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">bool</span> b = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    i = wait(u);</div><div class="line">    <span class="keyword">if</span>(b) &#123;</div><div class="line">      send(i, v);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      send(i, w);</div><div class="line">    &#125;</div><div class="line">    b = !b;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>整个 KPN 网络的单线程 <em>Java</em> 实现</li>
</ul>
</li>
<li>  <figure class="highlight java"><figcaption><span>KPN.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KPN</span> </span>&#123;</div><div class="line">  Queue&lt;Integer&gt; chan1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  Queue&lt;Integer&gt; chan2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  Queue&lt;Integer&gt; chan3 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  Queue&lt;Integer&gt; chan4 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  Queue&lt;Integer&gt; chan5 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">h1</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> init=<span class="number">1</span>;</div><div class="line">    h1()&#123;</div><div class="line">      chan1.add(init);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(chan4.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> tmp = chan4.remove();</div><div class="line">        chan1.add(tmp);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">h0</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> init=<span class="number">0</span>;</div><div class="line">    h0()&#123;</div><div class="line">      chan2.add(init);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(chan5.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> tmp = chan5.remove();</div><div class="line">        chan2.add(tmp);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">g</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> write_up = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(chan3.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> tmp = chan3.remove();</div><div class="line">        System.out.println(<span class="string">"Output is: "</span>+tmp+<span class="string">" at "</span>+counter++);</div><div class="line">        <span class="keyword">if</span>(write_up)&#123;</div><div class="line">          chan4.add(tmp);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">          chan5.add(tmp);</div><div class="line">        &#125;</div><div class="line">        write_up = !write_up;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">f</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> read_up = <span class="keyword">true</span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">      <span class="keyword">if</span>(read_up)&#123;</div><div class="line">        <span class="keyword">if</span>(chan1.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">int</span> tmp = chan1.remove();</div><div class="line">          chan3.add(tmp);</div><div class="line">          read_up = !read_up;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">if</span>(chan2.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">          <span class="keyword">int</span> tmp = chan2.remove();</div><div class="line">          chan3.add(tmp);</div><div class="line">          read_up = !read_up;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  h1 h1_;</div><div class="line">  h0 h0_;</div><div class="line">  f f_;</div><div class="line">  g g_;</div><div class="line">  </div><div class="line">  KPN()&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="comment">// Test 1:</span></div><div class="line">    <span class="comment">/* initialize the channel and processes. */</span></div><div class="line">    chan1.clear();</div><div class="line">    chan2.clear();</div><div class="line">    chan3.clear();</div><div class="line">    chan4.clear();</div><div class="line">    chan5.clear();</div><div class="line">    h1_ = <span class="keyword">new</span> h1();</div><div class="line">    h0_ = <span class="keyword">new</span> h0();</div><div class="line">    f_ = <span class="keyword">new</span> f();</div><div class="line">    g_ = <span class="keyword">new</span> g();</div><div class="line">    System.out.println(<span class="string">"Order 1:   h1, h0, f, g"</span>);</div><div class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; ++i)&#123;</div><div class="line">      h1_.run();</div><div class="line">      h0_.run();</div><div class="line">      f_.run();</div><div class="line">      g_.run();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Test 2:</span></div><div class="line">    <span class="comment">/* initialize the channel and processes. */</span></div><div class="line">    chan1.clear();</div><div class="line">    chan2.clear();</div><div class="line">    chan3.clear();</div><div class="line">    chan4.clear();</div><div class="line">    chan5.clear();</div><div class="line">    h1_ = <span class="keyword">new</span> h1();</div><div class="line">    h0_ = <span class="keyword">new</span> h0();</div><div class="line">    f_ = <span class="keyword">new</span> f();</div><div class="line">    g_ = <span class="keyword">new</span> g();</div><div class="line">    System.out.println(<span class="string">"Order 2:   h1, h1, h1, g, f, h0, h0"</span>);</div><div class="line">    <span class="keyword">for</span>(; i&lt;<span class="number">200</span>; ++i)&#123;</div><div class="line">      h1_.run();</div><div class="line">      h1_.run();</div><div class="line">      h1_.run();</div><div class="line">      g_.run();</div><div class="line">      f_.run();</div><div class="line">      h0_.run();</div><div class="line">      h0_.run();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Test 3:</span></div><div class="line">    <span class="comment">/* initialize the channel and processes. */</span></div><div class="line">    chan1.clear();</div><div class="line">    chan2.clear();</div><div class="line">    chan3.clear();</div><div class="line">    chan4.clear();</div><div class="line">    chan5.clear();</div><div class="line">    h1_ = <span class="keyword">new</span> h1();</div><div class="line">    h0_ = <span class="keyword">new</span> h0();</div><div class="line">    f_ = <span class="keyword">new</span> f();</div><div class="line">    g_ = <span class="keyword">new</span> g();</div><div class="line">    System.out.println(<span class="string">"Order 3:  f, f, g, h1, h0, h1, h0, h0, g"</span>);</div><div class="line">    <span class="keyword">for</span>(; i&lt;<span class="number">300</span>; ++i)&#123;</div><div class="line">      f_.run();</div><div class="line">      f_.run();</div><div class="line">      g_.run();</div><div class="line">      h1_.run();</div><div class="line">      h0_.run();</div><div class="line">      h1_.run();</div><div class="line">      h0_.run();</div><div class="line">      h0_.run();</div><div class="line">      g_.run();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Test 4:</span></div><div class="line">    <span class="comment">/* initialize the channel and processes. */</span></div><div class="line">    chan1.clear();</div><div class="line">    chan2.clear();</div><div class="line">    chan3.clear();</div><div class="line">    chan4.clear();</div><div class="line">    chan5.clear();</div><div class="line">    h1_ = <span class="keyword">new</span> h1();</div><div class="line">    h0_ = <span class="keyword">new</span> h0();</div><div class="line">    f_ = <span class="keyword">new</span> f();</div><div class="line">    g_ = <span class="keyword">new</span> g();</div><div class="line">    System.out.println(<span class="string">"Order 4:   g, h0, h1, f"</span>);</div><div class="line">    <span class="keyword">for</span>(; i&lt;<span class="number">400</span>; ++i)&#123;</div><div class="line">      g_.run();</div><div class="line">      h0_.run();</div><div class="line">      h1_.run();</div><div class="line">      f_.run();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Test 5:</span></div><div class="line">    <span class="comment">/* initialize the channel and processes. */</span></div><div class="line">    chan1.clear();</div><div class="line">    chan2.clear();</div><div class="line">    chan3.clear();</div><div class="line">    chan4.clear();</div><div class="line">    chan5.clear();</div><div class="line">    h1_ = <span class="keyword">new</span> h1();</div><div class="line">    h0_ = <span class="keyword">new</span> h0();</div><div class="line">    f_ = <span class="keyword">new</span> f();</div><div class="line">    g_ = <span class="keyword">new</span> g();</div><div class="line">    System.out.println(<span class="string">"Order 5: g, g, g, h0, h1, f"</span>);</div><div class="line">    <span class="keyword">for</span>(; i&lt;<span class="number">500</span>; ++i)&#123;</div><div class="line">      g_.run();</div><div class="line">      g_.run();</div><div class="line">      g_.run();</div><div class="line">      h0_.run();</div><div class="line">      h1_.run();</div><div class="line">      f_.run();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    <span class="keyword">new</span> KPN();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>整个 KPN 网络的多线程 <em>Java</em> 实现</li>
</ul>
</li>
<li>  <figure class="highlight java"><figcaption><span>KPN_multithread.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.Queue;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KPN</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; chan1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; chan2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; chan3 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; chan4 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  <span class="keyword">private</span> Queue&lt;Integer&gt; chan5 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> counter=<span class="number">0</span>;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">h</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    Queue&lt;Integer&gt; in, out;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> init;</div><div class="line">    </div><div class="line">    h(Queue&lt;Integer&gt; in, Queue&lt;Integer&gt; out, <span class="keyword">int</span> init)&#123;</div><div class="line">      <span class="keyword">this</span>.in = in;</div><div class="line">      <span class="keyword">this</span>.out = out;</div><div class="line">      <span class="keyword">this</span>.init = init;</div><div class="line">      out.add(<span class="keyword">this</span>.init);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">if</span>(in.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> tmp = in.remove();</div><div class="line">            out.add(tmp);</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          lock.unlock();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">f</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    Queue&lt;Integer&gt; in_up, in_down, out;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> read_up = <span class="keyword">true</span>;</div><div class="line">    f(Queue&lt;Integer&gt; in_up, Queue&lt;Integer&gt; in_down, Queue&lt;Integer&gt; out)&#123;</div><div class="line">      <span class="keyword">this</span>.in_up = in_up;</div><div class="line">      <span class="keyword">this</span>.in_down = in_down;</div><div class="line">      <span class="keyword">this</span>.out = out;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">if</span>(read_up) &#123;</div><div class="line">            <span class="keyword">if</span>(in_up.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">              <span class="keyword">int</span> tmp = in_up.remove();</div><div class="line">              read_up = !read_up;</div><div class="line">              out.add(tmp);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span>(in_down.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">              <span class="keyword">int</span> tmp = in_down.remove();</div><div class="line">              read_up = !read_up;</div><div class="line">              out.add(tmp);</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">        &#125;<span class="keyword">finally</span> &#123;</div><div class="line">          lock.unlock();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">g</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    Queue&lt;Integer&gt; in, out_up, out_down;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> write_up = <span class="keyword">true</span>;</div><div class="line">    </div><div class="line">    g(Queue&lt;Integer&gt; in, Queue&lt;Integer&gt; out_up, Queue&lt;Integer&gt; out_down)&#123;</div><div class="line">      <span class="keyword">this</span>.in = in;</div><div class="line">      <span class="keyword">this</span>.out_up = out_up;</div><div class="line">      <span class="keyword">this</span>.out_down = out_down;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          <span class="keyword">if</span>(in.size()&gt;<span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> tmp = in.remove();</div><div class="line">            <span class="keyword">if</span>(counter&lt;<span class="number">50</span>)</div><div class="line">              System.out.println(<span class="string">"Output is: "</span>+tmp+<span class="string">" at "</span>+(++counter));</div><div class="line">            <span class="keyword">if</span>(write_up)&#123;</div><div class="line">              out_up.add(tmp);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">              out_down.add(tmp);</div><div class="line">            &#125;</div><div class="line">            write_up = !write_up;</div><div class="line">          &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          lock.unlock();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  KPN()&#123;</div><div class="line">    h h1 = <span class="keyword">new</span> h(chan4, chan1, <span class="number">1</span>);</div><div class="line">    h h0 = <span class="keyword">new</span> h(chan5, chan2, <span class="number">0</span>);</div><div class="line">    g g_ = <span class="keyword">new</span> g(chan3, chan4, chan5);</div><div class="line">    f f_ = <span class="keyword">new</span> f(chan1, chan2, chan3);</div><div class="line">    <span class="comment">/*Order1: h1 h0 f g</div><div class="line">    new Thread(h1).start();</div><div class="line">    new Thread(h0).start();</div><div class="line">    new Thread(g_).start();</div><div class="line">    new Thread(f_).start();</div><div class="line">    */</span></div><div class="line">    <span class="comment">/*Order2: h1 h1 h1 g f h0 h0</div><div class="line">    new Thread(h1).start();</div><div class="line">    new Thread(h1).start();</div><div class="line">    new Thread(h1).start();</div><div class="line">    new Thread(g_).start();</div><div class="line">    new Thread(f_).start();</div><div class="line">    new Thread(h0).start();</div><div class="line">    new Thread(h0).start();</div><div class="line">    */</span></div><div class="line">    <span class="comment">/*Order3: f f g h1 h0 h1 h0 h0 g*/</span></div><div class="line">    <span class="keyword">new</span> Thread(f_).start();</div><div class="line">    <span class="keyword">new</span> Thread(f_).start();</div><div class="line">    <span class="keyword">new</span> Thread(g_).start();</div><div class="line">    <span class="keyword">new</span> Thread(h1).start();</div><div class="line">    <span class="keyword">new</span> Thread(h0).start();</div><div class="line">    <span class="keyword">new</span> Thread(h1).start();</div><div class="line">    <span class="keyword">new</span> Thread(h0).start();</div><div class="line">    <span class="keyword">new</span> Thread(h0).start();</div><div class="line">    <span class="keyword">new</span> Thread(g_).start();</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    <span class="keyword">new</span> KPN();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Scheduling Kahn Networks $\Longrightarrow$ KPN 网络难以调度<ul>
<li>系统运行顺畅：Challenge is running processes <strong>without accumulating tokens</strong> and <strong>without producing a deadlock</strong></li>
<li>Tom Parks’ Algorithm:  Schedules a Kahn Process Network in bounded memory<ul>
<li>Parks’ algorithm expensive and fussy to implement</li>
<li>Difficult to schedule because of need to balance relative process rates</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Synchronous-Dataflow-SDF"><a href="#Synchronous-Dataflow-SDF" class="headerlink" title="Synchronous Dataflow (SDF)"></a>Synchronous Dataflow (SDF)</h4><p>　从上面论述，我们了解到，<strong>KPN</strong> 需要<code>infinite buffer size</code>，另外，它难以调度，这些都是实际应用中几乎不可能解决的问题；相比之下，<strong>SDF</strong> 则更多运用在实际场景中。</p>
<p><center><img src="/img/TA-Cources/ES2017/DataFlow_SDF.png" width="480px" alt=""/><br/>Example: DAT-to-CD rate converter (converts a 44.1 kHz sampling rate to 48 kHz)</center></p>
<ul>
<li>KPN <strong>$\rightarrow$</strong> SDF<ul>
<li>Restriction of Kahn Networks to allow compile-time scheduling<ul>
<li>Each process reads and writes <strong>a fixed number of tokens</strong> each time it fires</li>
<li>Firing is an <strong>atomic process</strong></li>
</ul>
</li>
</ul>
</li>
<li>调度策略 $\Longrightarrow$ the schedule can be executed repeatedly without accumulating tokens in buffers<ul>
<li>Solving the Balancing Equation $\Longrightarrow$ <strong>Establish relative execution rates</strong><br><center><img src="/img/TA-Cources/ES2017/DataFlow_SDFEquation.png" width="540px" alt=""/></center><ul>
<li>对<strong>$n$ 个进程构成的 SDF</strong> 中的各条 channel 建立约束方程，得到 <strong>topology matrix（拓扑矩阵）</strong><code>M</code></li>
<li>解线性方程组 $M \overrightarrow{q} = 0$，得到每个进程在每个周期中的运行次数 $\overrightarrow{q}$<ul>
<li><strong>rank(M) = n-1</strong>: A connected SDF graph（连通且相容的 SDF）, then there exists a unique smallest positive integer solution $\overrightarrow{q}$  （存在周期性调度，最小正整数为对应的进程在每个周期中的运行次数）</li>
<li><strong>rank(M) &lt; n-1</strong>: Disconnected systems（不连通的 SDF）, then have two- or higher-dimensional solutions （存在某些进程可以独立运行，它们与整个系统脱离）</li>
<li><strong>rank(M) = n</strong>: Inconsistent systems（不相容的 SDF）, then only have the all-zeros solution （不存在可能的调度策略去运行，因为总会出现无限累积）</li>
</ul>
</li>
</ul>
</li>
<li>Determine Periodic Schedule<ul>
<li>Consistent Rates Not Enough: ① Rates do not avoid deadlock; ② Add an initial token (delay) on one of the channels $\Longrightarrow$ 在满足每个进程的运行次数下，决定一个周期内所有进程的运行顺序。</li>
<li>Systems often have many possible schedules. How can we use this flexibility<ul>
<li>Reduced code size (loop structure, hierarchy): <code>BBBCDDDDAA</code>$\Longrightarrow$<code>(3B)C(4D)(2A)</code></li>
<li>Reduced buffer sizes: 虽然整个系统在每次周期运行后，进程间的 channels 都不会出现数据积累，但每个周期运行过程中，每条 channel 需要有足够大小的 buffer 用于转存数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li>Slides from <em>Introduction to embedded systems, Kai Huang</em>, School of Data and Computer Science, Sun Yat-sen University, China. All rights reserved.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　承接前期&lt;a href=&quot;http://durant35.github.io/2016/10/01/TACouses_Embedded_System_2016/&quot;&gt;DOL Functional Simulation 和 MPARM Simulation&lt;/a&gt;的实验内容，结合在&lt;strong&gt;SystemC 系统设计&lt;/strong&gt;中提到的&lt;a href=&quot;http://durant35.github.io/2017/09/26/TACouses_ES2017_SystemC/&quot;&gt;Y-chart&lt;/a&gt;，本文将讨论在 Behavior 层面的系统建模：&lt;strong&gt;MoCs (Model of Computation)&lt;/strong&gt;，希望对 DOL 的建模原理有一定认识：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;　To model streaming applications, the &lt;strong&gt;dataflow process network&lt;/strong&gt; model of computation [Lee and Parks 1995], a subclass of &lt;strong&gt;Kahn process networks&lt;/strong&gt; [Kahn 1974], has been adopted in the DOL design flow. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　什么是&lt;strong&gt;dataflow process network&lt;/strong&gt;？&lt;strong&gt;Kahn process networks&lt;/strong&gt;又是什么？接下来我们将一一论述。
    
    </summary>
    
      <category term="TA Cources" scheme="http://durant35.github.io/categories/TA-Cources/"/>
    
      <category term="EmbeddedSystem" scheme="http://durant35.github.io/categories/TA-Cources/EmbeddedSystem/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式系统导论[04] Solutions for Priority Inversion in Real-time Scheduling</title>
    <link href="http://durant35.github.io/2017/10/24/TACouses_ES2017_PriorityInversionbyResourceSharing/"/>
    <id>http://durant35.github.io/2017/10/24/TACouses_ES2017_PriorityInversionbyResourceSharing/</id>
    <published>2017-10-24T04:50:14.000Z</published>
    <updated>2017-11-01T13:38:25.767Z</updated>
    
    <content type="html"><![CDATA[<p>　Real-time systems are collections of tasks where in addition to any <strong>ordering constraints</strong> imposed by precedences between the tasks, there are also <strong>timing constraints</strong>, requiring a scheduling strategy. Classical <font color="blue">real-time scheduling</font>（实时调度） for <strong>Periodic Tasks</strong> contains <strong>Periodic Rate Monotonic (RM)</strong> as well as <strong>Earliest Deadline First (EDF)</strong>. What’s more, tasks <em>share resources</em> and use <em>mutual exclusion</em> to guard access to those resources, resulting in <strong>Scheduling Anomalies</strong>（调度异常）.<br>　本文将讲述 <strong>Resources Sharing</strong> 给 <font color="blue">real-time scheduling</font> 带来的 <strong>Priority Inversion</strong>（优先级反转）异常，并将重点介绍对应的解决办法：Priority Inheritance Protocol (<strong>PIP</strong>)、Priority Ceiling Protocol (<strong>PCP</strong>)、Stack Resource Policy (<strong>SRP</strong>)。<a id="more"></a></p>
<h3 id="Priority-Inversion"><a href="#Priority-Inversion" class="headerlink" title="Priority Inversion"></a>Priority Inversion</h3><ul>
<li><strong>Resource Sharing</strong> &amp; Task Blocked<br><center><img src="/img/TA-Cources/ES2017/PriorityInversion_CriticalSection.png" width="400px" alt=""/></center><ul>
<li>Threads (or Processes): $J_1$, $J_2$.</li>
<li>Common resources $R_k$ likes: data structures, variables, main memory area, file, set of registers, I/O unit, …</li>
<li>Many shared resources do not allow simultaneous accesses but require <strong>mutual exclusion</strong> (exclusive resources). A piece of code executed under mutual exclusion ($P(S_k) \leftrightarrow V(S_k)$) constraints is called a <strong>critical section</strong>.</li>
<li>Each <strong>exclusive resource</strong> $R_k$ must be protected by a different semaphore $S_k$ and each critical section operating on a resource must begin with a <em>wait($S_k$)</em> primitive and end with a <em>signal($S_k$)</em> primitive（原子操作）.</li>
<li>Tasks waiting for an exclusive resource is said to be <strong>blocked</strong> on that resource. Otherwise, it proceeds by entering the <strong>critical section</strong> and <strong>holds</strong> the resource. When a task <strong>leaves</strong> a critical section, the associated resource becomes free.<ul>
<li>All tasks blocked on the same resource are kept in a queue associated with the semaphore. </li>
<li>When a running task executes a <em>wait</em> on a <strong>locked</strong> semaphore, it enters a waiting state, until another tasks executes a <em>signal</em> primitive that <strong>unlocks</strong> the semaphore.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Priority Inversion</strong><br><center><img src="/img/TA-Cources/ES2017/PriorityInversion_Example.png" width="480px" alt=""/></center><ul>
<li>priority of $T_1$ &gt; priority of $T_2$ &gt; priority of $T_3$</li>
<li>$T_3$ requests exclusive access first (at $t_0$), $T_1$ has to wait until $T_3$ releases the resource (at $t_2$)</li>
<li>$T_2$ preempts $T_3$ (at $t_1$): $T_2$ can prevent $T_3$ from releasing the resource.</li>
<li>If $T_1$ is blocked only by $T_3$, <strong>blocking is bounded</strong> by the length of the critical section, but blocked by &gt;2 tasks ($T_3$, $T_2$, …), <strong>blocking can exceed the length of any critical section</strong>.</li>
</ul>
</li>
</ul>
<blockquote>
<p>　Priority Inversion is a <strong>scheduling anomaly</strong> where a low priority task was holding a lock and blocking a high-priority task, while medium priority tasks,  unrelated lower-priority tasks, are executing. </p>
</blockquote>
<ul>
<li>Solving Priority Inversion: <strong>Resource Access Protocols</strong><ul>
<li>Basic idea: Modify the priority of those tasks that cause blocking. <ul>
<li>When a task $T_i$ blocks one or more higher priority tasks, it temporarily assumes a higher priority.</li>
</ul>
</li>
<li>Methods<ul>
<li><font color="green">Priority Inheritance Protocol (PIP)</font>, for <strong>static priorities</strong></li>
<li><font color="green">Priority Ceiling Protocol (PCP)</font>, for <strong>static priorities</strong></li>
<li><font color="green">Stack Resource Policy (SRP)</font>, for <strong>static and dynamic priorities</strong><blockquote>
<p>　<em>static priorities</em>（静态优先级）: 静态优先级是在创建进程时确定的，且在进程的整个运行期间保持不变，内核不会主动修改它。<br>　<em>dynamic priorities</em>（动态优先级）: 在创建进程时所赋予的优先级，是可以随进程的推进或随其等待时间的增加而改变的，调度程序增大或减少进程静态优先级来奖励 IO 消耗型进程或惩罚 CPU 消耗进程以便获得更好的调度性能；调整后的优先级为动态优先级。<br>　<em>real-time priorities</em>（实时优先级）: 实时优先级只对实时进程有效。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Priority-Inheritance-Protocol-PIP"><a href="#Priority-Inheritance-Protocol-PIP" class="headerlink" title="Priority Inheritance Protocol (PIP)"></a>Priority Inheritance Protocol (PIP)</h3><ul>
<li>Avoid Priority Inversion in previous example uisng PIP<br><center><img src="/img/TA-Cources/ES2017/PriorityInversion_PIP.png" width="640px" alt=""/> </center><ul>
<li><strong>Direct Blocking</strong>: higher-priority task $T_1$ tries to acquire a resource held by a lower priority task $T_3$.</li>
<li><strong>Push-through Blocking</strong>: medium-priority task $T_2$ is blocked by a lower-priority task $T_3$ that has inherited a higher priority from a task ($T_1$) it directly blocks.</li>
<li>Tasks have <strong>nominal</strong>（挂名优先级） and <strong>active</strong>（活跃优先级） priorities<ul>
<li><font color="green">Nominal priority</font>: assigned by the scheduling algorithm, e.g. $T_1$’s priority.<blockquote>
<p><em>static priorities</em> or <em>dynamic priorities</em> 取决于 <em>nominal priorities</em> 的情况</p>
</blockquote>
</li>
<li><font color="green">Active priority</font>: assigned by the priority inheritance protocol dynamically to avoid priority inversion, e.g. $T_3$’s priority inherited from $T_1$.</li>
</ul>
</li>
</ul>
</li>
<li>PIP Algorithm<ul>
<li>Tasks are scheduled according to their <strong>active priorities</strong>. Tasks with the same priorities are scheduled <strong>FCFS</strong>.</li>
<li>Task $T_i$’s nominal priority <strong>$P_i$</strong>, task $T_k$’s nominal priority <strong>$P_k$</strong>.</li>
<li>When a task $T_i$ tries to enter a critical section and the resource is blocked by a lower priority task $T_k$, the task $T_i$ is blocked. Otherwise it enters the critical section.<ul>
<li>When a task $T_i$ is blocked, it transmits its active priority to the task $T_k$ that holds the semaphore. </li>
</ul>
</li>
<li>$T_k$ resumes and executes the rest of its critical section with a priority $p_k=max(p_i)$, it inherits the priority of the highest priority of the tasks blocked by it.</li>
<li>When $T_k$ exits a critical section, it unlocks the semaphore and the highest priority task blocked on that semaphore is awakened. <ul>
<li>If no other tasks are blocked by $T_k$, then $p_k$ is set to its nominal priority <strong>$P_k$</strong>.</li>
<li>Otherwise it is set to the highest priority of the left tasks blocked by $T_k$.</li>
</ul>
</li>
<li>Thus, medium priority tasks which do no share resources with $T_k$ cannot preempt $T_k$ and cannot <strong>prolong the blocking</strong>（延长阻塞） of the higher priority tasks</li>
</ul>
</li>
<li><strong>Nested Critical Sections</strong>（一个临界区内嵌套了另一个临界区）<center><img src="/img/TA-Cources/ES2017/PriorityInversion_NestedCritical.png" width="500px" alt=""/><br/>PIP for Nested Critical Sections, $S_b$ nested in $S_a$.</center></li>
<li><strong>Transitiveness</strong> of Priority Inheritance<center><img src="/img/TA-Cources/ES2017/PriorityInversion_PIPTransitiveness.png" width="540px" alt=""/><br/>If $T_1$ is blocked by $T_2$ and $T_2$ is blocked by $T_3$, then $T_3$ inherits the priority of $T_1$ via $T_2$</center></li>
<li>Pros and Cons<ul>
<li>Advantages<ul>
<li>Under the priority inheritance protocol, a job $J$ can be blocked for at most the duration of $min(n, m)$ critical sections, where $n$ is the number of lower-priority jobs that could block $J$ and $m$ is the number of distinct semaphores that can be used to block $J$.</li>
</ul>
</li>
<li>Disadvantages<ul>
<li>Deadlock is Possible<center><img src="/img/TA-Cources/ES2017/PriorityInversion_PIPDeadlock.png" width="540px" alt=""/> </center></li>
<li>Chained Blocking: $J$ can get blocked on $n$ critical sections held by $n$ distinct lower priority jobs.<center><img src="/img/TA-Cources/ES2017/PriorityInversion_PIPChainedBlocking.png" width="480px" alt=""/><br/>$J_1$ is blocked for the duration of two critical sections, once to wait $J_3$ to release $S_a$ and then to wait $J_2$ to release $S_b$.</center>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Priority-Ceiling-Protocol-PCP"><a href="#Priority-Ceiling-Protocol-PCP" class="headerlink" title="Priority Ceiling Protocol (PCP)"></a>Priority Ceiling Protocol (PCP)</h3><ul>
<li>PIP $\rightarrow$ PCP: extension of Priority Inheritance Protocol to handle chained blocking and deadlocks<ul>
<li>avoids multiple blocking</li>
<li>guarantees that, once a task has entered a critical section, it cannot be blocked by lower priority tasks until its completion</li>
</ul>
</li>
<li>PCP Algorithm<br><center><img src="/img/TA-Cources/ES2017/PriorityInversion_PCP.png" width="540px" alt=""/><br/>Task $T_1$, $T_2$, $T_3$ and their corresponding priorities $P_1$ &gt; $P_2$ &gt;$P_3$</center><ul>
<li>Each semaphore $S_k$ is assigned a priority ceiling $C(S_k)$. It is the priority of the highest priority task that can lock $S_k$. This is a static value.<blockquote>
<p>$C(S_0) = P_1$　　$C(S_1) = P_1$　　$C(S_2) = P_2$</p>
</blockquote>
</li>
<li>Suppose $T_i$ is currently running and it wants to lock the semaphore $S_k$.<ul>
<li>$T_i$ is allowed to lock $S_k$ only if the priority of $T_i$ is strictly higher than the priority ceiling $C(S_k)$ of the semaphore $S_k$ where: $S_k$ is the semaphore with the highest priority ceiling among all the semaphores which are currently locked by tasks other than $T_i$<blockquote>
<p>　检测到自身优先级比所有被占有的资源的 ceiling 值都高的时候才可以获取到请求的资源；而且，当存在资源被其它任务占有的时候，才需要进行检测操作</p>
</blockquote>
</li>
<li>Otherwise, $T_i$ is said to be blocked by the semaphore $S_k$ (and the tasks currently holding $S_k$). When $T_i$ gets blocked by $S_k$ then the priority of $T_i$ is transmitted to the tasks $T$ that currently holds $T_k$.<blockquote>
<p><font color="green">At time t2</font>: $T_2$ can not lock $S_2$. Currently $T_3$ is holding $S_2$ and $C(S_2) = P_2$ and the current priority of $T_2$ is also $P_2$.<br><font color="green">At time t5</font>: $T_1$ can not lock $S_0$. Currently $T_3$ is holding $S_2$ and $S_1$ and $C(S_1) = T_1$ and the current priority of $T_1$ is also $P_1$. The (inherited) priority of $T_3$ is now $P_1$.</p>
</blockquote>
</li>
</ul>
</li>
<li>When $T_i$ leaves a critical section guarded by $S_k$  then it unlocks $S_k$ and the highest priority task, if any, which is blocked by $S_k$ is awakened. The priority of $T_i$ is set to the highest priority of the task that is blocked by other semaphores that $T_i$ is still holding. If none, the priority of $T_i$ is set to be its <strong>nominal one</strong>.<blockquote>
<p><font color="green">At time t6</font>: $T_3$ unlocks $S_1$. It awakens $T_1$. But $T_3$’s (inherited) priority is now only $P_2$ while $P_1 &gt; C(S_2) = P_2$. So $T_1$ preempts $T_3$ and runs to completion.<br><font color="green">At time t7</font>: $T_3$ resumes execution with priority $P_2$.<br><font color="green">At time t8</font>: $T_3$ unlocks $S_2$ and goes back to its <strong>nominal priority</strong> $P_3$. So $T_2$ preempts $T_1$ and runs to completion.</p>
</blockquote>
</li>
<li>Results<br>　<strong>+</strong> A task is not allowed to enter a critical section if there are already locked semaphores which could block it eventually.<br>　<strong>+</strong> Hence, once a task enters a critical section, it can not be blocked by lower priority tasks（不会被较当前任务低优先级的任务阻塞）till its completion.</li>
</ul>
</li>
<li>PCP: Properties<br>  　<strong>+</strong> A given task $T$ is delayed at most once by a lower priority task. The delay is a function of the time taken to execute the critical section<br>  　<strong>+</strong> Deadlock free (only changing priorities)<center><img src="/img/TA-Cources/ES2017/PriorityInversion_PCPDeadlockfree.png" width="540px" alt=""/><br/>Deadlock free using PCP with $ceil(S_1)=P_1$, $ceil(S_2)=P_1$</center>

</li>
</ul>
<h3 id="Stack-Resource-Policy-SRP"><a href="#Stack-Resource-Policy-SRP" class="headerlink" title="Stack Resource Policy (SRP)"></a>Stack Resource Policy (SRP)</h3><ul>
<li>PCP Extending: Stack Resource Policy (SRP)<ul>
<li>SRP supports dynamic priority scheduling</li>
<li>PCP blocks a task at the time it makes the resource request, while SRP blocks task at the time it attempts to preempt. </li>
</ul>
</li>
<li>SRP Algorithm<br><center><img src="/img/TA-Cources/ES2017/PriorityInversion_SRP.png" width="540px" alt=""/></center><ul>
<li><font color="blue">Preemption Level</font>:  $\pi _ i \propto \frac{1}{D_i}$, tasks $T_i$ with larger deadlines $D_i$ have lower preemption level (Intuition: they can be easily preempted), is a <strong>static</strong> value.</li>
<li><font color="blue">Resource ceiling</font>: of a resource is the <em>highest preemption level from amongst of all tasks that may access that resource</em>. Note: (i) this is associated with each resource (ii) this is <strong>static</strong>.<blockquote>
<p><em>Resource ceiling</em> for the <strong><font color="red">red</font></strong> resource is 3. For the <strong><font color="red">yellow</font></strong> resource, it is 2.</p>
</blockquote>
</li>
<li><font color="blue">System ceiling</font>: is the <em>highest resource ceiling level from amongst of resources that are currently blocked</em> (当前阻塞任务的所有资源的 <em>Resource ceiling</em> 的最大值). Note: (i) this is not associated with each resource but with the system (ii) this is a <strong>dynamic</strong> parameter that can change every time a resource is accessed or released.<blockquote>
<p>Based on this, we can see how the <em>system ceiling</em> $\prod _s$ varies dynamically.</p>
</blockquote>
</li>
<li><font color="red">*</font>A task can preempt another task if<ul>
<li>it has the <strong>highest priority</strong>;</li>
<li>and its preemption level is higher than the system ceiling. <strong>$\pi _ i &gt; \prod _s$</strong><blockquote>
<p>Task $T_3$ is not preempted by $T_2$ even though it does not share the <font color="red">red</font> resource ($\pi _2 &lt; \prod _s$).</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>SRP reduces preemptions compared to PCP.<br><center><img src="/img/TA-Cources/ES2017/PriorityInversion_SRPvsPCP.png" width="540px" alt=""/></center><ul>
<li><strong>优先级&lt;SystemCeiling</strong> 的进程最终会被阻塞，或因为请求访问临界区，或因为被高优先级抢占，考虑到这一点，<em>SRP</em> 相比于 <em>PCP</em> 能够明显减少 <strong>Context Switch</strong>.<blockquote>
<p>　<strong>A task cannot be blocked by tasks with lower premption levels</strong> (these tasks can resume only when the task completes). Hence, if there are tasks on the same preemption level, they can never occupy stack space on the same time. Higher the number of tasks on the same preemption level, larger the <strong>stack space</strong> saving!</p>
</blockquote>
</li>
<li>When a task needs a resource that is not available, it <font color="green">is blocked at the time it attempts to preempt</font>, rather than later.</li>
<li>To prevent multiple priority inversions, a task is not allowed to start until <font color="green">the resource currently available are sufficient to meet the maximum requirement of every task that could preempt it</font>.</li>
</ul>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li>Slides from <em>Introduction to embedded systems, Kai Huang</em>, School of Data and Computer Science, Sun Yat-sen University, China. All rights reserved.</li>
<li>E. A. Lee and S. A. Seshia, <em>Introduction to Embedded Systems - A Cyber-Physical Systems Approach</em>, LeeSeshia.org, 2011.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　Real-time systems are collections of tasks where in addition to any &lt;strong&gt;ordering constraints&lt;/strong&gt; imposed by precedences between the tasks, there are also &lt;strong&gt;timing constraints&lt;/strong&gt;, requiring a scheduling strategy. Classical &lt;font color=&quot;blue&quot;&gt;real-time scheduling&lt;/font&gt;（实时调度） for &lt;strong&gt;Periodic Tasks&lt;/strong&gt; contains &lt;strong&gt;Periodic Rate Monotonic (RM)&lt;/strong&gt; as well as &lt;strong&gt;Earliest Deadline First (EDF)&lt;/strong&gt;. What’s more, tasks &lt;em&gt;share resources&lt;/em&gt; and use &lt;em&gt;mutual exclusion&lt;/em&gt; to guard access to those resources, resulting in &lt;strong&gt;Scheduling Anomalies&lt;/strong&gt;（调度异常）.&lt;br&gt;　本文将讲述 &lt;strong&gt;Resources Sharing&lt;/strong&gt; 给 &lt;font color=&quot;blue&quot;&gt;real-time scheduling&lt;/font&gt; 带来的 &lt;strong&gt;Priority Inversion&lt;/strong&gt;（优先级反转）异常，并将重点介绍对应的解决办法：Priority Inheritance Protocol (&lt;strong&gt;PIP&lt;/strong&gt;)、Priority Ceiling Protocol (&lt;strong&gt;PCP&lt;/strong&gt;)、Stack Resource Policy (&lt;strong&gt;SRP&lt;/strong&gt;)。
    
    </summary>
    
      <category term="TA Cources" scheme="http://durant35.github.io/categories/TA-Cources/"/>
    
      <category term="EmbeddedSystem" scheme="http://durant35.github.io/categories/TA-Cources/EmbeddedSystem/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式系统导论[01] Linux 下手动配置 Java 环境</title>
    <link href="http://durant35.github.io/2017/09/28/TACouses_ES2017_Java/"/>
    <id>http://durant35.github.io/2017/09/28/TACouses_ES2017_Java/</id>
    <published>2017-09-28T04:50:14.000Z</published>
    <updated>2017-10-29T03:24:17.853Z</updated>
    
    <content type="html"><![CDATA[<p>　Linux 手动配置 Java 环境（JRE+JDK）。<br><a id="more"></a></p>
<h3 id="apt-快速安装"><a href="#apt-快速安装" class="headerlink" title="apt 快速安装"></a>apt 快速安装</h3><ul>
<li>通过以下方式能够快速自动配置好 Java 环境</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install openjdk-8-jdk</div><div class="line">sudo apt-get install openjdk-&lt;your-version&gt;-jdk</div></pre></td></tr></table></figure>
<ul>
<li>问题是环境变量也是自动配置的，安装路径等常常不为开发人员控制；</li>
<li>另外一个问题是，经常是重启失效，原因是上述自动配置只是一个临时配置；</li>
<li>建议通过手动的方式配置自己的 Java 开发环境。</li>
</ul>
</li>
</ul>
<h3 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h3><ul>
<li>修改环境变量注意事项<ul>
<li>加载用户主目录下的<code>&lt;sub&gt;/.profile</code>，期间会加载<strong>系统环境</strong>以及用户主目录下<code>&lt;/sub&gt;/.bashrc</code>设置的环境变量</li>
<li>系统目录下的<code>/etc/profile</code>文件、系统目录下的<code>/etc/environment</code>文件</li>
</ul>
</li>
<li>安装 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">jdk-8u40-linux-x64 or latest</a><ul>
<li>将安装包解压到 <code>/usr/lib/java</code></li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /usr/lib</div><div class="line">sudo mkdir java</div><div class="line"><span class="comment"># 进入安装包下载所在路径(在终端打开)</span></div><div class="line">sudo tar zxvf ./jdk-8u40-linux-x64.gz -C /usr/lib/java</div><div class="line"><span class="comment"># 重命名为jdk8</span></div><div class="line"><span class="built_in">cd</span> /usr/lib/java</div><div class="line">sudo mv jdk1.8.0_40/ jdk8</div></pre></td></tr></table></figure>
<ul>
<li>配置环境变量</li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gedit ~/.bashrc</div><div class="line"><span class="comment"># 在打开的文件的末尾添加 JDK 所在路径</span></div><div class="line"><span class="comment"># enable jdk environment</span></div><div class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/java/jdk8</div><div class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</div><div class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></div><div class="line"> </div><div class="line"><span class="comment"># 保存退出，然后输入下面的命令来使之生效</span></div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure>
<ul>
<li>配置默认JDK</li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看当前各种JDK版本和配置</span></div><div class="line">sudo update-alternatives --config java</div></pre></td></tr></table></figure>
<ul>
<li>通过以下命令验证配置是否成功</li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查看JDK版本</span></div><div class="line">java -version</div><div class="line">java</div><div class="line">javac</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　Linux 手动配置 Java 环境（JRE+JDK）。&lt;br&gt;
    
    </summary>
    
      <category term="TA Cources" scheme="http://durant35.github.io/categories/TA-Cources/"/>
    
      <category term="EmbeddedSystem" scheme="http://durant35.github.io/categories/TA-Cources/EmbeddedSystem/"/>
    
    
  </entry>
  
  <entry>
    <title>嵌入式系统导论[02] 浅谈 System C</title>
    <link href="http://durant35.github.io/2017/09/26/TACouses_ES2017_SystemC/"/>
    <id>http://durant35.github.io/2017/09/26/TACouses_ES2017_SystemC/</id>
    <published>2017-09-26T07:50:14.000Z</published>
    <updated>2017-10-29T03:24:05.600Z</updated>
    
    <content type="html"><![CDATA[<p>　<strong>SystemC</strong> 是一种基于 C++ 语言的用于 <strong>系统设计</strong> 的计算机语言，是用 C++ 编写的一组库和宏。为了更好的了解 <strong>SystemC</strong> 的用途，我们先从集成电路（<strong>IC</strong>：通用集成电路、专用集成电路）设计的一些基础讲起，谈谈 <strong>SystemC</strong> 在 IC 设计流程中的定位；通过对比 <strong>SystemC</strong> 和我们更为熟悉的 <strong>Verilog</strong>，进一步了解 <strong>SystemC</strong> 。<br><a id="more"></a></p>
<h3 id="Y-chart-gt-IC-层次设计"><a href="#Y-chart-gt-IC-层次设计" class="headerlink" title="Y-chart ==&gt; IC 层次设计"></a>Y-chart ==&gt; IC 层次设计</h3><p>　数字集成电路的设计可以分为系统级、芯片级（行为级、结构级）、RTL级、门级、电路级和版图级。<center><img src="/img/TA-Cources/ES2017/ICLevelDescription.png" width="640px" alt=""/></center></p>
<ul>
<li><strong>系统级</strong>是把各个部件联系为一个有机的整体：<center><img src="/img/TA-Cources/ES2017/SystemLevel.png" width="300px" alt=""/></center></li>
<li>芯片级：<strong>行为级</strong>就是实现何种功能， <strong>结构级</strong>更接近电路的实际结构，电路的层次化描述，类似于电路框图；</li>
<li><strong>RTL级</strong>就是寄存器级，贴近实际电路结构的描述，描述的细节到寄存器内容传输级别，可以精确描述电路的工作原理、执行顺序，细化到寄存器级别的结构描述等：<center><img src="/img/TA-Cources/ES2017/RTL.png" width="300px" alt=""/></center></li>
<li>寄存器由<strong>逻辑门</strong>构成，逻辑门由<strong>电路</strong>构成，最后电路由半导体晶体管P和N结（pmos/nmos）构成，<strong>版图</strong>完整描述了电路的细节：<center><img src="/img/TA-Cources/ES2017/LayoutLevel.png" width="300px" alt=""/></center></li>
</ul>
<h3 id="Why-SystemC"><a href="#Why-SystemC" class="headerlink" title="Why SystemC?"></a>Why SystemC?</h3><p>　通常，系统由软件部分和硬件部分组成，系统的一部分功能由软件实现，而另一部分功能则由硬件实现。早期的系统比较简单，系统工程师将准备设计的系统划分为软件部分和硬件部分，分别由软件工程师和硬件工程师进行设计、仿真、实现和改进，最后再将软件部分和硬件部分结合起来形成系统。</p>
<ul>
<li>软件工程师使用 C 或 C++ 等程序设计语言，因为这些语言专长于描述串行执行的程序，用来仿真软件部分；</li>
<li>硬件工程师则使用 VHDL 或 Verilog 等硬件描述语言，因为这些语言专长于描述并行运行的硬件，用来仿真硬件部分。</li>
</ul>
<p>　但是，随着电子系统的不断发展，系统结构越来越复杂，系统元件也越来越多，这就要求系统工程师在先期划分软件和硬件时，就对整个系统性能有很好的了解和掌握，以便更好地划分软件和硬件，减小设计中不必要的失误所带来的损失和风险。SystemC 也就由此孕育而生，因为它能够满足对软件和硬件协同仿真的需求。<br>　SystemC 是由一组 C++ 类库所组成的 <strong>建模平台</strong>，加入了一个仿真核，可以在系统级、行为级和 RTL 级支持硬件建模；SystemC 既是一个 C++ 类库，又是一种设计方法，可以用来有效地创建软件精确算法、硬件结构模型，以及 SOC 与系统级设计的接口，可以在各个抽象层次上对系统和硬件建模。<br>　利用 SystemC 描述硬件系统的过程如下（很多概念与使用 verilog 等硬件语言进行系统设计相似）：</p>
<ul>
<li>定义模块结构，利用 SystemC 的模块类来描述一个模块；</li>
<li>定义引脚，利用端口类定义特定模块的引脚，例如时钟引脚，数据引脚等；</li>
<li>定义进程，模块的功能描述主要是通过进程来实现，在 SystemC 中进程具有并发性；此外进程的执行需要一定的触发条件，如可以通过引脚值的改变来触发进程；</li>
<li>通过上面的三个步骤基本上完成了对一个硬件模块的描述，接下来需要实例化模块，模块实际上是一个类，实例化的过程在 SystemC 的主函数中进行，在主函数中需要定义一些信号对象，这些信号对象用于连接系统中各个模块的引脚，接着创建各个模块的对象，把对象中对应的引脚与前面定义的信号对象相连接，信号对象和引脚都有数据类型，例如可以在程序中定义整型，布尔型等数据类型的信号或引脚对象。只有相同数据类型的引脚和信号才能进行连接。</li>
</ul>
<p>　通过上面的四个步骤完成一个系统的设计，便可以进行仿真运行和验证整个系统的正确性。<center><img src="/img/TA-Cources/ES2017/DesignFlow.png" width="640px" alt=""/></center><br>　像我们经常使用的 <strong>verilog</strong> 有一套 IDE，最后通过综合工具综合出电路（常见的如 FPGA 的 <strong>bitstream</strong>），<strong>SystemC</strong> 也有专门的综合工具，完成系统硬件实现。
　</p>
<h3 id="SystemC-环境配置"><a href="#SystemC-环境配置" class="headerlink" title="SystemC 环境配置"></a><a href="http://www.accellera.org/downloads/standards/systemc">SystemC</a> 环境配置</h3><blockquote>
<p><a href="https://github.com/ArchC/SystemC">Github: ArchC/SystemC</a></p>
</blockquote>
<ul>
<li>Win：使用 <strong>VS</strong> 对 <code>msvc80</code>进行构建，生成 <strong>SystemC</strong> 库（静态库/动态库）<ul>
<li>如何在 VS 中引用 <strong>SystemC</strong> 动态库呢，如下：</li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">C/C++→General →Additional Include Directories (?\systemc-&lt;version&gt;\src)</div><div class="line"> </div><div class="line">C/C++ →Language →Enable Run-Time Type Info→Yes</div><div class="line"> </div><div class="line">C/C++→Code Generation→Runtime Library→Multi-thread Debug(/MTd)</div><div class="line"> </div><div class="line">C/C++→ Command Line→Additional Options加上 /vmg /D_CRT_SECURE_NO_DEPRECATE (注意空格！！)</div><div class="line"> </div><div class="line">Linker →General→Additional Library Directories (?\systemc-&lt;version&gt;\msvc80\SystemC\Debug)</div><div class="line"> </div><div class="line">Linker →Input→Additional Dependencies (SystemC.lib)</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Linux<ul>
<li>构建生成动态库/静态库</li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1. Change to the top level directory (systemc-&lt;version&gt;)</span></div><div class="line">xxx@...:~$ <span class="built_in">cd</span> systemc-&lt;version&gt;</div><div class="line">xxx@...:~$ <span class="built_in">pwd</span></div><div class="line"><span class="comment"># 2. Create a temporary directory(automake's out-of-source build), e.g.,</span></div><div class="line">xxx@...:~$ mkdir build</div><div class="line"><span class="comment"># 3. Change to the temporary directory, e.g.,</span></div><div class="line">xxx@...:~$ <span class="built_in">cd</span> build</div><div class="line"><span class="comment"># 4. Configure the package for your system, e.g.,</span></div><div class="line">xxx@...:~$ ../configure CXX=g++ --disable-async-updates</div><div class="line"><span class="comment"># 5. Compile the package.</span></div><div class="line">xxx@...:~$ make</div><div class="line"><span class="comment"># 6. [option] verify the compiled package by testing the example suite.</span></div><div class="line">xxx@...:~$ make check</div><div class="line"><span class="comment"># 7. Install the package.</span></div><div class="line">xxx@...:~$ make install</div><div class="line"><span class="comment"># 8. You can now remove the temporary directory, .e.g,</span></div><div class="line">xxx@...:~$ <span class="built_in">cd</span> ..</div><div class="line">xxx@...:~$ rm -rf build</div><div class="line"><span class="comment"># Alternatively, you can keep the temporary directory to allow you to:</span></div><div class="line"><span class="comment">#  a) Experiment with the examples.</span></div><div class="line"><span class="comment">#  b) Later uninstall the package. </span></div><div class="line"><span class="comment">#    To clean up the temporary directory, enter:</span></div><div class="line">xxx@...:~$ make clean</div><div class="line"><span class="comment">#    To uninstall the package, enter:</span></div><div class="line">xxx@...:~$ make uninstall</div></pre></td></tr></table></figure>
<ul>
<li><code>Hello World</code>：调用 SystemC 动态链接库</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>hello.h</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HELLO_H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _HELLO_H</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"systemc.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line">SC_MODULE(hello)&#123;</div><div class="line">  SC_CTOR(hello)&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello,SystemC!"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">/*</div><div class="line"> * Use the other kind</div><div class="line">class hello : public sc_module&#123;</div><div class="line">public:</div><div class="line">  hello(sc_module_name name) : sc_module(name)&#123;</div><div class="line">          cout &lt;&lt; "Hello,SystemC!" &lt;&lt; endl;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">*/</span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>hellp.cpp</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"hello.h"</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sc_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</div><div class="line">  <span class="function">hello <span class="title">h</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight plain"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LIB_DIR=-L your-systemc-dir/lib-linux64</div><div class="line">INC_DIR=-I your-systemc-dir/include</div><div class="line"> </div><div class="line">LIB=-l systemc</div><div class="line"> </div><div class="line">APP=hello</div><div class="line"> </div><div class="line">all:</div><div class="line">  g++ -o $(APP) $(APP).cpp $(LIB_DIR) $(INC_DIR) $(LIB)</div><div class="line"> </div><div class="line">clean:</div><div class="line">  rm -rf $(APP)</div></pre></td></tr></table></figure>
<ul>
<li>构建运行会出现以下错误</li>
</ul>
</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xxx@xxx$  ./hello</div><div class="line">error <span class="keyword">while</span> loading shared libraries: libsystemc-2.3.1.so: cannot open shared object file: No such file or directory</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　　<a href="http://blog.csdn.net/david_xtd/article/details/7625626">需要增添链接器<code>ld</code>加载路径</a></p>
<ul>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">xxx@xxx$ <span class="built_in">cd</span> /etc/ld.so.conf.d</div><div class="line">xxx@xxx$ sudo gedit usr-libs.conf</div><div class="line"><span class="comment"># 添加上述的 LIB_DIR 路径到新建的 usr-libs.conf 文件</span></div><div class="line">your-systemc-dir/lib-linux64</div><div class="line"><span class="comment"># 退出后让配置生效</span></div><div class="line">xxx@xxx$ sudo ldconfig</div></pre></td></tr></table></figure>
<ul>
<li>也可以直接调用 SystemC 静态链接库</li>
</ul>
</li>
<li>  <figure class="highlight plain"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">LIB_DIR=-L your-systemc-dir/lib-linux64</div><div class="line">INC_DIR=-I your-systemc-dir/include</div><div class="line"> </div><div class="line">LIB=-Wl,-Bstatic -l systemc -Wl,-Bdynamic</div><div class="line"> </div><div class="line">APP=hello</div><div class="line"> </div><div class="line">all:</div><div class="line">  g++ -o $(APP) $(APP).cpp $(LIB_DIR) $(INC_DIR) $(LIB)</div><div class="line"> </div><div class="line">clean:</div><div class="line">  rm -rf $(APP)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SystemC-vs-Verilog（初级等效性）"><a href="#SystemC-vs-Verilog（初级等效性）" class="headerlink" title="SystemC vs Verilog（初级等效性）"></a>SystemC vs Verilog（初级等效性）</h3><p>　SystemC 的基本类库有四种：模块(Module)、进程(Process)，端口/信号(Port/Signal)和数据类型(Data Types)。其中模块(Module)是 SystemC 中最基本的结构单元，其内可以包含端口、信号、进程或子模块。</p>
<ul>
<li>进程(Process)有三类：Method Process，Thread Process 和 Clocked Thread Process；进程是 SystemC 中的基本执行单元，它用来模拟目标设备或系统的行为<ul>
<li>Method Process(方法进程) 类似模块中的成员函数，体现模块的功能特性。当有事件(信号值发生变化)发生时，Method Process 开始执行，一直到操作完，操作期间不能被挂起或无限循环运行；</li>
<li>Thread Process(线程) 和 Method Process 的主要区别在于进程执行过程中可以被挂起和再次被激活，直到运行完毕；</li>
<li>Clocked Thread Process(钟控线程) 是 Thread Process 的一个子集，主要对时序电路和同步操作进行描述，它在时钟边沿触发时开始运行。</li>
</ul>
</li>
<li>端口/信号(Port/Signal)类主要负责模块间的相互连接和通信，其中端口有输入、输出和双向输入/输出3种类型；</li>
<li>数据类型(Data Types)继承了C++中的所有数据类型，同时为描述硬件的物理信息扩展了时间、延时和逻辑等物理数据类型。<br>　在 SystemC 中，硬件模块的引脚是通过<strong>端口类</strong>对象来进行描述的，而连线则用到了<strong>信号类</strong>，<strong>进程类</strong>则是用来描述硬件模块的并发性的结构。<h4 id="①基本结构等效性"><a href="#①基本结构等效性" class="headerlink" title="①基本结构等效性"></a>①基本结构等效性</h4></li>
<li>Verilog HDL 的基本组成结构是模块<code>module</code>，对应的 SystemC 描述是 <code>sc_module</code>或<code>SC_MODULE</code>；</li>
<li>与模块之间相联系的是端口信号的定义：Verilog 的输出信号也可以作为输入，而 SystemC 的端口定义了数据转移的方向，所以对于同样作为输入的 Verilog HDL 输出信号 output，在 SystemC 中必须定义为 inout；</li>
<li>Verilog HDL 不支持浮点型的输出，而 SystemC 则支持，这在 Verilog HDL 到 SystemC 转换的时候不会产生问题，反之则不可以；</li>
<li>对于 Verilog HDL 中的连续赋值语句<code>assign</code>和<code>always</code>语句，都对应于 SystemC 的进程。SytemC 的进程有3种：方法进程(<code>SC_METHOD</code>)、线程(<code>SC_THREAD</code>)和钟控线程(<code>SC_CTHREAD</code>)<ul>
<li>方法进程用来进行组合逻辑模拟；</li>
<li>线程可用来模拟测试平台；</li>
<li>钟控线程用来模拟同步有限状态机；</li>
<li>后两种都是行为模型 ，至少需要行为级综合工具才能综合；</li>
<li>方法进程可以用来描述寄存器传输级电路，一般将 Verilog HDL 中的<code>assign</code>和<code>always</code>语句翻译成方法进程。<ul>
<li>对于一个<code>always</code>语句中的所有阻塞赋值语句，应该映射到一个 SystemC 进程中</li>
<li>对于不同变量的非阻塞赋值，应该映射为不同的 SystemC 进程</li>
</ul>
</li>
</ul>
</li>
<li>Verilog HDL 的<code>initial</code>语句等效于 SystemC 进程的构造函数<code>SC_CTOR</code><h4 id="②时间模型的等效性"><a href="#②时间模型的等效性" class="headerlink" title="②时间模型的等效性"></a>②时间模型的等效性</h4></li>
<li>在Verilog HDL 中没有专门的时钟，用户需要定义一个 reg 信号来模拟时钟，SystemC 中则直接定义了结构<code>sc_clock</code>用于定义时钟。</li>
<li>  <figure class="highlight verilog"><figcaption><span>Verilog HDL</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// define a 20 MHz clock</span></div><div class="line"><span class="keyword">module</span>(clk);</div><div class="line">  <span class="keyword">initial</span> clk = #<span class="number">50</span>;</div><div class="line">  <span class="keyword">always</span> #<span class="number">25</span></div><div class="line">    clk = ~clk;</div><div class="line"><span class="keyword">endmodule</span></div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>SystemC</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// sc_clock (const char *name_, double period_, double duty_cycle_=0.5, double start_time_=0.0, bool posedge_first_=true)</span></div><div class="line"><span class="function">sc_clock <span class="title">clk</span><span class="params">(<span class="string">"clk"</span>, <span class="number">50</span>, <span class="number">0.5</span>, <span class="number">5</span>, <span class="literal">false</span>)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>Verilog HDL中，用<code>timescale</code>定义缺省的时间单位，在 SystemC 中使用了<code>sc_set_time_resolution()</code>和<code>sc_set_default_time_unit()</code>，两者等效。</li>
<li>  <figure class="highlight verilog"><figcaption><span>Verilog HDL</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1 ns/1 ps</span></div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>SystemC</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sc_set_time_resolution(<span class="number">1</span>, SC_PS);</div><div class="line">sc_set_default_time_unit(<span class="number">1</span>, SC_NS);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="③等待-wait-与事件-event-的等效性"><a href="#③等待-wait-与事件-event-的等效性" class="headerlink" title="③等待(wait)与事件(event)的等效性"></a>③等待(wait)与事件(event)的等效性</h4><ul>
<li>  <figure class="highlight verilog"><figcaption><span>Verilog HDL</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">`<span class="meta-keyword">define</span> DLY 2</span></div><div class="line"><span class="keyword">module</span> dif(clk, din, dout);</div><div class="line">  <span class="keyword">input</span> clk, din;</div><div class="line">  <span class="keyword">output</span> dout;</div><div class="line">  </div><div class="line">  <span class="keyword">assign</span> dout &lt;= # <span class="meta">`DLY din;</span></div><div class="line">  </div><div class="line"><span class="keyword">endmodule</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>在SystemC 中，<code>wait()</code>只能在线程或者钟控线程内使用，在方法进程内须用与<code>wait()</code>等效的函数<code>next_trigger()</code></li>
<li>  <figure class="highlight cpp"><figcaption><span>SystemC</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> DLY 2</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"systemc.h"</span></span></div><div class="line">SC_MODULE(delayer) &#123;</div><div class="line">  sc_in&lt;<span class="keyword">bool</span>&gt; din;</div><div class="line">  sc_out&lt;<span class="keyword">bool</span>&gt; dout;</div><div class="line">  </div><div class="line">  SC_CTOR(diff) &#123;</div><div class="line">    SC_METHOD(do_it);</div><div class="line">    sensitive &lt;&lt; din;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_it</span><span class="params">()</span> </span>&#123;</div><div class="line">    next_trigger(DLY, SC_NS);</div><div class="line">    dout = din;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="④仿真调度模型的等效性"><a href="#④仿真调度模型的等效性" class="headerlink" title="④仿真调度模型的等效性"></a>④仿真调度模型的等效性</h4><ul>
<li>为了支持寄存器传输级的并行描述，SystemC 采用了与 Verilog HDL 基本相同的调度模型——基于<strong>Δ(delta)延迟</strong>。 一个Δ周期包括求值和更新两个阶段，在一个时间点上 ，这样的Δ周期会持续出现，直到在求值前后的结果不再发生变化，而在宏观上，时间并没有前进。</li>
</ul>
<h3 id="Soft-Firm-Hard-IP-Core-option"><a href="#Soft-Firm-Hard-IP-Core-option" class="headerlink" title="Soft/Firm/Hard IP Core$^{[option]}$"></a>Soft/Firm/Hard IP Core$^{[option]}$</h3><ul>
<li>目前集成电路设计基本上都是用<strong>IP核</strong>搭积木的形式。</li>
<li><strong>IP核</strong>分为行为（Behavior）、结构（Structure）和物理（Physical）三级不同程度的设计，对应描述功能行为的不同分为三类，即<strong>软核（Soft IP Core）</strong>、完成结构描述的<strong>固核（Firm IP Core）</strong>和基于物理描述并经过工艺验证的<strong>硬核（Hard IP Core）</strong>。</li>
<li>软核就是我们熟悉的 RTL 代码，ARM 便是以软核为主的。<ul>
<li>硬件描述语言（hardware Deion Language，HDL）文本形式提交给用户，它经过 RTL 级设计优化和功能验证，但其中不含有任何具体的物理信息；</li>
<li>用户可以以此<strong>综合</strong>出正确的<strong>门电路级</strong>设计网表，并可以进行后续的结构设计，具有很大的灵活性，借助于EDA综合工具可以很容易地与其他外部逻辑电路合成一体，根据各种不同半导体工艺，设计成具有不同性能的器件；</li>
<li>主要缺点是缺乏对时序、面积和功耗的预见性。而且<strong>IP软核</strong>以源代码的形式提供的，<strong>IP知识产权</strong>不易保护。</li>
</ul>
</li>
<li>固核就是指<strong>网表</strong>。<ul>
<li>IP固核的设计程度则是介于软核和硬核之间，除了完成软核所需的设计外，还完成了门级电路综合和时序仿真等设计环节；</li>
<li>一般以门级电路网表的形式提供给用户。</li>
<li>固核 vs 固件<blockquote>
<p><strong>固件(firmware)</strong>常指写入EROM（可擦写只读存储器）或EEPROM(电可擦可编程只读存储器)中的程序。<br>　固件是担任着一个系统最基础最底层工作的软件。在硬件设备中，固件就是硬件设备的灵魂，一些硬件设备除了固件以外没有其它软件组成，因此该固件也就决定着硬件设备的功能及性能；<br>　固件是指设备内部保存的设备”驱动程序”，通过固件，操作系统才能按照标准的设备驱动实现特定机器的运行动作。<br><strong>driver</strong>和<strong>firmware</strong>没有什么直接的关系，但 firmware 通常由驱动去加载。在 Linux Kernel 中，driver 和 firmware 是有明确含义的。<br>　driver 是控制被操作系统管理的外部设备（devices）的代码段；<br>　firmware，是表示运行在非”控制处理器”（指不直接运行操作系统的处理器，例如外设中的处理器，或者被用于 bare metal 的主处理器的其中一些核)中的程序。</p>
</blockquote>
</li>
</ul>
</li>
<li>硬核就是指经过验证的<strong>设计版图</strong>。<br><center><img src="/img/TA-Cources/ES2017/LayoutGeneration.png" width="240px" alt=""/></center><ul>
<li>基于半导体工艺的物理设计，已有固定的拓扑布局和具体工艺，并已经过工艺验证，具有可保证的性能；</li>
<li>提供给用户的形式是电路物理结构掩模版图和全套工艺文件。由于无需提供寄存器转移级（Register transfer level，RTL）文件，因而更易于实现IP保护；</li>
<li>缺点是灵活性和可移植性差。</li>
</ul>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://www.sohu.com/a/139204143_391994">ADAS 漫谈之七：如何将算法变为芯片</a></li>
<li><a href="https://zh.wikipedia.org/wiki/SystemC">维基百科: SystemC</a></li>
<li><a href="http://blog.csdn.net/wxzking/article/details/4338613">SystemC 的语言结构简介</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_12e710f630101q56s.html">SystemC 与 verilog 的等效性</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　&lt;strong&gt;SystemC&lt;/strong&gt; 是一种基于 C++ 语言的用于 &lt;strong&gt;系统设计&lt;/strong&gt; 的计算机语言，是用 C++ 编写的一组库和宏。为了更好的了解 &lt;strong&gt;SystemC&lt;/strong&gt; 的用途，我们先从集成电路（&lt;strong&gt;IC&lt;/strong&gt;：通用集成电路、专用集成电路）设计的一些基础讲起，谈谈 &lt;strong&gt;SystemC&lt;/strong&gt; 在 IC 设计流程中的定位；通过对比 &lt;strong&gt;SystemC&lt;/strong&gt; 和我们更为熟悉的 &lt;strong&gt;Verilog&lt;/strong&gt;，进一步了解 &lt;strong&gt;SystemC&lt;/strong&gt; 。&lt;br&gt;
    
    </summary>
    
      <category term="TA Cources" scheme="http://durant35.github.io/categories/TA-Cources/"/>
    
      <category term="EmbeddedSystem" scheme="http://durant35.github.io/categories/TA-Cources/EmbeddedSystem/"/>
    
    
  </entry>
  
  <entry>
    <title>Summary after Robosense&#39;s Interview</title>
    <link href="http://durant35.github.io/2017/09/03/programPearls_Summary%20after%20Interview%20in%20Robosense/"/>
    <id>http://durant35.github.io/2017/09/03/programPearls_Summary after Interview in Robosense/</id>
    <published>2017-09-03T02:46:16.000Z</published>
    <updated>2017-09-03T07:48:46.218Z</updated>
    
    <content type="html"><![CDATA[<p>　昨天第一次到 xx 参观学习，略有点仓促地进行了笔试和面试，整体状态不好，可能没做好心理准备吧。感觉：Robosense 不显山不露水！<br>　下面是对期间觉得含糊不清的问题的整理。<a id="more"></a></p>
<h3 id="C-基础部分"><a href="#C-基础部分" class="headerlink" title="C++ 基础部分"></a>C++ 基础部分</h3><ul>
<li>把内存泄露和内存溢出弄混了<ul>
<li>泄漏是说你的程序有BUG，导致内存不释放；溢出是指内存不够用了，导致不够用的原因很多，泄漏只是其中一种。</li>
<li><a href="http://blog.csdn.net/buutterfly/article/details/6617375">wokaotesting：内存溢出和内存泄漏的区别</a><ul>
<li>内存泄露（<strong>memory leak</strong>）是指你的应用使用资源之后没有及时释放，导致应用内存中持有了不需要的资源，这是一种状态描述；</li>
<li>内存溢出（<strong>out of memory</strong>）是指你的应用的内存已经不能满足正常使用了，堆栈已经达到系统设置的最大值，进而导致崩溃，这是一种结果描述；<blockquote>
<p>申请了一个 int，但给它存了 long 才能存下的数，那也是内存溢出</p>
</blockquote>
</li>
<li>通常都是由于内存泄露导致堆栈内存不断增大，从而引发内存溢出。</li>
</ul>
</li>
</ul>
</li>
<li>怀疑自己写的 C++ 输入输出运算符重载</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt;(istream &amp;in, 自定义类型名 &amp;形参名) &#123;</div><div class="line">  in &gt;&gt; ......</div><div class="line">  <span class="keyword">return</span> in;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span> &lt;&lt;(ostream &amp;out, 自定义类型名 &amp;形参名) &#123;</div><div class="line">  out &lt;&lt; ......</div><div class="line">  <span class="keyword">return</span> out;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>　<strong>注：</strong>因为第一个参数是流对象，所以不能声明为其它类的成员函数，只能声明为友元函数（<strong>friend</strong>）或普通函数。如果声明为该类的成员函数，那么第一个参数就不是流对象，而是当前类的对象。</p>
<ul>
<li>C语言中如何获取指定位置<code>[start, ..., start+n-1]</code>的子串</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span> *src，<span class="keyword">int</span> count)</span></span>;</div><div class="line"><span class="comment">/*</div><div class="line"> * 函数功能: 将字符串 src 中的 count 个字符拷贝到字符串 dest 中去</div><div class="line"> * 函数返回: 指向 dest 的指针</div><div class="line"> * 参数说明: dest-目的字符串，src-源字符串，count-拷贝的字符个数</div><div class="line"> */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="built_in">strncpy</span>(dest, src+start, n);</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span></span>;</div><div class="line"><span class="comment">/*</div><div class="line"> * 函数功能: 将字符串 src 中的 n 个字符拷贝到字符串 dest 中去</div><div class="line"> * 函数返回: 指向 dest 的指针</div><div class="line"> * 参数说明: dest-目的字符串，src-源字符串，n-拷贝的字符个数</div><div class="line"> */</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mem.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="built_in">memcpy</span>(dest, src+start, n);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>C语言中的 <code>strcpy</code>、<code>strcat</code>等字符串函数模棱两可</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="comment">// 串拷贝</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>;</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *destin, <span class="keyword">char</span> *source, <span class="keyword">int</span> maxlen)</span></span>;</div><div class="line"> </div><div class="line"><span class="comment">// 字符串拼接函数</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strcat</span><span class="params">(<span class="keyword">char</span> *destin, <span class="keyword">char</span> *source)</span></span>;</div><div class="line"> </div><div class="line"><span class="comment">// 串比较：看 ASCII 码，str1&gt;str2，返回值 &gt; 0；两串相等，返回 0</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>;</div><div class="line"><span class="comment">// 以大小写不敏感方式比较两个串</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmpi</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>;</div><div class="line"><span class="comment">// 部分串比较</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2, <span class="keyword">unsigned</span> maxlen)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmpi</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2, <span class="keyword">unsigned</span> maxlen)</span></span>;</div><div class="line"> </div><div class="line"><span class="comment">// 在串中查找指定字符串</span></div><div class="line"><span class="comment">/*</div><div class="line"> * 返回第一次出现位置后半段子串</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strstr</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>;</div><div class="line"><span class="keyword">char</span> <span class="built_in">string</span>[SIZE];</div><div class="line"><span class="keyword">char</span> *ptr;</div><div class="line"><span class="built_in">strcpy</span>(<span class="built_in">string</span>, str1);</div><div class="line">ptr = <span class="built_in">strstr</span>(<span class="built_in">string</span>, c);</div><div class="line"><span class="comment">// 获取下标</span></div><div class="line">ptr - <span class="built_in">string</span></div><div class="line"> </div><div class="line"><span class="comment">// 分割字符串</span></div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strtok</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>;</div><div class="line"><span class="comment">// 返回前半段</span></div><div class="line">strtok(input, <span class="string">","</span>);</div><div class="line"><span class="comment">// 返回后半段</span></div><div class="line">strtok(<span class="literal">NULL</span>, <span class="string">","</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p><font color="red">Refer</font>: <a href="https://www.byvoid.com/zhs/blog/c-string">C语言字符串函数大全</a></p>
</blockquote>
<h3 id="LiDAR-算法部分"><a href="#LiDAR-算法部分" class="headerlink" title="LiDAR 算法部分"></a>LiDAR 算法部分</h3><p>① <code>Hector SLAM</code>有闭环检测吗？会存在什么问题？</p>
<blockquote>
<p><a href="http://blog.csdn.net/u012700322/article/details/52953768">2D激光SLAM算法比较+cartographer</a></p>
</blockquote>
<ul>
<li><code>Hector SLAM</code>优点<ul>
<li>不需要使用里程计，所以使得空中无人机及地面小车在不平坦区域建图存在运用的可行性；</li>
<li>利用 <strong>高斯牛顿方法</strong> 解决 scan-matching 问题（是对所有点云吗？），获得激光点集映射到已有地图的刚体变换（x, y, theta）；</li>
<li>利用已经获得的地图对激光束点阵进行优化，估计激光点在地图的表示和占据网格的概率；</li>
<li>为避免局部最小而非全局最优，使用多分辨率地图；</li>
<li>导航中的状态估计加入惯性测量系统（IMU），利用EKF滤波？</li>
</ul>
</li>
<li><code>Hector SLAM</code>缺点<ul>
<li>需要激光雷达（LRS）的更新频率较高，测量噪声小；</li>
<li>在制图过程中，需要 robot 速度控制在比较低的情况下，建图效果才会比较理想，这也是它 <font color="blue">没有回环（loop close）</font>的一个后遗症；</li>
<li>在里程计数据比较精确的时候，无法有效利用里程计信息，<font color="red">估计融合这一块没怎么考虑，靠激光雷达单挑</font>。<br>② 使用过的另外一种算法 <code>gmapping</code></li>
</ul>
</li>
<li>缺点：依赖里程计（odometry），无法适用无人机及地面小车不平坦区域；<font color="blue">无回环</font></li>
<li>优点：在长廊及低特征场景中建图效果好。<br>③ 我们的使用情况</li>
<li>Hector SLAM<blockquote>
<p>该系统虽然没有严格的闭环反馈和检测，但是在室内和一些常见环境（包括走廊）， <strong>Hector SLAM</strong> 已经足够精确。</p>
</blockquote>
</li>
<li>gmapping<ul>
<li><a href="https://github.com/Durant35/laser_scan_matcher">laser_scan_matcher</a>: faking odometry using 2D LiDAR<blockquote>
<p>使用点线特征的 ICP 变种</p>
<ul>
<li>The <a href="http://wiki.ros.org/csm">C(anonical) Scan Matcher (CSM)</a> is a pure C implementation of a very fast variation of ICP using a point-to-line metric optimized for range-finder scan matching.</li>
<li>Censi A. An ICP variant using a point-to-line metric[C]//Robotics and Automation, 2008. ICRA 2008. IEEE International Conference on. IEEE, 2008: 19-25.</li>
</ul>
</blockquote>
</li>
<li>运用在和 <strong>Hector SLAM</strong> 同样的环境下，建图效果没有 <strong>Hector SLAM</strong> 好（有走廊）<ul>
<li>可能是 <strong>gmapping</strong> 比较依赖 odometry，而 <strong>laser_scan_matcher</strong> 对于走廊这种特征不明显场景，匹配效果不好（AMCL 中使用 <strong>laser_scan_matcher</strong> 进行里程估算定位效果也不佳）。</li>
<li>可能是 <strong>gmapping</strong> 本身鲁棒 <strong>Hector SLAM</strong> 没有好</li>
</ul>
</li>
</ul>
</li>
<li>在AMCL 定位中使用 <strong>Hector mapping</strong> 进行里程估算能够得到最佳定位效果：精度+实时性<ul>
<li>定量分析？</li>
<li>定性分析：进门这个特定场景</li>
</ul>
</li>
</ul>
<p>④ 2D SLAM 闭环检测？？？</p>
<ul>
<li><a href="https://github.com/googlecartographer/cartographer">cartographer</a> 中的回环优化问题</li>
</ul>
<h3 id="AI-算法部分"><a href="#AI-算法部分" class="headerlink" title="AI 算法部分"></a>AI 算法部分</h3><ul>
<li>聚类分类的异同/KNN 是分类？K-means 是聚类？</li>
<li>SVM 增加训练集为什么效果并没有改善？</li>
<li>bias 和 variance？over-fitting 和 under-fitting？</li>
<li>adaboost？</li>
<li>随机森林？</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　昨天第一次到 xx 参观学习，略有点仓促地进行了笔试和面试，整体状态不好，可能没做好心理准备吧。感觉：Robosense 不显山不露水！&lt;br&gt;　下面是对期间觉得含糊不清的问题的整理。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="C/C++" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/C-C/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>ldconfig：[load]运行时库管理</title>
    <link href="http://durant35.github.io/2017/08/08/linux_ldconfig4RuntimeLibraries/"/>
    <id>http://durant35.github.io/2017/08/08/linux_ldconfig4RuntimeLibraries/</id>
    <published>2017-08-08T02:17:59.000Z</published>
    <updated>2017-08-10T02:05:40.795Z</updated>
    
    <content type="html"><![CDATA[<p>　　<code>ldconfig</code>命令的用途主要是在默认搜寻目录 <strong>/lib</strong> 和 <strong>/usr/lib</strong> 以及动态库配置文件 <strong>/etc/ld.so.conf</strong> 内所列的目录下，搜索出可共享的动态链接库（格式如 <strong>lib*.so*</strong>），进而创建出动态装入程序（<strong>ld.so</strong>）所需的连接（快捷方式）和缓存文件。<br>　　缓存文件默认为 <strong>/etc/ld.so.cache</strong>，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令<code>ldconfig</code>，此执行程序存放在 <strong>/sbin</strong> 目录下。<br>　　<code>ldconfig</code>通常在系统启动时运行；用户安装了一个新的动态链接库时，就需要手工运行这个命令才能生效。<br>　　<code>ldconfig</code> 只与程序运行时有关（运行时库管理：装载），跟程序构建（编译&amp;链接）一点关系都没有，构建的时候还是该加 -$l$（链接）就得加，不要混淆了。<a id="more"></a></p>
<h3 id="ldconfig-命令"><a href="#ldconfig-命令" class="headerlink" title="ldconfig 命令"></a>ldconfig 命令</h3><ul>
<li>更新动态链接库缓存文件</li>
<li> <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ldconfig 将显示正在扫描的目录及搜索到的动态链接库，还有它所创建的连接的名字。</span></div><div class="line">ldconfig -v</div><div class="line">ldconfig -verbose</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>获取 <strong>/etc/ld.so.cache</strong> 缓存文件动态链接库列表</li>
<li>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 此选项指示 ldconfig 打印出当前缓存文件所保存的所有共享库的名字</span></div><div class="line">ldconfig -p</div><div class="line">ldconfig --print-cache</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>其他选项</li>
<li>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">-n：</div><div class="line">  用此选项时,ldconfig仅扫描命令行指定的目录</div><div class="line">  不扫描默认目录（/lib、/usr/lib），也不扫描配置文件/etc/ld.so.conf 所列的目录</div><div class="line">-N：</div><div class="line">  此选项指示ldconfig不重建缓存文件（/etc/ld.so.cache）</div><div class="line">  若未用-X选项，ldconfig照常更新文件的连接</div><div class="line">-X：</div><div class="line">  此选项指示ldconfig不更新文件的连接</div><div class="line">  若未用-N选项，则缓存文件正常更新</div><div class="line">-f CONF：</div><div class="line">  此选项指定动态链接库的配置文件为CONF，系统默认为 /etc/ld.so.conf</div><div class="line">-C CACHE：</div><div class="line">  此选项指定生成的缓存文件为CACHE，系统默认的是 /etc/ld.so.cache</div><div class="line">  /etc/ld.so.cache 文件存放已排好序的可共享的动态链接库的列表</div><div class="line">-r ROOT：</div><div class="line">  此选项改变应用程序的根目录为 ROOT（是调用chroot函数实现的）；</div><div class="line">  选择此项时，系统默认的配置文件/etc/ld.so.conf，实际对应的为ROOT/etc/ld.so.conf；</div><div class="line">  用此选项，可以大大增加动态链接库管理的灵活性</div><div class="line">-l：</div><div class="line">  通常情况下，ldconfig搜索动态链接库时将自动建立动态链接库的连接，</div><div class="line">  选择此项时，将进入专家模式，需要手工设置连接，一般用户不用此项</div><div class="line">-c FORMAT 或 --format=FORMAT：</div><div class="line">  此选项用于指定缓存文件所使用的格式</div><div class="line">  共有三种：old(老格式)，new(新格式)和compat（兼容格式，此为默认格式）</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="几个需要注意的地方"><a href="#几个需要注意的地方" class="headerlink" title="几个需要注意的地方"></a><font color="red">几个需要注意的地方</font></h3><ul>
<li>往<strong>/lib</strong> 和 <strong>/usr/lib</strong> 里面加东西，是不用修改 <strong>/etc/ld.so.conf</strong> 的，但是完了之后要调一下 <code>ldconfig</code>，不然这个库会找不到。</li>
<li>往<strong>/lib</strong> 和 <strong>/usr/lib</strong> 两个目录以外放 lib 的时候，一定要修改 <strong>/etc/ld.so.conf</strong>，然后再调用 <code>ldconfig</code>，不然也会找不到。<blockquote>
<p>　例如：安装了一个 mysql 到 <strong>/usr/local/mysql</strong>，mysql 有一大堆 library 在 <strong>/usr/local/mysql/lib</strong> 下面，这时就需要在 <strong>/etc/ld.so.conf</strong>文件末尾追加一行 <strong>/usr/local/mysql/lib</strong>，保存过后 <code>ldconfig</code> 一下，新的 library 才能在程序运行时被找到</p>
</blockquote>
</li>
<li>往<strong>/lib</strong> 和 <strong>/usr/lib</strong> 这两个目录以外放 lib，但是又不想在 <strong>/etc/ld.so.conf</strong> 中加东西（或者是没有权限加东西），可以通过 <strong>export</strong> 一个全局变量 <code>LD_LIBRARY_PATH</code>，然后运行程序的时候就会去这个目录中找 library；一般来讲这只是一种临时的解决方案，在没有权限或临时需要的时候使用。</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://man.linuxde.net/ldconfig">ldconfig命令</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;code&gt;ldconfig&lt;/code&gt;命令的用途主要是在默认搜寻目录 &lt;strong&gt;/lib&lt;/strong&gt; 和 &lt;strong&gt;/usr/lib&lt;/strong&gt; 以及动态库配置文件 &lt;strong&gt;/etc/ld.so.conf&lt;/strong&gt; 内所列的目录下，搜索出可共享的动态链接库（格式如 &lt;strong&gt;lib*.so*&lt;/strong&gt;），进而创建出动态装入程序（&lt;strong&gt;ld.so&lt;/strong&gt;）所需的连接（快捷方式）和缓存文件。&lt;br&gt;　　缓存文件默认为 &lt;strong&gt;/etc/ld.so.cache&lt;/strong&gt;，此文件保存已排好序的动态链接库名字列表，为了让动态链接库为系统所共享，需运行动态链接库的管理命令&lt;code&gt;ldconfig&lt;/code&gt;，此执行程序存放在 &lt;strong&gt;/sbin&lt;/strong&gt; 目录下。&lt;br&gt;　　&lt;code&gt;ldconfig&lt;/code&gt;通常在系统启动时运行；用户安装了一个新的动态链接库时，就需要手工运行这个命令才能生效。&lt;br&gt;　　&lt;code&gt;ldconfig&lt;/code&gt; 只与程序运行时有关（运行时库管理：装载），跟程序构建（编译&amp;amp;链接）一点关系都没有，构建的时候还是该加 -$l$（链接）就得加，不要混淆了。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Linux" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Linux/"/>
    
    
      <category term="Linux" scheme="http://durant35.github.io/tags/Linux/"/>
    
      <category term="bash" scheme="http://durant35.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>[0024] Iterative Closest Points（迭代最近点）</title>
    <link href="http://durant35.github.io/2017/07/21/Algorithms_ICP/"/>
    <id>http://durant35.github.io/2017/07/21/Algorithms_ICP/</id>
    <published>2017-07-21T12:02:22.000Z</published>
    <updated>2017-08-16T02:59:36.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ICP-算法简介"><a href="#ICP-算法简介" class="headerlink" title="ICP 算法简介"></a>ICP 算法简介</h3><ul>
<li>由<strong>点云配准</strong> 说起<blockquote>
<p>　<strong>Point cloud registration</strong>, is the process of finding a spatial transformation that aligns two point clouds. The purpose is to merge point clouds of multiple views into a globally consistent model.<br>　Iterative Closest Points (ICP) is an algorithm employed to minimize the difference between two clouds of points. In the algorithm, target point cloud, is kept fixed, while the other one, the source, is transformed to best match the reference (the target). The algorithm iteratively revises the transformation (combination of translation and rotation) needed to minimize the distance from the source to the reference point cloud.<a id="more"></a></p>
</blockquote>
</li>
<li>问题描述<ul>
<li>有两个点集，source 和 target，target 不变（前一帧点云），source（当前帧）经过旋转（rotation）和平移（translation）甚至加上尺度（scale）变换，使得变换后的 source 点集尽量和 target 点集重合，这个变换的过程就叫 <strong>点云配准</strong>。<blockquote>
<p> Input：$M$，$P$<br>Output：rotation $R$，translation $T$，s.t. $min \verb|{| dist(M’, P) \verb|}|, \space M’ = R * M + T$</p>
</blockquote>
</li>
<li>ICP 是最广泛应用的配准方法，ICP 利用迭代一步步地算出正确的对应关系。</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="http://hustlwl.blog.sohu.com/69584430.html">经典的ICP算法</a></p>
</blockquote>
<ul>
<li>1992年，Paul J.Besl and Neil D.Mckay 在他们的文章<strong>《A method for Registration of 3D Shape》</strong>中提出了ICP（Iterative closest point）算法，通过迭代、寻找来不断搜索最近点，定义一个阀值（threhold）最终完成多视图的拼合。在那个年代提出这一划时代的算法，是不可思议的，其中很多思路没有一定的数学功底和站在一个相当的高度是难以实现的：<ul>
<li>将点集差异转换成协方差矩阵，然后通过奇异值 SVD 分解求最大特征向量；</li>
<li>最大特征向量对应四元数即为其欧式运动对应值，完成数据拼合。</li>
</ul>
</li>
<li>ICP Algorithm<ul>
<li>①Start from initial guess</li>
<li>②Iterate（<font color="blue">最大迭代次数</font>）<ul>
<li>2.1 For ecah point $M_i$，find closest point $P_i$</li>
<li>2.2 Find best transform for this correspondance</li>
<li>2.3 Transform M</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul>
<li>两个点集 $M$、$P$ 中的点数不一定相同，给出两个点集的空间变换 $f$ 使它们能进行空间匹配；$f$ 是一未知函数，求解 $f$ 的这个问题使用的最多的方法是迭代最近点法（Iterative Closest Points Algorithm）。</li>
<li>ICP 基本思想是：根据某种几何特征对数据进行匹配，并设这些匹配点为 <font color="blue">假想的对应点</font>，然后根据这种对应关系求解运动参数；再利用这些运动参数对数据进行变换；利用同一几何特征，确定新的对应关系，重复上述过程。<ul>
<li>第①步：计算 $M$ 中的每一个点在 $P$ 中的对应近点</li>
<li>第②步：求得使上述对应近点对平均距离最小的刚体变换（平移矩阵+旋转矩阵）</li>
<li>第③步：对 $M$ 使用上一步求得的平移矩阵和旋转矩阵，得到新的变换点集 $M’$</li>
<li>第④步：如果新的变换点集 $M’$ 与参考点集 $P$ 满足收敛条件，则停止迭代计算；否则，变换点集 $M’$ 作为新的 $M$ 继续迭代第①～③步，直到达到收敛条件。<ul>
<li>Converges（是否收敛？）<ul>
<li>Errors decrease monotonically（偏差单调减少）</li>
<li>Converges to local minimum（陷入局部最优解）</li>
<li>Good initial guess $\Longrightarrow$ Converges to global minimum（全局最优解）</li>
</ul>
</li>
<li>收敛条件<ul>
<li><font color="blue">前一个变换矩阵和当前变换矩阵的差异小于阈值时，认为已经收敛</font></li>
<li><font color="blue">均方误差和（Mean Square Error, $\sigma = \sqrt{\frac{\sum ^n \varepsilon _i ^2}{n}}$）小于阈值</font>

</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ICP-目标函数"><a href="#ICP-目标函数" class="headerlink" title="ICP 目标函数"></a>ICP 目标函数</h3><ul>
<li>三维空间中两个 3D 点，$\overrightarrow{M_i} = (x_i, y_i, z_i)$，$\overrightarrow{P_j} = (x_j, y_j, z_j)$，它们的欧氏距离表示为：$$dist(\overrightarrow{M_i}, \space \overrightarrow{P_j}) = || \overrightarrow{M_i} - \overrightarrow{P_j} || = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}$$</li>
<li>定义点到点集的距离为点到点集的所有点中的最短距离，故点$\overrightarrow{M_i}$ 的对应点定义为：$$ \overrightarrow{P_i}  \space s.t. \space arg \space min_{\overrightarrow{P_i} \in P} dist(\overrightarrow{P_i}, \overrightarrow{M_i}) $$ $\quad$ 即点集 $P$ 中与点$\overrightarrow{M_i}$ 距离最短的那个点（<font color="blue">最近点</font>）。</li>
<li>三维点云匹配问题的目的是找到 $M$ 和 $P$ 变换的矩阵 $R$ 和 $T$，对于 $\overrightarrow{P_i} = R*\overrightarrow{M_i} + T + N_i, \space i=1, 2, …, N$（$N_i$ 是噪声矢量，$N_i$ 的要素均为白噪声），利用最小二乘法求解最优解，使得 $$E = \sum _{i=1} ^N ||(R\overrightarrow{M_i} + T) - \overrightarrow{P_i}||$$ $\quad$ 最小时的 $R$ 和 $T$。</li>
</ul>
<h3 id="ICP-算法实现"><a href="#ICP-算法实现" class="headerlink" title="ICP 算法实现"></a>ICP 算法实现</h3><ol>
<li>令 $\overrightarrow{m} \in M$，$\overrightarrow{p} \in P$，且 $N_m = ||M||$，$N_p = ||P||$。</li>
<li>初始化初始点集 $P_0 = P$，初始化变换向量 $\overrightarrow{q} = [1, 0, 0, 0, 0, 0]$，即旋转为 0， 且各方向位移为 0，初始化迭代次数 $k = 0$，执行以下几个步骤直到收敛：<ul>
<li>计算获取对应点集（搜索最近点）：$Y_k = C(P_k, \space M)$</li>
<li>计算配准变换向量：$(\overrightarrow{q_k}, \space d_{k}) = Q(P_0, \space Y_k)$，$d_{k} = MSE(\overrightarrow{q_k} * P, \space M)$</li>
<li>应用配准：$P_{k+1} = \overrightarrow{q_k} * P_0$</li>
<li>终止迭代过程：两次误差小于一个给定阈值 $\tau \gt 0$，使得 $d_k - d_{k-1} \lt \tau$</li>
</ul>
</li>
</ol>
<h4 id="如何搜索最近点-Y-k"><a href="#如何搜索最近点-Y-k" class="headerlink" title=" 如何搜索最近点 $Y_k$"></a><1> 如何搜索最近点 $Y_k$</h4><ul>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// original points</span></div><div class="line"><span class="built_in">vector</span>&lt;Vertex&gt; P; </div><div class="line"><span class="built_in">vector</span>&lt;Vertex&gt; M;</div><div class="line"> </div><div class="line"><span class="comment">// control points number</span></div><div class="line"><span class="keyword">int</span> contNum; </div><div class="line"> </div><div class="line"><span class="comment">// control points</span></div><div class="line">Vertex *contP; </div><div class="line">Vertex *contM;</div><div class="line"> </div><div class="line"><span class="keyword">double</span> ICP::closest() &#123;</div><div class="line">  <span class="comment">//cout&lt;&lt;"find closest points and error"&lt;&lt;endl;</span></div><div class="line">  <span class="keyword">double</span> error = <span class="number">0.0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;contNum; i++) &#123;</div><div class="line">    <span class="keyword">double</span> maxdist = <span class="number">100.0</span>;</div><div class="line">    index[i] = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> j=<span class="number">0</span>; j&lt;M.size(); j++) &#123;</div><div class="line">      <span class="keyword">double</span> dist = distance(contP[i], M[j]);</div><div class="line">      <span class="keyword">if</span>(dist &lt; maxdist) &#123;</div><div class="line">        maxdist = dist;</div><div class="line">        index[i] = j;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    Vertex v = M[index[i]];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</div><div class="line">      contM[i].coord[j] = v.coord[j];</div><div class="line">    &#125;</div><div class="line">    error += maxdist;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> error;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">double</span> ICP::distance(Vertex a,Vertex b) &#123;</div><div class="line">  <span class="keyword">double</span> dist = <span class="number">0.0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</div><div class="line">    dist += (a.coord[i]-b.coord[i])*(a.coord[i]-b.coord[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> dist;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>最近点对查找的一种改进方法<ul>
<li>对应点的查找是整个配准过程中耗费时间最长的步骤，可以利用 <strong>kd-tree</strong> 提高查找速度；</li>
<li><strong>kd-tree</strong> 建立点的拓扑关系是基于二叉树的坐标轴分割，构造 kd-tree 的过程就是按照二叉树法则生成。<ul>
<li>首先按 X 轴寻找分割线，即计算所有点的 x 值的平均值，以最近这个平均值的点的 x 值将空间分成两部分；</li>
<li>在分成的子空间中按 Y 轴寻找分割线（与 X 轴方法类似），将其分成两部分，分隔好的子空间再按 X 轴分割；</li>
<li>重复上述分割操作，直到分割的区域内只有一个点，这样点的拓扑关系就建立了；</li>
<li>这样的分割过程就对应于一个二叉树，二叉树的分节点就对应一条分割线，而二叉树的每个叶子节点就对应一个点。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="控制点"><a href="#控制点" class="headerlink" title=" 控制点"></a><2> 控制点</h4><blockquote>
<p>　In order to speed up registration, another common extension to the original ICP algorithm is to register only subsets of the input point clouds sampled in an initial selection step</p>
</blockquote>
<ul>
<li>在确定对应关系时，所使用的几何特征是空间中位置最近的点，这里我们甚至不需要两个点集中的所有点，可以只用从某一点集中选取出来的一部分点，一般称这些点为 <strong>控制点（Control Points）</strong>。这时，配准问题转化为：$$ E = \sum_{i=1}^{N} ||(R\overrightarrow{p_i} + T) - \overrightarrow{m_i}||$$ $\quad$ 其中，$\overrightarrow{p_i}$、$\overrightarrow{m_i}$ 为最近匹配点。</li>
</ul>
<h4 id="求点集间变换矩阵-overrightarrow-q-k"><a href="#求点集间变换矩阵-overrightarrow-q-k" class="headerlink" title=" 求点集间变换矩阵 $\overrightarrow{q_k}$"></a><3> 求点集间变换矩阵 $\overrightarrow{q_k}$</h4><ul>
<li>完整的配准变换向量 $\overrightarrow{q_k} = [\overrightarrow{q_R} | \overrightarrow{q_T}]$<ul>
<li>旋转向量 $\Longrightarrow$ 采用 <strong>四元数</strong> 表示<ul>
<li>设单位四元数 $\overrightarrow{q_R} = [q_0, q_1, q_2, q_3]^T$</li>
</ul>
</li>
<li>位移向量 $\overrightarrow{q_T} = [q_4, q_5, q_6]^T$</li>
</ul>
</li>
<li>如何求旋转向量 $\overrightarrow{q_R}$<ul>
<li>设点集 $M$ 的质心（中心，center of mass）为：$$\overrightarrow{\mu _M} = \frac{1}{N_m} \sum _{i=1} ^{N_m} \overrightarrow{M_i}$$<br>$\quad$ 点集 $P$ 的质心为：$$\overrightarrow{\mu _P} = \frac{1}{N_p} \sum _{i=1} ^{N_p} \overrightarrow{P_i}$$</li>
<li>平移和旋转分离<blockquote>
<p>　To measure the <strong>similarity</strong> of sets P and M, we can find their <strong>cross-covariance</strong> $\Longrightarrow$ This removes the translation component, leaving on the rotation to deal with.</p>
<center><img src="/img/programPearls/icp/rotation&translation_separation.png" width="640px" alt="" /></center></blockquote>
</li>
<li>设点集 $P$ 和 $M$ 的协方差矩阵（cross-covariance matrix）为：$$ \sum\nolimits _{pm} =  \frac{1}{N_p} \sum _{i=1} ^{N_m} [(\overrightarrow{P_i} - \overrightarrow{\mu _P})(\overrightarrow{M_i} - \overrightarrow{\mu _M})^T] = \frac{1}{N_p} \sum _{i=1} ^{N_m} [\overrightarrow{P_i} \cdot \overrightarrow{M_i}^T - \overrightarrow{\mu _P} \overrightarrow{\mu _M}^T]$$<br>$\quad$ 设对应的反对称矩阵（anti-symmetric matrix）为：$$A_{ij} = (\sum\nolimits _{pm} - \sum\nolimits _{pm} ^T)_{ij}$$<br>$\quad$ 取其循环部分组成列向量：$$\Delta = [A_{23},\space A_{31},\space A_{12}]^T$$</li>
<li>构造 4×4 对称矩阵（symmetric matrix）：$$Q(\sum\nolimits _{pm}) = \begin{bmatrix} tr(\sum\nolimits _{pm}) &amp; \Delta^T \\ \Delta &amp; \sum\nolimits _{pm} - \sum\nolimits _{pm}^T - tr(\sum\nolimits _{pm})I_3 \end{bmatrix}$$ $\quad$ 其中 $tr(?)$ 是指矩阵的迹，即矩阵的对角线元素之和；$I_3$ 是 3×3 的单位矩阵<blockquote>
<p>The unit eigenvector corresponding to the maximum eigenvalue of the matrix is selected as the optimal rotation.</p>
</blockquote>
</li>
<li>取$Q(\sum\nolimits _{pm})$ 最大的特征值（maximum eigenvalue）对应的单位特征向量（unit eigenvector）$\overrightarrow{q_R} = [q_0, q_1, q_2, q_3]^T$ 为最优旋转。$\Longrightarrow$<font color="blue"> 这一步如何实现呢？？？</font></li>
</ul>
</li>
<li>如何求位移向量 $\overrightarrow{q_T}$<ul>
<li>最优位移向量 $$\overrightarrow{q_T} = \overrightarrow{\mu _M} - R_{\overrightarrow{q_R}}\overrightarrow{\mu _P} $$ $\quad$ 其中，$R_{\overrightarrow{q_R}}$ 是旋转向量对应的旋转矩阵。</li>
<li>由四元数到旋转矩阵的变换来说，单位四元数 $\overrightarrow{q_R} = [q_0, q_1, q_2, q_3]^T$，其旋转矩阵可以表示为：$$R_{\overrightarrow{q_R}} = \begin{bmatrix} q_0^2+q_1^2-q_2^2-q_3^2 &amp; 2(q_1 q_2 - q_0 q_3) &amp; q_1 q_3 + q_0 q_2 \\ 2(q_1 q_2 + q_0 q_3) &amp; q_0^2+q_2^2-q_1^2-q_3^2 &amp; 2(q_2 q_3 - q_0 q_1)\\ 2(q_1 q_3 - q_0 q_2) &amp; 2(q_2 q_3 + q_0 q_1) &amp; q_0^2+q_3^2-q_1^2-q_2^2 \end{bmatrix}$$</li>
</ul>
</li>
<li><font color="blue">旋转向量 $\overrightarrow{q_R} = [q_0, q_1, q_2, q_3]^T$ 的最小二乘法求解</font><ul>
<li>在ICP 算法的出处论文《A Method for Registration of 3-D Shapes》中只给出了上述的算法流程和公式转化，关于如何通过特征值求解 $\overrightarrow{q_R}$ 并没有明确的指出。通过了解发现，常见的代码实现中通常采用 SVD（奇异值）求解有关旋转向量的最小二乘问题。</li>
<li><a href="http://blog.csdn.net/lcydhr/article/details/52413179">SVD</a><blockquote>
<p>任意矩阵 $A$（m×n），都能被奇异值分解为：$$A = U \begin{bmatrix} \sum \nolimits _r &amp; &amp; 0 \\ &amp; &amp; \vdots \\ 0 &amp; \cdots &amp; 0 \end{bmatrix} V^T$$ $\quad$ 其中，$U$ 是 m×m 的正交矩阵，$V$ 是 n×n 的正交矩阵，$\sum \nolimits _r $ 是由 $r$ 个沿对角线从大到小排列的奇异值组成的方阵，$r$ 就是矩阵 $A$ 的秩。</p>
</blockquote>
</li>
<li>求解方法一（ <a href="http://blog.csdn.net/xiaowei_cqu/article/details/8470376">小魏的修行路：[3D]迭代最近点算法 Iterative Closest Points</a>）<ul>
<li>分别将点集 $P$ 和 $M$平移至中心点处（去中心化）：$$\overrightarrow{p_i’} = \overrightarrow{p_i} - \overrightarrow{\mu _P}$$ $$ \overrightarrow{m_i’} = \overrightarrow{m_i} - \overrightarrow{\mu _M} $$</li>
<li>对于第 $i$ 对点对，计算点对的矩阵 $A_i$：$$ A_i = \begin{bmatrix} 0 &amp; (\overrightarrow{p_i’}-\overrightarrow{m_i’})^T \\ \overrightarrow{p_i’}-\overrightarrow{m_i’} &amp; D_i^M  \end{bmatrix}$$ $\quad$其中，$D_i = \overrightarrow{p_i’}+\overrightarrow{m_i’}$，$D_i^M$ 是矩阵 $D_i$ 的 <font color="blue">Um 形式（什么是 Um 形式呢？）</font>，$$ D_i^M = \begin{bmatrix} 0 &amp; -D_i[2] &amp; -D_i[1] \\ -D_i[2] &amp; 0 &amp; D_i[0] \\ D_i[1] &amp; -D_i[0] &amp; 0 \end{bmatrix}$$</li>
<li>对于每一次迭代，计算矩阵 $B$：$$ B = \sum_{i=1}^{N_p} A_iA_i^T$$</li>
<li>关于旋转向量的最优化问题转化为求 $B$ 的最小特征值和特征向量（如下，通过第三方 newmat 库的 SVD 求解）</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>求解方法一</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// using newmat library</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;newmat/newmatap.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;newmat/newmat.h&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Vertex&#123;</div><div class="line">  <span class="keyword">double</span> coord[<span class="number">3</span>];</div><div class="line">&#125;;</div><div class="line"><span class="comment">// control points in P</span></div><div class="line">Vertex *contP; </div><div class="line">Vertex *contM;</div><div class="line"><span class="comment">// control points after removing center（去中心化）</span></div><div class="line">Vertex *rmcoP; </div><div class="line">Vertex *rmcoM;</div><div class="line"> </div><div class="line"><span class="keyword">void</span> ICP::transform() &#123;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"get transform matrix"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">  <span class="function">Matrix <span class="title">B</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span></span>;</div><div class="line">  B = <span class="number">0</span>;</div><div class="line">  <span class="keyword">double</span> u[<span class="number">3</span>]; <span class="comment">//di+di'</span></div><div class="line">  <span class="keyword">double</span> d[<span class="number">3</span>]; <span class="comment">//di-di'</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cono;i++) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++) &#123;</div><div class="line">      u[j] = rmcoP[i].coord[j]+rmcoM[i].coord[j];</div><div class="line">      d[j] = rmcoM[i].coord[j]-rmcoM[i].coord[j];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">double</span> uM[<span class="number">16</span>] = &#123;</div><div class="line">      <span class="number">0</span>,    -d[<span class="number">0</span>],  -d[<span class="number">1</span>],  -d[<span class="number">2</span>],</div><div class="line">      d[<span class="number">0</span>], <span class="number">0</span>,      -u[<span class="number">2</span>],  -u[<span class="number">1</span>],</div><div class="line">      d[<span class="number">1</span>], -u[<span class="number">2</span>],  <span class="number">0</span>,      u[<span class="number">0</span>],</div><div class="line">      d[<span class="number">2</span>], u[<span class="number">1</span>],   -u[<span class="number">0</span>],  <span class="number">0</span></div><div class="line">    	&#125;;</div><div class="line">     </div><div class="line">    <span class="function">Matrix <span class="title">Ai</span><span class="params">(<span class="number">4</span>,<span class="number">4</span>)</span> </span>;</div><div class="line">    Ai &lt;&lt; uM ;</div><div class="line">    B += Ai*Ai.t();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 利用奇异值分解计算B的特征值和特征向量（旋转向量四元数）</span></div><div class="line">  Matrix U;</div><div class="line">  Matrix V;</div><div class="line">  DiagonalMatrix D;</div><div class="line">  SVD(B,D,U,V);</div><div class="line"> </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) &#123;</div><div class="line">    quad[i] = V.element(i,<span class="number">3</span>);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  B.Release();</div><div class="line">  U.Release();</div><div class="line">  V.Release();</div><div class="line">  D.Release();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>求解方法二（<a href="(http://nghiaho.com/?page_id=671">FINDING OPTIMAL ROTATION AND TRANSLATION BETWEEN CORRESPONDING 3D POINTS</a>） $$H = \sum_{i=1}^N (P_i - \overrightarrow{\mu _P} )(M_i - \overrightarrow{\mu _M})^T$$ $$[U,\space S,\space V] = SVD(H)$$ $$ R = VU^T $$<ul>
<li>其中，$H$ 为 Familiar Covariance Matrix（近似协方差矩阵，论文中是协方差矩阵）；$R$ 即为最优的旋转矩阵。</li>
<li>Special reflection case<ul>
<li>Sometimes the SVD will return a ‘reflection’ matrix, which is numerically correct but is actually nonsense in real life. This is addressed by checking <strong>the determinant of R</strong> (from SVD above) and seeing if it’s negative (-1). If it is then the 3rd column of V is multiplied by -1.<blockquote>
<p>if determinant(R) &lt; 0<br>　multiply 3rd column of V by -1<br>   　recompute R<br>   end if</p>
</blockquote>
</li>
<li>An alternative check that is possibly more robust was suggested by Nick Lambert<blockquote>
<p>if determinant(R) &lt; 0<br>　multiply 3rd column of Ｒ by -1<br>   end if</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight py"><figcaption><span>求解方法二</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</div><div class="line"> </div><div class="line"><span class="comment"># Input: expects Nx3 matrix of points</span></div><div class="line"><span class="comment"># Returns R,t</span></div><div class="line"><span class="comment"># R = 3x3 rotation matrix</span></div><div class="line"><span class="comment"># t = 3x1 column vector</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">rigid_transform_3D</span><span class="params">(A, B)</span>:</span></div><div class="line">    <span class="keyword">assert</span> len(A) == len(B)</div><div class="line"> </div><div class="line">    N = A.shape[<span class="number">0</span>]; <span class="comment"># total points</span></div><div class="line"> </div><div class="line">    centroid_A = mean(A, axis=<span class="number">0</span>)</div><div class="line">    centroid_B = mean(B, axis=<span class="number">0</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># centre the points</span></div><div class="line">    AA = A - tile(centroid_A, (N, <span class="number">1</span>))</div><div class="line">    BB = B - tile(centroid_B, (N, <span class="number">1</span>))</div><div class="line"> </div><div class="line">    <span class="comment"># dot is matrix multiplication for array</span></div><div class="line">    H = transpose(AA) * BB</div><div class="line"> </div><div class="line">    U, S, Vt = linalg.svd(H)</div><div class="line"> </div><div class="line">    R = Vt.T * U.T</div><div class="line"> </div><div class="line">    <span class="comment"># special reflection case</span></div><div class="line">    <span class="keyword">if</span> linalg.det(R) &lt; <span class="number">0</span>:</div><div class="line">       <span class="keyword">print</span> <span class="string">"Reflection detected"</span></div><div class="line">       Vt[<span class="number">2</span>,:] *= <span class="number">-1</span></div><div class="line">       R = Vt.T * U.T</div><div class="line"> </div><div class="line">    t = -R*centroid_A.T + centroid_B.T</div><div class="line"> </div><div class="line">    <span class="keyword">print</span> t</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> R, t</div><div class="line"> </div><div class="line"><span class="comment"># !!! Test with random data</span></div><div class="line"><span class="comment"># &lt;1&gt;Random rotation and translation</span></div><div class="line">R = mat(random.rand(<span class="number">3</span>,<span class="number">3</span>))</div><div class="line">t = mat(random.rand(<span class="number">3</span>,<span class="number">1</span>))</div><div class="line"><span class="comment"># &lt;2&gt;make R a proper rotation matrix, force orthonormal</span></div><div class="line">U, S, Vt = linalg.svd(R)</div><div class="line">R = U*Vt</div><div class="line"><span class="comment"># &lt;3&gt;remove reflection</span></div><div class="line"><span class="keyword">if</span> linalg.det(R) &lt; <span class="number">0</span>:</div><div class="line">   Vt[<span class="number">2</span>,:] *= <span class="number">-1</span></div><div class="line">   R = U*Vt</div><div class="line"><span class="comment"># &lt;4&gt;number of points</span></div><div class="line">n = <span class="number">10</span></div><div class="line"> </div><div class="line">A = mat(random.rand(n,<span class="number">3</span>));</div><div class="line">B = R*A.T + tile(t, (<span class="number">1</span>, n))</div><div class="line">B = B.T;</div><div class="line"> </div><div class="line"><span class="comment"># &lt;5&gt;recover the transformation</span></div><div class="line">ret_R, ret_t = rigid_transform_3D(A, B)</div><div class="line">  </div><div class="line">A2 = (ret_R*A.T) + tile(ret_t, (<span class="number">1</span>, n))</div><div class="line">A2 = A2.T</div><div class="line"> </div><div class="line"><span class="comment"># &lt;6&gt;Find the error</span></div><div class="line">err = A2 - B</div><div class="line"> </div><div class="line">err = multiply(err, err)</div><div class="line">err = sum(err)</div><div class="line">rmse = sqrt(err/n);</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">"Points A"</span></div><div class="line"><span class="keyword">print</span> A</div><div class="line"><span class="keyword">print</span> <span class="string">""</span></div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">"Points B"</span></div><div class="line"><span class="keyword">print</span> B</div><div class="line"><span class="keyword">print</span> <span class="string">""</span></div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">"Rotation"</span></div><div class="line"><span class="keyword">print</span> R</div><div class="line"><span class="keyword">print</span> <span class="string">""</span></div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">"Translation"</span></div><div class="line"><span class="keyword">print</span> t</div><div class="line"><span class="keyword">print</span> <span class="string">""</span></div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">"RMSE:"</span>, rmse</div><div class="line"><span class="keyword">print</span> <span class="string">"If RMSE is near zero, the function is correct!"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="改进-ICP-算法"><a href="#改进-ICP-算法" class="headerlink" title="改进 ICP 算法"></a>改进 ICP 算法</h3><blockquote>
<p><a href="http://blog.csdn.net/yhlx125/article/details/52959892">夜空中明亮的星的专栏：点云匹配</a></p>
</blockquote>
<ul>
<li>加快寻找匹配点（最近点）的搜索效率<ul>
<li>K-D 树</li>
<li>Voronoi 图</li>
</ul>
</li>
<li>不同的距离量测方式<ul>
<li>点到点（标准 ICP 算法）</li>
<li>点到线</li>
<li>点到面</li>
<li>面到面</li>
</ul>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="https://web.eecs.umich.edu/~silvio/teaching/EECS598/lectures/lecture5_2.pdf">Summary of “A Method for Registration of 3-D Shapes”</a></li>
<li><a href="http://zhi.oschina.io/archives/2015/12/30/cv-icp.html">植的博客：ICP 算法过程</a></li>
<li><a href="http://nghiaho.com/?page_id=671">Nghia Ho: FINDING OPTIMAL ROTATION AND TRANSLATION BETWEEN CORRESPONDING 3D POINTS</a></li>
<li><a href="http://blog.csdn.net/xiaowei_cqu/article/details/8470376">小魏的修行路：[3D]迭代最近点算法 Iterative Closest Points</a></li>
<li><a href="http://blog.csdn.net/lcydhr/article/details/52413179">lcydhr的专栏：SVD(奇异值分解)及求解最小二乘问题</a></li>
<li><a href="http://chrisyayu.me/2016/07/07/ICP%28Iterative-Closest-Point%29%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Chrisyayu：ICP(Iterative Closest Point)学习笔记</a></li>
<li><a href="http://blog.csdn.net/u010696366/article/details/8941938">PCL学习笔记二：Registration (ICP算法)</a></li>
<li><a href="http://blog.csdn.net/yhlx125/article/details/52959892">夜空中明亮的星的专栏：点云匹配</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ICP-算法简介&quot;&gt;&lt;a href=&quot;#ICP-算法简介&quot; class=&quot;headerlink&quot; title=&quot;ICP 算法简介&quot;&gt;&lt;/a&gt;ICP 算法简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;由&lt;strong&gt;点云配准&lt;/strong&gt; 说起&lt;blockquote&gt;
&lt;p&gt;　&lt;strong&gt;Point cloud registration&lt;/strong&gt;, is the process of finding a spatial transformation that aligns two point clouds. The purpose is to merge point clouds of multiple views into a globally consistent model.&lt;br&gt;　Iterative Closest Points (ICP) is an algorithm employed to minimize the difference between two clouds of points. In the algorithm, target point cloud, is kept fixed, while the other one, the source, is transformed to best match the reference (the target). The algorithm iteratively revises the transformation (combination of translation and rotation) needed to minimize the distance from the source to the reference point cloud.
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="3D" scheme="http://durant35.github.io/tags/3D/"/>
    
  </entry>
  
  <entry>
    <title>[0025] Least Squares Line Fitting（最小二乘法直线拟合）</title>
    <link href="http://durant35.github.io/2017/07/21/Algorithms_LeastSquaresLineFitting/"/>
    <id>http://durant35.github.io/2017/07/21/Algorithms_LeastSquaresLineFitting/</id>
    <published>2017-07-21T12:02:22.000Z</published>
    <updated>2017-08-16T02:01:53.941Z</updated>
    
    <content type="html"><![CDATA[<p>　　<strong>最小二乘拟合</strong> 是一种数学上的近似和优化，利用已知的数据得出一条直线或者曲线，使之在坐标系上与已知数据之间的距离的平方和最小。<br><a id="more"></a></p>
<h3 id="最小二乘直线拟合"><a href="#最小二乘直线拟合" class="headerlink" title="最小二乘直线拟合"></a>最小二乘直线拟合</h3><ul>
<li><strong>TLS(Total Least Squares)</strong> vs <strong>OLS(Ordinary Least Squares)</strong><br><center><img src="/img/Algorithms/0025_TLSvsOLS.png" width="680px" alt=""/></center><ul>
<li>如上图，<strong>TLS</strong> 和 <strong>OLS</strong> 都是最小二乘拟合，只是在偏差评估上采取了不同的方式。</li>
<li>最小二乘法是一种较为简单的回归分析方法。<blockquote>
<p>The simplest example of a <strong>regression model</strong> is a straight line that passes through a set of points on a scatter plot.</p>
<ul>
<li>Regression involves fitting a mathematical model to data. </li>
<li>Regression involves estimating the mathematical relationship between one variable called the response variable (or dependent variable), and one or more explanatory variables (or independent variables)</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li>最常用的是 <strong>OLS</strong>（Ordinary  Least Square，普通最小二乘法）：所选择的回归模型应该使所有观察值的残差平方和达到最小（如上图左）。<br><center><img src="/img/Algorithms/0025_OLS.png" width="640px" alt=""/></center><ul>
<li>直接通过矩阵运算，容易得出：$B = (X^T X)^{-1}(X^T Y)$（拟合多项式：$y = b_0 + b_1 x + b_2 x^2 + … + b_k x^k$）</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Gary: O-Least-Square最小二乘拟合</span></div><div class="line">Segment::LocalLine Segment::fitLocalLine(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Bin::MinZPoint&gt; &amp;points) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> n_points = points.size();</div><div class="line">  <span class="comment">// 构造 X/Y 矩阵</span></div><div class="line">  Eigen::<span class="function">MatrixXd <span class="title">X</span><span class="params">(n_points, <span class="number">2</span>)</span></span>;</div><div class="line">  Eigen::<span class="function">VectorXd <span class="title">Y</span><span class="params">(n_points)</span></span>;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> iter = points.begin(); iter != points.end(); ++iter) &#123;</div><div class="line">    X(counter, <span class="number">0</span>) = iter-&gt;d;</div><div class="line">    X(counter, <span class="number">1</span>) = <span class="number">1</span>;</div><div class="line">    Y(counter) = iter-&gt;z;</div><div class="line">    ++counter;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 计算 B</span></div><div class="line">  <span class="keyword">const</span> Eigen::MatrixXd X_t = X.transpose();</div><div class="line">  <span class="keyword">const</span> Eigen::VectorXd result = (X_t * X).inverse() * X_t * Y;</div><div class="line">  LocalLine line_result;</div><div class="line">  line_result.first = result(<span class="number">0</span>);</div><div class="line">  line_result.second = result(<span class="number">1</span>);</div><div class="line">  <span class="keyword">return</span> line_result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>Eigen</strong> 是C++中可以用来调用并进行矩阵计算的一个库，里面封装了一些类。</p>
<center><img src="/img/Algorithms/0025_Eigen.jpg" width="540px" alt=""/></center>

</blockquote>
<ul>
<li>通过解 $XB = Y$ 我们就能解出 $B = [m \space b]$：$$m = \frac{\sum x_i^2 \sum y_i - \sum x_i (\sum x_i y_i)}{n \sum x_i^2 - (\sum x_i)^2}$$ $$b = \frac{n \sum x_i \sum y_i - \sum x_i (\sum x_i y_i)}{n \sum x_i^2 - (\sum x_i)^2}$$</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">OrdinaryLeastSquare(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; x, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;&amp; y) &#123;</div><div class="line">        <span class="keyword">double</span> t1=<span class="number">0</span>, t2=<span class="number">0</span>, t3=<span class="number">0</span>, t4=<span class="number">0</span>;  </div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;x.size(); ++i)  &#123; </div><div class="line">            t1 += x[i]*x[i];  </div><div class="line">            t2 += x[i];  </div><div class="line">            t3 += x[i]*y[i];  </div><div class="line">            t4 += y[i];  </div><div class="line">        &#125;</div><div class="line">        m = (t3*x.size() - t2*t4) / (t1*x.size() - t2*t2);</div><div class="line">        b = (t1*t4 - t2*t3) / (t1*x.size() - t2*t2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>OLS 这种 least square 存在问题，比如针对垂直线段就不行，于是引入第二种 <strong>Total Least Square</strong>。<br><center><img src="/img/Algorithms/0025_TLS(1).png" width="680px" alt=""/></center><br><center><img src="/img/Algorithms/0025_TLS(2).png" width="540px" alt=""/></center><ul>
<li>其中，$U = \begin{bmatrix} x_1 - \overline{x} &amp; y_1 - \overline{y} \\ \vdots &amp; \vdots \\ x_n - \overline{x} &amp; y_n - \overline{y} \end{bmatrix}$；</li>
<li>$\frac{dE}{dN} = \frac{d(N^T U^T U N)}{dN} = U^T U N + N^T U^T U$，因为 $U^T U$ 是一个对称矩阵（$U^T U = (U^T U)^T$），$U^T U N = N^T U^T U$，所以 $\frac{dE}{dN} = 2(U^T U)N$；</li>
<li>此外，$U^T U = \begin{bmatrix} \sum (x_i - \overline{x})^2 &amp; \sum (x_i - \overline{x})(y_i - \overline{y}) \\ \sum (x_i - \overline{x})(y_i - \overline{y}) &amp; \sum (y_i - \overline{y})^2 \end{bmatrix}$ 是关于 X、Y 的一个二阶矩（随机变量平方的期望）矩阵（second-moment matrix）；</li>
<li>二阶矩矩阵 $U^T U$ 的最小特征值对应的特征向量即为求解的 $N = [a \space b]$ <ul>
<li>特征值 &amp; 特征向量<blockquote>
<p>设 $A$ 为 n 阶矩阵<font color="blue">（n × n）</font>，若存在<strong>常数 $λ$</strong> 及 <strong>n 维非零向量 x</strong><font color="blue">（n × 1）</font>，使得 $Ax=λx$，则称 $λ$ 是矩阵 $A$ 的 <strong>特征值</strong>，$x$ 是 $A$ 属于特征值 $λ$ 的 <strong>特征向量</strong>。</p>
</blockquote>
</li>
<li>$eig(U^T U) = [V, D]$，$V$ 是特征向量阵（每列为一个特征向量），$D$ 特征值对角阵 $\Longrightarrow$ 寻找 $D$ 中特征值最小的对角元素对应的特征向量即为 $U^T U$ 最小特征值对应的特征向量<blockquote>
<p>特征值分解：$U^T U = V D V^{-1}$</p>
</blockquote>
</li>
<li>通过 <a href="https://durant35.github.io/2017/07/21/Algorithms_ICP/#求点集间变换矩阵-overrightarrow-q-k">SVD（奇异值）求解</a><ul>
<li>$SVD(A) = [U, S, V]$，即 $A = USV^T$<blockquote>
<p>﹢其中 $U$ 是一个<code>m*m</code>的<font color="green">正交阵（Orthogonal matrix：满足 $U U^T = I$ 或者 $U^T U = I$ 的 n 阶方阵，其中 $I$ 为 n 阶单位阵）</font>，$S$ 是一个<code>m*n</code>的<font color="green">对角阵（Diagonal matrix：主对角线之外的元素皆为 0 的矩阵，对角线上的元素可以为 0 或其他值）</font>，对角线上的元素为 $A$ 的<strong>奇异值（Singular value）</strong>，$V$ 是一个<code>n*n</code>的正交阵。$U$ 的 m 个列向量为 $A$ 的<strong>左奇异向量（Left singular vector）</strong>，$V$ 的 n 个列向量为 $A$ 的<strong>右奇异向量（Right singular vector）</strong>。$S$ 完全由 $A$ 决定和 $U$、$V$ 无关；<br>﹢$A$ 的左奇异向量（$U$）是 $A A^T$ 的特征向量；$A$ 的右奇异向量是 $A^T A$ 的特征向量。<br>﹢$A$ 的非零奇异值是 $A^T A$ 特征值的平方根，同时也是 $A A^T$ 特征值的平方根。</p>
</blockquote>
</li>
<li>寻找 $S$ 中最小奇异值对应的 $V$ 的右奇异向量即为 $A^T A$ 最小特征值对应的特征向量。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Eigenvalues&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// Eigenvalue</span></div><div class="line">    <span class="comment">// typedef Matrix&lt;int, 3, 3&gt; Matrix3d</span></div><div class="line">    Matrix3d A;</div><div class="line">    A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Here is a 3x3 matrix, A:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; A &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    EigenSolver&lt;Matrix3d&gt; es(A.transpose() * A);</div><div class="line">    <span class="comment">// 对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的</span></div><div class="line">    Matrix3d D = es.pseudoEigenvalueMatrix();</div><div class="line">    <span class="comment">// 特征向量（每一列）组成的矩阵</span></div><div class="line">    Matrix3d V = es.pseudoEigenvectors();</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The eigenvalue matrix D is:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; D &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The eigenvector matrix V is:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; V &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="comment">// 特征值分解</span></div><div class="line">    <span class="comment">// cout &lt;&lt; "Finally, V * D * V^(-1) = " &lt;&lt; endl &lt;&lt; V * D * V.inverse() &lt;&lt; endl;</span></div><div class="line">    <span class="comment">// 特征值&amp;特征向量</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"min-eigenvector &amp; min-eigenvalue"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" &lt;1&gt; The min-eigenvalue for A^T*A:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; D(D.rows()<span class="number">-1</span>, D.rows()<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" &lt;2&gt; The min-eigenvector for A^T*A:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; V.col(V.cols()<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" &lt;3&gt; (A^T*A)*min-eigenvector ="</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; (A.transpose()*A) * V.col(V.cols()<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" &lt;4&gt; min-eigenvalue*min-eigenvector ="</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; D(D.rows()<span class="number">-1</span>, D.rows()<span class="number">-1</span>)*V.col(V.cols()<span class="number">-1</span>) &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// SVD</span></div><div class="line">    <span class="comment">// Eigen::ComputeThinV | Eigen::ComputeThinU</span></div><div class="line">    Eigen::JacobiSVD&lt;Eigen::Matrix3d&gt; svd(A, Eigen::ComputeFullV | Eigen::ComputeFullU);</div><div class="line">    Eigen::Matrix3d S = svd.singularValues().asDiagonal();</div><div class="line">    <span class="comment">//得到最小奇异值的位置</span></div><div class="line">    Matrix3d::Index minColIdx;</div><div class="line">    svd.singularValues().rowwise().sum().minCoeff(&amp;minColIdx);</div><div class="line"> </div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The left singular vectors U is:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; svd.matrixU() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The singular-value matrix S is:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; S &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The right singular vectors V is:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; svd.matrixV() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The SVD: USV^T ="</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; svd.matrixU()*S*svd.matrixV().transpose() &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// 奇异值与特征值的关系</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The S^2 is:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; S*S &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"The min-eigenvector for A^T*A:"</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; svd.matrixV().col(minColIdx) &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>$d = a \overline{x} + b \overline{y}$；</li>
<li>最终得到的拟合直线：<font color="blue">$y = -\frac{a}{b} x + \frac{d}{b}$</font></li>
</ul>
</li>
</ul>
<h3 id="其他直线拟合方法"><a href="#其他直线拟合方法" class="headerlink" title="其他直线拟合方法"></a>其他直线拟合方法</h3><p><font color="blue" size="4">﹢基于 <strong>RANSAC(RANdom SAmple Consensus)</strong>（随机抽样一致） 的直线拟合</font></p>
<blockquote>
<p><a href="http://www.cnblogs.com/xrwang/archive/2011/03/09/ransac-1.html">王先荣：随机抽样一致性算法（RANSAC）</a></p>
</blockquote>
<ul>
<li>示例<br><center><img src="/img/Algorithms/0025_RANSAC_example.png" width="640px" alt=""/></center><br>　（１）从一组观测数据中找出合适的2维拟合直线，观测数据中包含局内点和局外点，其中局内点近似的被直线所通过，而局外点远离于直线（如上图）；<br>　（２）简单的 <strong>最小二乘法</strong> 不能找到适应于局内点的直线，原因是最小二乘法尽量去适应包括局外点在内的所有点；<strong>RANSAC</strong> 能得出一个仅仅用局内点计算出模型，并且概率还足够高。</li>
<li><strong>RANSAC</strong>　通过反复选择数据中的一组随机子集来达成目标（被选取的子集被假设为局内点），并用下述方法进行验证：<ul>
<li>①：有一个模型适应于<font color="green">假设的局内点</font>，即所有的未知参数都能从假设的局内点计算得出。</li>
<li>②：用①中得到的模型去测试所有的其它数据，如果某个点适用于估计的模型，认为它也是局内点。</li>
<li>③：如果有<font color="green">足够多的点被归类为假设的局内点</font>，那么估计的模型就足够合理；用所有假设的局内点去重新估计模型，因为它仅仅被初始的假设局内点估计过，通过估计局内点与模型的错误率来评估模型。</li>
<li>④：①-③这个过程被重复执行固定的次数，每次产生的模型要么因为局内点太少而被舍弃，要么因为比现有的模型更好而被选用。</li>
</ul>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://www.statisticalconsultants.co.nz/blog/total-least-squares.html">Total Least Squares</a></li>
<li><a href="http://blog.csdn.net/abcd1992719g/article/details/28118095">abcd1992719g: OpenCV2马拉松第25圈——直线拟合与RANSAC算法</a></li>
<li><a href="http://www.cnblogs.com/xrwang/archive/2011/03/09/ransac-1.html">王先荣：随机抽样一致性算法（RANSAC）</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　&lt;strong&gt;最小二乘拟合&lt;/strong&gt; 是一种数学上的近似和优化，利用已知的数据得出一条直线或者曲线，使之在坐标系上与已知数据之间的距离的平方和最小。&lt;br&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>i = i++;</title>
    <link href="http://durant35.github.io/2017/07/21/programPearls_i=i++/"/>
    <id>http://durant35.github.io/2017/07/21/programPearls_i=i++/</id>
    <published>2017-07-21T05:02:16.000Z</published>
    <updated>2017-07-21T09:47:45.370Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">100</span>; j++) &#123;</div><div class="line">  i = i++;</div><div class="line">&#125;</div><div class="line"><span class="comment">// what's the value of i ?</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="i-vs-i"><a href="#i-vs-i" class="headerlink" title="i++ vs ++i"></a>i++ vs ++i</h4><ul>
<li><strong>i++</strong> is called postfix increment. This means the value of i is passed on and then i is incremented.（后自增，先使用后自增，整个表达式的值为 i）</li>
<li><strong>++i</strong> is called prefix increment. This means 1 is added to i and then that value is passed on.（前自增，先自增后使用，整个表达式的值为 i+1）</li>
</ul>
<h4 id="Side-Effect（副作用）-amp-Sequence-Point（序列点）"><a href="#Side-Effect（副作用）-amp-Sequence-Point（序列点）" class="headerlink" title="Side Effect（副作用）&amp; Sequence Point（序列点）"></a>Side Effect（副作用）&amp; Sequence Point（序列点）</h4><blockquote>
<p><a href="https://www.clarkok.com/blog/2015/02/28/i-i-C-C-%E7%9A%84%E5%BA%8F%E5%88%97%E7%82%B9/">Clarkok: i = i++; C/C++ 的序列点</a></p>
</blockquote>
<p>　<font color="red">以下概念主要针对 C++ 解释，但其它语言有着相似的涵义</font>。</p>
<ul>
<li>Side Effect（副作用）<ul>
<li>C++ 标准中对副作用是这样定义的：<blockquote>
<p>Accessing an object designated by a volatile glvalue, modifying an object, calling a library I/O function, or calling a function that does any of those operations are all <strong>side effects</strong>, which are changes in the state of the execution environment.</p>
</blockquote>
</li>
<li>C++ （一个线程）在运行的时候有一个环境，这个环境只跟以下内容有关：<ul>
<li>内存状态</li>
<li>I/O</li>
</ul>
</li>
<li>每当程序改变了以上两件东西，就被当做程序产生了副作用。在 C++ 中，以下行为被视作带有副作用：<ul>
<li>访问一个被标注为<code>volatile</code>的对象</li>
<li>修改一个对象的值</li>
<li>调用函数库中的 I/O 函数</li>
<li>以及调用了任何包含上述行为的函数</li>
</ul>
</li>
<li>后面三个好理解，但是 <font color="red">为什么“访问一个被标注为<code>volatile</code>的对象”，也会被视作产生副作用呢？</font>想进一步了解可以阅读<a href="https://durant35.github.io/2017/07/06/programPearls_inline&amp;static&amp;const&amp;extern&amp;volatile/#volatile">C/C++常见修饰符（inline&amp;static&amp;const&amp;extern&amp;volatile）—— volatile</a></li>
</ul>
</li>
<li>Sequence Point（序列点）<ul>
<li>序列点的出现，是为了防止编译器过度优化，使得程序产生错误的结果。有如下代码：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">2</span>;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">j = i;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<ul>
<li>这段程序的副作用就是：<ul>
<li>使 i 的值加一</li>
<li>使 j 的值等于 i</li>
<li>输出 i</li>
<li>输出 j</li>
</ul>
</li>
<li>为了效率，编译器可能会改变程序的执行顺序，变成如下的执行顺序：</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 合并读取操作</span></div><div class="line">load i to reg1</div><div class="line">load j to reg2</div><div class="line"> </div><div class="line"><span class="comment">// 合并I/O操作</span></div><div class="line">output reg1, reg2</div><div class="line"> </div><div class="line"><span class="comment">// 合并写入操作</span></div><div class="line">reg2 = reg1 + <span class="number">1</span></div><div class="line">write reg2 to i</div><div class="line">write reg2 to j</div></pre></td></tr></table></figure>
<ul>
<li>很显然，这样做是不对的。序列点的出现就是为了解决这个，标准中如下定义：<blockquote>
<p>　At certain specified points in the execution sequence called <strong>sequence points</strong>, all <strong>side effects</strong> of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place.<br>　序列点出现的时候所有在序列点之前的副作用都必须被完成，所有在序列点之后的副作用都还没有发生，序列点分隔了副作用。</p>
</blockquote>
</li>
<li>标准中规定，序列点出现在下面几个地方：<ul>
<li>分号处</li>
<li>未重载的逗号运算符，|| 运算符，&amp;&amp; 运算符中</li>
<li>三元 ?: 运算符</li>
<li>计算完函数所有参数之后，且在函数的第一条语句之前</li>
<li>函数的返回值已经被写入调用者之后，且在调用处之后的第一条语句被执行之前</li>
<li>在初始化完所有基类和成员对象之后</li>
</ul>
</li>
<li>在 C++ 中，两个序列点之间的操作的顺序是 <strong>Unspecified Befavior</strong>，即标准中不指定，由编译器自己决定如何决策。这是因为 C/C++ 企图通过对语言进行较少（其实是适中）的约束，来使得编译器对语言有着更大的优化空间，以此来优化性能。</li>
</ul>
</li>
</ul>
<h4 id="Well-defined-meaning-in-Java"><a href="#Well-defined-meaning-in-Java" class="headerlink" title="Well-defined meaning in Java"></a>Well-defined meaning in Java</h4><blockquote>
<p><a href="https://stackoverflow.com/questions/23553358/why-does-this-expression-i-i-differs-from-java-and-c">Stackoverflow: Why does this expression i+=i++ differs from Java and C?</a><br><a href="https://stackoverflow.com/questions/6457130/pre-post-increment-operator-behavior-in-c-c-java-c-sharp">Stackoverflow: Pre &amp; post increment operator behavior in C, C++, Java, &amp; C#</a></p>
</blockquote>
<p>　Java and C# evaluate expressions <strong>from left to right</strong>, and the <strong>side-effects</strong> are visible immediately.<br>　Java evaluation order is from left to right and the operands are evaluated before the operation.<br>　Java 语法对<code>i = i++;</code>这样的表达式有着明确的执行定义 —— 从左到右先确定操作数，再按优先级顺序进行操作（主要是右操作数相关的操作）。</p>
<blockquote>
<p>　　At run time, the expression is evaluated in one of two ways. If the left-hand operand expression is not an array access expression（即使左操作数存在数组访问，也是满足先左后右）, then four steps are required:<br>　　率先按照从左到右的顺序对左右操作数进行 evaluation（计算），并保存下来。</p>
<ul>
<li>First, the left-hand operand is evaluated to produce a variable. If this evaluation completes abruptly（产生异常）, then the assignment expression completes abruptly for the same reason; the right-hand operand is not evaluated and no assignment occurs.</li>
<li>Otherwise, the value of the left-hand operand is saved and then the right-hand operand is evaluated. If this evaluation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.</li>
<li>Otherwise, the saved value of the left-hand variable and the value of the right-hand operand are used to perform the binary operation indicated by the compound assignment operator. If this operation completes abruptly, then the assignment expression completes abruptly for the same reason and no assignment occurs.</li>
<li>Otherwise, the result of the binary operation is converted to the type of the left-hand variable, subjected to value set conversion（数据类型转换） to the appropriate standard value set (not an extended-exponent value set), and the result of the conversion is stored into the variable.</li>
</ul>
</blockquote>
<ul>
<li>基于上述的要求，整个代码的完整操作顺序如下：</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确定左操作数：此处 i=0</span></div><div class="line"> </div><div class="line"><span class="comment">// 确定右操作数，(i++) 的值为 i：此处 i=0</span></div><div class="line">load i to reg2</div><div class="line"> <span class="comment">// 自增操作（++）是确定右操作数需要完成的操作</span></div><div class="line">reg3 = reg2 + <span class="number">1</span></div><div class="line">write reg3 to i</div><div class="line"> </div><div class="line"><span class="comment">// 赋值操作（可以被优化）：此处 i=0</span></div><div class="line"><span class="comment">// reg4 = reg2</span></div><div class="line"><span class="comment">// write reg4 to i</span></div><div class="line">write reg2 to i</div><div class="line"><span class="comment">// 此处 i=0</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Undefined-behavior-in-C-C"><a href="#Undefined-behavior-in-C-C" class="headerlink" title="Undefined behavior in C/C++"></a>Undefined behavior in C/C++</h4><p>　In C/C++, the order of evaluation of subexpressions is unspecified, and modifying the same object twice without an <strong>intervening sequence point</strong>（序列点间） is <strong>undefined behavior</strong>.<br>　C/C++ 语法对<code>i = i++;</code>这样的表达式出于效率的考虑并没有给出明确的执行定义（只有保证操作满足优先级顺序，操作数没有确定的 evaluation 顺序），编译器无论怎么做都是合法的，但对程序语义来说会导致不确定的行为（<strong>Undefined Behavior</strong>）。</p>
<blockquote>
<p>　Between the previous and next <strong>sequence point</strong> a scalar object shall have its stored value <strong>modified at most once</strong> by the evaluation of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored. The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full expression; <strong>otherwise the behavior is undefined</strong>.</p>
</blockquote>
<ul>
<li>因此，对于<code>i = i++;</code>这样的代码，i 的值被写入了两次，一次是 ++ 时，一次是被赋值时，这就出现了 <strong>Undefined Behavior</strong>，最终的执行顺序取决于编译器的优化，可能会像上面提到的在 Java 中按照 left-to-right 的顺序执行，也可能出现其它执行顺序（可以用<code>=</code>是从右到左的结合性解释），比如：</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确定右操作数，(i++) 的值为 i：此处 i=0</span></div><div class="line">load i to reg2</div><div class="line"> <span class="comment">// 自增操作（++）是确定右操作数需要完成的操作</span></div><div class="line">reg3 = reg2 + <span class="number">1</span></div><div class="line">write reg3 to i</div><div class="line"> </div><div class="line"><span class="comment">// 确定左操作数：此处 i=1</span></div><div class="line"> </div><div class="line"><span class="comment">// 赋值操作（可以被优化）：此处 i=1</span></div><div class="line"><span class="comment">// reg4 = reg2</span></div><div class="line"><span class="comment">// write reg4 to i</span></div><div class="line">write reg2 to i</div><div class="line"><span class="comment">// 此处 i=0</span></div></pre></td></tr></table></figure>
<ul>
<li>因为<code>=</code>操作符的这种结合性，编译器更多时候是生成上述执行顺序的代码，而不是 Java 语言那种。如下，是 <strong>x86-64 g++</strong> 编译器对该部分代码生成的汇编指令：</li>
</ul>
</li>
<li>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># load i to reg2</div><div class="line"><span class="number">400832</span>:	8b <span class="number">45</span> f8             	<span class="keyword">mov</span>    -<span class="number">0x8</span>(%rbp),%eax</div><div class="line"># reg3 = reg2 + <span class="number">1</span></div><div class="line"><span class="number">400835</span>:	<span class="number">8d</span> <span class="number">50</span> <span class="number">01</span>             	<span class="keyword">lea</span>    <span class="number">0x1</span>(%rax),%edx</div><div class="line"># write reg3 to i, i=<span class="number">1</span> after</div><div class="line"><span class="number">400838</span>:	<span class="number">89</span> <span class="number">55</span> f8             	<span class="keyword">mov</span>    %edx,-<span class="number">0x8</span>(%rbp)</div><div class="line"># write reg2 to i</div><div class="line">40083b:	<span class="number">89</span> <span class="number">45</span> f8             	<span class="keyword">mov</span>    %eax,-<span class="number">0x8</span>(%rbp)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="i-i"><a href="#i-i" class="headerlink" title="i += i++;"></a>i += i++;</h4><p>　<strong>i += i++;</strong> $\Longleftrightarrow$ <strong>i = i + i++;</strong></p>
<ul>
<li>Java</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确定左操作数：此处 i=0</span></div><div class="line">load i to reg1</div><div class="line"> </div><div class="line"><span class="comment">// 确定右操作数，(i++) 的值为 i：此处 i=0</span></div><div class="line">load i to reg2</div><div class="line"><span class="comment">// 自增操作（++）是确定右操作数需要完成的操作</span></div><div class="line">reg3 = reg2 + <span class="number">1</span></div><div class="line">write reg3 to i</div><div class="line"> </div><div class="line"><span class="comment">// 赋值操作（可以被优化）：此处 i=0</span></div><div class="line">reg4 = reg1 + reg2</div><div class="line">write reg4 to i</div><div class="line"><span class="comment">// 此处 i=0</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>C/C++</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 确定右操作数，++ 优先级比 + 高</span></div><div class="line"><span class="comment">// right of +：(i++) 的值为 i，此处 i=0</span></div><div class="line">load i to reg1</div><div class="line"><span class="comment">// 自增操作（++）是确定右操作数需要完成的操作</span></div><div class="line">reg2 = reg1 + <span class="number">1</span></div><div class="line">write reg2 to i</div><div class="line"> </div><div class="line"><span class="comment">// left of +：此处 i=1</span></div><div class="line">load i to reg3</div><div class="line"> </div><div class="line"><span class="comment">// 确定左操作数：此处 i=1</span></div><div class="line"> </div><div class="line"><span class="comment">// 赋值操作（可以被优化）：此处 i=1</span></div><div class="line">reg4 = reg3 + reg1</div><div class="line">write reg4 to i</div><div class="line"><span class="comment">// 此处 i=1</span></div></pre></td></tr></table></figure>
<ul>
<li><font color="red">注：上述这种执行顺序并不是唯一的执行顺序，但可以说是编译器最常采用的优化方案，在 <strong>g++</strong> 上正是这种情形</font>。</li>
</ul>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://www.clarkok.com/blog/2015/02/28/i-i-C-C-%E7%9A%84%E5%BA%8F%E5%88%97%E7%82%B9/">Clarkok: i = i++; C/C++ 的序列点</a></li>
<li><a href="https://stackoverflow.com/questions/23553358/why-does-this-expression-i-i-differs-from-java-and-c">Stackoverflow: Why does this expression i+=i++ differs from Java and C?</a></li>
<li><a href="https://stackoverflow.com/questions/6457130/pre-post-increment-operator-behavior-in-c-c-java-c-sharp">Stackoverflow: Pre &amp; post increment operator behavior in C, C++, Java, &amp; C#</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j&amp;lt;&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; j++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  i = i++;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// what&#39;s the value of i ?&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
      <category term="Java" scheme="http://durant35.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CMake 查找库: find_package vs pkg_check_modules</title>
    <link href="http://durant35.github.io/2017/07/14/tool_CMake_find_package$pkg_check_module/"/>
    <id>http://durant35.github.io/2017/07/14/tool_CMake_find_package$pkg_check_module/</id>
    <published>2017-07-14T13:45:13.000Z</published>
    <updated>2017-07-14T14:27:45.539Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文介绍 CMake 中两种查找库的方式：<strong>find_package</strong> 以及 <strong>pkg_check_modules</strong> 的用法与区别。<a id="more"></a></p>
<h4 id="find-package"><a href="#find-package" class="headerlink" title="find_package"></a><strong>find_package</strong></h4><ul>
<li>如果编译软件使用了外部库，事先并不知道它的头文件和链接库的位置，得在编译和链接命令中加上包含它们的查找路径，CMake 使用 <code>find_package</code> 命令来解决这个问题。</li>
<li>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FIND_PACKAGE</span>( &lt;name&gt; [version] [EXACT] [QUIET] [NO_MODULE] [ [ REQUIRED | COMPONENTS ] [ componets... ] ] )</div></pre></td></tr></table></figure>
<ul>
<li>这条命令执行后，CMake 会到变量<code>CMAKE_MODULE_PATH</code> 指示的目录下查找文件 <strong>Findname.cmake</strong> 并执行；</li>
<li>只要找到包，就会定义下面这些变量（都在 <strong>Findname.cmake</strong> 文件中设置）：</li>
</ul>
</li>
<li>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;NAME&gt;_FOUND</div><div class="line">&lt;NAME&gt;_INCLUDE_DIRS <span class="keyword">or</span> &lt;NAME&gt;_INCLUDES</div><div class="line">&lt;NAME&gt;_LIBRARIES <span class="keyword">or</span> &lt;NAME&gt;_LIBRARIES <span class="keyword">or</span> &lt;NAME&gt;_LIBS</div><div class="line">&lt;NAME&gt;_DEFINITIONS</div></pre></td></tr></table></figure>
<ul>
<li>要使用库<code>name</code>，我们在顶层目录中的 <strong>CMakeLists.txt</strong> 文件中，检查变量<code>NAME_FOUND</code> 来确定包是否被找到（大部分包的这些变量中的包名是全大写的，有些包则使用包的实际大小写）</li>
<li>如果找到这个包，我们用<code>NAME_INCLUDE_DIRS</code>调用 <strong>include_directories()</strong> 命令，用<code>NAME_LIBRARIES</code>调用 <strong>target_link_libraries()</strong> 命令。</li>
</ul>
</li>
</ul>
<h4 id="pkg-check-modules"><a href="#pkg-check-modules" class="headerlink" title="pkg_check_modules"></a><strong>pkg_check_modules</strong></h4><ul>
<li><a href="https://stackoverflow.com/questions/25959972/what-is-the-difference-between-find-package-and-pkg-search-module">what is the difference between find_package and pkg_search_module</a><blockquote>
<p>　　<strong>find_package</strong> is CMake’s very own mechanism for solving the same problem. For this to work you either need a CMake find script for the requested library (CMake already ships with a couple of those, but you can easily write your own) or alternatively a package config script provided by the requested library itself. In either case you might have to adjust your <code>CMAKE_MODULE_PATH</code> for CMake to be able to find the respective script.<br>　　<strong>pkg_search_module</strong> uses the <strong>pkg-config tool</strong> to determine the location of the requested library. This is mostly useful on systems where <strong>pkg-config</strong> is already in use, so you do not need to replicate all the information for CMake. Note that this approach has potential portability issues, since <font color="blue">it requires pkg-config to be setup correctly on the build machine</font>.</p>
</blockquote>
</li>
<li><strong>pkg_check_modules</strong> 是 CMake 自己的 <strong>pkg-config 模块</strong> 的一个用来简化的封装：你不用再检查 CMake 的版本，加载合适的模块，检查是否被加载，等等，参数和传给 <strong>find_package</strong> 的一样：先是待返回变量的前缀，然后是包名（pkg-config 的）。这样就定义了<code>&lt;prefix&gt;_INCLUDE_DIRS</code>和其他的这类变量，后续的用法就与 <strong>find_package</strong> 一致。</li>
<li><strong>pkg_check_modules</strong> 实质上是检测系统中的 <strong>pkg-config</strong> 是否存在制定的 <strong>.pc</strong> 文件。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文介绍 CMake 中两种查找库的方式：&lt;strong&gt;find_package&lt;/strong&gt; 以及 &lt;strong&gt;pkg_check_modules&lt;/strong&gt; 的用法与区别。
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="小工具" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="CMake" scheme="http://durant35.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>ROS launch file: &lt;arg&gt; vs &lt;param&gt; vs &lt;rosparam&gt;</title>
    <link href="http://durant35.github.io/2017/07/14/ROS_%3Carg%3E$%3Cparam%3E$%3Crosparam%3E/"/>
    <id>http://durant35.github.io/2017/07/14/ROS_&lt;arg&gt;$&lt;param&gt;$&lt;rosparam&gt;/</id>
    <published>2017-07-14T12:18:03.000Z</published>
    <updated>2017-08-16T02:02:05.461Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文介绍在 ROS 的 launch 文件中经常被使用到的三个与参数设置有关的标签 <code>&lt;arg&gt;</code>、<code>&lt;param&gt;</code>、<code>rosparam</code>。<a id="more"></a>
　　</p>
<h4 id="lt-arg-gt"><a href="#lt-arg-gt" class="headerlink" title="$\lt arg \gt$"></a>$\lt arg \gt$</h4><ul>
<li>声明 argument</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"arg-name"</span> <span class="attr">...</span>/&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>指定 argument 的值</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># 在命令行赋值</div><div class="line">roslaunch package-name launch-file-name arg-name:=arg-value</div><div class="line"># 在声明 argument 时赋值</div><div class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"arg-name"</span> <span class="attr">default</span>=<span class="string">"arg-value"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"arg-name"</span> <span class="attr">value</span>=<span class="string">"arg-value"</span> /&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>default</strong> 和 <strong>value</strong> 的区别在于，在命令行中赋值的参数可以覆盖 default，但是不能重写 value 的值。</li>
</ul>
</li>
<li>获取变量值</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(arg arg-name)</div></pre></td></tr></table></figure>
<ul>
<li>我们可以通过 $arg$ 来使用该变量，<strong>roslaunch</strong> 会用给定的参数 $arg-name$ 的值替换整个表达式的值。</li>
</ul>
</li>
<li>将 argument 值传递给 <strong>included launch 文件</strong></li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">"path-to-file"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"arg-name"</span> <span class="attr">value</span>=<span class="string">"arg-value"</span> /&gt;</span></div><div class="line">  ...</div><div class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li><font color="red">注意：</font>若 launch 文件及其 include 的 launch 文件出现相同的 argument，通过如下方式传递给 include launch 文件</li>
</ul>
</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">"arg-name"</span> <span class="attr">value</span>=<span class="string">"$(arg arg-name)"</span> /&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>第一个 <strong>arg-name</strong> 表示 include launch 文件中的变量；第二个则表示当前 launch 文件中的变量 $\Longrightarrow$ 指定的变量在当前 launch 文件以及 included launch 文件中都有相同的值。</li>
</ul>
</li>
</ul>
<h4 id="lt-rosparam-gt"><a href="#lt-rosparam-gt" class="headerlink" title="$\lt rosparam \gt$"></a><a href="http://wiki.ros.org/roslaunch/XML/rosparam">$\lt rosparam \gt$</a></h4><ul>
<li><font color="blue">尽管 argument（变量）和 parameter（参数）优势可互换，但二者在 ROS 中的意义完全不同：<strong>parameters</strong> 是 ROS 系统使用的数值，存在 parameter server 上，nodes 可通过<code>ros::param::get</code>函数编程得到，用户可通过<code>rosparam</code>命令获取；与之不同，<strong>arguments</strong> 仅在 launch 文件内部有意义，nodes 不能直接获取它们的值</font></li>
<li>前面介绍的<code>&lt;arg&gt;</code>用于设置变量；接下来介绍的两个<code>&lt;param&gt;</code>和<code>&lt;rosparam&gt;</code>标签用于设置参数。</li>
<li>参数访问有三种方式<ul>
<li>命令行：<code>rosparam set</code>、<code>rosparam get</code></li>
<li>launch 文件：<code>&lt;param&gt;</code>、<code>&lt;rosparam&gt;</code></li>
<li>API<ul>
<li>roscpp: <code>ros::param::set</code>、<code>ros::param::get</code></li>
<li>rospy: <code>set_param</code>、<code>set_param</code></li>
</ul>
</li>
</ul>
</li>
<li><code>&lt;rosparam&gt;</code> 通过配置文件<code>*.yaml</code>文件加载参数</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">"$(find navigation_launch)/config/costmap_common_params.yaml"</span> <span class="attr">command</span>=<span class="string">"load"</span> <span class="attr">ns</span>=<span class="string">"global_costmap"</span> /&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>&lt;rosparam&gt;</code> 其他常见方式</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">"delete"</span> <span class="attr">param</span>=<span class="string">"my/param"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">param</span>=<span class="string">"a_list"</span>&gt;</span>[1, 2, 3, 4]<span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">rosparam</span>&gt;</span></div><div class="line">  a: 1</div><div class="line">  b: 2</div><div class="line"><span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="lt-param-gt"><a href="#lt-param-gt" class="headerlink" title="$\lt param \gt$"></a>$\lt param \gt$</h4><ul>
<li><code>&lt;param&gt;</code>更像是 define 宏，必须在本地 launch 文件中赋值，无法用于在 launch 文件中获取命令中的参数（但可以通过下面介绍 <strong>rosrun</strong> 方式），通过以下方式接收和传递。定义的参数均会保留在 ROS 参数服务器(PARAMETERS)中，该参数会被节点(NODES)使用进行节点配置。</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param-name-1"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">....</span>&gt;</span></div><div class="line">     <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"param-name-2"</span> <span class="attr">value</span>=<span class="string">"..."</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></div><div class="line">...</div><div class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></div></pre></td></tr></table></figure>
<ul>
<li>第一个参数 <strong>param-name-1</strong> 是整个 launch 全局（global）有效；第二个参数 <strong>param-name-2</strong> 相对（relative）节点局部（private）有效。</li>
</ul>
</li>
<li><strong>rosrun</strong> 本身的设计是可以让使用者直接修改节点内的参数，通过以下的方式：</li>
<li>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rosrun package-name node-name _param-name:=param-value</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><a href="http://answers.ros.org/question/37916/when-to-use-param-and-rosparam-on-launch-file/">ROS ANSWERS: When to use param and rosparam on launch file?</a><blockquote>
<p>　　I believe that the main difference is that <font color="red"><code>&lt;param&gt;</code> may be used to set a single command on the ROS parameter server, while <code>&lt;rosparam&gt;</code> can be used to evaluate groups of parameters</font>.<br>　　So, in the cases above, <code>&lt;param&gt;</code> is setting a single parameter, and that parameter is an entire URDF file. The <code>&lt;rosparam&gt;</code> tag is reading in the rosparam yaml format from within the launch file.<br>　　<font color="red">The value set by the <code>&lt;param&gt;</code> tag may only be a string, int, bool, or double</font>, which may be set through the xml attribute value, or by reading in from a text file, bin file, or the output of a command line command.<br>　　<font color="red">The value set by the <code>&lt;rosparam&gt;</code> tag is most commonly a batch of related parameters</font>, read in from a YAML file (or from the output of rosparam dump). You can think of it as a programmatic way to access the functionality of rosparam from a launch file. </p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文介绍在 ROS 的 launch 文件中经常被使用到的三个与参数设置有关的标签 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt;、&lt;code&gt;rosparam&lt;/code&gt;。
    
    </summary>
    
      <category term="软硬兼施" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
      <category term="ROS" scheme="http://durant35.github.io/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/ROS/"/>
    
    
      <category term="ROS" scheme="http://durant35.github.io/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>hexo：告别多说，拥抱 Disqus</title>
    <link href="http://durant35.github.io/2017/07/14/hexo_DisqusInsteadofDuoshuo/"/>
    <id>http://durant35.github.io/2017/07/14/hexo_DisqusInsteadofDuoshuo/</id>
    <published>2017-07-14T06:54:28.000Z</published>
    <updated>2017-07-14T11:27:44.942Z</updated>
    
    <content type="html"><![CDATA[<p>　　首先说说，换了 Disqus 之后的体验吧，除了需要翻墙外，都挺好的。<font color="blue">最重要的是，以前一直希望多说有的邮件提醒（一直没有），Disqus 自带就有这个功能</font>。anyway，反正多说已经阵亡了，选择 Disqus 还挺不错的。<br>　　怎么从多说迁移到 Disqus 呢？配置上很简单，主要难题是如何迁移原先多说评论的数据。<a id="more"></a></p>
<h4 id="配置很简单"><a href="#配置很简单" class="headerlink" title="配置很简单"></a>配置很简单</h4><ul>
<li>只需要修改 <code>./themes/&lt;对应主题&gt;/</code>下的 <strong>_config.yml</strong> 文件即可，通过注释掉<code>#on: true</code>即可关闭多说。</li>
<li>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="attr">disqus:</span> </div><div class="line"><span class="attr">  on:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  shortname:</span> ？？？</div><div class="line">  <span class="comment"># https://help.disqus.com/customer/en/portal/articles/466208-what-s-a-shortname-</span></div><div class="line">  <span class="comment"># It is unnecessary to enable disqus here if </span></div><div class="line">  <span class="comment"># you have set "disqus_shortname" in your site's "_config.yml" </span></div><div class="line"> </div><div class="line"><span class="attr">duoshuo:</span> </div><div class="line">  <span class="comment">#on: true</span></div><div class="line"><span class="attr">  domain:</span> ？？？</div><div class="line">  <span class="comment"># 是否开启多说评论，http://duoshuo.com/create-site/</span></div><div class="line">  <span class="comment"># 使用上面网址登陆你的多说，然后创建站点，在 domain 中填入你设定的域名前半部分</span></div><div class="line">  <span class="comment"># http://&lt;要填的部分&gt;.duoshuo.com (domain只填上&lt;&gt;里的内容，不要填整个网址)</span></div></pre></td></tr></table></figure>
<ul>
<li>显然，在此之前，你需要注册一个 Disqus 账号。</li>
</ul>
</li>
</ul>
<h4 id="迁移有办法"><a href="#迁移有办法" class="headerlink" title="迁移有办法"></a>迁移有办法</h4><ul>
<li>数据迁移的步骤：从多说导出数据→数据格式转换（Disqus可用数据格式）→向 Disqus 导入数据。</li>
<li>参考 <a href="https://github.com/JamesPan/duoshuo-migrator#duoshuo2disqus">Github: JamesPan/duoshuo-migrator</a> 即可。</li>
<li>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install lxml</div><div class="line">python duoshuo-migrator.py -i duoshuo_export.json  -o disqus.xml</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://blog.jamespan.me/2015/04/18/goodbye-duoshuo">JAMES PAN’S BLOG：告别多说，拥抱 Disqus</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　首先说说，换了 Disqus 之后的体验吧，除了需要翻墙外，都挺好的。&lt;font color=&quot;blue&quot;&gt;最重要的是，以前一直希望多说有的邮件提醒（一直没有），Disqus 自带就有这个功能&lt;/font&gt;。anyway，反正多说已经阵亡了，选择 Disqus 还挺不错的。&lt;br&gt;　　怎么从多说迁移到 Disqus 呢？配置上很简单，主要难题是如何迁移原先多说评论的数据。
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="Hexo" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://durant35.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>32-bit program on 64-bit OS &amp; 64-bit program on 32-bit OS</title>
    <link href="http://durant35.github.io/2017/07/14/programPearls_32-bit%20program%20on%2064-bit%20OS%20$%2064-bit%20program%20on%2032-bit%20OS/"/>
    <id>http://durant35.github.io/2017/07/14/programPearls_32-bit program on 64-bit OS $ 64-bit program on 32-bit OS/</id>
    <published>2017-07-14T03:51:14.000Z</published>
    <updated>2017-07-14T11:39:17.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="32-bit-program-on-64-bit-OS"><a href="#32-bit-program-on-64-bit-OS" class="headerlink" title="32-bit program on 64-bit OS"></a>32-bit program on 64-bit OS</h4><blockquote>
<p><a href="https://www.viva64.com/en/k/0004/">Is it possible to run 64-bit applications in a 32-bit OS?</a></p>
</blockquote>
<p>　　还是有一定的现实意义，比如经常有一些开源库只有 32-bit 版本，为了对其进行构建，需要在 64-bit 系统上配置 32-bit 环境（通常是 32-bit 的 C/C++ 基本库）。<a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo dpkg --add-architecture i386</div><div class="line">sudo apt-get install multiarch-support</div></pre></td></tr></table></figure></p>
<h4 id="64-bit-program-on-32-bit-OS"><a href="#64-bit-program-on-32-bit-OS" class="headerlink" title="64-bit program on 32-bit OS"></a>64-bit program on 32-bit OS</h4><blockquote>
<p><a href="https://www.viva64.com/en/k/0004/">Is it possible to run 64-bit applications in a 32-bit OS?</a></p>
</blockquote>
<p>　　不太现实，也没多大意义的一件事。不过可以通过虚拟化技术实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;32-bit-program-on-64-bit-OS&quot;&gt;&lt;a href=&quot;#32-bit-program-on-64-bit-OS&quot; class=&quot;headerlink&quot; title=&quot;32-bit program on 64-bit OS&quot;&gt;&lt;/a&gt;32-bit program on 64-bit OS&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.viva64.com/en/k/0004/&quot;&gt;Is it possible to run 64-bit applications in a 32-bit OS?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　还是有一定的现实意义，比如经常有一些开源库只有 32-bit 版本，为了对其进行构建，需要在 64-bit 系统上配置 32-bit 环境（通常是 32-bit 的 C/C++ 基本库）。
    
    </summary>
    
      <category term="技术留档" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/"/>
    
      <category term="系统" scheme="http://durant35.github.io/categories/%E6%8A%80%E6%9C%AF%E7%95%99%E6%A1%A3/%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0023] 秋招华为在线笔试</title>
    <link href="http://durant35.github.io/2017/07/13/Algorithms_OnlineJudge4Huawei2017/"/>
    <id>http://durant35.github.io/2017/07/13/Algorithms_OnlineJudge4Huawei2017/</id>
    <published>2017-07-13T00:55:22.000Z</published>
    <updated>2017-07-14T09:27:57.068Z</updated>
    
    <content type="html"><![CDATA[<p>　　昨晚华为在线笔试，三道编程题，结果倒在第二题上，刷了两题半，没能 AK。</p>
<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><p>　第一题是括号（“(”、“[”、“{”）匹配，想法也比较简单，就通过栈<code>stack</code>模拟，遇到开括号推入堆栈，每当遇到闭括号（“)”、“]”、“}”），就进行配对，满足配对就将栈顶的开括号弹出。假如最终的栈是空的，说明输入表达式不存在括号或者括号能够完全匹配。<br>　需要注意的是：①满足配对并不是<code>stack.top()==inputStr[currentIdx]</code>，而需要分上述三种括号进行一一配对；②当存在闭括号，但栈为空或者栈顶元素并不是配对的开括号，已经能够证明输入表达式括号不匹配了，此时可以跳出循环。<a id="more"></a></p>
<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><ul>
<li>问题背景是打印机任务打印，给一个任务打印队列，不过是每个任务对应的优先级的一个优先级队列<code>int tasksPriority[MAX_TASK_NUM];</code>，每个任务通过其在优先级队列的下标唯一标识<code>0...tasksNum-1</code>；此外还有补充条件：任务的优先级只有 1~9 这九种，优先级数值越高优先级越大。要求：任务打印时，假如等待队列中有优先级更大的，该任务不能被打印，需要重新回到队列中（重新插入队尾），求通过下标标识的一个任务打印队列的最终打印顺序。</li>
<li>一开始的想法是，用一位数组<code>tasksIdx[]</code>维护一个优先级和任务下标标识的对应关系，因为优先级只有 1~9，可以开一个大小为 10 的数组，与<code>tasksIdx[1...9]</code>对应；打印顺序即是优先级的一个由大到小排序，通过<code>sort(vector.begin(), vector.end(), greater&lt;int&gt;())</code>实现，需要先将<code>tasksPriority[]</code>通过<code>vector.assign(tasksPriority, tasksPriority+tasksNum)</code>转为 vector。排序后对应的优先级下标<code>tasksIdx[tasksPriority[0...tasksNum-1]]</code>顺序即为最终的打印顺序。</li>
<li>可惜的是，第一种想法并没有考虑到一个优先级可能有多个重复任务。现在想想，这种应该维护一个<code>vector&lt;vector&lt;int&gt;&gt; tasksIdx(10, vector&lt;int&gt;())</code>的二维向量，按照优先级队列中的先后顺序插入在每个优先级下标对应的那个向量中。不过，就需要跳过降序排列的优先级队列中重复的优先级。</li>
<li>另一种想法，因为优先级和任务下标的这种关系，想到用<code>pair&lt;int, int&gt;</code>保存（<code>first</code>记录优先级，<code>second</code>记录任务下标），又因为排序，所以想到了优先级队列<code>priority_queue</code>，以优先级<code>first</code>作为键值，可怕的是，<code>priority_queue</code>驾驭不了那种存在多个键值相同的情形，不能保证顺序的稳定：相同优先级的多个任务，其打印顺序与其在输入的优先级队列中的顺序一致。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> cmp &#123;</div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span> </span>&#123;</div><div class="line">    <span class="comment">// fitst: tasksPriority[]</span></div><div class="line">    <span class="comment">// second: tasksIdx[]</span></div><div class="line">    <span class="keyword">return</span> a.first&gt;b.first;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, cmp&gt; tasksQueue;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>最后，现在想想，似乎应该回到问题的本质：其实就是一种稳定排序吧。所以想到了 Bubble Sort；因为交换的存在，干脆将需要进行冒泡排序的打印任务优先级队列与对应的打印任务下标队列（新建这样一个队列）通过二者下标绑定，交换优先级队列位置的时候，也将下标队列对应位置进行交换。最终得到排好序的优先级队列满足打印要求，下标队列也能与之一一对应，下标队列即为最终的打印顺序。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_TASK_NUM=<span class="number">100</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOrder</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> input[], <span class="keyword">int</span> len, <span class="keyword">int</span> output[])</span> </span>&#123;</div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input_(len);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx&lt;len; idx++) &#123;</div><div class="line">    output[idx] = idx;</div><div class="line">    input_[idx] = input[idx];</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">bool</span> isSorted;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</div><div class="line">    isSorted = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=len<span class="number">-1</span>; j&gt;i; j--) &#123;</div><div class="line">      <span class="keyword">if</span>(input_[j] &gt; input_[j<span class="number">-1</span>]) &#123;</div><div class="line">        isSorted = <span class="literal">false</span>;</div><div class="line">        <span class="keyword">int</span> tmpPriority = input_[j];</div><div class="line">        input_[j] = input_[j<span class="number">-1</span>];</div><div class="line">        input_[j<span class="number">-1</span>] = tmpPriority;</div><div class="line"> </div><div class="line">        <span class="keyword">int</span> tmpIdx = output[j];</div><div class="line">        output[j] = output[j<span class="number">-1</span>];</div><div class="line">        output[j<span class="number">-1</span>] = tmpIdx;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(isSorted) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">string</span> inputStr;</div><div class="line"> </div><div class="line">  <span class="keyword">while</span>(getline(<span class="built_in">cin</span>, inputStr)) &#123;</div><div class="line">    <span class="comment">// cout &lt;&lt; inputStr &lt;&lt; endl;</span></div><div class="line">    <span class="keyword">int</span> strLen = inputStr.length();</div><div class="line">    <span class="keyword">int</span> taskNum = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> tasks[MAX_TASK_NUM];</div><div class="line">    <span class="keyword">int</span> printTasks[MAX_TASK_NUM];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;strLen; i++) &#123;</div><div class="line">      <span class="comment">// cout &lt;&lt; inputStr[i] &lt;&lt; endl;</span></div><div class="line">      <span class="keyword">if</span>(inputStr[i]&gt;<span class="string">'0'</span> &amp;&amp; inputStr[i]&lt;=<span class="string">'9'</span>) &#123;</div><div class="line">        tasks[taskNum++] = inputStr[i] - <span class="string">'0'</span>;</div><div class="line">        <span class="comment">// cout &lt;&lt; inputStr[i] - '0' &lt;&lt; endl;</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">if</span>(taskNum&gt;=<span class="number">1</span>) &#123;</div><div class="line">      printOrder(tasks, taskNum, printTasks);</div><div class="line">      <span class="built_in">cout</span> &lt;&lt; printTasks[<span class="number">0</span>];</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;taskNum; i++) &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">", "</span> &lt;&lt; printTasks[i];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的是：①冒泡排序原理的正确实现，只有只比较相邻的元素，才能保证排序的稳定性；②输入输出格式的要求，输入格式“1, 1, 1, 1, 1”，除了上面这种获取方式，也可以通过<code>cin &gt;&gt; int &gt;&gt; char</code>获取，不过还得注意<code>cin</code>的空格自动结束，可能还是比上面的方式麻烦；输出格式的满足还是比较简单的。</li>
</ul>
</li>
</ul>
<h4 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h4><p>　第三题是输入平安果矩阵，即一个 row×col 的二维矩阵<code>appleGrids</code>，只不过矩阵的每个元素<code>appleGrids[rowIdx][colIdx]</code>表示当前格子中平安果数目；要求只能在二维网格中向下或者向右移动，求从网格左上角移动到网格右下角能收获的平安果的最大数目。<br>　显然通过 DP 可以很快速求解，<code>dp[rowIdx][colIdx]</code>表示从网格左上角移动到格子<code>[rowIdx][colIdx]</code>能收获的平安果最大数目，显然<code>dp[row-1][col-1]</code>便是最终的答案；又由于只能向下或者向右移动，动态转移方程，直观说就是<code>dp</code>二维表格从左到右（<code>[rowIdx-1][colIdx]</code>→<code>[rowIdx][colIdx]</code>）、从上到下（<code>[rowIdx][colIdx-1]</code>→<code>[rowIdx][colIdx]</code>）的填表过程，易知这个转移方程：$$ dp[rowIdx][colIdx] = max(dp[rowIdx-1][colIdx], dp[rowIdx][colIdx-1]) + appleGrids[rowIdx][colIdx] $$<br>　需要注意的是：①<code>dp[0][0]</code>、<code>dp[0][1...col-1]</code>、<code>dp[1...row-1][0]</code>需要单独初始化；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> (a&gt;b?a:b); &#125;</div><div class="line"> </div><div class="line"><span class="comment">// dp[i][j]: the largest collected apple number reach appleGrids[i][j]</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">0</span>));</div><div class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = appleGrids[<span class="number">0</span>][<span class="number">0</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> colIdx=<span class="number">1</span>; colIdx&lt;col; colIdx++) &#123;</div><div class="line">  dp[<span class="number">0</span>][colIdx] = dp[<span class="number">0</span>][colIdx<span class="number">-1</span>] + appleGrids[<span class="number">0</span>][colIdx];</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> rowIdx=<span class="number">1</span>; rowIdx&lt;row; rowIdx++) &#123;</div><div class="line">  dp[rowIdx][<span class="number">0</span>] = dp[rowIdx<span class="number">-1</span>][<span class="number">0</span>] + appleGrids[rowIdx][<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> rowIdx=<span class="number">1</span>; rowIdx&lt;row; rowIdx++) &#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> colIdx=<span class="number">1</span>; colIdx&lt;col; colIdx++) &#123;</div><div class="line">    <span class="comment">// max(up-&gt;down, left-&gt;right)</span></div><div class="line">    dp[rowIdx][colIdx] = max(dp[rowIdx<span class="number">-1</span>][colIdx], dp[rowIdx][colIdx<span class="number">-1</span>]) + appleGrids[rowIdx][colIdx];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　②二维平安果矩阵如何初始化<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> row, col;</div><div class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; row &gt;&gt; col) &#123;</div><div class="line">  <span class="keyword">if</span>(row&gt;<span class="number">1</span> &amp;&amp; col&gt;<span class="number">1</span>) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; appleGrids(row, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col, <span class="number">-1</span>));</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> rowIdx=<span class="number">0</span>; rowIdx&lt;row; rowIdx++) &#123;</div><div class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> colIdx=<span class="number">0</span>; colIdx&lt;col; colIdx++) &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; appleGrids[rowIdx][colIdx];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　昨晚华为在线笔试，三道编程题，结果倒在第二题上，刷了两题半，没能 AK。&lt;/p&gt;
&lt;h4 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h4&gt;&lt;p&gt;　第一题是括号（“(”、“[”、“{”）匹配，想法也比较简单，就通过栈&lt;code&gt;stack&lt;/code&gt;模拟，遇到开括号推入堆栈，每当遇到闭括号（“)”、“]”、“}”），就进行配对，满足配对就将栈顶的开括号弹出。假如最终的栈是空的，说明输入表达式不存在括号或者括号能够完全匹配。&lt;br&gt;　需要注意的是：①满足配对并不是&lt;code&gt;stack.top()==inputStr[currentIdx]&lt;/code&gt;，而需要分上述三种括号进行一一配对；②当存在闭括号，但栈为空或者栈顶元素并不是配对的开括号，已经能够证明输入表达式括号不匹配了，此时可以跳出循环。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
      <category term="HUAWEI" scheme="http://durant35.github.io/tags/HUAWEI/"/>
    
  </entry>
  
  <entry>
    <title>密码学：DES、3DES、AES</title>
    <link href="http://durant35.github.io/2017/07/11/programPearls_DES$3DES$AES/"/>
    <id>http://durant35.github.io/2017/07/11/programPearls_DES$3DES$AES/</id>
    <published>2017-07-11T10:02:16.000Z</published>
    <updated>2017-07-14T09:21:43.589Z</updated>
    
    <content type="html"><![CDATA[<p>　　加密方法可以分为两大类：一类是对称密码体制，又称单钥或私钥密码体制（private key cryptography）；还有一类是非对称密码体制，也称双钥或公开密钥体制（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。<br>　　在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要，一旦秘钥泄露，密文也就被破解了；在双钥加密的情况下，秘钥有两把，一把是公开的公钥，还有一把是不公开的私钥，公钥与私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。此外，①同时生成公钥和私钥应该是相对比较容易的：所有的公钥、私钥对都不同，用公钥可以解开私钥加密的信息，反之用私钥也可以解开公钥加密的信息；但是②从公钥推算出私钥，应该是很困难或者是不可能的。<br>　　目前，通用的单钥加密算法有 DES（Data Encryption Standard），通用的双钥加密算法为 RSA（Rivest-Shamir-Adleman），本文主要介绍三种常用的单钥加密算法：DES、3DES（Triple DES） 以及 AES（Advanced Encryption Standard）。<a id="more"></a></p>
<h3 id="DES-算法"><a href="#DES-算法" class="headerlink" title="DES 算法"></a>DES 算法</h3><ul>
<li>DES 算法简介<ul>
<li>DES 算法为密码体制中的对称密码体制，又被称为美国数据加密标准，是 1972 年美国 IBM 公司研制的对称密码体制加密算法；</li>
<li>DES 是一种用 56 位密钥来加密 64 位数据的方法，密钥长度为 56 位，明文按 64 位进行分组，将分组后的明文组和 56 位的密钥按位替代或交换的方法形成密文组；</li>
<li>DES 加密算法特点：分组比较短、密钥太短、秘钥生命周期短，运行速度较慢。</li>
</ul>
</li>
<li>DES 工作的基本原理<ul>
<li>入口参数有三个：key、data、mode<ul>
<li>key：加密解密使用的密钥</li>
<li>data：加密解密的数据</li>
<li>mode：工作模式<center><img src="/img/programPearls/encryption/DES_Diagram.jpg" width="320px" alt="" /></center></li>
</ul>
</li>
<li>当模式为加密模式时，明文按照 64 位进行分组，形成明文组，key 用于对数据加密。<ul>
<li>把输入的 64 位数据块经过初始置换按位重新组合，并把输出 $L_0$、$R_0$ 两部分，每部分各长32 位；</li>
<li>然后 $R_0$ 与第一轮子密钥 $K_1$ 进行 $f(R_0, K_1)$ 运算，运算结果再与 $L_0$ 进行按位异或运算，运行结果交换为下一轮的 $R_1$，$R_0$ 交换作为下一轮的 $L_1$；下一轮同样进行 $f(R_i, K_i)$ 运算，以此类推共进行 16 轮；</li>
<li>最后一轮不用进行交换，最后进行逆初始置换，即为密文输出。</li>
</ul>
</li>
<li>子密钥 $K_i$（48 bit）生成算法（概述）<ul>
<li>初始 key 值为 64 位，但 DES 算法规定，其中第 8、16、…、64 位是奇偶校验位，不参与 DES 运算，故 key 实际可用位数便只有 56 位；</li>
<li>经过缩小选择换位表 1 的变换后，key 的位数由 64 位变成了 56 位，此 56 位分为 $C_0$、$D_0$ 两部分，各 28 位；分别进行第 1 次循环左移，得到 $C_1$、$D_1$，将 $C_1$（28位）、$D_1$（28位）合并得到 56 位，再经过缩小选择换位 2，从而便得到了密钥 $K_0$（48位）；</li>
<li>以此类推，便可得到 $K_1$、$K_2$、…、$K_{15}$，不过需要注意的是，16 次循环左移对应的左移位数要依据下述规则进行：循环左移位数 $1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1$。</li>
</ul>
</li>
<li>当模式为解密模式时，key 用于对数据解密<ul>
<li>DES 的解密过程与加密一样，区别仅仅在于第一次迭代时用子密钥 $K_{15}$、第二次 $K_{14}$、…，最后一次用 $K_0$，算法本身并没有任何变化。</li>
</ul>
</li>
<li>在通信网络的两端，双方约定一致的 key，在通信的源点用 key 对核心数据进行 DES 加密，然后以密文形式在公共通信网（如电话网）中传输到通信网络的终点，数据到达目的地后，用同样的 key 对密文数据进行解密，便再现了明码形式的核心数据。</li>
<li>实际运用中，密钥只用到了 64 位中的 56 位，这样才具有高的安全性。<br><br/></li>
</ul>
</li>
</ul>
<h4 id="密钥的产生：子密钥-K-i-（48-bit）生成算法"><a href="#密钥的产生：子密钥-K-i-（48-bit）生成算法" class="headerlink" title="密钥的产生：子密钥 $K_i$（48 bit）生成算法"></a>密钥的产生：子密钥 $K_i$（48 bit）生成算法</h4><p>　　DES 含有 16 轮非线性变换，每一轮变换都用一个 48bits 的子密钥，共需 16 个不同的 48bits 的子密钥。一个 64bits 的外部密钥经过以下密钥产生器产生 16 个 48bits 的子密钥。</p>
<p><center><img src="/img/programPearls/encryption/DES_KiGenerate.png" width="540px" alt="" /></center></p>
<ul>
<li>奇偶校验：64 位 $K$ 中第 8、16、…、64 位是奇偶校验位。</li>
<li>置换 1：作用是将 56bits 密钥 $K’$ 各位上的数按规定方式进行换位，置换后的 56bits 分别存到两个 28bits 的寄存器 $C_0$、$D_0$ 中，如下图：<br><center><img src="/img/programPearls/encryption/DES_ReplacementOne.png" width="460px" alt="" /></center><ul>
<li>$C_0$ 的各位依次为原密钥中的第 57、49、41、…、36 位，$D_0$ 的各位依次为原密钥中的第 63、55、47、…、4 位。</li>
</ul>
</li>
<li>循环左移寄存器：每个循环左移寄存器都有 28bits，加密时，循环寄存器 $C_{i+1}$、$D_{i+1}$ 的内容是将循环寄存器 $C_i$、$D_i$ 的内容分别左移 1 至 2 位得到的，各级寄存器移位的比特数如下表：<center><img src="/img/programPearls/encryption/DES_LeftShiftTable.png" width="540px" alt="" /></center></li>
<li>压缩置换：从 56bits 内容中选出 48bits，产生 16 轮加密的 16 个子密钥，压缩置换表如下：<br><center><img src="/img/programPearls/encryption/DES_CompressionReplacementTable.png" width="340px" alt="" /></center><ul>
<li>压缩置换表中的数字表示循环寄存器对 $(C_i, D_i)$ 的比特序号，读取顺序是从左到右、从上到下，即 $D_i$ 的第 14、17、11、…、32位分别置换成 $C_i$ 的第 1、2、3、…、48位。</li>
</ul>
</li>
<li>具体实现如下<code>void initKey(const char key[8])</code>函数。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 置换 1 置换表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> REPLACE_ONE_TABLE[] = &#123;</div><div class="line">  <span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">1</span>,</div><div class="line">  <span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,</div><div class="line">  <span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,</div><div class="line">  <span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,</div><div class="line">  <span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,</div><div class="line">  <span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,<span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,</div><div class="line">  <span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 压缩置换表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> COMPRESSION_REPLACE_TABLE[] = &#123;</div><div class="line">  <span class="number">14</span>,<span class="number">17</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">28</span>,</div><div class="line">  <span class="number">15</span>,<span class="number">6</span>,<span class="number">21</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">19</span>,<span class="number">12</span>,<span class="number">4</span>,</div><div class="line">  <span class="number">26</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">7</span>,<span class="number">27</span>,<span class="number">20</span>,<span class="number">13</span>,<span class="number">2</span>,</div><div class="line">  <span class="number">41</span>,<span class="number">52</span>,<span class="number">31</span>,<span class="number">37</span>,<span class="number">47</span>,<span class="number">55</span>,<span class="number">30</span>,<span class="number">40</span>,</div><div class="line">  <span class="number">51</span>,<span class="number">45</span>,<span class="number">33</span>,<span class="number">48</span>,<span class="number">44</span>,<span class="number">49</span>,<span class="number">39</span>,<span class="number">56</span>,</div><div class="line">  <span class="number">34</span>,<span class="number">53</span>,<span class="number">46</span>,<span class="number">42</span>,<span class="number">50</span>,<span class="number">36</span>,<span class="number">29</span>,<span class="number">32</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 每轮迭代循环左移位数表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> LEFT_SHIFT_TABLE[] = &#123;</div><div class="line">  <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 16 轮子密钥</span></div><div class="line"><span class="keyword">bool</span> subKey[<span class="number">16</span>][<span class="number">48</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line"> </div><div class="line"><span class="comment">//--------------byte转换bit---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bytetobit</span><span class="params">(<span class="keyword">bool</span>* out, <span class="keyword">const</span> <span class="keyword">char</span>* in, <span class="keyword">int</span> bitslen)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitslen; i++)&#123;</div><div class="line">    out[i] = in[i/<span class="number">8</span>]&gt;&gt;(i%<span class="number">8</span>) &amp; <span class="number">0x1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------置换操作---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tableReplace</span><span class="params">(<span class="keyword">bool</span>* out, <span class="keyword">const</span> <span class="keyword">bool</span>* in, <span class="keyword">const</span> <span class="keyword">int</span>* table, <span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> temp[<span class="number">256</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">    temp[i] = in[table[i]<span class="number">-1</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">memcpy</span>(out, temp, len);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------循环左移---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftLoopShift</span><span class="params">(<span class="keyword">bool</span>* in, <span class="keyword">int</span> len, <span class="keyword">int</span> loop)</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> temp[<span class="number">256</span>];</div><div class="line">  <span class="built_in">memcpy</span>(temp, in, loop);</div><div class="line">  <span class="built_in">memcpy</span>(in, in+loop, len-loop);</div><div class="line">  <span class="built_in">memcpy</span>(in+len-loop, temp, loop);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/*--------------密钥初始化---------------</div><div class="line"> * key[8]: 64 位密钥</div><div class="line"> * subKey[16][48]: 16 个 48-bit 子密钥</div><div class="line"> */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">initKey</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> key[<span class="number">8</span>])</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> kbit[<span class="number">64</span>],*kl = &amp;kbit[<span class="number">0</span>], *kr = &amp;kbit[<span class="number">28</span>];</div><div class="line">  bytetobit(kbit, key, <span class="number">64</span>);</div><div class="line">  <span class="comment">// 置换1</span></div><div class="line">  tableReplace(kbit, kbit, REPLACE_ONE_TABLE, <span class="number">56</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i ++)&#123;</div><div class="line">    leftloop(kl, <span class="number">28</span>, LEFT_SHIFT_TABLE[i]);</div><div class="line">    leftloop(kr, <span class="number">28</span>, LEFT_SHIFT_TABLE[i]);</div><div class="line">    <span class="comment">// 压缩置换</span></div><div class="line">    tableReplace(subKey[i], kbit, COMPRESSION_REPLACE_TABLE, <span class="number">48</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="明文加密过程"><a href="#明文加密过程" class="headerlink" title="明文加密过程"></a>明文加密过程</h4><p><center><img src="/img/programPearls/encryption/DES_Details.png" width="720px" alt="" /></center></p>
<ul>
<li>初始置换 $IP$：将 64bits 明文的位置进行置换，得到一个乱序的 64bits 明文组，而后分成左右两段，每段为 32bits，以 $L_0$ 和 $R_0$ 表示；$IP$ 中各列元素位置号相差为 8，相当于将明文各字节按列读出，各列比特经过偶采样和奇采样置换后，再对各行进行逆序。<ul>
<li>初始置换表 $IP$ 如下：<br>  <center><img src="/img/programPearls/encryption/DES_IPTable.png" width="360px" alt="" /></center><ul>
<li>即将初始置换表中的元素按行读出构成置换输出。</li>
<li>$IP$ 和最后的 $IP^{-1}$ 在密码上意义不大，它们的作用在于打乱原输入的 ASCII 码字划分的关系，并将原来明文的校验位<code>[8]</code>、<code>[16]</code>、…、<code>[64]</code>变成 $IP$ 输出的一个字节。</li>
</ul>
</li>
</ul>
</li>
<li>乘积变换 $f$：DES 算法的核心部分。<ul>
<li>将经过 $IP$ 置换后的数据分成 32bits 的左右两组，在迭代过程中彼此左右交换位置。</li>
<li>每次迭代时只对右边的 32bits $R_{i-1}$ 进行一系列的加密交换，在此轮迭代即将结束时，把左边的 32bits $L_{i-1}$ 与右边得到的 32bits $R_{i-1}$ 逐位模 2 相加，作为下一轮迭代时右边的段 $R_{i}$，并将原来右边未经变换的段 $R_{i-1}$ 直接送到左边的寄存器作为下一轮迭代时左边的段 $L_i$。<center><img src="/img/programPearls/encryption/DES_ProductTransform.png" width="420px" alt="" /></center></li>
<li>在每一轮迭代时，右边的段 $R_{i-1}$ 要经过选择扩展运算 E、密钥加密运算、选择压缩算法 S、置换运算 P 和左右混合运算。<ul>
<li>选择扩展运算 E（扩展置换）：将输入的 32bits $R_{i-1}$ 扩展成 48bits 的输出，令 s 表示 E 原输入数据比特的原下标，则 E 的输出是将原下标 $s[ 0或1 (mod 4)]$ 的各比特重复一次得到，即对原来第 1、4、5、8、9、…、32 各位都重复一次，实现数据扩展，将下表中数据按行读出得到 48bits 输出。<br>  <center><img src="/img/programPearls/encryption/DES_ExtendedOperation.png" width="720px" alt="" /></center><ul>
<li>扩展置换的目的有两个：①生成与密钥长度相同的数据以进行异或运算；②提供更长的结果，在后续的替代运算中可以进行压缩。</li>
</ul>
</li>
<li>选择压缩运算 S（S-盒代替）：将前面送来的 48bits 数据自左至右分成 8 组，每组 6bits，而后并行送入 8 个 S-盒，每个 S-盒为一个非线性代换网络，有 4 个输出，如下图：<br>  <center><img src="/img/programPearls/encryption/DES_CompressionOperation.png" width="420px" alt="" /></center><ul>
<li>每个 S-盒都是一个 4×16 的矩阵，每行都是 0～15 的数字，但每行的数字排列都不同；每个 S-盒有 6 位输入，4 位输出，6 位输入中的第 1 位和第 6 位数字组成的二进制数值决定置换矩阵的行数，其余 4 位数字所组成的二进制数值决定置换矩阵的列数，行数和列数交点的数字便是 S-盒的输出。<center><img src="/img/programPearls/encryption/DES_S1Box.png" width="480px" alt="" /></center></li>
<li>上表是 $S_1$-盒：假设 $S_1$-盒的输入是<code>110010</code>，因第 1 位和第 6 位数字组成的二进制数为：$10_{(2) = 2}$，对应$S_1$-盒行号为 2 的那一行，其余 4 个数字所组成的二进制数为：$1001{(2) = 9}$，对应 $S_1$-盒列号为 9 的那一列，交点处的数是 12，则 $S_1$-盒的输出为<code>1100</code>。</li>
<li><font color="blue">S-盒代替是 DES 算法的关键步骤，所有其它的运算都是线性的，易于分析；而 S-盒是非线性的，相比于其它步骤，提供了更好的安全性</font>。</li>
</ul>
</li>
<li>置换运算  P（P-盒置换）：对 $S_1$-至 $S_8$-盒输出的 32bits 数据进行坐标置换，置换表如下：<center><img src="/img/programPearls/encryption/DES_ReplacementOperation.png" width="720px" alt="" /></center></li>
<li>置换 P 输出的 32bits 数据与左边 32bits，即 $R{i-1}$ 逐位模 2 相加（异或运算），所得到的 32bits 作为下一轮迭代用的右边的数字段 $R_i$，并将 $R_{i-1}$ 并行送到左边的寄存器，作为下一轮迭代用的左边的数字段 $L_i$。</li>
</ul>
</li>
</ul>
</li>
<li>逆初始置换 $IP^{-1}$：将 16 轮迭代后给出的 64bits 组进行置换，得到输出的密文组，输出为逆初始置换表中元素按行读得的结果。<ul>
<li>逆初始置换表 $IP^{-1}$ 如下：<br><center><img src="/img/programPearls/encryption/DES_IPInverseTable.png" width="360px" alt="" /></center><br>$\quad$ 逆初始置换是初始置换的逆过程，DES 最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组作为逆置换的输入，置换方法同上。</li>
</ul>
</li>
<li>具体实现如下<code>void DES(char out[8], char in[8], bool mode=encrypt)</code>函数。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> &#123;encrypt, decrypt&#125;;</div><div class="line"><span class="comment">// 初始置换表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> IP_TABLE[] = &#123;</div><div class="line">  <span class="number">58</span>,<span class="number">50</span>,<span class="number">42</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">18</span>,<span class="number">10</span>,<span class="number">2</span>,</div><div class="line">  <span class="number">60</span>,<span class="number">52</span>,<span class="number">44</span>,<span class="number">36</span>,<span class="number">28</span>,<span class="number">20</span>,<span class="number">12</span>,<span class="number">4</span>,</div><div class="line">  <span class="number">62</span>,<span class="number">54</span>,<span class="number">46</span>,<span class="number">38</span>,<span class="number">30</span>,<span class="number">22</span>,<span class="number">14</span>,<span class="number">6</span>,</div><div class="line">  <span class="number">64</span>,<span class="number">56</span>,<span class="number">48</span>,<span class="number">40</span>,<span class="number">32</span>,<span class="number">24</span>,<span class="number">16</span>,<span class="number">8</span>,</div><div class="line">  <span class="number">57</span>,<span class="number">49</span>,<span class="number">41</span>,<span class="number">33</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">1</span>,</div><div class="line">  <span class="number">59</span>,<span class="number">51</span>,<span class="number">43</span>,<span class="number">35</span>,<span class="number">27</span>,<span class="number">19</span>,<span class="number">11</span>,<span class="number">3</span>,</div><div class="line">  <span class="number">61</span>,<span class="number">53</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">29</span>,<span class="number">21</span>,<span class="number">13</span>,<span class="number">5</span>,</div><div class="line">  <span class="number">63</span>,<span class="number">55</span>,<span class="number">47</span>,<span class="number">39</span>,<span class="number">31</span>,<span class="number">23</span>,<span class="number">15</span>,<span class="number">7</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">// 逆初始置换表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> IIP_TABLE[] = &#123;</div><div class="line">  <span class="number">40</span>,<span class="number">8</span>,<span class="number">48</span>,<span class="number">16</span>,<span class="number">56</span>,<span class="number">24</span>,<span class="number">64</span>,<span class="number">32</span>,</div><div class="line">  <span class="number">39</span>,<span class="number">7</span>,<span class="number">47</span>,<span class="number">15</span>,<span class="number">55</span>,<span class="number">23</span>,<span class="number">63</span>,<span class="number">31</span>,</div><div class="line">  <span class="number">38</span>,<span class="number">6</span>,<span class="number">46</span>,<span class="number">14</span>,<span class="number">54</span>,<span class="number">22</span>,<span class="number">62</span>,<span class="number">30</span>,</div><div class="line">  <span class="number">37</span>,<span class="number">5</span>,<span class="number">45</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">21</span>,<span class="number">61</span>,<span class="number">29</span>,</div><div class="line">  <span class="number">36</span>,<span class="number">4</span>,<span class="number">44</span>,<span class="number">12</span>,<span class="number">52</span>,<span class="number">20</span>,<span class="number">60</span>,<span class="number">28</span>,</div><div class="line">  <span class="number">35</span>,<span class="number">3</span>,<span class="number">43</span>,<span class="number">11</span>,<span class="number">51</span>,<span class="number">19</span>,<span class="number">59</span>,<span class="number">27</span>,</div><div class="line">  <span class="number">34</span>,<span class="number">2</span>,<span class="number">42</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">18</span>,<span class="number">58</span>,<span class="number">26</span>,</div><div class="line">  <span class="number">33</span>,<span class="number">1</span>,<span class="number">41</span>,<span class="number">9</span>,<span class="number">49</span>,<span class="number">17</span>,<span class="number">57</span>,<span class="number">25</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// E 位选择表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> E_TABLE[] = &#123;</div><div class="line">  <span class="number">32</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,</div><div class="line">  <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</div><div class="line">  <span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,</div><div class="line">  <span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,</div><div class="line">  <span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>,</div><div class="line">  <span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>,<span class="number">25</span>,</div><div class="line">  <span class="number">24</span>,<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>,<span class="number">28</span>,<span class="number">29</span>,</div><div class="line">  <span class="number">28</span>,<span class="number">29</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">32</span>,<span class="number">1</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// S1-S8盒</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> S_BOX[<span class="number">8</span>][<span class="number">4</span>][<span class="number">16</span>] = &#123;</div><div class="line">  <span class="comment">//S1</span></div><div class="line">  <span class="number">14</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">7</span>,</div><div class="line">  <span class="number">0</span>, <span class="number">15</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>,</div><div class="line">  <span class="number">4</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">0</span>,</div><div class="line">  <span class="number">15</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">13</span>,</div><div class="line">  <span class="comment">//S2</span></div><div class="line">  <span class="number">15</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">10</span>,</div><div class="line">  <span class="number">3</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">5</span>,</div><div class="line">  <span class="number">0</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">15</span>,</div><div class="line">  <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">9</span>,</div><div class="line">  <span class="comment">//S3</span></div><div class="line">  <span class="number">10</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">14</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">8</span>,</div><div class="line">  <span class="number">13</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">1</span>,</div><div class="line">  <span class="number">13</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">7</span>,</div><div class="line">  <span class="number">1</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">12</span>,</div><div class="line">  <span class="comment">//S4</span></div><div class="line">  <span class="number">7</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">15</span>,</div><div class="line">  <span class="number">13</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">9</span>,</div><div class="line">  <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>,</div><div class="line">  <span class="number">3</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">14</span>,</div><div class="line">  <span class="comment">//S5</span></div><div class="line">  <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>,</div><div class="line">  <span class="number">14</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">6</span>,</div><div class="line">  <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">14</span>,</div><div class="line">  <span class="number">11</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>,</div><div class="line">  <span class="comment">//S6</span></div><div class="line">  <span class="number">12</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">11</span>,</div><div class="line">  <span class="number">10</span>, <span class="number">15</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">8</span>,</div><div class="line">  <span class="number">9</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">11</span>, <span class="number">6</span>,</div><div class="line">  <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>,</div><div class="line">  <span class="comment">//S7</span></div><div class="line">  <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">1</span>,</div><div class="line">  <span class="number">13</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">6</span>,</div><div class="line">  <span class="number">1</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>,</div><div class="line">  <span class="number">6</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">12</span>,</div><div class="line">  <span class="comment">//S8</span></div><div class="line">  <span class="number">13</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">7</span>,</div><div class="line">  <span class="number">1</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">9</span>, <span class="number">2</span>,</div><div class="line">  <span class="number">7</span>, <span class="number">11</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>,</div><div class="line">  <span class="number">2</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">11</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// P-盒置换表</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> P_TABLE[] = &#123;</div><div class="line">  <span class="number">16</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">21</span>,<span class="number">29</span>,<span class="number">12</span>,<span class="number">28</span>,<span class="number">17</span>,</div><div class="line">  <span class="number">1</span>,<span class="number">15</span>,<span class="number">23</span>,<span class="number">26</span>,<span class="number">5</span>,<span class="number">18</span>,<span class="number">31</span>,<span class="number">10</span>,</div><div class="line">  <span class="number">2</span>,<span class="number">8</span>,<span class="number">24</span>,<span class="number">14</span>,<span class="number">32</span>,<span class="number">27</span>,<span class="number">3</span>,<span class="number">9</span>,</div><div class="line">  <span class="number">19</span>,<span class="number">13</span>,<span class="number">30</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">11</span>,<span class="number">4</span>,<span class="number">25</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="comment">//--------------byte转换bit---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bytetobit</span><span class="params">(<span class="keyword">bool</span>* out, <span class="keyword">const</span> <span class="keyword">char</span>* in, <span class="keyword">int</span> bitslen)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bitslen; i++)&#123;</div><div class="line">    out[i] = in[i/<span class="number">8</span>]&gt;&gt;(i%<span class="number">8</span>) &amp; <span class="number">0x1</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------置换操作---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">tableReplace</span><span class="params">(<span class="keyword">bool</span>* out, <span class="keyword">const</span> <span class="keyword">bool</span>* in, <span class="keyword">const</span> <span class="keyword">int</span>* table, <span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> temp[<span class="number">256</span>];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</div><div class="line">    temp[i] = in[table[i]<span class="number">-1</span>];</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">memcpy</span>(out, temp, len);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------异或操作---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">xor</span><span class="params">(<span class="keyword">bool</span>* ina, <span class="keyword">const</span> <span class="keyword">bool</span>* inb, <span class="keyword">int</span> len)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;</div><div class="line">    ina[i] ^= inb[i];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------S盒变换---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sFunc</span><span class="params">(<span class="keyword">bool</span> out[<span class="number">32</span>], <span class="keyword">const</span> <span class="keyword">bool</span> in[<span class="number">48</span>])</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j,k; i&lt;<span class="number">8</span>; i++,in+=<span class="number">6</span>,out+=<span class="number">4</span>)&#123;</div><div class="line">    j = (in[<span class="number">0</span>]&lt;&lt;<span class="number">1</span>) + in[<span class="number">5</span>];</div><div class="line">    k = (in[<span class="number">1</span>]&lt;&lt;<span class="number">3</span>) + (in[<span class="number">2</span>]&lt;&lt;<span class="number">2</span>) + (in[<span class="number">3</span>]&lt;&lt;<span class="number">1</span>) + in[<span class="number">4</span>];</div><div class="line">    bytetobit(out, &amp;S_BOX[i][j][k], <span class="number">4</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------密码处理 f 函数---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fFunc</span><span class="params">(<span class="keyword">bool</span> in[<span class="number">32</span>], <span class="keyword">const</span> <span class="keyword">bool</span> subkey[<span class="number">48</span>])</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> mr[<span class="number">48</span>];</div><div class="line">  <span class="comment">// E 扩展置换</span></div><div class="line">  tableReplace(mr, in, E_TABLE, <span class="number">48</span>);</div><div class="line">  <span class="comment">// 异或操作</span></div><div class="line">  xor(mr, subkey, <span class="number">48</span>);</div><div class="line">  <span class="comment">// S-盒代替</span></div><div class="line">  sFunc(in, mr);</div><div class="line">  <span class="comment">// P-盒置换</span></div><div class="line">    tableReplace(in, in, P_TABLE, <span class="number">32</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------bite转换byte---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bittobyte</span><span class="params">(<span class="keyword">char</span>* out, <span class="keyword">const</span> <span class="keyword">bool</span>* in, <span class="keyword">int</span> bitslen)</span></span>&#123;</div><div class="line">  <span class="built_in">memset</span>(out, <span class="number">0</span>, (bitslen+<span class="number">7</span>)/<span class="number">8</span>);</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;bitslen; i++)&#123;</div><div class="line">    out[i/<span class="number">8</span>] |= in[i]&lt;&lt;(i%<span class="number">8</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//--------------加密解密处理---------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">DES</span><span class="params">(<span class="keyword">char</span> out[<span class="number">8</span>], <span class="keyword">char</span> in[<span class="number">8</span>], <span class="keyword">bool</span> mode=encrypt)</span></span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> obit[<span class="number">64</span>], temp[<span class="number">32</span>], *li = &amp;obit[<span class="number">0</span>], *ri = &amp;obit[<span class="number">32</span>];</div><div class="line"> </div><div class="line">  bytetobit(obit, in, <span class="number">64</span>);</div><div class="line">  <span class="comment">// 初始置换</span></div><div class="line">  tableReplace(obit, obit, IP_TABLE, <span class="number">64</span>);</div><div class="line"> 	<span class="comment">// 乘积变换</span></div><div class="line">  <span class="keyword">if</span>(mode == encrypt) &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">16</span>; i++)&#123;</div><div class="line">      <span class="built_in">memcpy</span>(temp, ri, <span class="number">32</span>);</div><div class="line">      fFunc(ri, subKey[i]);</div><div class="line">      xor(ri, li, <span class="number">32</span>);</div><div class="line">      <span class="built_in">memcpy</span>(li, temp, <span class="number">32</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">15</span>; i&gt;=<span class="number">0</span>; i--)&#123;</div><div class="line">      <span class="built_in">memcpy</span>(temp, li, <span class="number">32</span>);</div><div class="line">      fFunc(li, subkey[i]);</div><div class="line">      xor(li, ri, <span class="number">32</span>);</div><div class="line">      <span class="built_in">memcpy</span>(ri, temp, <span class="number">32</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 逆初始置换</span></div><div class="line">  tableReplace(obit, obit, IIP_TABLE, <span class="number">64</span>);</div><div class="line">  bittobyte(out, obit, <span class="number">64</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="密文解密过程"><a href="#密文解密过程" class="headerlink" title="密文解密过程"></a>密文解密过程</h4><ul>
<li>DES 是一种 16 轮循环的 <strong>Feistel 网络</strong>，在 Feistel 网络中，加密的各个步骤称为轮，整个加密过程就是进行若干次轮的循环；无论是任何轮数、任何轮函数，Feistel 网络都可以用相同的结构实现加密和解密，且加密结果必定能够正确解密。<center><img src="/img/programPearls/encryption/DES_FlowChart.png" width="420px" alt="" /></center></li>
<li>那么，基于 Feistel 网络的 DES 算法如何解密呢？很简单，只要按照逆序来使用子密钥，即输入变成密文，输出则为明文了；<font color="blue">此外，需要注意的是，加密过程的最后一轮存在左右互换（如上图），因此在解密过程中，在进入 Feistel 网络之前需要先将经过初始置换的密文左右互换，完成 $L_{16}$、$R_{16}$ 初始化</font>。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// DES 解密</span></div><div class="line"><span class="built_in">bitset</span>&lt;64&gt; decrypt(<span class="built_in">bitset</span>&lt;<span class="number">64</span>&gt;&amp; cipher) &#123;</div><div class="line">  <span class="built_in">bitset</span>&lt;64&gt; plain;</div><div class="line">  <span class="built_in">bitset</span>&lt;64&gt; currentBits;</div><div class="line">  <span class="built_in">bitset</span>&lt;32&gt; left;</div><div class="line">  <span class="built_in">bitset</span>&lt;32&gt; right;</div><div class="line">  <span class="built_in">bitset</span>&lt;32&gt; newLeft;</div><div class="line">  <span class="comment">// 第一步：初始置换IP</span></div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="comment">// 第二步：获取 L16 和 R16</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</div><div class="line">    left[i<span class="number">-32</span>] = currentBits[i];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</div><div class="line">    right[i] = currentBits[i];</div><div class="line">  </div><div class="line">  <span class="comment">// 第三步：共16轮迭代（子密钥逆序应用）</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> round=<span class="number">0</span>; round&lt;<span class="number">16</span>; ++round &#123;</div><div class="line">    ... subKey[<span class="number">15</span>-round]</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 第四步：合并 L0 和 R0，注意合并为 R0L0</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; ++i)</div><div class="line">    plain[i] = left[i];</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">32</span>; i&lt;<span class="number">64</span>; ++i)</div><div class="line">    plain[i] = right[i<span class="number">-32</span>];</div><div class="line">  </div><div class="line">  <span class="comment">// 第五步：逆初始置换</span></div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="comment">// 返回明文</span></div><div class="line">  <span class="keyword">return</span> plain;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><br/></p>
<ul>
<li>虽然 56 位密钥的 DES 算法已经风光不在，而且常有用 DES 加密的明文被破译的报道，但目前 DES 算法得到了广泛的应用，在某些场合，仍然发挥着余热。</li>
</ul>
<h3 id="3DES-算法"><a href="#3DES-算法" class="headerlink" title="3DES 算法"></a>3DES 算法</h3><ul>
<li>3DES 简介<ul>
<li>密码学中，3DES（Triple DES）是三重数据加密算法（Triple Data Encryption Algorithm）块密码的通称，它相当于是对每个数据块应用三次 DES 加密算法。</li>
<li>由于计算机运算能力的增强，原版 DES 密码的密钥长度变得容易被暴力破解；3DES 即是设计用来提供一种相对简单的方法，即通过增加 DES 的密钥长度来避免类似的攻击，而不是设计一种全新的块密码算法。</li>
</ul>
</li>
<li>3DES 加密过程<ul>
<li>加密算法为：密文 = $E_{K_3}(D_{K_2}(E_{K_1}(明文)))$，其中 $E$ 为 DES 加密操作，$D$ 为 DES 解密操作。<center><img src="/img/programPearls/encryption/3DES_Diagram.jpg" width="480px" alt="" /></center></li>
<li>3DES 将密钥长度增至 112 位或 168 位，通过增加迭代次数提高安全性；标准定义了三种密钥选项：<ul>
<li>密钥选项①：三个密钥独立的，强度最高，拥有 3×56=168 个独立的密钥位；</li>
<li>密钥选项②：$K_1$ 和 $K_2$ 是独立的，而 $K_3 = K_1$，安全性稍低，拥有 2×56=112 个独立的密钥位；</li>
<li>密钥选项③：三个密钥均相等，即 $K_1 = K_2 = K_3$，等同于 DES，只有 56 个密钥位，因为第 1 和第 2 次 DES 操作相互抵消了，因此与 DES 兼容。</li>
</ul>
</li>
</ul>
</li>
<li>3DES 解密过程<ul>
<li>解密算法为：明文 = $D_{K_3}(E_{K_2}(D_{K_3}(密文)))$，3DES 的解密过程和加密相反，是以密钥 $K_3$、$K_2$、$K_1$ 的顺序进行解密、加密、解密的操作，即将上图从明文到密文的箭头反过来就是解密的流程。</li>
</ul>
</li>
<li>3DES 是 DES 向 AES 过渡的加密算法，3DES 存在以下缺点：处理速度较慢、密钥计算时间较长，加密效率不高。</li>
</ul>
<h3 id="AES-算法"><a href="#AES-算法" class="headerlink" title="AES 算法"></a>AES 算法</h3><ul>
<li>AES 简介<ul>
<li>对于三种对称密码，DES 因为已经很容易被暴力破解，因此不建议再使用；3DES 目前还被银行等机构使用，但其处理速度不高，而且在安全性方面也逐渐显现出了一些问题；AES 作为最新标准，安全、快速，而且可以在各种平台上工作，可以算是目前最佳的选择。</li>
<li>AES 是取代其前任标准 DES 而成为新标准的一种对称密码算法。AES 最终候选算法名单中，总共有 5 种算法，分别为：MARS、RC6、Rijndael、Serpent、Twofish，最终被选定为 AES 的是 <strong>Rijndael 算法</strong>。<center><img src="/img/programPearls/encryption/AES_FlowChart(De&En).png" width="640px" alt="" /></center></li>
</ul>
</li>
<li>AES 算法（即 Rijndael 算法）是一种对称分组密码算法，数据长度必须是 128bits，使用的密钥长度为 128bits、192bits 或 256bits，对于三种不同长度的 AES 算法，分别称为<strong>“AES-128”</strong>、<strong>“AES-192”</strong>、<strong>“AES-256”</strong>，上图是 AES 加密解密的整体流程图，其中<ul>
<li>状态（State）：密码运算的中间结果称为状态，状态用以字节为基本构成元素的矩阵阵列来表示，该阵列有 4 行，列数记为 $Nb$，Nb = 分组长度（bits）÷32；</li>
<li>密码密钥（Cipher Key）的表示：Cipher Key类似地用一个 4 行的矩阵阵列来表示，列数记为 $Nk$，Nk = 密钥长度（bits）÷32；<center><img src="/img/programPearls/encryption/AES_NbNkNr.png" width="480px" alt="" /></center></li>
<li>$Nr$：加密的轮数，对于不同的密钥长度，轮数不一样，具体如上表。<center><img src="/img/programPearls/encryption/AES_OrganizeMatrix.png" width="480px" alt="" /></center></li>
<li>算法中 16 字节（128bits）、192bits、256bits 的明文、密文和轮密钥以一个 4×4、4×6、4×8 的矩阵表示，组织排列方式如上，以字节为单位。</li>
</ul>
</li>
</ul>
<h4 id="密钥扩展"><a href="#密钥扩展" class="headerlink" title="密钥扩展"></a>密钥扩展</h4><ul>
<li>加解密中每轮的密钥分别由初始密钥扩展得到。密钥 bit 的总数 = 分组长度 ×（轮数 + 1）；字总数 = 分组列数 Nb ×（轮数 Nr + 1）。</li>
<li>AES 算法通过密钥扩展（Key Expansion）将用户输入的密钥 K 扩展生成 <font color="blue">$Nb(Nr+1)$ 个字</font>，存放在一个线性数组<code>w[Nb*(Nr+1)]</code>中，具体如下：<ul>
<li>位置变换（<code>RotWord</code>）：接受一个字 [a0, a1, a2, a3] 作为输入，循环左移一个字节后输出 [a1, a2, a3, a0]；</li>
<li>S-盒变换（<code>SubWord</code>/<code>SubBytes</code>）：S-盒是一个 16×16 的表，其中每一个元素是一个字节；接受一个字 [a0, a1, a2, a3] 的输入，对于输入的每一个字节 ai，前四位 ai[7…4] 组成十六进制数作为行号，后四位 ai[3…0] 组成十六进制数作为列号，查找表中对应的值；最后函数输出 4 个新字节组成的 32-bit 字；</li>
<li>轮常数（<code>Rcon</code>）：直接当做常量数组使用；</li>
<li>扩展密钥数组<code>w[]</code>的前 $Nk$ 个元素就是外部密钥 $K$，以后的元素<code>w[i]</code>等于它的前一个元素<code>w[i-1]</code>与前 $Nk$ 个元素 <code>w[i-Nk]</code>的异或，即 <code>w[i] = w[i-1] XOR w[i-Nk]</code>；但若 $i$ 为 $Nk$ 的倍数，则 <code>w[i] = w[i-Nk] XOR SubWord(RotWord(w[i-1]) XOR Rcon[i/Nk - 1])$</code>。</li>
<li>详细的伪代码如下：<br><img src="/img/programPearls/encryption/AES_KeyExpansionPseudocode.png" width="540px" alt="" /></li>
</ul>
</li>
<li>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">typedef bitset&lt;8&gt; byte;</div><div class="line">typedef bitset&lt;32&gt; word;</div><div class="line"> </div><div class="line">const int Nr = 10;  // AES-128需要 10 轮加密</div><div class="line">const int Nk = 4;   // Nk 表示输入密钥的 word 个数</div><div class="line"> </div><div class="line">// S盒</div><div class="line">byte S_BOX[16][16] = &#123;</div><div class="line">  /*  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f */</div><div class="line">  0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, /*0*/ </div><div class="line">  0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, /*1*/</div><div class="line">  0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, /*2*/</div><div class="line">  0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, /*3*/</div><div class="line">  0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, /*4*/</div><div class="line">  0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, /*5*/</div><div class="line">  0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, /*6*/ </div><div class="line">  0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, /*7*/</div><div class="line">  0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, /*8*/</div><div class="line">  0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, /*9*/</div><div class="line">  0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, /*a*/</div><div class="line">  0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, /*b*/</div><div class="line">  0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, /*c*/</div><div class="line">  0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, /*d*/</div><div class="line">  0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, /*e*/</div><div class="line">  0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  /*f*/</div><div class="line">&#125;;</div><div class="line">  </div><div class="line">// 将4个 byte 转换为一个 word.</div><div class="line">word Word(byte&amp; k1, byte&amp; k2, byte&amp; k3, byte&amp; k4) &#123;</div><div class="line">  word result(0x00000000);</div><div class="line">  word temp;</div><div class="line">  temp = k1.to_ulong();  // K1</div><div class="line">  temp &lt;&lt;= 24;</div><div class="line">  result |= temp;</div><div class="line">  temp = k2.to_ulong();  // K2</div><div class="line">  temp &lt;&lt;= 16;</div><div class="line">  result |= temp;</div><div class="line">  temp = k3.to_ulong();  // K3</div><div class="line">  temp &lt;&lt;= 8;</div><div class="line">  result |= temp;</div><div class="line">  temp = k4.to_ulong();  // K4</div><div class="line">  result |= temp;</div><div class="line">  return result;</div><div class="line">&#125;</div><div class="line">  </div><div class="line">/**</div><div class="line"> *  按字节 循环左移一位</div><div class="line"> *  即把[a0, a1, a2, a3]变成[a1, a2, a3, a0]</div><div class="line"> */</div><div class="line">word RotWord(word&amp; rw) &#123;</div><div class="line">  word high = rw &lt;&lt; 8;</div><div class="line">  word low = rw &gt;&gt; 24;</div><div class="line">  return high | low;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/**</div><div class="line"> *  对输入word中的每一个字节进行S-盒变换</div><div class="line"> */</div><div class="line">word SubWord(word&amp; sw) &#123;</div><div class="line">  word temp;</div><div class="line">  for(int i=0; i&lt;32; i+=8) &#123;</div><div class="line">    int row = sw[i+7]*8 + sw[i+6]*4 + sw[i+5]*2 + sw[i+4];</div><div class="line">    int col = sw[i+3]*8 + sw[i+2]*4 + sw[i+1]*2 + sw[i];</div><div class="line">    byte val = S_Box[row][col];</div><div class="line">    for(int j=0; j&lt;8; ++j)</div><div class="line">      temp[i+j] = val[j];</div><div class="line">  &#125;</div><div class="line">  return temp;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">/**</div><div class="line"> *  密钥扩展函数 - 对Nk-word密钥进行扩展得到 w[4*(Nr+1)]</div><div class="line"> */ </div><div class="line">void KeyExpansion(byte key[4*Nk], word w[4*(Nr+1)])</div><div class="line">&#123;</div><div class="line">  word temp;</div><div class="line">  int i = 0;</div><div class="line">  // w[]的前4个就是输入的key</div><div class="line">  while(i &lt; Nk) &#123;</div><div class="line">    w[i] = Word(key[4*i], key[4*i+1], key[4*i+2], key[4*i+3]);</div><div class="line">    ++i;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  i = Nk;</div><div class="line"> </div><div class="line">  while(i &lt; 4*(Nr+1))&#123;</div><div class="line">    temp = w[i-1]; // 记录前一个word</div><div class="line">    if(i % Nk == 0)</div><div class="line">      w[i] = w[i-Nk] ^ SubWord(RotWord(temp)) ^ Rcon[i/Nk-1];</div><div class="line">    else </div><div class="line">      w[i] = w[i-Nk] ^ temp;</div><div class="line">    ++i;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>从扩展密钥中取出轮密钥：第一个轮密钥由扩展密钥的第一个 $Nb$ 个字（4 字节），第二个轮密钥由接下来的 $Nb$ 个字组成，一次类推。<h4 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h4></li>
<li>依据本节开头的 AES 流程图可以得到下图的伪代码：<br>  <center><img src="/img/programPearls/encryption/AES_CipherPseudocode.png" width="640px" alt="" /></center><ul>
<li>从伪代码描述中可以看出，AES 加密时主要涉及以下几个步骤<ul>
<li>字节替换（SubBytes） 就是根据一张替换表（S-Box），将输入中每个字节的值替换成另一个字节的值，在密钥扩展部分已经介绍了；</li>
<li>行移位（ShiftRows） 即将 SubBytes 的输出以字节为单位进行打乱出路，这种打乱处理也是有规律的：通过作用于行上的循环左移，第 0 行不变，第 1 行循环移位 $C1$ 字节，第 2 行循环移位 $C2$ 字节，第 3 行循环移位 $C3$ 字节，如下图：<center><img src="/img/programPearls/encryption/AES_ShiftRows.png" width="540px" alt="" /></center><br>$\quad$ 偏移量 $C1$、$C2$、$C3$ 与分组长度 $Nb$ 有关，如下表所示：<br><center><img src="/img/programPearls/encryption/AES_ShiftRowsTable.png" width="280px" alt="" /></center></li>
<li>列混淆（MixColumns） 即对一个 4 字节的值进行变换，将其变成另外一个 4 字节的值，变换方式如下：<br><center><img src="/img/programPearls/encryption/AES_MixColumns.png" width="540px" alt="" /></center><br>$\quad$ <font color="red">注意公式中用到的乘法是伽罗华域（$GF(2^8)$，有限域）上的乘法</font>。</li>
<li>轮密钥加（AddRoundKey） ：扩展密钥只参与了这一步，就是将 MixColumns 的输出与轮密钥进行按位 XOR 处理，至此，一轮就结束了。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div></pre></td><td class="code"><pre><div class="line">typedef bitset&lt;8&gt; byte;</div><div class="line">typedef bitset&lt;32&gt; word;</div><div class="line"> </div><div class="line">const int Nr = 10;  // AES-128需要 10 轮加密</div><div class="line">const int Nk = 4;   // Nk 表示输入密钥的 word 个数</div><div class="line"> </div><div class="line">// S盒</div><div class="line">byte S_BOX[16][16] = &#123;</div><div class="line">  /*  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f */</div><div class="line">  0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76, /*0*/ </div><div class="line">  0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0, /*1*/</div><div class="line">  0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15, /*2*/</div><div class="line">  0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75, /*3*/</div><div class="line">  0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84, /*4*/</div><div class="line">  0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf, /*5*/</div><div class="line">  0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8, /*6*/ </div><div class="line">  0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2, /*7*/</div><div class="line">  0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73, /*8*/</div><div class="line">  0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb, /*9*/</div><div class="line">  0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79, /*a*/</div><div class="line">  0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08, /*b*/</div><div class="line">  0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a, /*c*/</div><div class="line">  0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e, /*d*/</div><div class="line">  0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf, /*e*/</div><div class="line">  0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16  /*f*/</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// S盒变换 -每个字节前4位为行号，后4位为列号</div><div class="line">void SubBytes(byte mtx[4*4]) &#123;</div><div class="line">  for(int i=0; i&lt;16; ++i) &#123;</div><div class="line">    int row = mtx[i][7]*8 + mtx[i][6]*4 + mtx[i][5]*2 + mtx[i][4];</div><div class="line">    int col = mtx[i][3]*8 + mtx[i][2]*4 + mtx[i][1]*2 + mtx[i][0];</div><div class="line">    mtx[i] = S_Box[row][col];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 行变换 - 按字节循环移位</div><div class="line">void ShiftRows(byte mtx[4*4]) &#123;</div><div class="line">  // 第二行循环左移一位</div><div class="line">  byte temp = mtx[4];</div><div class="line">  for(int i=0; i&lt;3; ++i)</div><div class="line">    mtx[i+4] = mtx[i+5];</div><div class="line">  mtx[7] = temp;</div><div class="line">  // 第三行循环左移两位</div><div class="line">  for(int i=0; i&lt;2; ++i) &#123;</div><div class="line">    temp = mtx[i+8];</div><div class="line">    mtx[i+8] = mtx[i+10];</div><div class="line">    mtx[i+10] = temp;</div><div class="line">  &#125;</div><div class="line">  // 第四行循环左移三位</div><div class="line">  temp = mtx[15];</div><div class="line">  for(int i=3; i&gt;0; --i)</div><div class="line">    mtx[i+12] = mtx[i+11];</div><div class="line">  mtx[12] = temp;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 有限域上的乘法 GF(2^8)</div><div class="line">byte GFMul(byte a, byte b) &#123; </div><div class="line">  byte p = 0;</div><div class="line">  byte hi_bit_set;</div><div class="line">  for (int counter = 0; counter &lt; 8; counter++) &#123;</div><div class="line">    if ((b &amp; byte(1)) != 0) &#123;</div><div class="line">      p ^= a;</div><div class="line">    &#125;</div><div class="line">    hi_bit_set = (byte) (a &amp; byte(0x80));</div><div class="line">    a &lt;&lt;= 1;</div><div class="line">    if (hi_bit_set != 0) &#123;</div><div class="line">      a ^= 0x1b; /* x^8 + x^4 + x^3 + x + 1 */</div><div class="line">    &#125;</div><div class="line">    b &gt;&gt;= 1;</div><div class="line">  &#125;</div><div class="line">  return p;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 列混淆</div><div class="line">void MixColumns(byte mtx[4*4]) &#123;</div><div class="line">  byte arr[4];</div><div class="line">  for(int i=0; i&lt;4; ++i) &#123;</div><div class="line">    for(int j=0; j&lt;4; ++j)</div><div class="line">      arr[j] = mtx[i+j*4];</div><div class="line"> </div><div class="line">    mtx[i] = GFMul(0x02, arr[0]) ^ GFMul(0x03, arr[1]) ^ arr[2] ^ arr[3];</div><div class="line">    mtx[i+4] = arr[0] ^ GFMul(0x02, arr[1]) ^ GFMul(0x03, arr[2]) ^ arr[3];</div><div class="line">    mtx[i+8] = arr[0] ^ arr[1] ^ GFMul(0x02, arr[2]) ^ GFMul(0x03, arr[3]);</div><div class="line">    mtx[i+12] = GFMul(0x03, arr[0]) ^ arr[1] ^ arr[2] ^ GFMul(0x02, arr[3]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 轮密钥加变换 - 将每一列与扩展密钥进行异或</div><div class="line">void AddRoundKey(byte mtx[4*4], word k[4]) &#123;</div><div class="line">  for(int i=0; i&lt;4; ++i) &#123;</div><div class="line">    word k1 = k[i] &gt;&gt; 24;</div><div class="line">    word k2 = (k[i] &lt;&lt; 8) &gt;&gt; 24;</div><div class="line">    word k3 = (k[i] &lt;&lt; 16) &gt;&gt; 24;</div><div class="line">    word k4 = (k[i] &lt;&lt; 24) &gt;&gt; 24;</div><div class="line">    </div><div class="line">    mtx[i] = mtx[i] ^ byte(k1.to_ulong());</div><div class="line">    mtx[i+4] = mtx[i+4] ^ byte(k2.to_ulong());</div><div class="line">    mtx[i+8] = mtx[i+8] ^ byte(k3.to_ulong());</div><div class="line">    mtx[i+12] = mtx[i+12] ^ byte(k4.to_ulong());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 加密</div><div class="line">void encrypt(byte in[4*4], word w[4*(Nr+1)]) &#123;</div><div class="line">  word key[4];</div><div class="line">  for(int i=0; i&lt;4; ++i)</div><div class="line">    key[i] = w[i];</div><div class="line">  AddRoundKey(in, key);</div><div class="line"> </div><div class="line">  for(int round=1; round&lt;Nr; ++round)&#123;</div><div class="line">    SubBytes(in);</div><div class="line">    ShiftRows(in);</div><div class="line">    MixColumns(in);</div><div class="line">    for(int i=0; i&lt;4; ++i)</div><div class="line">      key[i] = w[4*round+i];</div><div class="line">    AddRoundKey(in, key);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  SubBytes(in);</div><div class="line">  ShiftRows(in);</div><div class="line">  for(int i=0; i&lt;4; ++i)</div><div class="line">    key[i] = w[4*Nr+i];</div><div class="line">  AddRoundKey(in, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解密过程"><a href="#解密过程" class="headerlink" title="解密过程"></a>解密过程</h4><ul>
<li>①AES 使用的并不是 Feistel 网络，而是 SPN 结构，加密时的 SubBytes、ShiftRows、MixColumns，解密时分别为反向运算的 InvSubBytes、InvShiftRows、InvMixColumns，这是因为 SPN 结构不像 Feistel 网络一样能够用一种结构实现加密和解密；②加解密所有操作的顺序正好是相反的；正是这两点，保证了解密能够正确地恢复明文。</li>
<li>依据本节开头的 AES 流程图可以得到下图的伪代码：<br>  <center><img src="/img/programPearls/encryption/AES_InvCipherPseudocode.png" width="640px" alt="" /></center><ul>
<li>从伪代码描述中可以看出，AES 解密时主要涉及以下几个步骤<ul>
<li>逆行移位（InvShiftRows）：加密时是对矩阵每一行进行循环左移，所以解密时的 InvShiftRows 操作是对矩阵每一行进行循环右移；</li>
<li>逆字节替换（InvSubBytes）：与加密时的字节替换一样也是查表，查表的方式也一样，只不过查的是另外一张表，S-Box 的逆表；</li>
<li>逆列混淆（MixColumns）：与加密时的列混淆一样，只不过变换公式中的系数矩阵发生了变化，如下图：<center><img src="/img/programPearls/encryption/AES_InvMixColumns.png" width="640px" alt="" /></center></li>
<li>轮密钥加（AddRoundKey） ：与加密时的操作一致。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div></pre></td><td class="code"><pre><div class="line">typedef bitset&lt;8&gt; byte;</div><div class="line">typedef bitset&lt;32&gt; word;</div><div class="line"> </div><div class="line">const int Nr = 10;  // AES-128需要 10 轮加密</div><div class="line">const int Nk = 4;   // Nk 表示输入密钥的 word 个数</div><div class="line"> </div><div class="line">// S-盒逆表</div><div class="line">byte INV_S_BOX[16][16] = &#123;</div><div class="line">  /*  0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f  */ </div><div class="line">  0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb, /*0*/</div><div class="line">  0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb, /*1*/</div><div class="line">  0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e, /*2*/</div><div class="line">  0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25, /*3*/</div><div class="line">  0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92, /*4*/</div><div class="line">  0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84, /*5*/</div><div class="line">  0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06, /*6*/</div><div class="line">  0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b, /*7*/</div><div class="line">  0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73, /*8*/</div><div class="line">  0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e, /*9*/</div><div class="line">  0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b, /*a*/</div><div class="line">  0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4, /*b*/</div><div class="line">  0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f, /*c*/</div><div class="line">  0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef, /*d*/</div><div class="line">  0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61, /*e*/</div><div class="line">  0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d  /*f*/</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">// 逆行变换 - 以字节为单位循环右移</div><div class="line">void InvShiftRows(byte mtx[4*4]) &#123;</div><div class="line">  // 第二行循环右移一位</div><div class="line">  byte temp = mtx[7];</div><div class="line">  for(int i=3; i&gt;0; --i)</div><div class="line">    mtx[i+4] = mtx[i+3];</div><div class="line">  mtx[4] = temp;</div><div class="line">  // 第三行循环右移两位</div><div class="line">  for(int i=0; i&lt;2; ++i) &#123;</div><div class="line">    temp = mtx[i+8];</div><div class="line">    mtx[i+8] = mtx[i+10];</div><div class="line">    mtx[i+10] = temp;</div><div class="line">  &#125;</div><div class="line">  // 第四行循环右移三位</div><div class="line">  temp = mtx[12];</div><div class="line">  for(int i=0; i&lt;3; ++i)</div><div class="line">    mtx[i+12] = mtx[i+13];</div><div class="line">  mtx[15] = temp;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 逆字节替换</div><div class="line">void InvSubBytes(byte mtx[4*4]) &#123;</div><div class="line">  for(int i=0; i&lt;16; ++i) &#123;</div><div class="line">    int row = mtx[i][7]*8 + mtx[i][6]*4 + mtx[i][5]*2 + mtx[i][4];</div><div class="line">    int col = mtx[i][3]*8 + mtx[i][2]*4 + mtx[i][1]*2 + mtx[i][0];</div><div class="line">    mtx[i] = Inv_S_Box[row][col];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 有限域上的乘法 GF(2^8)</div><div class="line">byte GFMul(byte a, byte b) &#123; </div><div class="line">  byte p = 0;</div><div class="line">  byte hi_bit_set;</div><div class="line">  for (int counter = 0; counter &lt; 8; counter++) &#123;</div><div class="line">    if ((b &amp; byte(1)) != 0) &#123;</div><div class="line">      p ^= a;</div><div class="line">    &#125;</div><div class="line">    hi_bit_set = (byte) (a &amp; byte(0x80));</div><div class="line">    a &lt;&lt;= 1;</div><div class="line">    if (hi_bit_set != 0) &#123;</div><div class="line">      a ^= 0x1b; /* x^8 + x^4 + x^3 + x + 1 */</div><div class="line">    &#125;</div><div class="line">    b &gt;&gt;= 1;</div><div class="line">  &#125;</div><div class="line">  return p;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 逆列混淆</div><div class="line">void InvMixColumns(byte mtx[4*4]) &#123;</div><div class="line">  byte arr[4];</div><div class="line">  for(int i=0; i&lt;4; ++i) &#123;</div><div class="line">    for(int j=0; j&lt;4; ++j)</div><div class="line">      arr[j] = mtx[i+j*4];</div><div class="line"> </div><div class="line">    mtx[i] = GFMul(0x0e, arr[0]) ^ GFMul(0x0b, arr[1]) </div><div class="line">      ^ GFMul(0x0d, arr[2]) ^ GFMul(0x09, arr[3]);</div><div class="line">    mtx[i+4] = GFMul(0x09, arr[0]) ^ GFMul(0x0e, arr[1]) </div><div class="line">      ^ GFMul(0x0b, arr[2]) ^ GFMul(0x0d, arr[3]);</div><div class="line">    mtx[i+8] = GFMul(0x0d, arr[0]) ^ GFMul(0x09, arr[1]) </div><div class="line">      ^ GFMul(0x0e, arr[2]) ^ GFMul(0x0b, arr[3]);</div><div class="line">    mtx[i+12] = GFMul(0x0b, arr[0]) ^ GFMul(0x0d, arr[1]) </div><div class="line">      ^ GFMul(0x09, arr[2]) ^ GFMul(0x0e, arr[3]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 轮密钥加变换 - 将每一列与扩展密钥进行异或</div><div class="line">void AddRoundKey(byte mtx[4*4], word k[4]) &#123;</div><div class="line">  for(int i=0; i&lt;4; ++i) &#123;</div><div class="line">    word k1 = k[i] &gt;&gt; 24;</div><div class="line">    word k2 = (k[i] &lt;&lt; 8) &gt;&gt; 24;</div><div class="line">    word k3 = (k[i] &lt;&lt; 16) &gt;&gt; 24;</div><div class="line">    word k4 = (k[i] &lt;&lt; 24) &gt;&gt; 24;</div><div class="line">     </div><div class="line">    mtx[i] = mtx[i] ^ byte(k1.to_ulong());</div><div class="line">    mtx[i+4] = mtx[i+4] ^ byte(k2.to_ulong());</div><div class="line">    mtx[i+8] = mtx[i+8] ^ byte(k3.to_ulong());</div><div class="line">    mtx[i+12] = mtx[i+12] ^ byte(k4.to_ulong());</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 解密</div><div class="line">void decrypt(byte in[4*4], word w[4*(Nr+1)]) &#123;</div><div class="line">  word key[4];</div><div class="line">  for(int i=0; i&lt;4; ++i)</div><div class="line">    key[i] = w[4*Nr+i];</div><div class="line">  AddRoundKey(in, key);</div><div class="line"> </div><div class="line">  for(int round=Nr-1; round&gt;0; --round) &#123;</div><div class="line">    InvShiftRows(in);</div><div class="line">    InvSubBytes(in);</div><div class="line">    for(int i=0; i&lt;4; ++i)</div><div class="line">      key[i] = w[4*round+i];</div><div class="line">    AddRoundKey(in, key);</div><div class="line">    InvMixColumns(in);</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  InvShiftRows(in);</div><div class="line">  InvSubBytes(in);</div><div class="line">  for(int i=0; i&lt;4; ++i)</div><div class="line">    key[i] = w[i];</div><div class="line">  AddRoundKey(in, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html">阮一峰: 密码学笔记</a></li>
<li><a href="http://www.jianshu.com/p/7e30a71626a8">DES加密算法：设计与实现</a></li>
<li><a href="http://www.alonemonkey.com/2016/05/25/aes-and-des/">AloneMonkey: DES和AES算法详解</a></li>
<li><a href="http://www.cnblogs.com/songwenlong/p/5944139.html">安全体系（一）—— DES算法详解</a></li>
<li><a href="http://keeganlee.me/post/reading/20160629">Keegan小钢: 读《图解密码技术》(一):密码</a></li>
<li><a href="https://my.oschina.net/zchuanzhao/blog/525898">对称加密算法DES、3DES原理和实现方式</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%87%8D%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95">Wikipedia：三重資料加密演算法-密钥选项</a></li>
<li><a href="https://songlee24.github.io/2014/12/13/aes-encrypt/">神奕的博客：AES加密算法的C++实现</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　加密方法可以分为两大类：一类是对称密码体制，又称单钥或私钥密码体制（private key cryptography）；还有一类是非对称密码体制，也称双钥或公开密钥体制（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。&lt;br&gt;　　在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要，一旦秘钥泄露，密文也就被破解了；在双钥加密的情况下，秘钥有两把，一把是公开的公钥，还有一把是不公开的私钥，公钥与私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。此外，①同时生成公钥和私钥应该是相对比较容易的：所有的公钥、私钥对都不同，用公钥可以解开私钥加密的信息，反之用私钥也可以解开公钥加密的信息；但是②从公钥推算出私钥，应该是很困难或者是不可能的。&lt;br&gt;　　目前，通用的单钥加密算法有 DES（Data Encryption Standard），通用的双钥加密算法为 RSA（Rivest-Shamir-Adleman），本文主要介绍三种常用的单钥加密算法：DES、3DES（Triple DES） 以及 AES（Advanced Encryption Standard）。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="DES" scheme="http://durant35.github.io/tags/DES/"/>
    
      <category term="AES" scheme="http://durant35.github.io/tags/AES/"/>
    
  </entry>
  
  <entry>
    <title>JPEG编码&amp;算术编码、LZW编码</title>
    <link href="http://durant35.github.io/2017/07/11/programPearls_JPEG$Arithmetic$LZW/"/>
    <id>http://durant35.github.io/2017/07/11/programPearls_JPEG$Arithmetic$LZW/</id>
    <published>2017-07-11T10:02:16.000Z</published>
    <updated>2017-07-12T09:35:22.643Z</updated>
    
    <content type="html"><![CDATA[<p>　　本文介绍 JPEG 编解码过程（附简单的<code>cpp</code>实现）。JPEG 中常用到的熵编码是变长编码：Huffman 编码，本文也对算术编码（附<code>cpp</code>实现）、LZW 编码（附<code>py</code>实现）两种熵编码进行介绍。<a id="more"></a></p>
<h4 id="JPEG-编解码过程"><a href="#JPEG-编解码过程" class="headerlink" title="JPEG 编解码过程"></a>JPEG 编解码过程</h4><ul>
<li>JPEG 编码过程<br>  <center><img src="/img/programPearls/jpeg/JPEG_Diagram.jpg" width="480px" alt=""/></center><ul>
<li>色彩空间转换<br>$\quad$ 将 RGB 色彩空间转换到其他色彩空间，比如 YUV 色彩空间，根据人对亮度更敏感些，增加亮度的信号，减少颜色的信号，以这样“欺骗”人的眼睛的手段来节省空间。YUV 的格式也很多，常见的有 420 和 422 格式。在 420 格式中，<font color="blue">每四个 Y 共用一组  UV 分量</font>，每个 YUV 分量和 RGB 一样都用 8 位来表示，YUV 色彩空间就比 RGB 色彩空间所需的存储空间少一半，数据就被压缩到了一半。</li>
<li>将图像 8×8 分块<br>$\quad$ 对图像按一定的采样格式进行采样，常见的格式有 4:4:4、4:2:2 和 4:2:0，采样完成后，将图像按 8×8(pixel) 划分成 MCU。</li>
<li>离散余弦变换 DCT<ul>
<li>DCT 将时间或空间数据变成频率数据，利用人的听觉或视觉对高频信号（的变化）不敏感和对不同频带数据的感知特征不一样等特点，可以对多媒体数据进行压缩。</li>
<li>DCT 是数码率压缩需要常用的一个变换编码方法：①任何连续的实对称函数的傅里叶变换中只含余弦项，因此余弦变换与傅里叶变换一样有明确的物理意义；②由于大多数图像的高频分量较小，相应于图像高频分量的系数经常为零，加上人眼对高频成分的失真不敏感，所以可用更粗的量化。</li>
<li>传送变换系数的数码率要大大小于传送图像像素所用的数码率，到达接收端后通过反离散余弦变换回到样值，虽然会有一定的失真，但人眼是可以接受的。</li>
<li>二维正反离散余弦变换（FDCT/IDCT）的公式如下：<br>$$C(\omega) = \begin{cases} \frac{1}{\sqrt{2}}, \space\space \omega = 0 \cr 1, \quad \omega \gt 0 \end{cases}$$ $$ FDCT: F(u, v) = \frac{2}{N} C(u)C(v) \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} f(x, y) cos[\frac{(2x+1)u \pi}{2N}] cos[\frac{(2y+1)v \pi}{2N}]$$ $$IDCT: f(x, y) = \frac{2}{N} \sum_{u=0}^{N-1} \sum_{v=0}^{N-1} C(u)C(v)F(u, v) cos[\frac{(2x+1)u \pi}{2N}] cos[\frac{(2y+1)v \pi}{2N}]$$<ul>
<li>其中 $N$ 是像块的水平、垂直像素数，一般取 $N=8$。$N$ 大于 8 时效率增加不多但复杂性大为增加。8×8 的二维数据块经 DCT 后变成 8×8 个变换系数，这些系数都有明确的意义：$F(u=0, v=0)$ 是原 64 个样值的平均，相当于直流分量；随着 $u$、$v$ 值增加，相应系数分别代表逐步增加的水平空间频率和垂直空间频率分量的大小，如下图：<center><img src="/img/programPearls/jpeg/DCT_schematic.png" width="440px" alt=""/></center></li>
<li>图像信号被分解成直流信号+从低频到高频的各种余弦成分；DCT 系数只是表示了该种成分所占原图像信号的份额大小；显然，恢复图像信息可以表示这样一个矩阵形式：$f(x, y) = F(u, v) * C(u, v)$，$C(u, v)$ 是一个基底，$F(u, v)$ 是 DCT 系数，$f(x, y)$ 则是图像信号。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>FDCT</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> w)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> w&gt;<span class="number">0</span>?<span class="number">1</span>:<span class="keyword">double</span>(<span class="number">1</span>/<span class="built_in">sqrt</span>(<span class="number">2</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">func_F</span><span class="params">(<span class="keyword">int</span> f[][<span class="number">8</span>], <span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</div><div class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">8</span>; j++)&#123;</div><div class="line">      sum += f[i][j]*<span class="built_in">cos</span>((<span class="number">2</span>*i+<span class="number">1</span>)*u*M_PI/<span class="number">16</span>)*<span class="built_in">cos</span>((<span class="number">2</span>*j+<span class="number">1</span>)*v*M_PI/<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="number">0.25</span>*C(u)*C(v)*sum;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// DCT transform </span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fdct</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      F[row][col] = func_F(f, row, col);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>量化（quantization）<ul>
<li>量化是对经过 FDCT 变换后的频率系数进行量化，是一个将信号的幅度离散化的过程，离散信号经过量化后变为数字信号；量化的目的是减少非“0”系数的幅度以及增加“0”值系数的数目，利用人眼对高频部分不敏感的特性来舍去高频部分。</li>
<li>对于有损压缩算法，JPEG 算法使用均匀量化器进行量化，量化步距是按照系数所在的位置和每种颜色分量的色调值来确定的，因为人眼对亮度信号比对色差信号敏感，因此使用了如下两种量化表：标准亮度量化表（<code>bright_table.txt</code>）和标准色差量化表（<code>color_diff_table.txt</code>）。</li>
</ul>
</li>
<li><figure class="highlight cpp"><figcaption><span>bright_table.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">17</span>	<span class="number">18</span>	<span class="number">24</span>	<span class="number">47</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">18</span>	<span class="number">21</span>	<span class="number">26</span>	<span class="number">66</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">24</span>	<span class="number">26</span>	<span class="number">56</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">47</span>	<span class="number">66</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div><div class="line"><span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span>	<span class="number">99</span></div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight cpp"><figcaption><span>color_diff_table.txt</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">16</span>	<span class="number">11</span>	<span class="number">10</span>	<span class="number">16</span>	<span class="number">24</span>	<span class="number">40</span>	<span class="number">51</span>	<span class="number">61</span></div><div class="line"><span class="number">12</span>	<span class="number">12</span>	<span class="number">14</span>	<span class="number">19</span>	<span class="number">26</span>	<span class="number">58</span>	<span class="number">60</span>	<span class="number">55</span></div><div class="line"><span class="number">14</span>	<span class="number">13</span>	<span class="number">16</span>	<span class="number">24</span>	<span class="number">40</span>	<span class="number">57</span>	<span class="number">69</span>	<span class="number">56</span></div><div class="line"><span class="number">14</span>	<span class="number">17</span>	<span class="number">22</span>	<span class="number">29</span>	<span class="number">51</span>	<span class="number">87</span>	<span class="number">80</span>	<span class="number">62</span></div><div class="line"><span class="number">18</span>	<span class="number">22</span>	<span class="number">37</span>	<span class="number">56</span>	<span class="number">68</span>	<span class="number">109</span>	<span class="number">103</span>	<span class="number">77</span></div><div class="line"><span class="number">24</span>	<span class="number">35</span>	<span class="number">55</span>	<span class="number">64</span>	<span class="number">81</span>	<span class="number">104</span>	<span class="number">113</span>	<span class="number">92</span></div><div class="line"><span class="number">49</span>	<span class="number">64</span>	<span class="number">78</span>	<span class="number">87</span>	<span class="number">103</span>	<span class="number">121</span>	<span class="number">120</span>	<span class="number">101</span></div><div class="line"><span class="number">72</span>	<span class="number">92</span>	<span class="number">95</span>	<span class="number">98</span>	<span class="number">112</span>	<span class="number">100</span>	<span class="number">103</span>	<span class="number">99</span></div></pre></td></tr></table></figure>
<ul>
<li>由于人眼对低频分量的图像比对高频分量更敏感，因此左上角的量化步距要比右下角的量化步距小；把 DCT 系数块的数值除以对应量化表位置上的数值，并四舍五入到最近的整数；解码的时候，反量化步骤会乘回量化表相应值，但是四舍五入导致低频有所损失，高频“0”字段被舍弃；这一步为有损运算，会导致图像质量变低，量化是图像质量下降的最主要原因，所以说 JPEG 编码是有损压缩。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> Q[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"><span class="keyword">int</span> Sq[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">color_diff_quantization_table_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename)</span></span>&#123;</div><div class="line">  <span class="function">ifstream <span class="title">in</span><span class="params">(filename)</span></span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>; col++)&#123;</div><div class="line">      in &gt;&gt; Q[row][col];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  in.close();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Sq(u,v) = round(F(u,v) / Q(u,v))</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quantilize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="comment">//color_diff_quantization_table_init("bright_table.txt");</span></div><div class="line">  color_diff_quantization_table_init(<span class="string">"color_diff_table.txt"</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      Sq[row][col] = round(F[row][col] / Q[row][col]);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>zig-zag Z 字形游程编码<br>$\quad$ 量化后的数据还可以通过以下 ZigZag 表的规则进行重排后，重排后的结果中可以看到出现连续的多个 0，达到简化、更大程度的去压缩，这样有利于进行游程编码。<center><img src="/img/programPearls/jpeg/zig-zagTable.png" width="720px" alt=""/></center></li>
<li>使用差分脉冲编码调制（DPCM）对直流系数（DC）进行编码<br>$\quad$ 8×8 图像经过 DCT 变换之后得到的 DC 直流系数有两个特点：一是系数的数值比较大；二是相邻 8×8 图像块的 DC 系数值变化不大。根据这两个特点，JPEG 算法使用了差分脉冲调制编码（DPCM）技术，对相邻图像块之间量化的 DC 系数的差值（Delta）进行编码：$Delta = DC(0, 0)_k - DC(0, 0)_{k-1}$</li>
<li>使用行程长度编码（RLE）对交流系数（AC）进行编码<ul>
<li>Z 字形读出的量化后的 AC 系数的特点是 1×64 矢量中包含有许多“0”系数并且许多“0”是连续的，因此使用非常简单和直观的游程长度编码（RLE）对它们进行编码：只将“0”作为重复的内容，JPEG 使用了一个字节的高4位来表示连续“0”的个数（最多重复内容可以记录数量为 15，超过 15 次要进行分段处理），而使用它的低4位来表示编码下一个非“0”系数所需要的位数；特别到最后，如果都是“0”，在读到最后一个数后，只要给出“快结束”（EOB）码字，就可以结束输出，因此节省了很多码率。</li>
<li>如下面的 4×4 图像块 $\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 2 &amp; 4 &amp; 0 &amp; 0 \\ 5 &amp; 0 &amp; 0 &amp; 0 \\ 8 &amp; 0 &amp; 0 &amp; 0 \end{bmatrix}$，按 Z 字形抽取得到的码字是：$\verb|{| 1, 0, 2, 5, 4, 0, 0, 0, 0, 8, 0, …, 0 \verb|}|$，经过游程编码得到的码值为：<code>(0,1,0)(1,2,0)(0,5,0)(0,4,0)(4,8,1)EOB</code></li>
</ul>
</li>
<li>熵编码（Huffman或算术）<ul>
<li>使用熵编码还可以对 DPCM 编码后的直流 DC 系数和 RLE 编码后的交流 AC 系数作进一步的压缩；常用的熵编码有变长编码，即 哈弗曼（Huffman）编码。</li>
<li>Huffman 编码的基本原理：根据数据中元素出现的基本频率，调整元素的编码长度，以得到更高的压缩比；编码方法：对出现概率大的符号分配短字长的二进制码，对出现概率小的符号分配长字长的二进制码，得到符号的平均码长最短的码。</li>
<li>Huffman 编码的步骤：<ol>
<li>将符号按概率从小到大顺序从左至右排列叶节点；</li>
<li>连接两个概率最小的顶层节点来组成一个父节点，并在到左右子节点的两条连线上分别标记“0”和“1”（可以对概率大的赋值“0”，小的赋值“1”）；</li>
<li>重复步骤<code>2</code>，直到得到根节点，形成一棵二叉树；</li>
<li>从根节点开始到相应于每个符号的叶节点的 0/1 串，就是该符号的二进制编码。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;queue&gt;</div><div class="line">#include &lt;map&gt;</div><div class="line">#include &lt;climits&gt; // for CHAR_BIT</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line"> </div><div class="line">const int UniqueSymbols = 1 &lt;&lt; CHAR_BIT;</div><div class="line">const char* SampleString = "this is an example for huffman encoding";</div><div class="line"> </div><div class="line">typedef std::vector&lt;bool&gt; HuffCode;</div><div class="line">typedef std::map&lt;char, HuffCode&gt; HuffCodeMap;</div><div class="line"> </div><div class="line">class INode &#123;</div><div class="line">public:</div><div class="line">    const int f;</div><div class="line">    virtual ~INode() &#123;&#125;</div><div class="line">protected:</div><div class="line">    INode(int f) : f(f) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">class InternalNode : public INode &#123;</div><div class="line">public:</div><div class="line">    INode *const left;</div><div class="line">    INode *const right;</div><div class="line">    InternalNode(INode* c0, INode* c1) : INode(c0-&gt;f + c1-&gt;f), left(c0), right(c1) &#123;&#125;</div><div class="line">    ~InternalNode()&#123;</div><div class="line">        delete left;</div><div class="line">        delete right;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">class LeafNode : public INode &#123;</div><div class="line">public:</div><div class="line">    const char c;</div><div class="line">    LeafNode(int f, char c) : INode(f), c(c) &#123;&#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">struct NodeCmp&#123;</div><div class="line">    bool operator() (const INode* lhs, const INode* rhs) const &#123; return lhs-&gt;f &gt; rhs-&gt;f; &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">INode* BuildTree(const int (&amp;frequencies)[UniqueSymbols]) &#123;</div><div class="line">    std::priority_queue&lt;INode*, std::vector&lt;INode*&gt;, NodeCmp&gt; trees;</div><div class="line"> </div><div class="line">    for (int i = 0; i &lt; UniqueSymbols; ++i) &#123;</div><div class="line">        if(frequencies[i] != 0)</div><div class="line">            trees.push(new LeafNode(frequencies[i], (char)i));</div><div class="line">    &#125;</div><div class="line">    while (trees.size() &gt; 1) &#123;</div><div class="line">        INode* childR = trees.top();</div><div class="line">        trees.pop();</div><div class="line"> </div><div class="line">        INode* childL = trees.top();</div><div class="line">        trees.pop();</div><div class="line"> </div><div class="line">        INode* parent = new InternalNode(childR, childL);</div><div class="line">        trees.push(parent);</div><div class="line">    &#125;</div><div class="line">    return trees.top();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void GenerateCodes(const INode* node, const HuffCode&amp; prefix, HuffCodeMap&amp; outCodes) &#123;</div><div class="line">    if (const LeafNode* lf = dynamic_cast&lt;const LeafNode*&gt;(node)) &#123;</div><div class="line">        outCodes[lf-&gt;c] = prefix;</div><div class="line">    &#125;</div><div class="line">    else if (const InternalNode* in = dynamic_cast&lt;const InternalNode*&gt;(node)) &#123;</div><div class="line">        HuffCode leftPrefix = prefix;</div><div class="line">        leftPrefix.push_back(false);</div><div class="line">        GenerateCodes(in-&gt;left, leftPrefix, outCodes);</div><div class="line"> </div><div class="line">        HuffCode rightPrefix = prefix;</div><div class="line">        rightPrefix.push_back(true);</div><div class="line">        GenerateCodes(in-&gt;right, rightPrefix, outCodes);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main() &#123;</div><div class="line">    // Build frequency table</div><div class="line">    int frequencies[UniqueSymbols] = &#123;0&#125;;</div><div class="line">    const char* ptr = SampleString;</div><div class="line">    while (*ptr != '\0')</div><div class="line">        ++frequencies[*ptr++];</div><div class="line"> </div><div class="line">    INode* root = BuildTree(frequencies);</div><div class="line"> </div><div class="line">    HuffCodeMap codes;</div><div class="line">    GenerateCodes(root, HuffCode(), codes);</div><div class="line">    delete root;</div><div class="line"> </div><div class="line">    for (HuffCodeMap::const_iterator it = codes.begin(); it != codes.end(); ++it) &#123;</div><div class="line">        std::cout &lt;&lt; it-&gt;first &lt;&lt; " ";</div><div class="line">        std::copy(it-&gt;second.begin(), it-&gt;second.end(),</div><div class="line">                  std::ostream_iterator&lt;bool&gt;(std::cout));</div><div class="line">        std::cout &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>组成位数据流<br>$\quad$ JPEG 编码的最后一个步骤是把各种标记代码和编码后的图像数据组成一帧一帧的数据，这样做的目的是为了便于传输、存储和译码器进行译码，这样组织的数据通常称为 JPEG 位数据流（JPEG bitstream）。</li>
</ul>
</li>
<li>JPEG 解码过程<br>  <center><img src="/img/programPearls/jpeg/JPEG_Decompression.jpg" width="640px" alt=""/></center><ul>
<li>AC 系数、DC 系数的解码<br>$\quad$ 每个颜色分量单元都应该由两部分组成：1 个直流分量和 63 个交流分量。</li>
<li>直流系数的差分编码</li>
<li>反量化</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// inverse quantization</span></div><div class="line"><span class="keyword">int</span> invSq[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"> </div><div class="line"><span class="comment">// invSq(u,v) = Sq(u,v) * Q(u,v)</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse_quantilize</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      invSq[row][col] = Sq[row][col] * Q[row][col];</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>反 Zig-Zag 编码</li>
<li>反离散余弦变换（Inverse DCT）</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// reconstructed sample data</span></div><div class="line"><span class="keyword">int</span> invV[<span class="number">8</span>][<span class="number">8</span>];</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">func_f</span><span class="params">(<span class="keyword">int</span> F[][<span class="number">8</span>], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">  <span class="keyword">double</span> sum = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u&lt;<span class="number">8</span>; u++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v=<span class="number">0</span>; v&lt;<span class="number">8</span>; v++)&#123;</div><div class="line">      sum += C(u)*C(v)*F[u][v]*<span class="built_in">cos</span>((<span class="number">2</span>*i+<span class="number">1</span>)*u*M_PI/<span class="number">16</span>)*<span class="built_in">cos</span>((<span class="number">2</span>*j+<span class="number">1</span>)*v*M_PI/<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;	</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> <span class="number">0.25</span>*sum;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">reconstruct</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</div><div class="line">  <span class="comment">// inverse DCT transform</span></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>; row&lt;<span class="number">8</span>; row++)&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>; col&lt;<span class="number">8</span>;col++)&#123;</div><div class="line">      invV[row][col] = func_f(invSq, row, col);</div><div class="line">      <span class="comment">// inverse of pre process</span></div><div class="line">      invV[row][col] += <span class="number">128</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>YCrCb（YUV） 向 RGB 转换</li>
</ul>
</li>
</ul>
<h4 id="算术编码"><a href="#算术编码" class="headerlink" title="算术编码"></a>算术编码</h4><ul>
<li>算术编码克服了 Huffman 编码必须为整数位，这与实数的概率值相差大的缺点，如在 Huffman 编码中，本来只需要 0.1 位就可以表示的符号，却必须用 1 位来表示，结果造成 10 倍的浪费。算术编码所采用的解决办法是，不用二进制代码来表示符号，而改用 $[0，1)$ 中的一个宽度等于其出现概率的实数区间来表示一个符号，符号表中的所有符号刚好布满整个 $[0，1)$ 区间（概率之和为 1，不重不漏），<font color="blue">把输入符号串（数据流）映射成 $[0，1)$ 区间中的一个实数值</font>。</li>
<li>编码方法<ul>
<li>符号串编码方法：将串中使用的符号表按原编码（如字符的ASCII编码、数字的二进制编码）从小到大顺序排列成表，计算表中每种符号 $s_i$ 出现的概率 $p_i$，然后依次根据这些符号概率大小 $p_i$ 来确定其在 $[0, 1)$ 期间中对应的小区间范围 $[x_i, y_i)$<br>$$ x_i = \sum_{j=0}^{i-1} p_j, y_i = x_i + p_i, i=1, …, m$$</li>
<li>对输入符号串进行编码<ul>
<li>设串中第 $j$ 个符号 $c_j$ 为符号表中的第 $i$ 个符号 $s_i$，则可根据 $s_i$ 在符号表中所对应区间的上下限 $x_i$ 和 $y_i$，来计算编码区间 $I_j = [l_j, r_j)$：$l_j = l_{j-1} + d_{j-1}·x_i$，$r_j = l_{j-1} + d_{j-1}·y_i$；</li>
<li>其中，$d_j = r_j - l_j$ 为区间 $I_j$ 的宽度，$l_0 = 0，r_0 = 1，d_0 = 1$。显然，$l_j$↑而 $d_j$ 与 $r_j$↓。串的最后一个符号所对应区间的下限 $l_n$ 就是该符号串的算术编码值。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"> </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> STRLEN 100</span></div><div class="line"> </div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> str[STRLEN], source_str[STRLEN];</div><div class="line">  <span class="keyword">int</span> str_len;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input a string..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cin</span>.getline(str, STRLEN);</div><div class="line"></div><div class="line">  str_len = <span class="built_in">strlen</span>(str);</div><div class="line">  <span class="built_in">strcpy</span>(source_str, str);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"*input string length: "</span>);</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; str_len &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">  <span class="built_in">printf</span>(<span class="string">"*sorting string letters in dictionary order: "</span>);</div><div class="line">  sort(str, str+str_len);</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\"%s\"\n"</span>, str);</div><div class="line"> </div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; word;				<span class="comment">//存放字符串中的字符word[i]</span></div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; freq;				<span class="comment">//存放word[i]字符所对应的频率freq[i]</span></div><div class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; endpoint;			<span class="comment">//每个字符word[i]对应频率区间的左右点[endpoint[2i], endpoint[2i+1]);</span></div><div class="line">   </div><div class="line">  <span class="comment">// 计算每个字母的频率(by dictionary order)</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len;)&#123;</div><div class="line">    <span class="keyword">int</span> tmp_num = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> cur_word = str[i];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; str_len; j++)&#123;</div><div class="line">      <span class="keyword">if</span> (str[j] == cur_word)&#123;</div><div class="line">        tmp_num++;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    word.push_back(cur_word);</div><div class="line">    freq.push_back(<span class="keyword">double</span>(tmp_num) / str_len);</div><div class="line">    i += tmp_num;</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  <span class="comment">//for (int i = 0; i &lt; word.size(); i++)&#123;</span></div><div class="line">  <span class="comment">//	cout &lt;&lt; word[i]&lt;&lt; " " &lt;&lt; freq[i] &lt;&lt; endl;</span></div><div class="line">  <span class="comment">//&#125;</span></div><div class="line">   </div><div class="line">  <span class="comment">// 计算每个字母的频率区间的左右端点</span></div><div class="line">  <span class="keyword">double</span> left_endpoint = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</div><div class="line">    endpoint.push_back(left_endpoint);</div><div class="line">    left_endpoint += freq[i];</div><div class="line">    endpoint.push_back(left_endpoint);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n----------- Symbol Table -----------\n"</span>);</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.size(); i++)&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\'%c\' %8.6lf [%8.6lf, %8.6lf)\n"</span>, word[i], freq[i], endpoint[<span class="number">2</span>*i], endpoint[<span class="number">2</span>*i+<span class="number">1</span>]);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// 编码</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"\n----------- Arithmetic Coding -----------\n"</span>);</div><div class="line">  <span class="keyword">double</span> left = <span class="number">0.</span>, right = <span class="number">1.</span>, delta = <span class="number">1.</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++)&#123;</div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.size(); j++)&#123;</div><div class="line">      <span class="keyword">if</span> (source_str[i] == word[j])&#123;</div><div class="line">        index = j;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    left = left + delta*endpoint[<span class="number">2</span> * index];</div><div class="line">    right = left + delta*endpoint[<span class="number">2</span> * index + <span class="number">1</span>];</div><div class="line">    <span class="comment">// delta = right - left = delta * (endpoint[2 * index + 1] - endpoint[2 * index]) = delta * freq[index]</span></div><div class="line">    delta = delta*freq[index];</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%c %0.18lf %0.18lf %0.18lf\n"</span>, source_str[i], left, right, delta);</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"*Arithmetic Coding Result: %.18lf\n"</span>, left);</div><div class="line">  </div><div class="line">  <span class="comment">//...</span></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>解码方法<ul>
<li>由符号表（包括符号对应的概率与区间）和实数编码 $l_n$，可以按下面的解码算法来重构输入符号串。<ul>
<li>① 设 $v_1 = l_n = \space$码值；</li>
<li>② 若 $v_j \in [x_i, y_j) \Longrightarrow c_j = s_i, j = 1, …, n$；</li>
<li>③ $v_{j+1} = \frac{v_j - x_i}{p_j}, j = 1, …, n-1$，重复步骤②、③。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; word;				<span class="comment">//存放字符串中的字符word[i]</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; freq;				<span class="comment">//存放word[i]字符所对应的频率freq[i]</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; endpoint;			<span class="comment">//每个字符word[i]对应频率区间的左右点[endpoint[2i], endpoint[2i+1]);</span></div><div class="line"> </div><div class="line"><span class="built_in">printf</span>(<span class="string">"*Arithmetic Coding Result: %.18lf\n"</span>, left);</div><div class="line"> </div><div class="line"><span class="built_in">printf</span>(<span class="string">"\n----------- Arithmetic Decoding -----------\n"</span>);</div><div class="line"><span class="keyword">double</span> v = left;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str_len; i++)&#123;</div><div class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word.size(); j++)&#123;</div><div class="line">    <span class="keyword">if</span> (v &lt; endpoint[<span class="number">2</span> * j + <span class="number">1</span>])&#123;</div><div class="line">      index = j;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%.18lf %d \'%c\'\n"</span>, v, index+<span class="number">1</span>, word[index]);</div><div class="line">  v = (v - endpoint[<span class="number">2</span> * index]) / freq[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="LZW编码"><a href="#LZW编码" class="headerlink" title="LZW编码"></a>LZW编码</h4><ul>
<li>LZW 编码和 Huffman编码、算术编码一样，是无损压缩中的一种；该算法通过建立字典，实现字符重用与编码，适用于 source 中重复率很高的文本压缩。<ul>
<li>LZW 算法是一种基于字典的编码——将变长的输入符号串映射成定长的码字——形成一本短语词典索引（串表），利用字符出现的频率冗余度及串模式高使用率冗余度达到压缩的目的。该算法只需一遍扫描，且具有自适应的特点（从空表开始逐步生成串表，码字长从 1 逐步增加到12），</font color="blue">不需保存和传送串表</font>。</li>
<li>串表具有前缀性——若串 $wc$（$c$ 为字符）在串表中，则串 $w$ 也在串表中（所以，可初始化串表为含所有单个字符的串）。</li>
<li>匹配采用贪婪算法——每次只识别与匹配串表中最长的已有串 $w$（输出对应的码字）、并可与下一输入字符 $c$ 拼成一个新的码字 $wc$。</li>
</ul>
</li>
<li>LZW 压缩算法<ul>
<li>初始化<ul>
<li>①将所有单个字符（$n$ 个不同字符）的串放入串表 ST 中（共 $n$ 项[码字为$1~n$]，实际操作时不必放入，只需空出串表的前 $n$ 项，字符对应码字所对应的串表索引即可）；</li>
<li>②读首字符入前缀串 $w$；</li>
<li>③设置码长 $codeBits = n+1$；</li>
<li>④设置串表中当前表项的索引值 $next = 初始码字 = n+1$</li>
</ul>
</li>
<li>循环<ul>
<li>⑤读下一输入字符 $c$；</li>
<li>⑥若 $c=EOF$（文件结束符），则输出 $w$ 的码字 $dict[w]$，结束循环（输出结束码字）；</li>
<li>⑦若 $wc$ 已在串表中，则 $w = wc$，转到循环开始处⑤；否则，输出 $w$ 的码字 $dict[w]$，将 $wc$ 放入 ST 中的 $next$ 处，$next++$；令 $w=c$，转到循环开始处⑤；</li>
<li>⑧若 $next$ 的位数超过码长（$\gt codeBits$），则 $codeBits++$；若串表已满（$next$ 的位数已超过最大码长 12），则清空串表，输出清表码字，转到初始化开始处①（一般不太可能发生）。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="comment"># coding= utf-8</span></div><div class="line"> </div><div class="line"><span class="keyword">import</span> sys</div><div class="line"> </div><div class="line">reload(sys)</div><div class="line">sys.setdefaultencoding(<span class="string">'utf-8'</span>)</div><div class="line"> </div><div class="line">input = raw_input(<span class="string">u"请输入字符串："</span>.encode(<span class="string">'mbcs'</span>))</div><div class="line"><span class="keyword">print</span> <span class="string">u"编码过程："</span></div><div class="line">inputlist = list(input)</div><div class="line"> </div><div class="line">wclist = list(set(inputlist))</div><div class="line">diclen = len(wclist)</div><div class="line">wclist.sort()</div><div class="line">phrases_dict = &#123;&#125;</div><div class="line"> </div><div class="line"><span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">1</span>, diclen+<span class="number">1</span>):</div><div class="line">    phrases_dict[x] = wclist[x<span class="number">-1</span>]</div><div class="line"> </div><div class="line">nextlist = range(<span class="number">1</span>, len(wclist)+<span class="number">1</span>)</div><div class="line">wlist = [<span class="string">'--'</span>] * len(wclist)</div><div class="line">procedurelist = [<span class="string">'--'</span>] * len(wclist)</div><div class="line">poslist = [<span class="string">'--'</span>]*len(wclist)</div><div class="line">mstr = <span class="string">''</span></div><div class="line">nstr = <span class="string">''</span></div><div class="line">k = <span class="number">0</span></div><div class="line"> </div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(inputlist)):</div><div class="line">    nstr = nstr + inputlist[i]</div><div class="line">    <span class="keyword">if</span> nstr <span class="keyword">in</span> wclist:</div><div class="line">        mstr = nstr</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        k = k+<span class="number">1</span></div><div class="line">        wclist.append(nstr)</div><div class="line">        nextlist.append(len(nextlist)+<span class="number">1</span>)</div><div class="line">        a = wclist.index(mstr)</div><div class="line">        wlist.append(a+<span class="number">1</span>)</div><div class="line">        procedurelist.append(k)</div><div class="line">        poslist.append(i-len(nstr)+<span class="number">2</span>)</div><div class="line">        mstr = inputlist[i]</div><div class="line">        nstr = inputlist[i]</div><div class="line"> </div><div class="line">wclist.append(<span class="string">'--'</span>)</div><div class="line">nextlist.append(<span class="string">'--'</span>)</div><div class="line">a = wclist.index(mstr)</div><div class="line">wlist.append(a+<span class="number">1</span>)</div><div class="line">procedurelist.append(k+<span class="number">1</span>)</div><div class="line">poslist.append(<span class="string">'--'</span>)</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u'步 骤  位 置   Next      Wc      输出W'</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, len(wclist)):</div><div class="line">    <span class="keyword">print</span> <span class="string">'%s\t %s\t %s\t %s\t %s\t'</span>%(procedurelist[i], poslist[i], nextlist[i], wclist[i], wlist[i])</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>LZW 还原算法<ul>
<li>初始化<ul>
<li>①将所有单个字符（$n$ 个不同字符）的串放入串表 ST 中（共 $n$ 项[码字为$1~n$]，实际操作时不必放入，只需空出串表的前 $n$ 项，字符对应码字所对应的串表索引即可）；</li>
<li>②设置码长 $codeBits = n+1$；</li>
<li>③设置串表中当前表项的索引值 $next = 初始码字 = n+1$</li>
<li>④读首个码字（所对应的单个字符）入老串 $old$，输出该字符；</li>
</ul>
</li>
<li>循环<ul>
<li>⑤读下一码字 $new$：若 $new$ 为结束码字，结束循环；若 $new$ 为清表码字，清空串表，转到初始化开始处①；</li>
<li>⑥若 $new \geq next$，则输出串 $newStr = old + old[0]$（例外处理）；若 $new \lt next$，则输出串 $newStr = ST[new]$；</li>
<li>⑦将 $old + newStr[0]$ 放入串表 ST[next] 中，$next++$；</li>
<li>⑧若 $next$ 的位数超过码长（$\gt codeBits$），则 $codeBits++$；若加一后 $codeBits \gt 12$，则重新让 $codeBits = 12$；</li>
<li>⑨$old = newStr$，转到循环开始处⑤。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_before_decode</span><span class="params">(phrases_dict)</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">u'步骤 码字   词 典    输 出'</span></div><div class="line">    keys = sorted(list(phrases_dict.keys()))</div><div class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keys:</div><div class="line">        <span class="keyword">print</span> <span class="string">'%-4s %-4s %-4s %-5s %-4s'</span> % \</div><div class="line">            (<span class="string">''</span>, <span class="string">''</span>, <span class="string">'('</span> + str(key) + <span class="string">')'</span>, phrases_dict[key], <span class="string">''</span>)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decodeLZW</span><span class="params">(codes, phrases_dict)</span>:</span></div><div class="line">    step = <span class="number">1</span></div><div class="line">    next = len(phrases_dict) + <span class="number">1</span></div><div class="line">    old = phrases_dict[codes[<span class="number">0</span>]]</div><div class="line">    <span class="keyword">print</span> <span class="string">'%-4s %-4s %-4s %-5s %-4s'</span> % \</div><div class="line">        (step, <span class="string">'(1)'</span>, <span class="string">'-'</span>, <span class="string">'-'</span>, old)</div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(codes)):</div><div class="line">        new = codes[i]</div><div class="line">        <span class="keyword">if</span> new &gt;= next:</div><div class="line">            newStr = old + old[<span class="number">0</span>]</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            newStr = phrases_dict[new]</div><div class="line">        phrases_dict[next] = old + newStr[<span class="number">0</span>]</div><div class="line">        step += <span class="number">1</span></div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'%-4s %-4s %-4s %-5s %-4s'</span> % \</div><div class="line">            (step, <span class="string">'('</span> + str(new) + <span class="string">')'</span>, <span class="string">'('</span> + str(next) + <span class="string">')'</span>,</div><div class="line">             phrases_dict[next], newStr)</div><div class="line">        next += <span class="number">1</span></div><div class="line">        old = newStr</div><div class="line"> </div><div class="line"><span class="keyword">print</span> <span class="string">u"解码过程："</span></div><div class="line">codes = wlist[diclen:]</div><div class="line">print_before_decode(phrases_dict)</div><div class="line">decodeLZW(codes, phrases_dict)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="https://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Felix: jpeg编码学习笔记</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_61d40cc30100f5e1.html">quennel的博客: JPEG编解码过程详解（一）</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_61d40cc30100f5e6.html">quennel的博客: JPEG编解码过程详解（二）</a></li>
<li><a href="http://edwin-wang.com/2006/06/jpeg%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E7%AC%94%E8%AE%B0/">EdwinWang.com: JPEG 压缩编码笔记</a></li>
<li>《多媒体技术基础：李才伟编著》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　本文介绍 JPEG 编解码过程（附简单的&lt;code&gt;cpp&lt;/code&gt;实现）。JPEG 中常用到的熵编码是变长编码：Huffman 编码，本文也对算术编码（附&lt;code&gt;cpp&lt;/code&gt;实现）、LZW 编码（附&lt;code&gt;py&lt;/code&gt;实现）两种熵编码进行介绍。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="JPEG" scheme="http://durant35.github.io/tags/JPEG/"/>
    
      <category term="LZW" scheme="http://durant35.github.io/tags/LZW/"/>
    
  </entry>
  
  <entry>
    <title>算法设计与分析[0022] BST（二叉查找树）和 R-B Tree（红黑树）</title>
    <link href="http://durant35.github.io/2017/07/08/Algorithms_BST$R-B%20Tree/"/>
    <id>http://durant35.github.io/2017/07/08/Algorithms_BST$R-B Tree/</id>
    <published>2017-07-08T04:02:22.000Z</published>
    <updated>2017-07-11T03:52:16.963Z</updated>
    
    <content type="html"><![CDATA[<p>　一些计算机程序设计中常用的线性数据结构：<code>Array</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>List</code>、<code>Stack</code>、<code>Queue</code>、<code>Hashtable</code> 和<code>Dictionary</code>。为了更高效的进行数据的查找和访问，例如避免普通数据查找的 $O(N)$ 线性时间复杂度，常用树这种数据结构保存数据。<br>　树（Tree）是由多个节点（Node）的集合组成，每个节点又有多个与其关联的子节点（Child Node）；子节点就是直接处于节点之下的节点，而父节点（Parent Node）则位于节点直接关联的上方；树的根（Root）指的是一个没有父节点的单独的节点。所有的树都呈现了一些共有的性质：<font color="blue">①只有一个根节点；②除了根节点，所有节点都有且只有一个父节点；③无环。将任意一个节点作为起始节点，都不存在任何回到该起始节点的路径（正是前两个性质保证了无环的成立）</font>。<br>　更高效同时也相对更加复杂的树型数据结构包括 <strong>BST</strong>（二叉查找树）、<strong>R-B Tree</strong>（红黑树）、<strong>AVL Tree</strong>（平衡二叉树：父节点的左子树和右子树的高度之差不能大于1）、<strong>Treap</strong>（树堆：满足①二叉查找树的性质；满足②堆的性质）、<strong>Splay Tree</strong>（伸展树：在一次搜索后，会对树进行一些特殊的操作，这些操作的理念与AVL树有些类似，即通过旋转，来改变树节点的分布，并减小树的深度；伸展树并没有AVL树的平衡要求，任意节点的左右子树可以相差任意深度）、<strong>B-Tree</strong>（B树：多叉平衡查找树，<strong>B$^{+}$-Tree</strong>（B+树）是B树的变体）等。<br>　本文主要介绍基础的 <font color="red">BST（二叉查找树）</font>以及提升搜索效率的更高级的数据结构：<font color="red">R-B Tree（红黑树）</font>。<a id="more"></a></p>
<h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><ul>
<li>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树<ul>
<li>若任意节点的左子树不空，则左子树上所有结点的值均不大于它的根结点的值</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均不小于它的根结点的值</li>
<li>任意节点的左、右子树也分别为二叉查找树</li>
</ul>
</li>
<li>二叉查找树的一般结构：</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> TreeNode &#123;</div><div class="line">  <span class="comment">// 节点关键字</span></div><div class="line">  <span class="keyword">int</span> key;</div><div class="line">  <span class="comment">// 节点卫星数据</span></div><div class="line">  type val;</div><div class="line">  <span class="comment">// 指向父节点</span></div><div class="line">  TreeNode* parent;</div><div class="line">  <span class="comment">// 指向左子树</span></div><div class="line">  TreeNode* left;</div><div class="line">  <span class="comment">// 指向右子树</span></div><div class="line">  TreeNode* right;</div><div class="line">  TreeNode(<span class="keyword">int</span> key): key(key), val(<span class="literal">NULL</span>), parent(<span class="literal">NULL</span>), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="查询二叉查找树"><a href="#查询二叉查找树" class="headerlink" title="查询二叉查找树"></a>查询二叉查找树</h4><p>　查询某元素、最大最小节点、前驱后继节点。</p>
<ul>
<li>查询某元素<ul>
<li>在二叉查找树中查询某个元素k<ul>
<li>若k大于当前节点关键字，则搜索其右子树；</li>
<li>若k小于当前节点关键字，则搜索其左子树；</li>
<li>若k等于当前节点关键字或者当前节点为空，返回当前节点。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>递归版本</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：node二叉查找树的根节点，k为待查找元素</span></div><div class="line"><span class="comment">//输出：查找到的对应节点</span></div><div class="line">Tree-Search(node, k)</div><div class="line">  <span class="keyword">if</span>(node==<span class="literal">NULL</span> || k==node-&gt;key)</div><div class="line">    <span class="keyword">return</span> node;</div><div class="line">  <span class="keyword">if</span>(k &lt; node-&gt;key)</div><div class="line">    <span class="keyword">return</span> Tree-Search(node-&gt;left, k);</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> Tree-Search(node-&gt;right, k);</div></pre></td></tr></table></figure>
</li>
<li>  <figure class="highlight cpp"><figcaption><span>非递归版本</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：node二叉查找树的根节点，k为待查找元素</span></div><div class="line"><span class="comment">//输出：查找到的对应节点</span></div><div class="line">Tree-Search(node, k)</div><div class="line">  <span class="keyword">while</span>(node!=<span class="literal">NULL</span> &amp;&amp; k!=node-&gt;key) &#123;</div><div class="line">    <span class="keyword">if</span>(k &lt; node-&gt;key)</div><div class="line">      node = node-&gt;left;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      node = node-&gt;right;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> node;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>查询最大最小节点<ul>
<li>最大节点：二叉查找树最右侧节点</li>
<li>最小节点：二叉查找树最左侧节点</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Tree-Minimum(node)</div><div class="line">  <span class="keyword">while</span>(node-&gt;left != <span class="literal">NULL</span>)</div><div class="line">    node = node-&gt;left;</div><div class="line">  <span class="keyword">return</span> node;</div><div class="line"> </div><div class="line">Tree-Maximum(node)</div><div class="line">  <span class="keyword">while</span>(node-&gt;right != <span class="literal">NULL</span>)</div><div class="line">    node = node-&gt;right;</div><div class="line">  <span class="keyword">return</span> node;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>查询前驱后继节点<ul>
<li>后继：指关键字大于某节点<code>key[x]</code>的所有节点中，关键字最小的节点，即对树进行中序遍历，紧随其后的节点。</li>
<li>前驱：小于某节点<code>key[x]</code>的关键字中最大的那个节点，即树的中序遍历中，排在其前的节点。</li>
<li>求某个节点的后继节点分为三种情况：<ul>
<li>该节点有右子树，则其后继节点是其右子树的最左侧节点，即右子树的最小节点。</li>
<li>该节点无右子树，但是父节点的左孩子，则该节点的后继节点是该父节点。</li>
<li>该节点无右子树，且是父节点的右孩子，则需要一直向上搜索，直到它的<code>n-1</code>代祖先是它第<code>n</code>代祖先的左孩子，则它的后继就是第<code>n</code>个祖先。如果一直搜索到根节点，也没有找到<code>n-1</code>代祖先是它第<code>n</code>代祖先的左孩子，则该节点是整个树的中序遍历中的最后一个节点，即它没有后继。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Tree-Successor(node)</div><div class="line">  <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> Tree-Minimum(node-&gt;right)</div><div class="line">  <span class="comment">//x用来保存待确定的节点</span></div><div class="line">  <span class="comment">//y为x的父节点</span></div><div class="line">  x = node;</div><div class="line">  TreeNode y = x-&gt;parent;</div><div class="line">  <span class="comment">// x==y-&gt;right &lt;==&gt; x!=y-&gt;left</span></div><div class="line">  <span class="keyword">while</span>(y!=<span class="literal">NULL</span> &amp;&amp; x==y-&gt;right)</div><div class="line">    x = y;</div><div class="line">    y = x-&gt;parent;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> y;</div></pre></td></tr></table></figure>
<ul>
<li>求某个节点的前驱节点与求后继节点类似：<ul>
<li>该节点有左子树，则其前驱节点是其左子树的最右侧节点，即左子树的最大节点。</li>
<li>该节点无左子树，但是父节点的右孩子，则该节点的前驱节点是该父节点。</li>
<li>该节点无左子树，且是父节点的左孩子，则需要一直向上搜索，直到它的<code>n-1</code>代祖先是它第<code>n</code>代祖先的右孩子，则它的后继就是第<code>n</code>个祖先。如果一直搜索到根节点，也没有找到<code>n-1</code>代祖先是它第<code>n</code>代祖先的右孩子，则该节点是整个树的中序遍历中的第一个节点，即它没有前驱。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Tree-Predecessor(node)</div><div class="line">  <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)</div><div class="line">    <span class="keyword">return</span> Tree-Maximum(node-&gt;right)</div><div class="line">  <span class="comment">//x用来保存待确定的节点</span></div><div class="line">  <span class="comment">//y为x的父节点</span></div><div class="line">  x = node;</div><div class="line">  TreeNode y = x-&gt;parent;</div><div class="line">  <span class="comment">// x==y-&gt;left &lt;==&gt; x!=y-&gt;right</span></div><div class="line">  <span class="keyword">while</span>(y!=<span class="literal">NULL</span> &amp;&amp; x==y-&gt;left)</div><div class="line">    x = y;</div><div class="line">    y = x-&gt;parent;</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> y;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h4><p>　插入和删除需要在保持二叉查找树性质的情况下，对树进行修改。</p>
<ul>
<li>插入<ul>
<li>若为空树，则直接将插入的节点作为根节点；</li>
<li>若插入节点关键字小于当前节点关键字，应插入在当前节点左子树中；否则应插入在右子树中；</li>
<li>直到当前节点为叶子节点，则将插入节点变成当前节点的左孩子或右孩子。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Tree-Insert(root, node)</div><div class="line">  curNode = root</div><div class="line">  leafNode = <span class="literal">NULL</span></div><div class="line">  <span class="keyword">while</span>(curNode != <span class="literal">NULL</span>)</div><div class="line">    leafNode = curNode</div><div class="line">    <span class="keyword">if</span>(node-&gt;key &gt;= curNode-&gt;key)</div><div class="line">      curNode = curNode-&gt;right</div><div class="line">    <span class="keyword">else</span></div><div class="line">      curNode = curNode-&gt;left</div><div class="line"> </div><div class="line">  node-&gt;parent = leafNode</div><div class="line">  <span class="comment">// 当前树为空树</span></div><div class="line">  <span class="keyword">if</span>(leafNode==<span class="literal">NULL</span>)</div><div class="line">    root = node</div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">if</span>(node-&gt;key &gt;= leafNode-&gt;key)</div><div class="line">      leafNode-&gt;right = node</div><div class="line">    <span class="keyword">else</span></div><div class="line">      leafNode-&gt;left = node</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>删除<ul>
<li>相比插入，删除操作较为复杂。删除操作分为三种情况：<ul>
<li>若删除节点为叶子节点（没有左右子树），此时删除该节点不会破坏二叉查找树的结构，则直接将其删除；</li>
<li>若删除节点只有一个子节点，则用子节点<strong>替代</strong>删除节点的位置（直接删除该节点，并将其左子树或者右子树设置为其父节点的左子树或者右子树即可，此操作不会破坏二叉查找树的结构），此时该子节点称为“替代节点”；</li>
<li>若删除节点有两个子节点，一般的删除策略是用其右子树的最小数据（容易找到）代替要删除的节点数据，并删除该节点（此时为<code>NULL</code>）：因为右子树的最小节点不可能有左孩子，所以第二次删除较为容易。<br><center><img src="/img/Algorithms/0022_BSTDeletewithLeftRight.png" width="640px" alt=""/></center><ul>
<li>右子树的最小数据即为当前节点的<strong>后继节点</strong>，$z$ 的左子树和右子树均不空，找到 $z$ 的后继 $y$，用 $y$ 的值代替 $z$ 的值；因为 $y$ 一定没有左子树，所以可以删除 $y$，并让 $y$ 的父亲节点成为 $y$ 的右子树的父亲节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">Tree-Delete(root, node)</div><div class="line">  curNode = root;</div><div class="line">  parent = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">while</span>(<span class="literal">NULL</span> != node) &#123;</div><div class="line">    <span class="keyword">if</span>(node-&gt;key &lt; curNode-&gt;key) &#123;</div><div class="line">      parent = curNode;</div><div class="line">      curNode = curNode-&gt;left;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &gt; curNode-&gt;key) &#123;</div><div class="line">      parent = curNode;</div><div class="line">      curNode = curNode-&gt;right;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// found</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 叶子节点</span></div><div class="line">      <span class="keyword">if</span>(<span class="literal">NULL</span>==curNode-&gt;left &amp;&amp; <span class="literal">NULL</span>==curNode-&gt;right) &#123;</div><div class="line">        <span class="comment">// 根结点</span></div><div class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>) &#123; </div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 非根结点</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 父节点的左子树部分还是右子树部分</span></div><div class="line">          (parent-&gt;left==curNode)? (parent-&gt;left=<span class="literal">NULL</span>) : (parent-&gt;right=<span class="literal">NULL</span>);</div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 只有左孩子</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span>!=curNode-&gt;left &amp;&amp; <span class="literal">NULL</span>==curNode-&gt;right) &#123;</div><div class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>) &#123;</div><div class="line">          TreeNode tmp = curNode;</div><div class="line">          curNode = curNode-&gt;left;</div><div class="line">          <span class="keyword">delete</span> tmp;</div><div class="line">          tmp = <span class="literal">NULL</span>; </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 父节点的左子树部分还是右子树部分</span></div><div class="line">          (parent-&gt;left==curNode)?(parent-&gt;left=curNode-&gt;left):(parent-&gt;right=curNode-&gt;left);</div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 只有右孩子</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(<span class="literal">NULL</span>==curNode-&gt;left &amp;&amp; <span class="literal">NULL</span>!=curNode-&gt;right) &#123;</div><div class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>) &#123;</div><div class="line">          TreeNode tmp = curNode;</div><div class="line">          curNode = curNode-&gt;right;</div><div class="line">          <span class="keyword">delete</span> tmp;</div><div class="line">          tmp = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 父节点的左子树部分还是右子树部分</span></div><div class="line">          (parent-&gt;left==curNode)?(parent-&gt;left=curNode-&gt;right):(parent-&gt;right=curNode-&gt;right);</div><div class="line">          <span class="keyword">delete</span> curNode;</div><div class="line">          curNode = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 既有左孩子又有右孩子</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        TreeNode* rightNode = curNode;</div><div class="line">        <span class="keyword">while</span>(rightNode-&gt;left != <span class="literal">NULL</span>) &#123;</div><div class="line">          parent = rightNode;</div><div class="line">          rightNode = rightNode-&gt;left;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 交换rightNode与curNode</span></div><div class="line">        <span class="keyword">int</span> swapKey = rightNode-&gt;key;</div><div class="line">        rightNode-&gt;key = curNode-&gt;key;</div><div class="line">        curNode-&gt;key = swapKey;</div><div class="line"> </div><div class="line">        <span class="comment">// 删除rightNode，parent肯定不为空</span></div><div class="line">        <span class="comment">// 后继节点没有右孩子</span></div><div class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == rightNode-&gt;right) &#123;</div><div class="line">          parent-&gt;left = <span class="literal">NULL</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">          parent-&gt;left = rightNode-&gt;right;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="keyword">delete</span> rightNode;</div><div class="line">        rightNode = <span class="literal">NULL</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="满二叉树-amp-完全二叉树"><a href="#满二叉树-amp-完全二叉树" class="headerlink" title="满二叉树&amp;完全二叉树"></a>满二叉树&amp;完全二叉树</h4><ul>
<li>满二叉树（Full Binary Tree）<ul>
<li>官方解释<blockquote>
<p>A full binary tree is a tree in which every node other than the leaves has two children.</p>
</blockquote>
</li>
<li>总节点数 $k$：深度为 $h$，有 $k = 2^h - 1$</li>
<li>树高 $h$：$h = log_2 (k+1)$<center><img src="/img/Algorithms/0022_FBT&CBT.jpg" width="420px" alt=""/></center></li>
</ul>
</li>
<li>完全二叉树（Complete Binary Tree）<ul>
<li>官方解释<blockquote>
<p>A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.</p>
</blockquote>
</li>
<li>深度为 $h$，有 $n$ 个节点的二叉树，当且仅当其每一个节点都与深度为 $h$ 的满二叉树中，序号为 $1$ 至 $n$ 的节点对应时，为一棵<strong>完全二叉树</strong>。</li>
<li>总节点数 $k$：深度为 $h$，有 $2^{h-1} \leq k \lt 2^h - 1$</li>
<li>树高 $h$：$h = log_2 k + 1$</li>
</ul>
</li>
</ul>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>　一棵由 $N$ 个节点的随机构造的二叉查找树的高度为 $logN$，所以顺理成章，二叉查找树的一般操作（主要是查找）的执行时间为 $O(logN)$。但二叉查找树若退化成了一棵具有 $N$ 个节点的线性链后，这些操作就变成最坏情况，运行时间变成 $O(N)$。<br>　红黑树虽然本质上是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的插入、删除、主要是查找的时间复杂度最坏为 $O(logN)$。</p>
<ul>
<li>R-B Tree(Red-Black Tree)，它是一种特殊的二叉查找树，红黑树的每个节点除了包含<code>key</code>、<code>left</code>、<code>right</code>、<code>parent</code>外，还有存储位表示节点的颜色，可以是红(Red)或黑(Black)。但它是如何保证一棵 $N$ 个节点的红黑树的高度始终在 $logN$ 的呢？这就引出了红黑树的 5 个性质：<br>  <center><img src="/img/Algorithms/0022_R-B Tree.png" width="480px" alt=""/></center><ul>
<li>①每个节点不是黑色便是红色；</li>
<li>②根节点为黑色；</li>
<li>③每个叶子节点（<font color="red">即指树尾端那些空(<code>NIL</code>/<code>NULL</code>)的叶子节点</font>）是黑色的；</li>
<li>④如果一个节点是红色的，则它的子节点（两个子节点）必须是黑色的（<font color="red">即从每个叶子节点到根的所有路径上不能有两个连续的红色节点</font>）；</li>
<li>⑤从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。<ul>
<li>对于任意节点而言，其到其子孙叶子节点树尾端<code>NIL</code>指针的每条路径都包含相同数目的黑节点。</li>
<li>确保没有一条路径会比其它路径长出两个节点（一红一黑），因此，红黑树相对是接近平衡的二叉树。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>　正是红黑树的这 5 条性质，使一棵 $N$ 个节点的红黑树始终保持了 $logN$ 的高度，也即</font color="blue">“保证了红黑树的插入、删除、主要是查找的时间复杂度最坏为 $O(logN)$”</font>。<br>　红黑树的应用比较广泛，主要用它来存储有序的数据，例如，Java 集合中的 TreeSet、TreeMap，C++ STL 中的 set、map，以及 Linux虚拟内存的管理，都是通过红黑树去实现的，它的时间复杂度是 $O(logN)$，效率非常之高。</p>
<h4 id="红黑树的搜索时间复杂度"><a href="#红黑树的搜索时间复杂度" class="headerlink" title="红黑树的搜索时间复杂度"></a>红黑树的搜索时间复杂度</h4><ul>
<li>下面通过<strong>数学归纳法</strong>证明定理：一棵含有$N$个节点的红黑树的高度至多为$2log(N+1)$<ul>
<li>转化为证明逆否命题<blockquote>
<p> “一棵含有 $N$ 个节点的红黑树的高度至多为 $2log(N+1)$” 的<font color="red">逆否命题</font>是：”高度为 $h$ 的红黑树，它包含的节点个数至少为 $2^{h/2}$-1 个”。我们只需要证明逆否命题，即可证明原命题为真，即只需证明 “高度为 $h$ 的红黑树，它包含的节点个数至少为 $2^{h/2}$-1 个”。</p>
</blockquote>
</li>
<li>从某个节点 $x$ 出发（不包括该节点）到达一个叶节点的任意一条路径上，黑色节点的个数称为该节点的<strong>黑高度(x’s black height)</strong>，记为 $bh(x)$。关于 $bh(x)$ 有两点需要说明：<ul>
<li>第1点：根据上述红黑树的<code>性质⑤</code>可知，从节点 $x$ 出发到达的所有的叶节点具有相同数目的黑节点，这也就意味着，$bh(x)$ 的值是唯一的！</li>
<li>第2点：根据上述红黑树的<code>性质④</code>可知，从节点 $x$ 出发达到叶节点：$所经历的黑色节点数目 \geq 所经历的红节点的数目$。假设 $x$ 是根节点，则可以得出结论：$bh(x=root) \geq h/2$。进而，我们只需证明：<font color="red">“高度为 $h$ 的红黑树，它包含的黑色节点个数至少为 $2^{bh(x)}$-1个”</font> 即可。</li>
</ul>
</li>
<li><strong>“数学归纳法”</strong> 论证：<font color="blue">“高度为 $h$ 的红黑树，它包含的黑色节点个数至少为 $2^{bh(x)}$-1个”</font><ul>
<li>①当树的高度 $h=0$ 时，节点个数是 0，$bh(x)$ 为 0，$2^{bh(x)}$-1 也为 0。显然，原命题成立。</li>
<li>②当 $h \gt 0$，无妨设树的高度为 $h$-1 时，它包含的节点个数至少为 $2^{bh(x)-1}$-1。<ul>
<li>当树的高度为 $h$ 时，对于节点 $x$（$x$ 为根节点），其黑高度为 $bh(x)$；对于节点 $x$ 的左右子树，它们黑高度为 $bh(x)$ 或者 $bh(x)$-1；</li>
<li>根据假设条件，我们已知 <font color="blue">“$x$ 的左右子树，即高度为 $h$-1 的节点，它包含的节点至少为 $2^{bh(x)-1}$-1 个” </font>；</li>
<li>所以，节点 $x$ 所包含的节点至少为：$(2^{bh(x)-1}-1) + (2^{bh(x)-1}-1) + 1 = 2^{bh(x)}-1$，即节点 $x$ 所包含的节点至少为 $2^{bh(x)}$-1。因此，原命题成立。</li>
</ul>
</li>
<li>结合①、②，得出：<font color="blue">“高度为 $h$ 的红黑树，它包含的黑色节点个数至少为 $2^{bh(x)}$-1个”</font>，因此，<font color="red">“一棵含有 $N$ 个节点的红黑树的高度至多为 $2log(N+1)$”</font>。</li>
</ul>
</li>
</ul>
</li>
<li>上述定理说明：一棵 $N$ 个节点的红黑树始终能保持 $logN$ 的高度，故</font color="blue">红黑树的各操作时间复杂度最坏为 $O(logN)$</font>，红黑树的搜索时间复杂度为：$logN$。</li>
</ul>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><ul>
<li>当对红黑树进行插入和删除等操作时，对树做了修改可能会破坏红黑树的性质。为了继续保持红黑树的性质，可以通过对树进行相关的<font color="blue">旋转操作（修改树的指针结构）</font>，以及对节点进行<font color="blue">重新着色（修改树中某些节点的颜色）</font>，来达到对红黑树进行插入或删除等操作后继续保持它的性质 $\Longrightarrow$ 平衡的目的。  <center><img src="/img/Algorithms/0022_LeftRightRotate.png" width="640px" alt=""/></center></li>
<li>如上图所示，从左图到右图的过程为左旋，反之为右旋。旋转前后 $x$、$y$ 与三棵子树 $\alpha$、$\beta$、$\gamma$ 之间的大小关系均满足红黑树的搜索性质：$\alpha \lt x \lt \beta \lt y \lt \gamma$ </li>
<li>左旋转：以 $y$ 节点为中心，将 $x$、$y$ 之间的轴（蓝色箭头）左旋（逆时针旋转），这使得 $y$ 称为该子树的新根；对 $x$ 进行左旋，意味着将 $x$ 变成一个左节点，显然是新根（即原本 $x$ 的右孩子 $y$）的左节点。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：root为树的根节点，x与x的右子节点为待左旋的节点</span></div><div class="line"><span class="comment">//输出：旋转后的树结构</span></div><div class="line">Left-Rotate(root, x)</div><div class="line">  <span class="comment">// 前提</span></div><div class="line">  y = x-&gt;right</div><div class="line">  </div><div class="line">  <span class="comment">// 将β设为x的右孩子</span></div><div class="line">  x-&gt;right = y-&gt;left</div><div class="line">  <span class="comment">// 将β的父亲设为x</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> != y-&gt;left)</div><div class="line">    y-&gt;left-&gt;parent = x</div><div class="line">  </div><div class="line">  <span class="comment">// 情况1：x的父节点为空，即x原先为根节点，将y设为根节点</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == x-&gt;parent)</div><div class="line">    root = y</div><div class="line">  <span class="comment">// 情况2：子树的根x原先是它的父亲的左孩子，将y设为x的父亲的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">    x-&gt;parent-&gt;left = y</div><div class="line">  <span class="comment">// 情况3：子树的根x原先是它的父亲的右孩子，将y设为x的父亲的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    x-&gt;parent-&gt;right = y</div><div class="line">   </div><div class="line">  <span class="comment">// 将x设为y的左孩子</span></div><div class="line">  y-&gt;left = x</div><div class="line">  <span class="comment">// 将x的父节点设为y</span></div><div class="line">  x-&gt;parent = y</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>右旋转</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入：root为树的根节点，y与y的左子节点为待右旋的节点</span></div><div class="line"><span class="comment">//输出：旋转后的树结构</span></div><div class="line">Right-Rotate(root, y)</div><div class="line">  <span class="comment">// 前提</span></div><div class="line">  x = y-&gt;left</div><div class="line"> </div><div class="line">  <span class="comment">// 将β设为y的左孩子</span></div><div class="line">  y-&gt;left = x-&gt;right</div><div class="line">  <span class="comment">// 将β的父亲设为x</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> != x-&gt;right)</div><div class="line">    x-&gt;right-&gt;parent = y</div><div class="line"> </div><div class="line">  <span class="comment">// 情况1：y的父节点为空，即y原先为根节点，将x设为根节点</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == y-&gt;parent)</div><div class="line">    root = x</div><div class="line">  <span class="comment">// 情况2：子树的根y原先是它的父亲的左孩子，将x设为y的父亲的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(y == y-&gt;parent-&gt;left)</div><div class="line">    y-&gt;parent-&gt;left = x</div><div class="line">  <span class="comment">// 情况3：子树的根y原先是它的父亲的右孩子，将x设为y的父亲的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    x-&gt;parent-&gt;right = y</div><div class="line"> </div><div class="line">  <span class="comment">// 将y设为x的右孩子</span></div><div class="line">  x-&gt;right = y</div><div class="line">  <span class="comment">// 将y的父节点设为x</span></div><div class="line">  y-&gt;parent = x</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>一棵红黑树在经过左旋和右旋之后，树的搜索性质（二叉查找树性质）保持不变，但树的红黑性质则被破坏了，因此需要通过重新着色来恢复树的红黑性质。</li>
</ul>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>　将一个节点插入到红黑树中，需要执行哪些步骤呢？首先，将红黑树当做一棵二叉查找树，将节点插入；然后，将节点着色为红色；最后，通过旋转和重新着色等方法来修正该树，使之重新成为一棵红黑树。</p>
<ul>
<li>将红黑树当做一棵二叉查找树，将节点插入。<ul>
<li>无论是左旋还是右旋，若旋转之前这棵树是一棵二叉查找树，旋转之后它一定还是二叉查找树；任何的旋转和重新着色操作，都不会改变它仍然是一棵二叉查找树的事实。</li>
<li>红黑树本身就是一棵二叉查找树，将节点插入后，该树仍然是一棵二叉查找树，即树的键值仍然是有序的。</li>
</ul>
</li>
<li>将插入的节点着色为“红色”。为什么着色成红色，而不是黑色呢？因为将着色为“红色”，不会违背红黑树<code>性质⑤</code>：从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点；少违背一条特性，就意味着我们需要处理的情况越少，接下来只需要使其满足其它性质即可。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// root为红黑树的树根，z为要插入的新节点</span></div><div class="line">RB-Insert(root, z)</div><div class="line">  <span class="comment">// 新建节点y，将y设为空节点</span></div><div class="line">  y = <span class="literal">NULL</span>;</div><div class="line">  <span class="comment">// 设红黑树的根节点为x</span></div><div class="line">  x = root;</div><div class="line"> </div><div class="line">  <span class="comment">// 找出要插入新节点z在二叉树中的位置y</span></div><div class="line">  <span class="keyword">while</span>(<span class="literal">NULL</span> != x)</div><div class="line">    y = x;</div><div class="line">    <span class="keyword">if</span>(z-&gt;key &lt; x-&gt;key)</div><div class="line">      x = x-&gt;left;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      x = x-&gt;right;</div><div class="line"> </div><div class="line">  <span class="comment">// 设z的父亲为y</span></div><div class="line">  z-&gt;parent = y;</div><div class="line">  <span class="comment">// 情况1：y是空节点，将z设为根</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == y)</div><div class="line">    root = z;</div><div class="line">  <span class="comment">// 情况2：z设为y的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;key &lt; y-&gt;key)</div><div class="line">    y-&gt;left = z;</div><div class="line">  <span class="comment">// 情况3：z设为y的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    y-&gt;right = z;</div><div class="line"> </div><div class="line">  <span class="comment">// z的左右孩子设为空格</span></div><div class="line">  z-&gt;left = <span class="literal">NULL</span>;</div><div class="line">  z-&gt;right = <span class="literal">NULL</span>;</div><div class="line">  <span class="comment">// 至此，已经完成将新节点z插入到二叉树中</span></div><div class="line"> </div><div class="line">  <span class="comment">// 将z着色为“红色”</span></div><div class="line">  z-&gt;color = RED;</div><div class="line">  <span class="comment">// 通过RB-Insert-Fixup对红黑树的节点进行颜色修改以及旋转，让树仍然是一棵红黑树</span></div><div class="line">  RB-Insert-Fixup(root, z);</div></pre></td></tr></table></figure>
<ul>
<li>接下来的问题就是：想方设法地旋转以及重新着色，是这棵树重新称为一棵红黑树！</li>
</ul>
</li>
<li>通过一系列的旋转或重新着色操作，使之重新成为一棵红黑树。<ul>
<li>将插入节点着色为“红色”之后，不会违背<code>性质⑤</code>，那它到底会违背哪些性质呢？<ul>
<li>对于<code>性质①</code>，因为已经将它涂成红色了，显然不会违背；</li>
<li>对于<code>性质②</code>，在上面步骤中我们将红黑树当做二叉查找树，然后执行插入操作；根据二叉查找树的特点，除非是根节点，插入操作不会改变根节点，所以，根节点仍然是黑色，除非插入的就是根节点；</li>
<li>对于<code>性质③</code>，显然不会违背，这里的叶子节点是指空叶子节点，插入非空节点（其左右空叶子节点初始化即为黑色的）并不会对它们造成影响；</li>
<li>对于<code>性质④</code>，很有可能违背！接下来是想办法使这棵树满足<code>性质④</code>，将树重新构造成红黑树。</li>
</ul>
</li>
<li>根据被插入节点 $N$ 的父节点的情况，可以划分为以下三类情况处理：<ul>
<li>第一类：被插入的节点是根节点 $\Longrightarrow$ 直接把新节点涂为黑色</li>
<li>第二类：被插入节点的父节点是黑色节点 $\Longrightarrow$ 新节点被插入后，仍然是红黑树</li>
<li>第三类：被插入节点的父节点是红色节点 $\Longrightarrow$ 显然与<code>性质⑤</code>冲突，这种情况下，新节点一定存在非空祖父节点（肯定有黑色的节点作为父节点的父节点）；新节点也一定存在叔叔节点，即使叔叔节点为空叶子节点，其本身也是黑色节点，视之为存在。对于这类情况，需要依据“叔叔节点的情况”，进一步划分为一下三种情况（这三种情况可能存在一定转换关系）。<ul>
<li>Case 1：叔叔节点 $U$ 是红色节点<br><center><img src="/img/Algorithms/0022_RBInsertCase1.png" width="720px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $P$ 设为黑色节点；</li>
<li>将叔叔节点 $U$ 设为黑色节点；</li>
<li>将祖父节点 $G$ 设为红色节点；</li>
<li>将祖父节点设为“当前节点”$N$，之后继续对“当前节点”进行操作。</li>
</ol>
</li>
<li>Case 2：叔叔节点 $14$ 是黑色节点，且当前节点 $N$ 是右孩子<br><center><img src="/img/Algorithms/0022_RBInsertCase2.png" width="720px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $2$ 作为新的“当前节点”$N$；</li>
<li>以新的“当前节点”$N$ 为支点进行左旋。</li>
</ol>
</li>
<li>Case 3：叔叔节点 $14$ 是黑色节点，且当前节点 $N$ 是左孩子<br><center><img src="/img/Algorithms/0022_RBInsertCase3.png" width="720px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $7$ 设为黑色节点；</li>
<li>将祖父节点 $11$ 设为红色节点；</li>
<li>以祖父节点 $11$ 为支点进行右旋。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// root为红黑树的树根，z为要插入的新节点</span></div><div class="line">RB-Insert-Fixup(root, z)</div><div class="line">  <span class="comment">// 若当前节点z的父节点是红色，则进行以下处理</span></div><div class="line">  <span class="keyword">while</span>(RED == z-&gt;parent-&gt;color)</div><div class="line">    <span class="comment">// 若z的父节点是z的祖父节点的左孩子</span></div><div class="line">    <span class="keyword">if</span>(z-&gt;parent == z-&gt;parent-&gt;parent-&gt;left)</div><div class="line">      <span class="comment">// 将y设置为z的叔叔节点（z的祖父节点的右孩子）</span></div><div class="line">      y = z-&gt;parent-&gt;parent-&gt;right;</div><div class="line"> </div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == y-&gt;color)</div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        y-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        z = z-&gt;parent-&gt;parent;</div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(z == z-&gt;parent-&gt;right)</div><div class="line">        Left-Rotate(root, z);</div><div class="line">      <span class="comment">// Case 3</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        Right-Rotate(root, z-&gt;parent-&gt;parent);</div><div class="line">    <span class="comment">// z在父节点是z的祖父节点的右孩子，与左子树原理相同，将right与left互换即可</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment">// 将y设置为z的叔叔节点（z的祖父节点的左孩子）</span></div><div class="line">      y = z-&gt;parent-&gt;parent-&gt;left;</div><div class="line"> </div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == y-&gt;color)</div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        y-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        z = z-&gt;parent-&gt;parent;</div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(z == z-&gt;parent-&gt;left)</div><div class="line">        Right-Rotate(root, z);</div><div class="line">      <span class="comment">// Case 3</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        z-&gt;parent-&gt;color = BLACK;</div><div class="line">        z-&gt;parent-&gt;parent-&gt;color = RED;</div><div class="line">        Left-Rotate(root, z-&gt;parent-&gt;parent);</div><div class="line">  <span class="comment">// 被插入的节点是根节点</span></div><div class="line">  root-&gt;color = BLACK;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>　将红黑树内的某一个节点删除，需要执行的操作依次是：首先将红黑树当做一棵二叉查找树，将该节点从二叉查找树中删除；然后，通过“旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。</p>
<ul>
<li>将红黑树当做一棵二叉查找树，将节点删除，这和在常规二叉查找树中删除节点的方法一样，分3种情况：<ul>
<li>①被删除节点没有儿子，即为叶子节点，那么，直接将该节点删除；</li>
<li>②被删除节点只有一个儿子，那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置；</li>
<li>③被删除节点有两个儿子，那么，先找出它的后继节点，然后把该后继节点的“内容”复制给该节点的“内容”，之后删除该后继节点。<ul>
<li>该后继节点相当于替身，在将后继节点的“内容”赋值给被删除节点之后，再将后继节点删除，这样就巧妙地将问题转换为“删除后继节点”的情况了；</li>
<li>在被删除节点有两个非空子节点的情况下，它的后继节点不可能是双子非空的（至少左孩子为空，否则显然不可能是后继节点）：若没有儿子，则按<code>情况①</code>进行处理；若只有一个儿子，则按<code>情况②</code>进行处理。</li>
</ul>
</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">RB-Delete(root, z)</div><div class="line">  <span class="comment">// 若z的左孩子或右孩子为空</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span>==z-&gt;left || <span class="literal">NULL</span>==z-&gt;right)</div><div class="line">    y = z;</div><div class="line">  <span class="comment">// 将z的后继节点赋值给y</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    y = Tree-Successor(z);</div><div class="line"> </div><div class="line">  <span class="comment">// y至少一个孩子为空</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> != y-&gt;left)</div><div class="line">    x = y-&gt;left;</div><div class="line">  <span class="keyword">else</span></div><div class="line">    x = y-&gt;right;</div><div class="line"> </div><div class="line">  <span class="comment">// 将y的父节点设置为x的父节点</span></div><div class="line">  x-&gt;parent = y-&gt;parent;</div><div class="line"> </div><div class="line">  <span class="comment">// 情况1：y的父节点为空，则设置x为根节点</span></div><div class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == y-&gt;parent)</div><div class="line">    root = x;</div><div class="line">  <span class="comment">// 情况2：y是它父节点的左孩子，则设置x为y的父节点的左孩子</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(y == y&gt;parent-&gt;left)</div><div class="line">    y-&gt;parent-&gt;left = x;</div><div class="line">  <span class="comment">// 情况3：y是它父节点的右孩子，则设置x为y的父节点的右孩子</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    y-&gt;parent-&gt;right = x;</div><div class="line"> </div><div class="line">  <span class="comment">// 将z的后继节点y的值赋值给z，这里只拷贝z的值给y，而没有拷贝z的颜色!!!</span></div><div class="line">  <span class="keyword">if</span>(y != z)</div><div class="line">    z-&gt;key = y-&gt;key;</div><div class="line">    <span class="comment">//copy y's satelite date into z;</span></div><div class="line"> </div><div class="line">  <span class="comment">// 若y为黑色节点</span></div><div class="line">  <span class="keyword">if</span>(BLACK == y-&gt;color)</div><div class="line">    RB-Delete-Fixup(root, x);</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>上一步中删除节点之后，可能会违背红黑树的性质，所以需要通过“旋转和重新着色”来修正该树，使之重新成为一棵红黑树。<ul>
<li>由上面的算法，我们知道：删除节点 $y$ 之后，$x$ 占据了原本节点 $y$ 的位置。既然删除 $y$（$y$ 是黑色节点），意味着减少一个黑色节点，那么，再在该位置上增加一个黑色节点即可，即假设“$x$ 包含一个额外的黑色节点”（$x$ 最终需要变成一个黑色节点），就正好弥补了“删除 $y$ 所丢失的黑色节点”，也就不会违反<code>性质⑤</code>；<ul>
<li>现在，$x$ 不仅包含它原本的颜色属性，还包含一个额外的颜色，即 $x$ 的颜色属性是“红+黑”或者“黑+黑”，它违反了<code>性质①</code>；我们面临的问题，由解决“违反<code>性质②</code>、<code>性质④</code>、<code>性质⑤</code>”转换成了解决违反<code>性质①</code>、<code>性质②</code>、<code>性质④</code>”；</li>
</ul>
</li>
<li>解决的思想是：将 $x$ 所包含的额外的黑色属性不断沿树上移（向根方向移动：<code>Case 2</code>），直到出现下面的情况：<ul>
<li>第一类：$x$ 是“红+黑”节点，此时，直接将 $x$ 设为一个“黑”节点即可，红黑树的性质全部恢复；<ul>
<li>如果删除的节点是红色节点，则删除后，树依然能够保持红黑性？？？（<font color="red">错误的命题？</font>）<ol>
<li>树中各节点的黑高度不会发生变化？可能会发生变化；</li>
<li>不存在父子节点都是红色节点的情况；</li>
<li>根依然是黑色节点。</li>
</ol>
</li>
</ul>
</li>
<li>第二类：$x$是“黑+黑”节点且 $x$ 是根，此时，将 $x$ 设为一个“黑”节点即可，红黑树的性质全部恢复；</li>
<li>第三类：$x$是“黑+黑”节点但 $x$ 不是根，这种情况又可以划分为以下 4 种情况：<ul>
<li>Case 1：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是红色（此时 $A$ 的父节点 $B$ 和 $A$ 的兄弟节点的子节点 $C$、$E$ 都是黑色）<br><center><img src="/img/Algorithms/0022_RBDeleteCase1.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将 $A$ 的兄弟节点 $D$ 设为黑色节点；</li>
<li>将 $A$ 的父节点 $B$ 设为红色节点；</li>
<li>对 $A$ 的父节点 $B$ 进行左旋（BD为轴）；</li>
<li>左旋后，由于 $A$ 的兄弟节点发生了变化，需要更新 $A$ 的兄弟节点（由 $D$ 变成 $C$），继续进行后续处理（Case 1 转换为 Case 2、Case 3 或 Case 4）。</li>
</ol>
</li>
<li>Case 2：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是黑色，$A$ 的兄弟节点的两个孩子 $C$、$E$ 都是黑色<br><center><img src="/img/Algorithms/0022_RBDeleteCase2.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将兄弟节点 $D$ 设为红色节点；</li>
<li>将父节点 $B$ 设为新的“当前节点”$N$，之后继续对“当前节点”进行操作。</li>
</ol>
</li>
<li>Case 3：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是黑色；$A$ 的兄弟节点的左孩子 $C$ 是红色节点、右孩子 $E$ 是黑色节点<br><center><img src="/img/Algorithms/0022_RBDeleteCase3.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将兄弟节点 $D$ 的左孩子 $C$ 设为黑色节点；</li>
<li>将兄弟节点 $D$ 设为红色节点；</li>
<li>对兄弟节点 $D$ 进行右旋；</li>
<li>右旋后，需要更新 $A$ 的兄弟节点（由 $D$ 变成 $C$），继续进行后续处理（Case 3 转换为 Case 4）。</li>
</ol>
</li>
<li>Case 4：$A$ 是 “黑+黑”节点，$A$ 的兄弟节点 $D$ 是黑色；$A$ 的兄弟节点的右孩子 $E$ 是红色节点、左孩子 $C$ 可以是任意颜色<br><center><img src="/img/Algorithms/0022_RBDeleteCase4.png" width="640px" alt=""/></center><br>$\quad$处理策略：<ol>
<li>将父节点 $B$ 的颜色赋值给兄弟节点 $D$；</li>
<li>将父节点 $B$ 设为黑色节点；</li>
<li>将兄弟节点 $D$ 的右孩子 $E$ 设为黑色节点；</li>
<li>对父节点 $B$ 进行左旋；</li>
<li>设置 $x$ 设为根节点，就可以跳出<code>while</code>循环，即完成了全部处理。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>上述<code>Case 1-4</code>都只是树的局部，并非树的整体部分；且删除后红黑树恢复<code>Case 3</code>、<code>Case 4</code>在经过上面的调整后，还要继续调整直至重新恢复平衡。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// x：被删除节点位置的替换节点</span></div><div class="line">RB-Delete-Fixup(root, x)</div><div class="line">  <span class="comment">// 删除节点x是根节点或删除节点x是红色节点，红黑树的性质都能保持!!!</span></div><div class="line">  <span class="keyword">while</span>(x!=root &amp;&amp; BLACK==x-&gt;color)</div><div class="line">    <span class="comment">// x是它父节点的左孩子，w为x叔叔，即父节点的右孩子</span></div><div class="line">    <span class="keyword">if</span>(x == x-&gt;parent-&gt;left)</div><div class="line">      w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == w-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为黑色</span></div><div class="line">        w-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的父节点设为红色</span></div><div class="line">        x-&gt;parent-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的父节点进行左旋</span></div><div class="line">        Left-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 左旋后，重新设置x的兄弟节点</span></div><div class="line">        w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 1 ==&gt; Case 2、3、4</span></div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">if</span>(BLACK==w-&gt;left-&gt;color &amp;&amp; BLACK==w-&gt;right-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 设置x的父节点为新一轮迭代的x节点，向上转移</span></div><div class="line">        x = x-&gt;parent;</div><div class="line">      <span class="comment">// Case 3：x的兄弟节点左孩子是红色，右孩子是黑色</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(BLACK==w-&gt;right-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点的左孩子设为黑色</span></div><div class="line">        w-&gt;left-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的兄弟节点进行右旋</span></div><div class="line">        Right-Rotate(root, w);</div><div class="line">        <span class="comment">// 右旋后，重新设置x的兄弟节点，进行下一轮迭代 ==&gt; Case 4</span></div><div class="line">        w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 4：z的兄弟节点右孩子是红色，左孩子任意颜色</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="comment">// 将x父节点的颜色赋值给x的兄弟节点</span></div><div class="line">        w-&gt;color = x-&gt;parent-&gt;color;</div><div class="line">        <span class="comment">// 将x父节点设为黑色</span></div><div class="line">        x-&gt;parent-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 将x兄弟节点的右孩子设为黑色</span></div><div class="line">        w-&gt;right-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 对x的父节点进行左旋</span></div><div class="line">        Left-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 设置x为根节点，退出while循环</span></div><div class="line">        x = root;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="comment">// z是父节点的右孩子，与左子树原理相同，将right与left互换即可</span></div><div class="line">      w = x-&gt;parent-&gt;left;</div><div class="line">      <span class="comment">// Case 1</span></div><div class="line">      <span class="keyword">if</span>(RED == w-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为黑色</span></div><div class="line">        w-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的父节点设为红色</span></div><div class="line">        x-&gt;parent-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的父节点进行右旋</span></div><div class="line">        Right-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 右旋后，重新设置x的兄弟节点</span></div><div class="line">        w = x-&gt;parent-&gt;left;</div><div class="line">      <span class="comment">// Case 1 ==&gt; Case 2、3、4</span></div><div class="line">      <span class="comment">// Case 2</span></div><div class="line">      <span class="keyword">if</span>(BLACK==w-&gt;left-&gt;color &amp;&amp; BLACK==w-&gt;right-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 设置x的父节点为新一轮迭代的x节点，向上转移</span></div><div class="line">        x = x-&gt;parent;</div><div class="line">      <span class="comment">// Case 3：x的兄弟节点右孩子是红色，左孩子是黑色</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(BLACK==w-&gt;left-&gt;color)</div><div class="line">        <span class="comment">// x的兄弟节点的右孩子设为黑色</span></div><div class="line">        w-&gt;right-&gt;color = BLACK;</div><div class="line">        <span class="comment">// x的兄弟节点设为红色</span></div><div class="line">        w-&gt;color = RED;</div><div class="line">        <span class="comment">// 对x的兄弟节点进行左旋</span></div><div class="line">        Left-Rotate(root, w);</div><div class="line">        <span class="comment">// 左旋后，重新设置x的兄弟节点，进行下一轮迭代 ==&gt; Case 4</span></div><div class="line">        w = x-&gt;parent-&gt;right;</div><div class="line">      <span class="comment">// Case 4：z的兄弟节点左孩子是红色，右孩子任意颜色</span></div><div class="line">      <span class="keyword">else</span></div><div class="line">        <span class="comment">// 将x父节点的颜色赋值给x的兄弟节点</span></div><div class="line">        w-&gt;color = x-&gt;parent-&gt;color;</div><div class="line">        <span class="comment">// 将x父节点设为黑色</span></div><div class="line">        x-&gt;parent-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 将x兄弟节点的左孩子设为黑色</span></div><div class="line">        w-&gt;left-&gt;color = BLACK;</div><div class="line">        <span class="comment">// 对x的父节点进行右旋</span></div><div class="line">        Right-Rotate(root, x-&gt;parent);</div><div class="line">        <span class="comment">// 设置x为根节点，退出while循环</span></div><div class="line">        x = root;</div><div class="line"> </div><div class="line">  x-&gt;color = BLACK;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html">浅谈算法和数据结构: 七 二叉查找树</a></li>
<li><a href="http://www.cnblogs.com/gaochundong/p/binary_search_tree.html">Scale-out Thinking：二叉查找树</a></li>
<li><a href="http://blog.csdn.net/u014593748/article/details/72857498">二叉搜索树</a></li>
<li><a href="http://blog.csdn.net/lalor/article/details/7621239">求一棵二叉树中任意节点的后继节点（后继节点是指在中序遍历中紧随其后的节点）</a></li>
<li><a href="http://blog.csdn.net/dengzhilong_cpp/article/details/6669641">二叉查找树后继节点和前驱节点查找</a></li>
<li><a href="http://www.cnblogs.com/skywang12345/p/3245399.html">Sky Wang ：红黑树(一)之 原理和算法详细介绍</a></li>
<li><a href="http://blog.csdn.net/u014593748/article/details/72864573">KDK‘s CSDN：红黑树</a></li>
<li><a href="http://blog.csdn.net/v_july_v/article/details/6105630">July’s CSDN：教你初步了解红黑树</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　一些计算机程序设计中常用的线性数据结构：&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;LinkedList&lt;/code&gt;、&lt;code&gt;List&lt;/code&gt;、&lt;code&gt;Stack&lt;/code&gt;、&lt;code&gt;Queue&lt;/code&gt;、&lt;code&gt;Hashtable&lt;/code&gt; 和&lt;code&gt;Dictionary&lt;/code&gt;。为了更高效的进行数据的查找和访问，例如避免普通数据查找的 $O(N)$ 线性时间复杂度，常用树这种数据结构保存数据。&lt;br&gt;　树（Tree）是由多个节点（Node）的集合组成，每个节点又有多个与其关联的子节点（Child Node）；子节点就是直接处于节点之下的节点，而父节点（Parent Node）则位于节点直接关联的上方；树的根（Root）指的是一个没有父节点的单独的节点。所有的树都呈现了一些共有的性质：&lt;font color=&quot;blue&quot;&gt;①只有一个根节点；②除了根节点，所有节点都有且只有一个父节点；③无环。将任意一个节点作为起始节点，都不存在任何回到该起始节点的路径（正是前两个性质保证了无环的成立）&lt;/font&gt;。&lt;br&gt;　更高效同时也相对更加复杂的树型数据结构包括 &lt;strong&gt;BST&lt;/strong&gt;（二叉查找树）、&lt;strong&gt;R-B Tree&lt;/strong&gt;（红黑树）、&lt;strong&gt;AVL Tree&lt;/strong&gt;（平衡二叉树：父节点的左子树和右子树的高度之差不能大于1）、&lt;strong&gt;Treap&lt;/strong&gt;（树堆：满足①二叉查找树的性质；满足②堆的性质）、&lt;strong&gt;Splay Tree&lt;/strong&gt;（伸展树：在一次搜索后，会对树进行一些特殊的操作，这些操作的理念与AVL树有些类似，即通过旋转，来改变树节点的分布，并减小树的深度；伸展树并没有AVL树的平衡要求，任意节点的左右子树可以相差任意深度）、&lt;strong&gt;B-Tree&lt;/strong&gt;（B树：多叉平衡查找树，&lt;strong&gt;B$^{+}$-Tree&lt;/strong&gt;（B+树）是B树的变体）等。&lt;br&gt;　本文主要介绍基础的 &lt;font color=&quot;red&quot;&gt;BST（二叉查找树）&lt;/font&gt;以及提升搜索效率的更高级的数据结构：&lt;font color=&quot;red&quot;&gt;R-B Tree（红黑树）&lt;/font&gt;。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="Algorithm" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://durant35.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>声明/定义/初始化/赋值</title>
    <link href="http://durant35.github.io/2017/07/07/programPearls_declaration$definition$initialization$assignment/"/>
    <id>http://durant35.github.io/2017/07/07/programPearls_declaration$definition$initialization$assignment/</id>
    <published>2017-07-07T06:02:16.000Z</published>
    <updated>2017-07-07T06:36:05.935Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义（定义性声明）</span></div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="comment">// 声明（引用性声明）</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">int</span> j;</div><div class="line"><span class="comment">// 初始化</span></div><div class="line"><span class="keyword">int</span> k = <span class="number">7</span>;</div><div class="line"><span class="comment">// 默认初始化</span></div><div class="line"><span class="keyword">int</span> l;</div><div class="line"><span class="comment">// 赋值</span></div><div class="line">l = <span class="number">100</span>;</div></pre></td></tr></table></figure>
<ul>
<li>引用性<font color="red">声明</font>不分配存储空间，如：<code>extern int x;</code>只是告诉编译器变量<code>x</code>是整型，已经在其它地方定义了。</li>
<li><font color="red">定义</font>是在内存中确定变量的位置、大小。</li>
<li><font color="red">初始化</font>是定义变量的时候赋给变量的值，强调从无到有这一过程。</li>
<li><font color="red">赋值</font>是初始化后用到该变量，赋给该变量新的值。<a id="more"></a>
</li>
</ul>
<h4 id="定义-vs-声明"><a href="#定义-vs-声明" class="headerlink" title="定义 vs 声明"></a>定义 vs 声明</h4><ul>
<li>变量的声明有两种情况<ul>
<li>一种是需要建立存储空间的：<code>int a;</code></li>
<li>另一种是不需要建立存储空间的：<code>extern int b;</code></li>
<li>前者是<strong>定义性声明(defining declaration)</strong>，或者称为<strong>定义(definition)</strong>，而后者是<strong>引用性声明(referencing declaration)</strong>。从广义的角度讲，声明中包含着定义，但不是所有的声明都是定义，因此这里所说的声明和定义，都是狭义上的，声明特指不需要建立存储空间的引用性声明；定义则指需要建立存储空间的定义性声明。</li>
</ul>
</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明</span></div><div class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// 声明</span></div><div class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> a;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 定义</span></div><div class="line"><span class="keyword">int</span> a;</div></pre></td></tr></table></figure>
<ul>
<li>外部变量（普通全局变量）的定义只能有一次，其位置肯定在函数之外；而同一个文件中对一个外部变量的声明可以有多次，既可以在函数之内（哪个函数要用到就在那个函数中声明），也可以在函数之外（在外部变量的定义点之前）。</li>
</ul>
</li>
<li>函数的声明和定义则相对区分明显。</li>
<li>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 函数声明</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStringLen</span><span class="params">()</span></span>;</div><div class="line"><span class="comment">// 函数定义（实现）</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getStringLen</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul>
<li><a href="http://boyishachang.blog.51cto.com/3485129/1285493">声明、定义、初始化、赋值的区别</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 定义（定义性声明）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明（引用性声明）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 初始化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 默认初始化&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; l;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 赋值&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;l = &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;引用性&lt;font color=&quot;red&quot;&gt;声明&lt;/font&gt;不分配存储空间，如：&lt;code&gt;extern int x;&lt;/code&gt;只是告诉编译器变量&lt;code&gt;x&lt;/code&gt;是整型，已经在其它地方定义了。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;定义&lt;/font&gt;是在内存中确定变量的位置、大小。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;初始化&lt;/font&gt;是定义变量的时候赋给变量的值，强调从无到有这一过程。&lt;/li&gt;
&lt;li&gt;&lt;font color=&quot;red&quot;&gt;赋值&lt;/font&gt;是初始化后用到该变量，赋给该变量新的值。
    
    </summary>
    
      <category term="编程珠玑" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
    
      <category term="C/C++" scheme="http://durant35.github.io/categories/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/C-C/"/>
    
    
      <category term="C/C++" scheme="http://durant35.github.io/tags/C-C/"/>
    
  </entry>
  
</feed>
